so think about Reader Functor,
e -> is the context, a is the value
e is the input, a is the result


1. change the value inside a context without change its structure,


so input e-> here is the structure, result a here is the value inside a context e->
change the result without change its input, make it as a Functor

fmap :: (a -> b) -> (e -> a) -> (e -> b)
fmap (+1) (*2) == \x -> (+1) $ (*2) x == (+1) . (*2)

*2 input is 3
fmap (+1) (*2) input is 3 too
they have the same structure, but with diffrent result in the structure


2. you will get b if you give e in e -> b


because (*2) is f a, you give the input x to *2, so you can get the result a,
then fmap make (+1) work on that result
so fmap on function, it's function compose


3. input -> is the structure in Functor and Monad, 
change the result without change the structure


(+1) >>= \x -> return (x+2)
e -> b is 3 -> 6

you give 3 to (+1) :: e -> a,
3 is the input e,
you can get result a is 4 here
then x is 4, 
( (+1) >>= \x -> return (x+2) ) :: e -> b
and e is 3, because you give 3 to this,
you will get b 6

(+1) >>= (+)
>>= :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
(+1) :: e -> a
(+) :: a -> (e -> b)

the structure is 3, and you give 3 to (+1)
(+) will get result a 4, then plus the structure 3, so it's 7

e -> b is 3 -> 7 

f :: e -> a
g :: a -> (e -> b)

f >>= g = \x -> g (f x) x

(f >>= g) :: e -> b
since you will give e it to f at first, so you will get b at last
f >>= g will be b

-------------------------------------------------------
#Functor
<liiae> > liftA (+1) [1,2,3]
<lambdabot>  [2,3,4]

#Applicative
<liiae> > liftA2 (+) [1,2,3] [2,5]
<lambdabot>  [3,6,4,7,5,8]

#Monad
<liiae> > [1,2,3] >>= (\x -> if x == 1 then return x else return (x+2))
<lambdabot>  [1,4,5]
<liiae> now I see

<liiae> Functor and Applicative, do the same behavior on the value inside a
        context without change their structures
<liiae> Monad, can do different behavior

when you need to operate on a value inside a context without change its structure,
make it as an instance of Functor, implement fmap

when you need to operate on one more values inside same contexts,
make it as an instance of Applicative, implement <*>

when you need to operate different behaviors based on the value,
make it as an instance of Monad, implement >>=

-------------------------------------------------------------




        0
       / \
      1   2
     / \ / \
    3  4 5 6

this data type can express lke

    data Tree a = Leaf | Node a (Tree a) (Tree a)

so that is Node 0 (Node 1 (Node 3 Leaf Leaf) (Node 4 Leaf Leaf)) (Node 2 (Node 5 Leaf Leaf) (Node 6 Leaf Leaf))

also if you want three branches it would be 

    data Tree a = Leaf | Node a (Tree a) (Tree a) (Tree a)

if we want to get the sum of number, make it as an instance of Foldable, implement sum
if you want every element plus 1, make it as instance of Functor, implement fmap
if you want to operate on two those trees, make it as instance of Applicative, implement liftA2

there're more than one tree,

    data Tree a = Leaf a | Node (Tree a) (Tree a)

          0
           \ 
            1
           / 
          2
           \ 
            3
           / \
          4   5
                         
 
            
    data Tree a = Leaf a | Node a (Tree a) (Tree a)
this would force every node to have two populated descendents, it can't represent trees with odd numbers
https://stackoverflow.com/questions/41408922/data-type-for-tree-in-haskell
http://learnyouahaskell.com/zippers

data Tree a = Leaf | Node a (Tree a) (Tree a) deriving (Show)

instance Functor Tree where
    fmap f Leaf = Leaf
    fmap f (Node a l r) = Node (f a) (fmap f l) (fmap f r)

x :: Tree Int
x = Node 0 (Node 1 (Node 3 Leaf Leaf) (Node 4 Leaf Leaf)) (Node 2 Leaf Leaf)

main = print $ fmap (+1) x
-- Node 1 (Node 2 (Node 4 Leaf Leaf) (Node 5 Leaf Leaf)) (Node 3 Leaf Leaf)


getNode :: Num a => Tree a -> [a]
getNode Leaf = [0]
getNode (Node a l r) = [a] <> (getNode l) <> (getNode r)

-- main = print $ getNode x
main = print . sum . getNode $ x

--------------------------------------------------------

fmap :: Functor f => (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
f is a context, a is a value in that context f,
Functor will let you "lift" functions of one value into a context
Applicative will let you "lift" functions of multiple values into a context

>=> :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c

<ski> `Functor' lets you operate, independently, on each "element" of a "collection". or to add (non-effectful) "post-processing" operations to an effectful operation
<ski> `Applicative' let's you merge multiple effectful operations into one, sequencing them. but it doesn't let you decide what effectful operation to do later, depending on what intermediate result you got earlier, while `Monad' allows that. one might call what `Applicative' gives you, "static sequencing", while `Monad' gives "dynamic sequencing"
"Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
<ski> `mpa toLower <$> getLine' attaches a "to lower case" transformation to be done after doing the I/O effect of getting a line. that's just using `Functor'
<ski> `replicate <$> readLn <*> getLine' will combine two effectful operations, in order : first read (parse) an `Int', then get a line. give back a list containing that line, repeated the specified number of times
<ski> we can combine the two intermediate result values here, with `Applicative', but we can't use any of them to decide what effects to perform .. unless we start using other "plumbing" operations thatn just `Applicative', such as `Monad'
<ski> `flip replicateM getLine =<< readLn' will first get the `Int', then use that to get that many lines (rather than getting a single line, then replicating that value). this is an example of "dynamic sequenceing", with `Monad', letting previous intermediate results of effectful operations determine what effects you do later. you could also imagine having an `if' or a `case' on the intermediate value, branching out
<ski> .. for some time, some people were a bit reluctant to use the terminology "sequencing" with `Applicative' and `Monad', saying that they're not really about sequencing
<ski> (a) not every `Applicative' or `Monad' instance cares about the sequencing you may express. there are "commutative" instances, such as `Reader r', e.g.
<ski> (b) the sequencing that is being expressed doesn't necessarily have to correspond directly to what you may think of as sequencing, depending on the particular instance

http://tunes.org/~nef/logs/haskell/20.07.04

<jusss`> there's a list [1,2,[3,4],[3,[5,6,[7]]]], who to let every element in it plus 1?
<Cale> jusss`: That's not a valid list, unless you have some way to interpret 6 as being of the same type as [7]
<Cale> (so you'd need a way to interpret numbers as lists, which I suppose you could have via a Num instance)
<Cale> jusss`: All the elements of a Haskell list must have the same type
<Cale> jusss`: If we want a tree, we'll use a tree data type
<Cale> data Tree a = Nil | Cons a (Tree a) | Subtree (Tree a) (Tree a)
<Cale> Then we can encode your nested thing like:
<Cale> Cons 1 (Cons 2 (Subtree (Cons 3 (Cons 4 Nil)) (Subtree (Cons 3 (Subtree (Cons 5 (Cons 6 (Subtree (Cons 7 Nil) Nil))) Nil)) Nil)))
<Cale> We can write a function which applies a function to all the elements of such a thing
<Cale> and in fact, while we're at it, might as well make it a Functor instance :)
<Cale> instance Functor Tree where
<Cale>   fmap f = g
<Cale>     where
<Cale>       g Nil = Nil
<Cale>       g (Cons x t) = Cons (f x) (g t)
<Cale>       g (Subtree t t') = Subtree (g t) (g t')
http://tunes.org/~nef/logs/haskell/20.07.02

<jusss> g :: (Functor f) => f Int -> f (Int -> String) -> f String
<jusss> how I implement this function?
<Cale> You need Applicative f if you want the sensible thing. You could also ignore the first argument and do something like g _ x = fmap ($ 0) x
<Cale> :t fmap
<lambdabot> Functor f => (a -> b) -> f a -> f b
<Cale> Functor doesn't let you do anything to combine values of f-typed things
<Cale> :t (<*>)
<lambdabot> Applicative f => f (a -> b) -> f a -> f b
<jusss> that `f Int` is new to me, I never thought that I can change the type constructor
<jusss> f Int, so I can use Maybe Int, [Int], Either a Int
<Cale> yeah
<jusss> we always use that `f a`, f and a here both can be replaced
<Cale> It's polymorphic in a choice of functor f
<jusss> but the most time, we just replace that a,
<jusss> and we use type variables too much, 
<jusss> Cale: like that type constraints, can we constraint the `f` from `f a` ?
<dmwit> Yes, neither the `f` nor the `a` is particularly special.
<dmwit> Just about anything you can do to one, you can do to the other.
<jusss> Cale: like we can constraint types have *, can we constraint types have * -> *?
<Cale> jusss: There are examples of that just above
<dmwit> Yes. (I think. Maybe I don't understand the question. But if I do understand the question, then the answer is yes.)
<Cale> Functor f => ...
<Cale> I think you meant to say "constrain" (which is a verb) rather than "constraint" (which is a noun or adjective) though
<jusss> Cale: I see, if I just want Maybe and [], so I should make a new typeclass, and make Maybe and [] as its instances?
<jusss> then declare where I'd like to use with the new typeclass constraints
<dmwit> Right.

---------------------------------------------------

after all, Monad is a typeclass, and typeclass is used for polymorphism,
typeclass's instance is type, Monad's instance is Maybe type, List type
its different type instances have differnet function definitions
and return function is a specific function, and action is not

>>= :: m a -> (a -> m b) -> m b
this (a->m b) is an action, not a specific function like return

so when Monad's instance is (e->)
>>= :: (e->a) (a-> (e->b)) -> (e->b)

and its instance is []
>>= :: [a] -> (a->[b]) -> [b]

and when its instance is Maybe
>>= :: Maybe a -> (a-> Maybe b) -> Maybe b

and that action (a-> m b) is using three different function definitions to implement

in Monad typeclass,
class Monad m where
    >>= :: m a -> (a->m b) -> m b
    return :: a-> m a

in Maybe type, turn this Maybe type as an instance of Monad
instance Monad Maybe where
    return x = Just x
    Nothing >>= f = Nothing
    Just x >>= f = f x
    (>>=) (Just x) f = f x

write signature in typeclass, and write function definition in type instance
and also you can write function definition in typeclass, and that function
just describe the relationship between functions, not function's specific definition

if we want turn a type to an instance of typeclass like Monad,
we have to implement that functions which type signatures are in Monad
like >>=, return, >>, functions

about that return, return is implement in the instance,
so Maybe has its return x = Just x, and List has its return x = [x]
all that Monad instance have they return,
and >>= work on Monad instance
so   
Just 3 >>= \x -> return (x + 1)
return 3 >>= \x -> Just x
Just 3>>=(\x -> Just (x+1))

the return and >>= know which monad the parameter is
'cause defferent >>= and return in every Monad instance
in Maybe, return x = Just x, so >>= work on Just 3, its
return will return Just x

>>='s first Monad parameter, it makes sure the specific Monad it is,
so it returns specific Monad 

in Maybe Monad
return x = Just x
in List Monad
return x = [x]


and that Monad is *->*   so Either a is a Monad, and Either not

ok then, time to write my own Monad instance 

import Control.Applicative
import Control.Monad
data T a = V a deriving (Show)
instance Functor T where
 fmap f (V x) = V (f x)
instance Applicative T where
 pure = V
 (V f) <*> (V x) = V (f x)
instance Monad T where
 return x = V x
 (V x) >>= f = f x

V 3 >>= return
fmap (\x-> x + 1) (V 3)


one symbol can represent multipy types, that's polymorphism

id :: a -> a
id :: (a->b) -> a -> b

this is polymorphism, a can be (a->b), can be (a->b->c), can be Int, Char, any type


############################################`

>>= :: m a -> (a -> m b) -> m b
if m is (e->)
>>= :: e->a -> (a-> (e->b)) -> (e->b)
f::e->a
g::a->(e->b)
x::e
>>= f g x = g (f x) x 

f :: Int->String
f x = show x

g :: String->(Int->[String])
g x = \y ->[show y ++ x ]

Prelude> z=(>>=) f g
Prelude> :t z
z :: Show a => a -> [[Char]]


######################################################

<jusss> dminuoso: oh, I think I understand what you mean, fmap turn (a->b)
        into (e->a) -> (e->b)
<jusss> now we can say fmap transform (a->b) to ( (e->a) -> (e->b) ), so I
        wonder how to express about <*> and >>=                         [16:11]
<dminuoso> jusss: Applicative too transforms functions.
<jusss> in functor, a->b,  in applicative, a or a->b or a->b->c
<dminuoso> Except Functor limits you to functions taking one argument.
<dminuoso> Applicative lets you do this with functions taking *any* number of
           arguments
<jusss> dminuoso: but <*> :: f (a->b) -> f a -> fb,  <*> transform that
        function in Applicative to another function(f a -> f b) right?
<dminuoso> jusss: Right. So the diagram I showed you is basically what you can
           do with pure and (<*>)

<dminuoso> mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b)       [16:55]
<jusss> Prelude> mango f g x = (f x) (g x)                              [17:14]
<jusss> mango :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
<dminuoso> jusss: Looks great.

<jusss> dminuoso: yeah, functor and applicative both need a type to complete
        themself?
<dminuoso> jusss: Exactly. They work on types missing one type argument.
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
<jusss> dminuoso: that (->) e can be monad?
<dminuoso> jusss: Yes. You just wrote the (>>=) implementation for it.  [18:04]
<dminuoso> (>>=) is your cocoa
<dminuoso> (<*>) is your mango
<jusss> dminuoso: what?
<dminuoso> and pure/return is your coconut
<dminuoso> And banana is fmap                                           [18:05]
<jusss> dminuoso: cocoa and >>=
<dminuoso> jusss: cocoa = flip (>>=)
<jusss> dminuoso: about the a-> m b, I don't understand what it's used for
                                                                        [18:09]
<jusss> it's not like functor and applicative
<jusss> this a->m b
<dminuoso> jusss: Yeah its not.
<jusss> dminuoso: and what it is
<dminuoso> jusss: Well what is (<>)
<dminuoso> jusss: Its not for anything.
<Bish> dminuoso: o/
<jusss> <>:: s->s->s?                                                   [18:10]
<arianvp> % :t  (>>=) @((->) r)
<yahb> arianvp: ; <interactive>:1:14: error: Not in scope: type variable `r'
<dminuoso> Right
<arianvp> :/
<dminuoso> jusss: It exists because many things happen to have this shape, for
           some reason.
<Taneb> % :t (>>=) @((->) _)
<yahb> Taneb: (w -> a) -> (a -> w -> b) -> w -> b
<arianvp> Taneb: thanks
<arianvp> % :t (=<<) @((->) _)
<yahb> arianvp: (a -> w -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: It doesnt have any intrinstic meaning.
<Bish> there is a flipped version of bind, but not a prefix bind?
<dminuoso> Bish: You can put (>>=) in parens                            [18:11]
<dminuoso> And then use it in prefix notation.
<Bish> yeah great :D i am just sometimes confused about the logic
<Bish> people would flip it, but never use it prefix
<jusss> dminuoso: use <> to shape for what
<dminuoso> jusss: I wouldnt focus on Monad really, ask what the ((->) e)
           instance does                                                [18:12]
##############################################

deduce a function definition from its type signature, and this one function is just an instance of its type signature, this type can have different function definition,
id :: a->a
id :: (a->b) -> a -> b
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
let's assume
f::a->Int->b
g::Int->a
x::Int
cocoa f g x = b
f a:: Int->b
f a x :: b
g Int :: a
g x :: a
f (g x) x :: b
cocoa f g x = f (g x) x
######################################################

Functor can do:


  a -> b
    |
    |
    v
f a -> f b

Applicative can do:

 a        a -> b          a -> b -> c             a -> b -> c -> d                .... and so on ....
 |          |                  |                          |
 |          |                  |                          |
 v          v                  v                          v
f a f a -> f b f a -> f b -> f c f a -> f b -> f c -> f d .... and so on ....

and when Functor and Applicative are e->
<jusss> dminuoso: if f is (e->),   so <*> :: (e->) (a->b) -> (e->a) -> (e->b)
######################################################

fmap  ::   (a -> b) -> f a -> f b
(<*>) :: f (a -> b) -> f a -> f b
(=<<) :: (a -> f b) -> f a -> f b


####################################################

<jusss> dminuoso: then fmap id = id, this id shoud change its name like id2 or
        idf
<jusss> 'cause that new id :: f b -> f b, not id :: a -> a,   the new id is a
        subset of the old id
##################################
(e->) doesn't "contain" anything, but (e->a) "contain" a value 'a'
[] doesn't "contain" anything, but [a] "contain" a value 'a'
####################################

<[exa]> like, Maybe , [], Either l, (e->), IO all "contain" 'a' and can be
        converted using '(a->b)' to contain 'b'
<[exa]> jusss: the point about functors is that you can change what type they
        "contain" by fmapping a simple function (a->b)
<jusss> what about to see a container that 'contain' a value, a function that
        'contain' a output, a list that 'contain' its value             [17:47]
<jusss> (e->a) is a container (e->) 'contain' its output value 'a'
<jusss> [a] is a container [] 'contain' its value 'a'
<jusss> fmap apply a function on that value which is in the container, and get
        a same container with a new value                               [17:50]
###################################################

fmap :: (a->b) -> (e->a) -> (e->b)
let's assume a->b is function f1,     (f1 is an unary function)
fmap (+1) ((+1) x) = (+1 ((+1) x)) 
through right associal
fmap (+1) (+1) x = (+1) (+1) x
                 = (+2) x
through eta-reduce
fmap (+1) (+1) = (+2)

fmap (+1) (+1) is a currying form, through eta-reduce
fmap (+1) (+1) == (+2)
in this case (a->b) is (+1)

+1 is just a name of function, nothing else, it doesn't mean (+ 1 x)

in other languages:
    fmap = \fn fc a -> fn (fc a)
    fmap f1 f2  = \x -> f1 (f2 x)

    t = fmap (+1) (+2)
    t 3 == 6
    t :: Num t2=> t2 -> t2

f.g is (.) f g, is fmap f g, is \x -> f (g x)


currying and partial (curry is an unary function, partial is a binary function)

f(x,y)
curry f = \x -> \y -> (f x y)

partial f x = \y -> (f x y)


Prelude> curry f = \x -> \y -> (f x y)
Prelude> t = curry (+)
Prelude> t 1 2
3
Prelude> t2 = t 1
Prelude> t3 = t2 2
Prelude> t3
3


------------------------------------------
when Functor is (->) e, then fmap is (.)
fmap :: (a->b) -> ((->) e a) -> ((->) e b)

a1 x=x+1
c=fmap a1 a1

:t c
c::Num b=>b->b

c 1 == 3

--------------------------------------------------------

fmap :: Functor f => (a -> b) -> f a -> f b

>>= :: Monad m => m a -> (a -> m b) -> m b

<*> :: Applicative f => f (a -> b) -> f a -> f b

Maybe Monad, m a is Maybe a, is Just 3, m is Just, a is 3
and there is function \x -> Just ((+2) x)

>>= (Just 3) (\x -> Just ((+2) x))

(Just 3) >>= (\x -> Just ((+2) x)) == Just 5


Maybe Functor, f a is Maybe a, is Just 3, f is Just, a is 3
fmap (+2) (Just 3) == Just 5

Maybe Applicative, f a is Maybe a, is Jut 3, f is Just, a is 3
(Just (+2)) <*> (Just 3) == Just 5

Just is a value constructor, so all that value constructor can be Monad?
of course not, because Monad is also a typeclass,
Maybe Monad is an instance of the typeclass Monad,
it means >>= <*> and fmap, functions is defined in Maybe
you can do it if you make your type as an instance of Monad

data T a = V a
instance Monad (T a) where
    (>>=) = ...
    (<*>) = ...
    fmap  = ...


Prelude> [1] >>= \x -> (Just x)

<interactive>:7:16: error:
    • Couldn't match type ‘Maybe’ with ‘[]’
      Expected type: [b]
        Actual type: Maybe b
    • In the expression: (Just x)
      In the second argument of ‘(>>=)’, namely ‘\ x -> (Just x)’
      In the expression: [1] >>= \ x -> (Just x)
Prelude> [1] >>= \x -> [x+1]
[2]

it means the type must be the same that befor >>= and after
