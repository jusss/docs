
after all, Monad is a typeclass, and typeclass is used for polymorphism,
typeclass's instance is type, Monad's instance is Maybe type, List type
its different type instances have differnet function definitions
and return function is a specific function, and action is not

>>= :: m a -> (a -> m b) -> m b
this (a->m b) is an action, not a specific function like return

so when Monad's instance is (e->)
>>= :: (e->a) (a-> (e->b)) -> (e->b)

and its instance is []
>>= :: [a] -> (a->[b]) -> [b]

and when its instance is Maybe
>>= :: Maybe a -> (a-> Maybe b) -> Maybe b

and that action (a-> m b) is using three different function definitions to implement

in Monad typeclass,
class Monad m where
    >>= :: m a -> (a->m b) -> m b
    return :: a-> m a

in Maybe type, turn this Maybe type as an instance of Monad
instance Monad Maybe where
    return x = Just x
    Nothing >>= f = Nothing
    Just x >>= f = f x
    (>>=) (Just x) f = f x

write signature in typeclass, and write function definition in type instance
and also you can write function definition in typeclass, and that function
just describe the relationship between functions, not function's specific definition

if we want turn a type to an instance of typeclass like Monad,
we have to implement that functions which type signatures are in Monad
like >>=, return, >>, functions

about that return, return is implement in the instance,
so Maybe has its return x = Just x, and List has its return x = [x]
all that Monad instance have they return,
and >>= work on Monad instance
so   
Just 3 >>= \x -> return (x + 1)
return 3 >>= \x -> Just x
Just 3>>=(\x -> Just (x+1))

the return and >>= know which monad the parameter is
'cause defferent >>= and return in every Monad instance
in Maybe, return x = Just x, so >>= work on Just 3, its
return will return Just x

>>='s first Monad parameter, it makes sure the specific Monad it is,
so it returns specific Monad 

in Maybe Monad
return x = Just x
in List Monad
return x = [x]


and that Monad is *->*   so Either a is a Monad, and Either not

ok then, time to write my own Monad instance 

import Control.Applicative
import Control.Monad
data T a = V a deriving (Show)
instance Functor T where
 fmap f (V x) = V (f x)
instance Applicative T where
 pure = V
 (V f) <*> (V x) = V (f x)
instance Monad T where
 return x = V x
 (V x) >>= f = f x

V 3 >>= return
fmap (\x-> x + 1) (V 3)


one symbol can represent multipy types, that's polymorphism

id :: a -> a
id :: (a->b) -> a -> b

this is polymorphism, a can be (a->b), can be (a->b->c), can be Int, Char, any type


############################################`

>>= :: m a -> (a -> m b) -> m b
if m is (e->)
>>= :: e->a -> (a-> (e->b)) -> (e->b)
f::e->a
g::a->(e->b)
x::e
>>= f g x = g (f x) x 

f :: Int->String
f x = show x

g :: String->(Int->[String])
g x = \y ->[show y ++ x ]

Prelude> z=(>>=) f g
Prelude> :t z
z :: Show a => a -> [[Char]]


######################################################

<jusss> dminuoso: oh, I think I understand what you mean, fmap turn (a->b)
        into (e->a) -> (e->b)
<jusss> now we can say fmap transform (a->b) to ( (e->a) -> (e->b) ), so I
        wonder how to express about <*> and >>=                         [16:11]
<dminuoso> jusss: Applicative too transforms functions.
<jusss> in functor, a->b,  in applicative, a or a->b or a->b->c
<dminuoso> Except Functor limits you to functions taking one argument.
<dminuoso> Applicative lets you do this with functions taking *any* number of
           arguments
<jusss> dminuoso: but <*> :: f (a->b) -> f a -> fb,  <*> transform that
        function in Applicative to another function(f a -> f b) right?
<dminuoso> jusss: Right. So the diagram I showed you is basically what you can
           do with pure and (<*>)

<dminuoso> mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b)       [16:55]
<jusss> Prelude> mango f g x = (f x) (g x)                              [17:14]
<jusss> mango :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
<dminuoso> jusss: Looks great.

<jusss> dminuoso: yeah, functor and applicative both need a type to complete
        themself?
<dminuoso> jusss: Exactly. They work on types missing one type argument.
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
<jusss> dminuoso: that (->) e can be monad?
<dminuoso> jusss: Yes. You just wrote the (>>=) implementation for it.  [18:04]
<dminuoso> (>>=) is your cocoa
<dminuoso> (<*>) is your mango
<jusss> dminuoso: what?
<dminuoso> and pure/return is your coconut
<dminuoso> And banana is fmap                                           [18:05]
<jusss> dminuoso: cocoa and >>=
<dminuoso> jusss: cocoa = flip (>>=)
<jusss> dminuoso: about the a-> m b, I don't understand what it's used for
                                                                        [18:09]
<jusss> it's not like functor and applicative
<jusss> this a->m b
<dminuoso> jusss: Yeah its not.
<jusss> dminuoso: and what it is
<dminuoso> jusss: Well what is (<>)
<dminuoso> jusss: Its not for anything.
<Bish> dminuoso: o/
<jusss> <>:: s->s->s?                                                   [18:10]
<arianvp> % :t  (>>=) @((->) r)
<yahb> arianvp: ; <interactive>:1:14: error: Not in scope: type variable `r'
<dminuoso> Right
<arianvp> :/
<dminuoso> jusss: It exists because many things happen to have this shape, for
           some reason.
<Taneb> % :t (>>=) @((->) _)
<yahb> Taneb: (w -> a) -> (a -> w -> b) -> w -> b
<arianvp> Taneb: thanks
<arianvp> % :t (=<<) @((->) _)
<yahb> arianvp: (a -> w -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: It doesnt have any intrinstic meaning.
<Bish> there is a flipped version of bind, but not a prefix bind?
<dminuoso> Bish: You can put (>>=) in parens                            [18:11]
<dminuoso> And then use it in prefix notation.
<Bish> yeah great :D i am just sometimes confused about the logic
<Bish> people would flip it, but never use it prefix
<jusss> dminuoso: use <> to shape for what
<dminuoso> jusss: I wouldnt focus on Monad really, ask what the ((->) e)
           instance does                                                [18:12]
##############################################

deduce a function definition from its type signature, and this one function is just an instance of its type signature, this type can have different function definition,
id :: a->a
id :: (a->b) -> a -> b
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
let's assume
f::a->Int->b
g::Int->a
x::Int
cocoa f g x = b
f a:: Int->b
f a x :: b
g Int :: a
g x :: a
f (g x) x :: b
cocoa f g x = f (g x) x
######################################################

Functor can do:


  a -> b
    |
    |
    v
f a -> f b

Applicative can do:

 a        a -> b          a -> b -> c             a -> b -> c -> d                .... and so on ....
 |          |                  |                          |
 |          |                  |                          |
 v          v                  v                          v
f a f a -> f b f a -> f b -> f c f a -> f b -> f c -> f d .... and so on ....

and when Functor and Applicative are e->
<jusss> dminuoso: if f is (e->),   so <*> :: (e->) (a->b) -> (e->a) -> (e->b)
######################################################

fmap  ::   (a -> b) -> f a -> f b
(<*>) :: f (a -> b) -> f a -> f b
(=<<) :: (a -> f b) -> f a -> f b


####################################################

<jusss> dminuoso: then fmap id = id, this id shoud change its name like id2 or
        idf
<jusss> 'cause that new id :: f b -> f b, not id :: a -> a,   the new id is a
        subset of the old id
##################################
(e->) doesn't "contain" anything, but (e->a) "contain" a value 'a'
[] doesn't "contain" anything, but [a] "contain" a value 'a'
####################################

<[exa]> like, Maybe , [], Either l, (e->), IO all "contain" 'a' and can be
        converted using '(a->b)' to contain 'b'
<[exa]> jusss: the point about functors is that you can change what type they
        "contain" by fmapping a simple function (a->b)
<jusss> what about to see a container that 'contain' a value, a function that
        'contain' a output, a list that 'contain' its value             [17:47]
<jusss> (e->a) is a container (e->) 'contain' its output value 'a'
<jusss> [a] is a container [] 'contain' its value 'a'
<jusss> fmap apply a function on that value which is in the container, and get
        a same container with a new value                               [17:50]
###################################################

fmap :: (a->b) -> (e->a) -> (e->b)
let's assume a->b is function f1,     (f1 is an unary function)
fmap (+1) ((+1) x) = (+1 ((+1) x)) 
through right associal
fmap (+1) (+1) x = (+1) (+1) x
                 = (+2) x
through eta-reduce
fmap (+1) (+1) = (+2)

fmap (+1) (+1) is a currying form, through eta-reduce
fmap (+1) (+1) == (+2)
in this case (a->b) is (+1)

+1 is just a name of function, nothing else, it doesn't mean (+ 1 x)

in other languages:
    fmap = \fn fc a -> fn (fc a)
    fmap f1 f2  = \x -> f1 (f2 x)

    t = fmap (+1) (+2)
    t 3 == 6
    t :: Num t2=> t2 -> t2

f.g is (.) f g, is fmap f g, is \x -> f (g x)


currying and partial (curry is an unary function, partial is a binary function)

f(x,y)
curry f = \x -> \y -> (f x y)

partial f x = \y -> (f x y)


Prelude> curry f = \x -> \y -> (f x y)
Prelude> t = curry (+)
Prelude> t 1 2
3
Prelude> t2 = t 1
Prelude> t3 = t2 2
Prelude> t3
3


------------------------------------------
when Functor is (->) e, then fmap is (.)
fmap :: (a->b) -> ((->) e a) -> ((->) e b)

a1 x=x+1
c=fmap a1 a1

:t c
c::Num b=>b->b

c 1 == 3

--------------------------------------------------------

fmap :: Functor f => (a -> b) -> f a -> f b

>>= :: Monad m => m a -> (a -> m b) -> m b

<*> :: Applicative f => f (a -> b) -> f a -> f b

Maybe Monad, m a is Maybe a, is Just 3, m is Just, a is 3
and there is function \x -> Just ((+2) x)

>>= (Just 3) (\x -> Just ((+2) x))

(Just 3) >>= (\x -> Just ((+2) x)) == Just 5


Maybe Functor, f a is Maybe a, is Just 3, f is Just, a is 3
fmap (+2) (Just 3) == Just 5

Maybe Applicative, f a is Maybe a, is Jut 3, f is Just, a is 3
(Just (+2)) <*> (Just 3) == Just 5

Just is a value constructor, so all that value constructor can be Monad?
of course not, because Monad is also a typeclass,
Maybe Monad is an instance of the typeclass Monad,
it means >>= <*> and fmap, functions is defined in Maybe
you can do it if you make your type as an instance of Monad

data T a = V a
instance Monad (T a) where
    (>>=) = ...
    (<*>) = ...
    fmap  = ...


Prelude> [1] >>= \x -> (Just x)

<interactive>:7:16: error:
    • Couldn't match type ‘Maybe’ with ‘[]’
      Expected type: [b]
        Actual type: Maybe b
    • In the expression: (Just x)
      In the second argument of ‘(>>=)’, namely ‘\ x -> (Just x)’
      In the expression: [1] >>= \ x -> (Just x)
Prelude> [1] >>= \x -> [x+1]
[2]

it means the type must be the same that befor >>= and after
