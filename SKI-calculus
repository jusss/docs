S is Substitution
K is Constant
I is Identity

https://www.buildreactapp.com/fun-with-ski-calculus/
https://en.wikipedia.org/wiki/SKI_combinator_calculus
https://zhuanlan.zhihu.com/p/22231273
liftA2 f g h = \x -> f (g x) (h x)
S (K f) g h
S (S (K f) g) h
S (B f g) h
ap (f . g) h

liftA2 f g = ap (f . g) = <*> (f <$> g)

S f g x = (f x) (g x)  -- ap
K c x = c  -- const and also return
I x = x  -- id
B f g x = f (g x) -- fmap

C f x y = f y x  -- flip
W f x = f x x  -- join
https://dkeenan.com/Lambda/index.htm
`W' is `join',
(and `(=<<)' is `B S C')
@src (->) (>>=)
lambdabot :f >>= k = \ r -> k (f r) r
@src (->) return
lambdabot :return = const
which is `K'

ski :@djinn (a -> Maybe b) -> Maybe a -> Maybe b
lambdabot :f a b =
lambdabot : case b of
lambdabot : Nothing -> Nothing
lambdabot : Just c -> a c

ski :@hoogle (a -> Maybe b) -> Maybe a -> Maybe b
lambdabot :Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b


hippoid :that factoid makes the whole monad="monoid in the category of endofuctors" thing make sense to me!
ski :fwiw, there's also a notion of "monad morphism". if `M' and `N' are monads, then `f :: forall a. M a -> N a' is a monad morphism iff `f . return = return' and `f . join = join . (f . fmap f) = join . (fmap f . f)' (the latter two must be equal, because `f' is a natural transformation, because it's polymorphic (with no class constraints), and Haskell enjoys the parametricity property)

ski :e.g. `reverse :: [a] -> [a]', `listToMaybe :: [a] -> Maybe a' are monad morphisms
compare with a monoid morphism `f :: M -> N', which must satisfy `f mempty = mempty' and `f (x <> y) = f x <> f y'

Theorems for Free
ski :@free foo :: [Maybe a] -> [a]
lambdabot :$map f . foo = foo . $map ($map_Maybe f)
ski :@free map
lambdabot :g . h = k . f => $map g . map h = map k . $map f



liftA2 :: (a -> (b->c)) -> (e->a) -> (e->b) -> e->c
liftA2 f g h = \e -> f (g e) (h e)

ap :: (e->a->b) -> (e->a) -> e -> b
ap f g x = f x (g x)

S f g x = f x (g x)

S is ap
K is const
I is id



what SKI calculus is used for?
It's not so much useful as it is an interesting thing to think about -- that 2 or 3 combinators are sufficient to encode computation. The types of S and K in a typed lambda calculus can be taken as axioms for intuitionistic logic (though usually most would prefer a presentation based on structural rules these days)

also, they're closely related to Applicative: pure and (<*>) for the instance Applicative ((->) e) are exactly K and S
If you need something which is Turing complete and extremely simple, it can sometimes fit the bill, though there are a lot of those.
it makes sense because lambda calc is turing complete, and all S and K do is give you "computation with an implied environment". So if you make every single function argument as an implied argument in a reader monad, then bam, you have the same program but just using (<*>) and pure to deal with the environment that would otherwise be done with lambda abstractions

SKI doesn't use variables, which makes certain analyses and constructions much easier... variable scope, hygiene, etc, is complicated
first you remove loops, then mutability, then variables... a hat trick to impress friends

S is ap, K is const, I is id, right?
edwardk : yes, i like to think of them in terms of the reader monad as well. S is like 'f <*> x' an application that takes an extra environment and plumbs it both ways. K ignores it (pure = const). I uses it (ask = id)

i wanted to say things with explicitly reader-like analogues, because then its clearer, mixing (<*>) with const and id makes it pretty hard to see the reader connections
otoh, pure and ask are pretty obscure if you just want to think of it in combinator terms =)

every Applicative must be a Functor, but not every Functor must be an Applicative
`Data.Map.Map k` is `Functor` and `Apply` (from `semigroupoids`) but not `Applicative` (no valid `pure`)


