Reader r a = Reader $ \a -> r

a is the input and r is the result

in Reader r a >>= ...
put r as a to the next one, but you can in the rest use `ask' to get the original a

so State s a, in the next computation chain, use `get' to get the original input,
use `put' to change the original input

g x = do {o <- get; let {n=o+1}; put n; return (n+x);}
runState (traverse g [1,1,1]) 0 == ([2,3,4],3)

traverse g [1,1,1], the `get' will get 0, then `get' will get 1, then `get' will get 2

you see, the first 'get' will get value only throught runState (State $ \s -> (a, s)) the-original-s
the-original-s is the first 'get' will get, if not changed by put, then the whole >>= chain, 'get' will get the same

