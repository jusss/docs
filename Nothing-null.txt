

recv null isn't a failure computation, apply functions on null cause a failure computation

Nothing is a specific value, it's used to detect a computation before it runs.
if it may fail then return Nothing,

use detection before running, prevent failure, there's no need for try-catch-except 


error/Exception, null, failure computation (Error, Exception, abort computation)


IO may produce null,
1/0 produces an error,
Nothing is a specific value, 

head [] case an Exception, it can't return a Nothing, 
but you could check it if it's empty before head,
and if it's empty, you can return a Nothing to tell it's empty 

but this means you detect it if it's empty before the computation

there's no null in Haskell

anything produce an error, I call it a failure computation
Nothing is not a failure computation
abort computation I think it's called failure computation

1/0 is an abort computation, it's an error, it's a failure computation

read socket is an IO, IO may produce a null value because Java design it, but in Java, it's not an error, 
only when you do some functions work on that null value may abort computation, case an error,

but you can't expect read Nothing from IO, unless you detect it may cause an error before the computation, 
and then you can return a value like Nothing or other else to tell it may cause an error

there's no null in Haskell, bottom value _ is just magic stuff only in GHC, not Haskell

in Java, only IO can produce null, others produce error like 1/0

there's no null design in Haskell, only error

Java design null, Haskell doesn't design null.







Maybe Monad, I'd like to call it DetectError Monad, or PreventFailure Monad 
think 1/0 in python

def div(x,y):
  if x==0:
    print("x is 0")
  else:
    return y/x

it return None or Int

but this can't happen in Haskell, because return values have one type, 
you can't return two types as values' types (related to generics, ad-hoc, polymorphics result)
anyway, so you can use Sum type (enum in Java, dataclass in Kotlin) (related to Product type, ADT)

so it must be Nothing :: Maybe Int or Just (y/x) :: Maybe Int

div :: Int -> Int -> Maybe Int 
div 0 y = Nothing
div x y = Just (y/x)

this Maybe detect that y/x may be failed and prevent it by before running it.
detect fail computation before running it can avoid errors, no need for exception

so I call it DetectError Monad 

also it has to implement bind and apply and fmap to make it as a monad

once it's Nothing then all next fmap/apply/bind computations are stopped
because you defined that, other functions won't stop 

like it's null then stop all next computations in Java and you must define that 
