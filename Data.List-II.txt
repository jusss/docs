since Data.List doesn't have splitOn, so implement it yourself, turn to Data.Text is absurd

findElementInList element alist = fmap fst $ filter ((== element) . snd) $ zip [0..(length alist)] alist

findElementInList '/' "/ab/c/d" == [0,3,5]

slice alist (start, end) = drop start $ take end alist

getIndexList subList sourceList = fmap fst $ filter (isPrefixOf subList . snd) $ zip [0..] $ tails sourceList

splitOn subList sourceList = case getIndexList subList sourceList of
    [] -> [sourceList]
    indexList -> fmap (slice sourceList) $  [(0, head indexList)] <> (zip starts (tail indexList)) <> [(last starts, length sourceList)] where
        starts = fmap (+ (length subList)) indexList

splitOn "/a/b" "this is a test /ab/c/a/b /c /a/b absurd" == ["this is a test /ab/c"," /c "," absurd"]

-----------------------------
since fmap :: (a->b) -> [a] -> [b] can't do replace character to string in list
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
concatMap (\x -> if x == '\r' then "\\r" else [x]) "a\r\nb" == "a\\r\nb"
-------------------------
scanl1 (<>) $ fmap (("/:" <>) . ("l" <>) . show) [1..9]
["/:l1","/:l1/:l2","/:l1/:l2/:l3","/:l1/:l2/:l3/:l4","/:l1/:l2/:l3/:l4/:l5","/:l1/:l2/:l3/:l4/:l5/:l6","/:l1/:l2/:l3/:l4/:l5/:l6/:l7","/:l1/:l2/:l3/:l4/:l5/:l6/:l7/:l8","/:l1/:l2/:l3/:l4/:l5/:l6/:l7/:l8/:l9"]
-----------------------------

intersect = foldl1 (\xs ys -> [x | x<- xs, elem x ys])
intersect [[1,2,3], [4,3,5], [3,7,8,9,12]] == [3]

-------------------------------

check if all elements are equal in a list

allEqual :: (Eq a) => [a] -> Bool
allEqual xs = all (\a -> a == True) $ fmap (\(x,y) -> x == y) $ zip <*> tail $ xs
\a -> a == True == \a -> a
allEqual xs = all (\a -> a) $ fmap (\(x,y) -> x == y) $ zip <*> tail $ xs
\a -> a == id
allEqual xs = all id $ fmap (\(x,y) -> x == y) $ zip <*> tail $ xs
all id == and
allEqual xs = and $ fmap (\(x,y) -> x == y) $ zip <*> tail $ xs
fmap (uncurry something) $ zip == zipWith something
allEqual xs = and $ zipWith (==) <*> tail $ xs
allEqual = and $ zipWith (==) <*> tail

----------------------------
reverse_ l = let
    _reverse (x:xs) y = _reverse xs (x:y)
    _reverse [] y = y
    in _reverse l []


{- main = print $ _reverse [1..6] [] -}
main = print $ reverse_ [1..6]

--------------------------------
there're two list, alist ["a","b","c"] and blist ["awe", "bword", "ces", "de"]
print that blist's element which contain alist's element

in python it would be 

for a in alist:
    for b in blist:
        if a in b:
            print(b)

[ b for a in alist for b in blist if a in b ]

in haskell with list comprehension
[ e | i <- lista, e <- listb, elem i e ]

try fmap . fmap 

import Data.List

alist = ["a","b","c"]
blist = ["awe","bword","fc","wf","lp"]

getSeq :: String -> String -> Maybe String
getSeq x y = if x `isSubsequenceOf` y
                then Just y
                else Nothing

{- main = print $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist -}
{- [Just "awe",Just "bword",Just "fc"] -}
main = print $ foldl1 (<>) $ fmap (filter (/= Nothing)) $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist

----------------------------------------
check if a int list is ordered
all (== True) $ fmap (\x -> (fst x) >= (snd x)) $ zip (tail [1..6]) [1..6]

foldMap = fold . fmap 

[3,1,2,7] \\ [3,1,5,9] == [2,7]
[1,2] \\ [1,2,3] == []

Data.Either
lefts [Left "3", Right "2", Left "5"] == ["3","5"]

fold . fmap (<> "\n") . lefts $ [Left "a", Right "b", Left "c"]
== "a\nc\n"

Data.Foldable
fold = foldl1 (<>)

Data.Text.isInfixOf is just check if it contain, if it ends with, true
isInfixOf "=" "ab=" == True

splitWith x xs = L.filter (/= "") . T.splitOn x $ xs

concatMap (fromLeft []) [Left "a", Right "b", Left "c"] == "ac"

Data.Text.replace

T.replace "\r" "\n" "a\r\nb\rc\n" == "a\n\nb\nc\n"

L.filter (/= "") . T.splitOn "\n" $ T.replace "\r" "\n" "a\r\nb\rc\n\n\nd"
== ["a","b","c","d"]


split with "\r" or "\n" or "\r\n"
the good way is replace "\r" to "\n" then split on "\n", and filter empty strings

T.filter (/= ' ') to filter spaces
T.replace "\r" "\n" to replace "\r" with "\n"
T.splitOn "\n" split with "\n"
L.filter (/= "") filter empty strings
