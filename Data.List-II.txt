
reverse_ l = let
    _reverse (x:xs) y = _reverse xs (x:y)
    _reverse [] y = y
    in _reverse l []


{- main = print $ _reverse [1..6] [] -}
main = print $ reverse_ [1..6]

--------------------------------
there're two list, alist ["a","b","c"] and blist ["awe", "bword", "ces", "de"]
print that blist's element which contain alist's element

in python it would be 

for a in alist:
    for b in blist:
        if a in b:
            print(b)

[ b for a in alist for b in blist if a in b ]

in haskell with list comprehension
[ e | i <- lista, e <- listb, elem i e ]

try fmap . fmap 

import Data.List

alist = ["a","b","c"]
blist = ["awe","bword","fc","wf","lp"]

getSeq :: String -> String -> Maybe String
getSeq x y = if x `isSubsequenceOf` y
                then Just y
                else Nothing

{- main = print $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist -}
{- [Just "awe",Just "bword",Just "fc"] -}
main = print $ foldl1 (<>) $ fmap (filter (/= Nothing)) $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist

----------------------------------------
check if a int list is ordered
all (== True) $ fmap (\x -> (fst x) >= (snd x)) $ zip (tail [1..6]) [1..6]

foldMap = fold . fmap 

[3,1,2,7] \\ [3,1,5,9] == [2,7]
[1,2] \\ [1,2,3] == []

Data.Either
lefts [Left "3", Right "2", Left "5"] == ["3","5"]

fold . fmap (<> "\n") . lefts $ [Left "a", Right "b", Left "c"]
== "a\nc\n"

Data.Foldable
fold = foldl1 (<>)

Data.Text.isInfixOf is just check if it contain, if it ends with, true
isInfixOf "=" "ab=" == True

splitWith x xs = L.filter (/= "") . T.splitOn x $ xs

concatMap (fromLeft []) [Left "a", Right "b", Left "c"] == "ac"

Data.Text.replace

T.replace "\r" "\n" "a\r\nb\rc\n" == "a\n\nb\nc\n"

L.filter (/= "") . T.splitOn "\n" $ T.replace "\r" "\n" "a\r\nb\rc\n\n\nd"
== ["a","b","c","d"]


split with "\r" or "\n" or "\r\n"
the good way is replace "\r" to "\n" then split on "\n", and filter empty strings

T.filter (/= ' ') to filter spaces
T.replace "\r" "\n" to replace "\r" with "\n"
T.splitOn "\n" split with "\n"
L.filter (/= "") filter empty strings
