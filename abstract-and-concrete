
abstract & concrete

if you want use a type's methods, then make the type concret

fun <A> t(e:A){
    e.length //will be not resolved, even you will pass a string to e
} //this is OK in js or python, but not OK in kotlin

fun t2(e:String){
    e.lenght //will be resolved, 'cause e has String type, and String type has lenght method
}

abstract type and concret type
it's like to be evalated or not to be evalated

if you want e has methods of String, then make e as String
don't set e as T, and pass String to e, that won't work in static language like kotlin
but it works in dynamic languages like python

def f(x){
    x + "1"
    or x +1 
} both ok, 'cause x can be String or Int

but fun <T> f(x:T) {
    x + "1"
    or x+1
} will not ok, 'cause + "1" x need to be String, +1 x need to be Int

sealed class Either<A,B>
data class Left<A,B>(val v:A):Either<A,B>()
data class Right<A,B>(val v:B):Either<A,B>()

fun  test(e: Either<Int,String>):Any{
    when (e){
         is Left<Int,String> -> return e.v
         is Right<Int,String> -> return e.v
    }
}

fun <A,B> test2(e:Either<A,B>):Any{
    when (e){
        is Left<A,B> -> e.v //return e.v then test2 return A, and return e.v on Right will return B, and Any is not ok here, 'cause A and B are not concret
        is Right<A,B> -> e.v //so don't use return, will return Unit
    }
}

fun main(){
    val t = Left<Int,String>(3)
    println(t.v)
    val t2 = test(Left<Int,String>(3))
    println(t2)
}

fun <A> t(e:A){
    //e.length
}
fun t2(e:String){
    e.length
}

