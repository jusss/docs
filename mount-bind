挂载点标记 shared, private, slave, unbindable
shared共享挂载，从共享挂载克隆的挂载对象也是共享的挂载；它们相互传播挂载事件。
如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。
private私有挂载，在默认情况下，所有挂载都是私有的。可以用以下命令将挂载对象显式地标为共享挂载：
mount --make-shared <mount-object>    标为共享
mount --make-private <mount-object>   标为私有
mount --make-unbindable <mount-object> 标为不可绑定
slave从属挂载，如果两个挂载对象形成从属（slave）关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象
但是反过来不行；在这种关系中，从属对象是事件的接收者。
从从属挂载克隆的挂载对象也是从属的挂载，它也从属于原来的从属挂载的主挂载对象。
mount --make-slave <shared-mount-object>
递归应用所有子目录
mount --make-rslave <shared-mount-object>


-B, --bind
      将某个目录树绑定挂载到其它地方，这样就可以同时从两个地方进行访问。
-R, --rbind
      将某个目录树绑定挂载到其它地方，并且其子目录如果是挂载点的话也递归的进行绑定。

 mount -t tmpfs tmpfs /tmp

http://www.ibm.com/developerworks/cn/linux/l-mount-namespaces.html
http://www.jinbuguo.com/man/mount.html
http://blog.csdn.net/quqi99/article/details/43087001
https://wiki.gentoo.org/wiki/Chroot

root #mount --rbind /dev /mnt/mychroot/dev
root #mount --make-rslave /mnt/mychroot/dev
root #mount -t proc /proc /mnt/mychroot/proc
root #mount --rbind /sys /mnt/mychroot/sys
root #mount --make-rslave /mnt/mychroot/sys
root #mount --rbind /tmp /mnt/mychroot/tmp

-------------------------------------------------------------------------------------------------------
sudo mount -o bind ~/tmp ~/tmp2/
~/tmp有的， ~/tmp2全有
touch tmp/test2  tmp2下也会有test2
touch tmp2/test  tmp下也会有test
sudo umount ~/tmp2
~/tmp会有test test2,而tmp2会恢复原状

mount -o bind /mnt  ~/
解决/home空间不足，可以把/mnt挂载到~/,这样/mnt有的，~/全有(覆盖，原本的~/会隐藏？所以建议把~/的配置文件复制到/mnt)
写入/mnt的会写入到/mnt并且~/下也有，写入~/的也会写入到/mnt,一旦卸载~/, 所有的改动
都会保存在/mnt, 而原本的~/会不变

为什么不mount -o bind ~/  /mnt呢？这样umount /mnt后所有的改动会保存在~/下，~/本来空间都不足，会撑爆的

挂载A到B, A覆盖B, 卸载B, B不变, A保留所有变化

so what if `sudo mount -o bind /bla2 /bla2/jessie/bla2` 这样就可以在chroot env里修改host系统的/bla2了
(在朋友的mbp上玩过，它里面有个文件目录里包含整个系统目录，就好比/bla2/whatever里面又能看到/ /bla2 /home根目录，很神奇)
------------------------------------------------------------------
<SysGhost> jusss: That is also possible. And if it would prevent you to mount
       it directly, you can always do a "bind mount": mount -o bind /bla2
       /bla2/whatevever.
<jusss> SysGhost: I used my friends mbp latop, and I found there's a directory
    I forgot that I can see whole / directory, I don't know why
<jusss> SysGhost: I mean cd /bla2 and ls I saw / /boot /home ... whole /
    directory show in /bla2, but /bla2 is under /
<Namarrgon> jusss: you can mount the same filesystem in more than one place 
<jusss> Namarrgon: with -o bind option?
<Namarrgon> jusss: yes but they will be implicetly bind-mounts even if you
        don't specifiy - o bind  
<Namarrgon> *implicitly
--------------------------------------------------------------------
mount -o bind 解决home空间不足
mount /dev/mmcblk1p1 /mnt
mount -o bind /mnt ~
此时~就是/mnt，所有操作~/的文件都会操作/mnt/的文件
为了能用~/下的配置文件， cp ~/ /mnt -r;  mount -o bind /mnt ~/;
卸载 umount ~/
ls -lh / 知/mnt是 drwxr-xr-x root root, 所以用set gid
chmod 3757 /mnt
这样非root的root组其它用户无权去写，而非root组的用户只可以修改自己创建的文件
当然更简单的是直接把mmcblk1p1挂载到普通用可以读写的目录里更好如/media/john/

set uid只能对文件操作 chmod u+s 一般是可执行文件，当别的用户执行这个文件时会以文件拥有者的身份去执行
set gid 可以对目录操作 chmod g+s 比如B目录属于bbb用户组，而B目录的other权限是rwx,所以用户组aaa的用户A可以
在B目录创建文件或目录，但创建的文件或目录，拥有者是用户A,所属的目录却是bbb
set sticky 可以不让别的用户删除你创建的文件 chmod o+t 目录

set gid和 set sticky大多用于公共目录的共享文件
set uid多用于需要root权限的可执行文件
set uid 4, gid 2, sticky 1



