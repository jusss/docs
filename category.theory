

22:52:30 <jusss> what is Functor composition?
23:01:35 <jusss> ski: f . g is function composition?
23:03:26 <ski> if `f' is a function from `T' to `U', and `g' a function from `U' to `V', (`T',`U',`V' being types / (structural) sets), then `g . f' is a function from `T' to `V', the composition of `g' after `f'. defined by `(g . f) x = g (f x)', for all inhabitants/values `x' in `T'
23:05:37 <ski> if `F' is a functor from `C' to `D', and `G' a functor from `D' to `E', (`C',`D',`E' being categories), then `G . F' is a functor from `C' to `E', the composition of `G' after `F'. defined on all objects `A' of `C' by `(G . F) A = G (F A)' (result is an object in `E'); and defined, for all objects `A',`B' of `C', on all morphisms `f' (in `C') from `A' to `B', by `(G . F) f = G (F f)' (result is a morphism (in `E') from `G (F A)' to `G (F B)')
23:08:07 <ski> in Haskell, an instance `f' of the type class `Functor' (iow an `f' where `Functor f' holds) must be a type `f' of king `* -> *', so the from and to categories (say `C' and `D' above) would both be the same category, corresponding to `*', sometimes written `Hask'. so `f' is a functor from `Hask' to `Hask' (both `C' and `D' being `Hask'), iow an *endo*functor (on `Hask')
23:11:04 <ski> one could also talk about functors between other categories in Haskell, but they wouldn't be instance of the type class `Functor' (which is only for endofunctors on `Hask')
23:11:04 <ski> e.g. if one defines `newtype StreamVia f a = SV (f (a,StreamVia f a))', then `StreamVia' is a functor to `Hask', from : the category of all functors from `Hask' to `Hask'. iow from the category of endofunctors on `Hask'
23:11:12 <ski> er, actually, sorry, the "to" is also that functo category here, not `Hask'
23:11:50 <ski> let's say `newtype IntegerStreamVia f = ISV (f (Integer,IntegerStreamVia f))' instead, to remedy that
23:12:46 <ski> in terms of Haskell kinds, we then have `IntegerStreamVia :: (* -> *) -> *' (`StreamVia :: (* -> *) -> (* -> *)' for the other one) -- but that doesn't say anything about `Functor'
23:14:14 <ski> one could imagine writing something like `IntegerStreamVia :: {f :: * -> * | Functor f} -> *', or `IntegerStreamVia : Hask^Hask >---> Hask' (in more "mathematical" notation)
23:15:36 <ski> for simpler cases, like `Maybe',`Either e' (for some `e :: *'), we get `Maybe :: * -> *',`Either e :: * -> *' (or `Maybe : Hask >---> Hask',`Either e : Hask >---> Hask')
23:16:27 <ski> we can compose `Maybe' and `Either e', in either way (let's take `Maybe' after), so `Maybe . Either e :: * -> *' (or `Maybe . Either e : Hask -> Hask')
23:17:03 * ski looks at jusss, idly wonders whether they're bewildered yet
23:20:02 <dminuoso> You probably intimidated them. ;)
23:22:30 <ski> anyway, `Either e' is a functor from `Hask' to `Hask', because it will accept one concrete type (like `Integer'), before producing a concrete type (then `Either e Integer') (assuming `e' is a concrete type, a type of kind `*', the type would be an object in the category `Hask' of all concrete types)
23:22:30 <ski> anyway, `Either e' is a functor from `Hask' to `Hask', because it will accept one concrete type (like `Integer'), before producing a concrete type (then `Either e Integer') (assuming `e' is a concrete type, a type of kind `*', the type would be an object in the category `Hask' of all concrete types)
23:25:24 <ski> what then is `Either' ? it will accept a concrete type `e' (an object in `*' / `Hask'), and produce a type `Either e' (a functor from `*' / `Hask' to itself). iow produce an object in the category of endofunctors on `*' / `Hask', written `{f :: * -> * | Functor f}' / `Hask^Hask' above
23:26:41 <ski> iow, `Either :: * -> {f :: * -> * | Functor f}' is a functor from `*' to `{f :: * -> * | Functor f}'. in other notation, `Either : Hask >---> Hask^Hask'
23:27:50 <ski> combining that with `IntegerStreamVia :: {f :: * -> * | Functor f} -> *' / `IntegerStreamVia : Hask^Hask >---> Hask'. composing that functor `IntegerStreamVia' after `Either', we get `IntegerStreamVia . Either :: * -> *' / `IntegerStreamVia . Either : Hask >---> Hask'
23:28:51 <ski> (and i'll stop here. the point/goal was to show a slightly more complicated composition than say `Maybe . Maybe' or `Maybe . Either e', where the categories involved were not all `*' / `Hask')
23:31:08 <jusss> ski: sorry, I was busy
23:31:16 * ski nods
23:31:41 --- join: cur8or (~cur8or@41.79.221.218) joined #haskell
23:31:44 <jusss> MarcelineVQ: I heard "Functor composition" from here yesterday
23:31:48 <ski> jusss : tell me where you can't follow any longer, and we'll see what we can do
23:32:02 <ski> jusss : first things first, do you know about basic function composition ?
23:32:54 <jusss> ski: how to know if I know or don't know?
23:33:17 <jusss> f . g = \x -> f (g x) this one I know
23:33:54 <ski> can you predict what the type of e.g. `filter . (0 <=)' will be, just by looking at that (and perhaps writing on paper, or in a buffer. but not asking the interactor). you may assume `0' is an `Integer' here
23:33:58 <ski> ?
23:34:02 * ski nods
23:34:08 <ski> @src (.)
23:34:09 <lambdabot> (f . g) x = f (g x)
23:34:15 <ski> (which is the same thing)
23:34:19 --- join: afk (~afk@114.242.122.145) joined #haskell
23:34:21 --- join: Vikfret (~Vikfret@189.216.85.255) joined #haskell
23:34:58 <jusss> I can use type inference to get (f . g) x = f (g x) based on its type signature
23:35:00 <jusss> :t (.)
23:35:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:35:25 <ski> yes. can you do that in your head ? (or on paper, or writing in a text buffer)
23:35:47 <jusss> @src filter
23:35:47 <lambdabot> filter _ []     = []
23:35:48 <lambdabot> filter p (x:xs)
23:35:48 <lambdabot>     | p x       = x : filter p xs
23:35:48 <lambdabot>     | otherwise = filter p xs
23:35:48 --- quit: cods (Ping timeout: 245 seconds)
23:35:59 <ski> @type filter
23:36:00 <lambdabot> (a -> Bool) -> [a] -> [a]
23:36:02 <ski> @type (<=)
23:36:04 <lambdabot> Ord a => a -> a -> Bool
23:36:41 --- quit: jusss (Remote host closed the connection)
23:36:50 --- join: jusss (~user@unaffiliated/jusss) joined #haskell
23:37:24 <ski> `(<=)' here involves type class constraints. but since feed it `0' (as first argument), which we agreed to assume was an `Integer' in this case, we'll actually have
23:37:38 <jusss> sorry, network disconnected
23:37:41 <ski>   (<=) :: Ord Integer => Integer -> Integer -> Bool
23:38:16 <ski> and since we know `Integer' is an instance of `Ord' (iow we know `Ord Integer' holds), we can skip that (true/holding) constraint, getting
23:38:19 <ski>   (<=) :: Integer -> Integer -> Bool
23:38:23 <DariusTheMede> I am trying to install https://github.com/NixOS/cabal2nix/tree/master/hackage2nix
23:38:48 <DariusTheMede> I get * Missing (or bad) header file: openssl/evp.h
23:38:57 <ski> so, that's the type of `(<=)', in our case. and `(0 <=)' will do the same as `(<=) 0', so that's just feeding `0' as first argument to `(<=)'
23:39:09 <DariusTheMede> I have done sudo apt install libssl-dev
23:39:17 <DariusTheMede> But that hasn't fixed the problem
23:39:18 <ski> jusss : does that make any sense to you ?
23:39:27 <jusss> ski: yeah
23:39:32 --- join: dansho (~dansho4@71-84-161-204.dhcp.astr.or.charter.com) joined #haskell
23:39:54 <jusss> we feed another one Integer and get a Bool 
23:39:59 <ski> jusss : so, what's the type of `(<=) 0' (and thus of `(0 <=)') ?
23:40:17 <jusss> (<=) 0 :: Integer -> Bool
23:40:20 <ski> yes
23:40:22 <ski> now take
23:40:34 <DariusTheMede> Perhaps I should ask on #hackage
23:41:00 <ski>   (.) :: (b -> c) -> (a -> b) -> (a -> c)  -- the last pair of brackets here is redundant, but may help inserting here, for emphasis
23:41:28 <jusss> :t filter
23:41:29 <lambdabot> (a -> Bool) -> [a] -> [a]
23:41:30 <ski> however, let's rename `a',`b',`c' here, to not confuse them with the `a' in the signature of `filter'
23:41:44 <ski>   (.) :: (y -> z) -> (x -> y) -> (x -> z)
23:41:59 --- quit: Volt_ (Quit: exit();)
23:42:10 --- quit: mostendocrine (Ping timeout: 268 seconds)
23:42:13 <ski>   filter :: (a -> Bool) -> ([a] -> [a])  -- last pair of brackets redundant, added for clarity / emphasis
23:42:21 <ski>   (<=) 0 :: Integer -> Bool
23:42:25 --- join: gerri (~justen@183.109.194.26) joined #haskell
23:42:51 <ski> so, what will the type of `filter . (<=) 0' (or `filter . (0 <=)') become ?
23:43:13 <ski> and, what's the particular type of `filter' and `(.)', as used in this particular instance ?
23:43:42 <ski> jusss : try and see for a short while whether you can figure out the answer to those questions
23:43:46 <jusss> ski : Integer -> ([a]->[a]) ?
23:44:14 --- quit: cur8or (Ping timeout: 258 seconds)
23:44:25 --- quit: chr15 (Ping timeout: 250 seconds)
23:44:38 --- quit: Zer0xp (Ping timeout: 268 seconds)
23:46:04 <ski> jusss : would that be an answer to the former or the latter of those two questions ?
23:46:23 <ski> oh
23:46:27 * ski smiles
23:46:55 * ski just realized a type error in the example
23:47:02 <jusss> ski: ...
23:47:05 <ski> jusss : can you spot it ?
23:47:14 <jusss> ski: wait a min
23:47:32 --- join: Stuk (~Stuk@192.145.126.244) joined #haskell
23:47:45 --- quit: gerri (K-Lined)
23:48:02 --- join: cods (~fred@tuxee.net) joined #haskell
23:48:12 <ski> (that's probably what i get for trying to do two conversations at the same time. i'm sorry for the inconvenience. but perhaps it could be good practice trying to find it out, and what to do to fix it)
23:49:12 <ski> (jusss : probably you already have sortof an idea of what the intent of the example was to be)
23:49:28 --- join: chele (~chele@2a02:8106:1:f900:faca:b8ff:fe2f:8499) joined #haskell
23:49:36 --- quit: texasmynsted (Ping timeout: 258 seconds)
23:50:20 --- join: maurise (~darren@183.97.107.29) joined #haskell
23:50:31 --- quit: maurise (K-Lined)
23:50:47 --- quit: afk (Read error: Connection reset by peer)
23:51:18 --- join: encod3 (~encod3@89.20.162.146.static.ef-service.nl) joined #haskell
23:51:27 --- join: osa1 (~omer@haskell/developer/osa1) joined #haskell
23:51:59 <jusss> ski: function composition seems to me like connect two function to one, like t = f . g, t has g's input type, and t's result type is f's result type
23:52:20 <ski> yes, that's correct
23:52:28 <ski> it's like a "pipeline"
23:52:51 <jusss> yeah, connect them to new one
23:53:03 <ski>   V <--{ f }--< U <--{ g }--< T
23:53:05 <ski> assuming
23:53:08 --- quit: tromp_ (Read error: Connection reset by peer)
23:53:09 <ski>   g :: T -> U
23:53:15 <ski>   f :: U -> V
23:53:22 <ski>   f . g :: T -> V
23:53:29 --- join: Sk01 (~sky3@144.122.52.71) joined #haskell
23:53:29 --- join: tromp (~tromp@2a02:a210:1585:3200:e050:7321:c75c:3766) joined #haskell
23:53:38 <jusss> yeah
23:54:06 <ski> however, if we consider `filter . (<=) 0', and the signatures for `(<=) 0' and `filter', we have
23:54:12 <ski>   (<=) 0 :: Integer -> Bool
23:54:16 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
23:54:37 --- join: mostendocrine (~mostendoc@c-73-171-123-243.hsd1.va.comcast.net) joined #haskell
23:54:41 <hc> hi all, trying a simple example to run into mem exhaustion due to lazy evaluation; recent ghc seems to optimize that away?
23:54:47 <hc> incf i = if i == 1000000000 then i else (incf $ i + 1)
23:55:10 <ski> so the output type of the "previous" function, `(<=) 0', is `Bool', but the input type of the "next" function, `filter', is `(a -> Bool)', and these can't possibly match
23:55:23 --- join: fphilipe (~phil@2a02:168:f6c3:0:b8bf:e638:1609:c942) joined #haskell
23:55:24 <ski> however, we could *pass* `(<=) 0' as *input* to `filter'
23:55:39 <ski> iow, `filter ((<=) 0)' would be okay
23:55:53 <ski> but since `f (g x)' is `(f . g) x'
23:55:57 <ski> @src (.)
23:55:57 <lambdabot> (f . g) x = f (g x)
23:56:38 <ski> `filter ((<=) 0)' should then be `(filter . (<=)) 0', and so it looks like `filter . (<=)' is actually the composition that we probably had in mind here
23:56:47 <ski> so, then we want to compose instead
23:56:55 <ski>   (<=) :: Integer -> Integer -> Bool
23:57:00 <ski> before
23:57:05 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
23:57:12 <ski> jusss : making sense ?
23:57:18 <jusss> ski: ok
23:57:22 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
23:57:28 <ski> or, let's clarify the signature of `(<=)' as
23:57:33 <ski>   (<=) :: Integer -> (Integer -> Bool)
23:57:45 <ski> by introducing an extra pair of (redundant) brackets
23:58:04 --- quit: ltriant (Quit: leaving)
23:58:17 <ski> so, will the output type of the "previous" function now match the input type of the "next" function ?
23:58:26 --- quit: fphilipe_ (Ping timeout: 276 seconds)
23:58:35 <jusss> matched
23:59:39 --- quit: tromp (Ping timeout: 252 seconds)
23:59:44 --- join: dima__ (~dima14@ppp-124-122-28-243.revip2.asianet.co.th) joined #haskell
23:59:57 <ski> so, what's the type of the whole composition `filter . (<=)' here ?
23:59:59 --- log: ended haskell/19.08.27
00:00:00 --- log: started haskell/19.08.28
00:00:09 <ski> and what's the particular type of this usage of `filter' ?
00:00:13 --- quit: shiradz (Quit: shiradz)
00:00:23 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:d990:ab00:8e8d:2270) joined #haskell
00:00:25 --- quit: fphilipe (Ping timeout: 264 seconds)
00:01:28 <jusss> filter . (<=) :: Integer -> [Integer] -> [Integer]
00:01:35 <ski> yes
00:01:50 <ski> and `filter' ?
00:02:09 <jusss> ski: check some list if they <= 0
00:02:41 <ski> the composition will do something along those lines, yes
00:02:45 <jusss> get the new list , which elements which is <= 0
00:02:49 --- quit: nineonine (Remote host closed the connection)
00:03:02 --- join: shiradz (~shiradz@197.255.156.29) joined #haskell
00:03:03 --- join: actuallybatman (~sam@S010664777dafd303.cg.shawcable.net) joined #haskell
00:03:09 --- part: osa1 left #haskell
00:03:17 <ski> well, the elements which are `(<=) 0'. iow which are `(0 <=)'. iow which are at *least* zero (not at most)
00:03:43 --- quit: petersen (Ping timeout: 245 seconds)
00:03:45 <jusss> ok
00:03:46 <ski> (so gives the non-negative numbers (non-negative integers, aka natural numbers), in the list)
00:03:51 <ski> but what's the particular type of `filter' here ?
00:04:21 <ski> what is the result of matching the output type of `(<=)', namely `Integer -> Bool', with the input type of `filter', namely `a -> Bool' ?
00:05:35 --- join: pycer (~pycer@unaffiliated/pycer) joined #haskell
00:05:50 --- quit: cynick (Ping timeout: 245 seconds)
00:06:03 <jusss> filter now take Integer->Bool as input type and [Integer] as result type
00:06:36 <jusss> no
00:06:42 --- join: fphilipe (~phil@81.6.34.65) joined #haskell
00:07:16 <jusss> ski: sorry, I don't follow your words...
00:08:11 <jusss> filter's a will be Integer?
00:08:22 <ski> yes
00:08:25 <ski> that's right
00:08:27 <ski> so ..
00:08:32 <ski>   filter :: (a -> Bool) -> ([a] -> [a])
00:08:37 <ski> will therefore become ?
00:08:56 <jusss>   filter :: (Integer -> Bool) -> ([Integer] -> [Integer])
00:10:17 --- quit: dima__ (Quit: This computer has gone to sleep)
00:10:31 <ski> yes, right
00:11:13 <ski> and so the input type of `filter . (<=)' is the input type of `(<=)', which is `Integer'. and the output type of `filter . (<=)' is the output type of `filter', which is .. ?
00:12:06 <jusss> ([Integer] -> [Integer])
00:12:12 <ski> right
00:12:15 --- join: ggole (~ggole@2001:8003:8119:7200:1dd3:cd8d:29f5:9682) joined #haskell
00:12:25 --- quit: ub (Ping timeout: 264 seconds)
00:12:28 <ski> so the type signature of the composition is
00:12:46 <ski>   filter . (<=) :: Integer -> ([Integer] -> [Integer])
00:12:51 <jusss> yes
00:12:54 <ski> which can be abbreviated as just
00:12:56 <ski>   filter . (<=) :: Integer -> [Integer] -> [Integer]
00:13:07 --- join: nfd9001 (~nfd9001@2601:602:8500:2443:b9de:f368:e4c1:efdf) joined #haskell
00:13:13 <ski> in Haskell, which is (of course) what you already said above
00:13:24 <ski> now, here's an example of using this function
00:13:30 <ski> > (filter . (<=)) 0 [13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13]
00:13:32 <lambdabot>  [13,5,2,1,0,1,1,2,3,5,8,13]
00:13:36 --- join: tromp (~tromp@2a02:a210:1585:3200:e050:7321:c75c:3766) joined #haskell
00:14:05 <ski> so, we feed a number (`0') as input to `(<=)'. it outputs a function that waits for a second number to compare `0' with
00:14:36 <ski> this *function* is passed as input to `filter', which outputs another *function, which we immediately pass a list as input
00:15:33 <ski> the definition of `filter' will then call the intermediate function, the one in the middle of the "pipeline", on every element of that list, and discard those elements where that function yeilds `False' (keeping those that it yields `True' for)
00:15:50 <ski> so, we keep all numbers in the list which are at *least* zero
00:16:03 <ski> jusss : i hope this example makes sense, now
00:16:10 <jusss> ski:yes
00:16:34 <jusss> ski: and about Functor?
00:16:42 <ski> the interesting part here, was that the "intermediate" type was a function type, not a "simpler" type like `Integer' or `[Integer]' or `(String,Integer)'
00:17:43 --- join: cynick (~worm@ec2-52-206-86-1.compute-1.amazonaws.com) joined #haskell
00:18:19 --- quit: pycer (Quit: "sleep")
00:18:21 --- quit: tromp (Ping timeout: 252 seconds)
00:18:59 --- join: dima__ (~dima14@ppp-124-122-28-243.revip2.asianet.co.th) joined #haskell
00:19:07 --- join: ctag1 (~ctag@24.42.183.214) joined #haskell
00:20:45 <ski> hm
00:21:07 <ski> jusss : do you want to hear a Haskell story, or a category theory story ? (or maybe both ?)
00:21:26 --- quit: ctag_ (Ping timeout: 244 seconds)
00:22:55 --- quit: darjeeling_ (Ping timeout: 245 seconds)
00:23:45 --- join: darjeeling_ (~darjeelin@115.215.40.230) joined #haskell
00:26:36 --- quit: oish (Ping timeout: 244 seconds)
00:28:51 --- quit: gioyik (Quit: WeeChat 2.5)
00:28:57 --- join: reactormonk (~tass@185.85.220.201) joined #haskell
00:31:19 --- join: tromp (~tromp@2a02:a210:1585:3200:e050:7321:c75c:3766) joined #haskell
00:31:20 --- quit: dima__ (Quit: This computer has gone to sleep)
00:32:12 <jusss> ski: sorry, busy, I'd like to heard both :)
00:32:16 --- join: tromp_ (~tromp@ip-213-127-58-74.ip.prioritytelecom.net) joined #haskell
00:32:35 <jusss> only child do choice, we adults want all :)
00:33:11 --- join: vicfred (~vicfred@189.216.85.255) joined #haskell
00:33:13 <ski> ok, do you think you know the basic definition of what a category is ?
00:33:16 --- join: milanj (~milan@178.220.178.4) joined #haskell
00:33:33 <jusss> ski: not exactly
00:34:50 --- quit: spion (Ping timeout: 258 seconds)
00:35:35 --- quit: tromp (Ping timeout: 252 seconds)
00:35:51 --- join: ilikeheaps (~sushi@176.120.120.135.telemedia.pl) joined #haskell
00:35:56 --- join: raichoo (~raichoo@office02.saltation.de) joined #haskell
00:36:06 --- join: cur8or_ (~cur8or@2c0f:feb0:2c:5700:4c68:c694:5703:3603) joined #haskell
00:36:19 <ski> should we start with that, then ?
00:36:28 <jusss> ski: ok
00:37:03 --- quit: cur8or (Ping timeout: 252 seconds)
00:37:28 <ski> ok
00:37:52 <ski> so, category theory can be seen as an abstract theory of functions and function *composition* (not application)
00:37:54 <jusss> "the absence abstract"
00:38:31 <ski> we know there's an identity function, for every type / (structural) set, in Haskell `id' has type `a -> a', for any type `a', e.g. `Integer'
00:38:47 --- quit: freeman42x]NixOS (Remote host closed the connection)
00:38:52 <ski> each particular choice of `a' will give an identity function, for the chosen type
00:39:08 <ski> so the identity function on `Integer' has type `Integer -> Integer'
00:39:30 <ski> the interesting thing about the identity function, in relation to composition, is that composing with it changes nothing
00:39:32 --- join: spion (~spion@unaffiliated/spion) joined #haskell
00:39:41 <jusss> f . id = f
00:39:52 <jusss> id is the unit
00:39:54 <ski> so `f . id' is `f', for any function `f'. and that is equal to `id . f'
00:39:55 <ski> yes
00:40:25 <jusss> monoid (.), id is the unit
00:40:43 <ski> this is similar to `x + 0 = x',`x = 0 + x'. and `xs ++ [] = xs',`xs = [] ++ xs'. and `x * 1 = x',`x = 1 * x'
00:40:53 <jusss> ok
00:41:12 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
00:41:46 <ski> yes. but if we talk about monoids, then we talk about *endo*functions, so `id' has type `a -> a', for some type `a', and `f' *also* has type `a -> a' (for the same choice of `a'), in those equations/laws involving `id' above
00:42:10 <ski> however, even if `f :: a -> b', then `f . id = f' (where here `id :: a -> a')
00:42:11 --- quit: nowhere_man (Ping timeout: 252 seconds)
00:42:25 <ski> and also, if `f :: a -> b', then `f = id . f' (where here `id :: b -> b')
00:42:41 <ski> and this is *not* captured by the monoid idea (but is similar to it)
00:42:46 <ski> jusss : okay ?
00:42:51 <jusss> ski: ok
00:43:49 <ski> in the monoid case, we also have `(h . g) . f = h . (g . f)' (just as we have `(x + y) + z = x + (y + z)',`(xs ++ ys) ++ zs = xs ++ (ys ++ zs)',`(x * y) * z = x * (y * z)')
00:44:09 <jusss> the associativity law
00:44:25 <ski> and, in the monoid case, this is assuming that `f,g,h :: a -> a', for some particular type `a' (for each choice of `a', we get a different endofunction monoid on `a')
00:44:28 <ski> yes
00:44:45 <jusss> because become a monid, must become a semigroup first
00:44:58 <ski> now, what we do in category theory is we generalize from this monoid case, to the corresponding case that looks like function composition
00:45:00 <jusss> and semigroup has the associativity law
00:45:08 --- join: Silent_Alex (~Alex@205.175.205.245) joined #haskell
00:45:30 <dminuoso> jusss: Its not about semigroup, its about that monoid requires the arguments and result to be of the same "group of things"
00:45:42 <ski> so, instead of just having "elements" of a monoid, which we can "combine"/"compose". now we have "morphisms" of a category, which we can "compose" -- but *only* if they are "compsable"
00:45:49 <jusss> dminuoso: ok
00:46:12 <ski> in a monoid, all elements can be combined together, using the monoid combination operation
00:46:51 <ski> in a category, each morphism has a "source"/"domain" (you can think "input type"), and a "target"/"codomain" (you can think "output type")
00:47:33 <jusss> ski: what is "the monoid combination operation"?
00:47:56 <ski> and we can only compose a morphism `g' after a morphism `f', yielding a composition `g . f', in case the target/codomain ("output type") of `f' matches (is the same as, is equal to) the source/domain ("input type") of `g'
00:48:29 <jusss> ok
00:48:50 --- quit: reallymemorable (Quit: reallymemorable)
00:49:06 <ski> jusss : in the monoid `(Integer,0,(+))', the (binary) operation is `(+)'. in the monoid `(Integer,1,(*))', it is `(*)', in the monoid `([a],[],(++))' (one monoid for each choice of the type `a'), it is `(++)'
00:49:27 --- join: yoneda (~mike@193.206.102.122) joined #haskell
00:49:39 <jusss> ski: yes
00:49:51 --- join: baskeboler (~user@r186-54-73-130.dialup.adsl.anteldata.net.uy) joined #haskell
00:50:06 <ski> (a monoid is a triple `(M,neut,comb)' of a type / (structural) set `M', an element `neut' (neutral element) of `M', and a binary operation `comb' on `M' (which can combine any two elements of `M' into an element of `M'))
00:51:40 --- quit: Gurkenglas (Ping timeout: 245 seconds)
00:51:56 --- join: kuribas (~user@ip-188-118-57-242.reverse.destiny.be) joined #haskell
00:52:03 <ski> (well, a monoid is such a triple, that *satisfies* the monoid laws, `forall (x :: M). comb x neut = x',`forall (x :: M). x = comb neut x',`forall (x :: M) (y :: M) (z :: M). comb (comb x y) z = comb x (comb y z)' .. one could write the combination as an infix symbol instead, say `<>', and then the laws would look more similar, syntactically, to what we had above)
00:52:28 --- join: danvet (~Daniel@212-51-149-96.fiber7.init7.net) joined #haskell
00:52:42 --- quit: kubek2k (Quit: WeeChat 2.3)
00:52:57 --- quit: darjeeling_ (Ping timeout: 244 seconds)
00:53:02 --- join: kubek2k (~Jakub_Jan@213-241-3-97.static.ip.netia.com.pl) joined #haskell
00:53:36 --- quit: cur8or_ (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
00:54:16 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:4c68:c694:5703:3603) joined #haskell
00:54:20 <Silent_Alex> how to send the word with the symbol for underscore
00:55:12 <ski> jusss : ok, so
00:55:40 <ski> for a category, we can't just compose any two morphisms (also called arrows) with each other, they must be composable
00:55:47 <ski> instead of writing say
00:55:50 <ski>   x :: M
00:56:03 <jusss> ski: I don't now how we get here, but we start with Functor....
00:56:05 --- quit: noan (Quit: ZNC 1.7.3 - https://znc.in)
00:56:05 --- quit: DigitalKiwi (Quit: quite.)
00:56:09 * dminuoso smiles
00:56:11 <ski> to mean that `x' is an element of the monoid `M' (really of a monoid whose carrier set/type is `M')
00:56:30 <ski> jusss : functors comes after categories. one step at a time
00:56:50 <ski> instead of saying that, we say
00:57:00 <ski>   f : A >--->_C B
00:57:04 --- join: Marc0F3 (~marcofe@5.102.12.253) joined #haskell
00:57:05 <ski> or, for short
00:57:06 <ski>   f : A >---> B
00:57:18 <jusss> ok
00:57:35 <ski> where `C' is the category that our morphism/arrow `f' lies in (just like `M' was the monoid that the monoid element `x' belonged to)
00:57:51 --- quit: heatsink (Remote host closed the connection)
00:57:54 --- join: DigitalKiwi (~kiwi@unaffiliated/digitalkiwi) joined #haskell
00:57:54 --- join: noan (~noan@192.241.157.119) joined #haskell
00:58:08 --- quit: cur8or (Client Quit)
00:58:45 <ski> and now we can't just say what category (namely `C' here) that `f' belongs to, we must also specify for each morphism `f' (in our category `C') its source/domain/"input type" and target/codomain/"output type"
00:58:51 <ski> which would be `A' and `B' above
00:59:09 --- join: chalkmonster (~chalkmons@unaffiliated/chalkmonster) joined #haskell
00:59:24 <jusss> ok
00:59:27 --- join: dmitri (~dima14@ppp-124-122-28-243.revip2.asianet.co.th) joined #haskell
00:59:37 <ski> a monoid just "contains" elements. a category "contains" morphisms. but in order to keep track of when they're composable, we also need these "types", which are called "objects"
00:59:50 <ski> so, `A' and `B' above are objects of the category `C'
01:00:16 <ski> now, let's for a moment step back to the endofunction monoid `(a -> a,id,(.))'
01:00:23 <jusss> wait a sec
01:00:27 <ski> ok
01:00:27 --- quit: DigitalKiwi (Client Quit)
01:00:27 --- quit: noan (Client Quit)
01:00:59 --- join: noan (~noan@192.241.157.119) joined #haskell
01:01:03 <dminuoso> Given some monad M, and some `T -> M X`, how can I turn `M T` into `M (T, X)` in a concise manner?
01:01:06 <jusss> C is the categroy, and C has types A and B, 
01:01:20 --- join: m0rphism1 (~m0rphism@149.172.82.115) joined #haskell
01:01:28 --- join: DigitalKiwi (~kiwi@unaffiliated/digitalkiwi) joined #haskell
01:01:48 <dminuoso> Or is âŒœdo t <- a; q <- b t; pure (t, q)âŒ the most sensible way?
01:02:02 <jusss> and C has monoid in it?
01:02:28 <ski> jusss : the concept of a category is a generalization of the concept of a monoid
01:03:28 <jusss> ski: a monoid is a category?
01:03:29 <ski> in a monoid, we can combine any two elements. in a category, we can only compose "composable" morphism. where "composable" means that the "input type" of the "later" morphism equals the "output type" of the "earlier" morphism
01:03:38 <dminuoso> jusss: a monoid is a special case of a category, yes.
01:03:41 <ski> jusss : yes, every monoid can be considered to be a category
01:03:50 <dminuoso> jusss: every monoid is a category, but not every category is a monoid.
01:04:07 <ski> (or, "is a category", if we're being slightly sloppy with our words, for the sake of brevity)
01:04:07 --- quit: lambda-11235 (Quit: Bye)
01:04:42 --- join: o1lo01ol1o (~o1lo01ol1@152.80.136.95.rev.vodafone.pt) joined #haskell
01:04:47 <jusss> ski dminuoso ok
01:05:05 --- join: knupfer (~Thunderbi@200116b82c8efe00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
01:07:09 --- quit: encod3 (Remote host closed the connection)
01:07:46 <jusss> in a monoid, "input type" can point "output type" through "later" morphism?
01:07:46 <ski> jusss : let's make a pictoresque analogy
01:07:47 --- join: encod3_ (~encod3@144.178.76.42.static.ef-service.nl) joined #haskell
01:08:02 <ski> think of the elemnts in a monoid as small lumps of clay (or something similar), having somewhat different qualities (say color). and you can take two elements, and mold them together into a new element
01:08:08 <ski> you can combine any two elements
01:08:25 <jusss> ok
01:08:37 <jusss> two become one
03:11:13 --- log: started haskell/19.08.28
03:11:13 --- join: clog (~nef@bespin.org) joined #haskell
03:11:13 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
03:11:13 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
03:11:13 --- names: list (clog cybai ub Phillemann howdoi freeman42x]NixOS zaquest encod3 zargoertzel the_true_potato o1lo01ol1o mikolaj skim_ rruizt laem xff0x doublex MarconM Ariakenom cfricke baskebol` boxscape acidjnk ph88 fendor kubek2k tabaqui iuno samebchase Lord_of_Life jose_zap gehmehgeh DavidEichmann plutoniix Insanity_ chr15 cosimone Zer0xp DigitalKiwi noan housecarpenter thc202 knupfer m0rphism1 danvet kuribas yoneda Silent_Alex spion raichoo ilikeheaps milanj tromp_)
03:11:13 --- names: list (reactormonk ctag1 cynick nfd9001 ggole actuallybatman shiradz mostendocrine Sk01 chele cods dansho alanz DariusTheMede asheshambasta lastmanstanding Amras0000 sword865 sQVe linarcx esph edwardk vlatkoB jneira _vaibhavingale_ cyphase lions[m] esrse echoreply thonkpod EvanR sagax piyush-kurur Unhammer jokester fjellfras poljar1 theDon matej58 pfurla lagothrix felixfoertsch pi__ shutdown_-h_now polman jluttine_ conal MindlessDrone Guest93722 olligobber ciet[m])
03:11:13 --- names: list (grag[m] ircer[m] ookfof[m] fiddeldibu[m] unclechu atopuzov[m] arianvp[m] Grgoire[m] uelen[m] biox[m] jrozanski alko[m]1 SmiVan[m] laniusfnv[m] hsw[m] patonw[m] vpei[m] ldesgoui[m] sielicki wildtrees[m] imposs[m] pagoda_5b[m] aqtusia[m] illandan[m] noteventime krhubert[m] fswalker[m] LasEspuelas Bimmie[m] kumarbis[m] danielbmarkham[m hkimhvyh[m] aruncom2006[m] M2en[m] teej adaizen[m] bgamari andreabedini _janne pie_ MarcelineVQ gabiruh MonkeyNOS yaroot pavonia)
03:11:13 --- names: list (Jesin hive-mind hukyld suppi kAworu dstolfa blazered_ Xeyame lukelau kaol jgt inkbottle iqubic alicemaz xelxebar ravenous_ evanjs sim590 shwouchk davr0s_ davr0s Anthaas involans Lowl3v3l ClaudiusMaximus monochrom danpalmer miklcct carter Lears ralu SCHAPiE s00pcan atomi mudri Sgeo_ raatiniemi megaTherion DTZUZO carlomagno kuttifunk kori Natch Majiir ravenousmoose shafox wonko7 roman4 swalladge _dga sshaaf Axman6 alx741 rsoeldner gentauro nshepperd Sonokinetic)
03:11:13 --- names: list (notzmv hololeap gbellinoz CSP-SOFTWARE kingofmemes droplet AGmotive[m] mkoenig hc sdrodge ziyourenxiang jb55 dysfigured Rama[m] orzo tomboy64 cantstanya andreas303 klntsky phreedom khisanth_ mceier johnw hegge revprez_anzio nshepperd2 nshepperd1 jakalx acarrico lassulus tv JoelMcCracken amb007[m] saml carif luite seanparsons theorbtwo Neo-- Saulzar_ chin-tastic n3t daGrevis dennisb nahra ruffy_ cp- nesqi zfnmxt laith1[m] phaul lemmih totte AWizzArd Fischmiep)
03:11:13 --- names: list (DTZUZU thunderrd_ ziman restrictedchoice diginet abra0 reorder_ ephemera_ atk bydo justanotheruser hiptobecubic Vq Fubar^ dTal edwtjo devalot unlink2 pyan Wamanuz stepnem juri_ nisstyre gienah_ flux fliife sukbeom tombusby amiri marble_visions hovgaard[m] kini fantasti` noCheese puffnfresh Seich BoneTone marmalodak mnrmnaugh Tourist coddinkn Rich[m]11 cbarrett atraii jrm avn Rudd0 Neuromancer tlax mjuad no-n moldybits dolio Deadhand rom1504 fionnan nekomune)
03:11:13 --- names: list (srnty jlvvlj[m] goulix haasn nicoulaj jle` hvr TimWolla petermw thaumavorio a3f kyleondy[m] NinjaTrappeur keep-learning[m] quaestor glguy violeta wagle scal Ekho jchia RusAlex pent aetherfreak zekt srk dolanbatar Adluc drbean_ nil m4lvin Klumben xacktm SolarAqu- cheers Moyst bartavelle moobar graingert theNeuron barrucadu drewr systemfault bolverkr hongminhee elcaro petercommand eagleflo markus1189 nullifidian caasih aidecoe w1gz bjs m1dnight_ i7c sicklorkin)
03:11:13 --- names: list (gonz_ mountaingoat remexre rann stux|RC nyuszika7h pothyurf[m] yur3shmukcik[m] betz[m] ist5shreawf[m] cawal[m] jeeg[m] etjet[m] cesar[m] EuAndreh[m] contrun[m] mat8913[m] e godva[m] jak[m] josef[m] somni[m] wuxianhuiyi[m] wrunt[m] boistordu pineapple[m] M0ddba11[m] thekyriarchy jonreeve[m] GNULizard[m]1 Hanma[m] Artifth[m] fulgjon kaychaks[m] ghastfilms[m] eyenx[m] simbergm vikraman NickHu1 cbg[m] yoltid[m] ad5twoknebor[m] avocado derberg[m]1 runningriot9[m])
03:11:13 --- names: list (hans[m]5 ppseafield[m] whoops periapseez[m] Brio[m] iarp[m] wobbol[m] peter-js[m] papazeus[m] Chromad[m] pong vigilian[m] ilmu[m] steshaw[m] arturo[m] MonsieurArcher[m reedhhw[m] ovigren[m] hjoest[m] Jonathan[m]2 zopsi[m] Guest63612 EmilKarlson alxev[m] zmlww[m] natmac[m] gandi[m] gspia[m] ajirx[m] bee[m]1 lukasubo[m]1 yi[m] lmolr[m] miseenplace[m] likliklik cosson[m] joe[m]31 sayukimans[m] tops[m] aloiscochard[m] charliebucket[m] midi[m] Ekho[m] aearnus[m])
03:11:13 --- names: list (cepxuo rowan[m] potato44[m] roberth lapav[m] mobile_x[m] reconmaster[m] bkl[m] nolep[m] oniani[m] xlogan[m] GreenKarm[m] roninkaizen[m] tomtau[m] macerbi[m] iceychris[m] d1mur4tdj[m] torkel[m]1 nartir[m] veeee[m] nonlinear[m] freu[m] coil[m] iantownsend abbe[m] suppenkasper[m] hifutakiko[m] benzoid[m] undu[m] steamedbun[m] dag[m] fgaz siraben fiberpunk[m] humanwire[m] DenisLehmann[m]1 ClownMaster[m] lierdakil[m] Godel[m] atpotts danielemarsella[ beaky)
03:11:13 --- names: list (nullheroes[m] dustyp[m] souldev[m] tmallard[m] laniu[m]1 JulesRen-George4 Mesa[m]11 markus[m]21 kitsune[m]1 josiah_sama rihardsk[m] Richy[m]1 MerlinGttlinger[ Guy[m]1 mattia[m] sriehl[m] buggeas40d[m] PotatoRick[m] dumuzid[m] sm[m] blakec[m] labs[m] davex32[m] stan[m] vaibhavsagar javjarfer[m] spacekitteh[m] sergiotarxz[m] sylvie[m] ninjatrappeur[m] mithrandi[m] friedm[m] domenkozar[m] hdurer[m] jonge[m] tswett[m] mujx[m4 infinisil masaeedu[m] dude[m]1)
03:11:13 --- names: list (corin[m] aquarial[m] ShujaRafi[m] themsay[m] JoGoSi[m] thekyriarchy[m]1 gkobeaga[m] gentlehelm[m] jak[m]1 maigel[m] nh2[m] matrixyz[m] WeiTang[m] krowlan3[m] sudorebootsudor4 shiroeni[m]1 Syllo[m] jhgarner[m] neat72[m] Vincent[m]2 jesusvega[m] gswuichet[m]1 dlilja[m]1 jumzi[m] edwel[m] corin[m]1 aitzol[m]1 buster528[m]1 deikatsuo[m] jwerner[m] unitymember[m]1 vespuccy[m] peel Pete[m] dxml[m] Surgeon[m] luisjira[m] intellection3to3 vancha112[m] themadman[m]1)
03:11:13 --- names: list (PoopSick[m] lihram hogarth[m] Orbstheorem[m] Kenneth[m] asonixDogHeThey[ luftmensch[m] tempaccount1[m] brandon123[m] jochens[m] glothit7ok[m] giuseppe[m] schum mssx89m[m]1 inflationova[m] eckt[m] dice[m]1 imp0s5ible tuxsoy bt[m]1 georgescratcherd null14[m] zorkedon[m] rainbyte[m] gmips[m] Noughtmare[m] Tom[m]7 amerocu[m] pietromrtn[m] tarigo[m]1 Alec[m]2 GhostofaConsole[ Mougan[m]1 vkleen tejok[m] foxadee[m] brevalda[m]1 adziahel[m] kerru[m] excel_gate[m])
03:11:13 --- names: list (kylos[m] alibabzo abdolence[m]1 asayers[m]1 Godslatestgift[4 MartinKlimi[m] GNULambda[m] Cenion[m] yrid[m] PrimeSeeker[m] M31violet13[m] rahduro[m] beatricejensen[m aquarial triskeon[m] sphalerit anton-latukha[m] JoelMcCracken[m] texpat[m] mmynsted[m] pschooom[m] sepp2k phanimahesh[m] pebeto[m] apurvapavaskar bobach[m] weebull[m] m00n[m] sghir_med[m] odd13[m]1 abc123zzz[m] M|GNUisnotLinux[ joenase[m] alexfmpe[m] ChristopherBurg[ unrooted[m]1 Lite[m] vorbex[m])
03:11:13 --- names: list (jibby[m]1 supersweetsweet4 xethrog42[m] nybble41[m] soaoaig[m] afontain[m] AMlivinfree[m] PonyLoop1000[m] olmvnec[m] twom[m] jwaksbaum[m] tindvik[m] apx[m] talvdav[m] pqwy[m] thosgood[m] ineff testacc3[m] n0ma_d[m] NickHu gmind[m] qasim[m] triste[m] cjwelborn PhilipWhite[m] SFL[m] vsts[m] teaknow[m] link2xt[m] jibby kaiyou[m] Marceline[m] jg[m] jdks[m] kai10[m] heyakyra[m] dopplergange MichalLaskus[m] imdoor[m] korlaplankton[m] gd2398[m] JakeO[m] deklund[m])
03:11:13 --- names: list (nalix[m] ludovicdanjoumad johanejg[m] admdch[m] mouse008[m] cale[m] cjskaggs[m] Paavo[m] beaverfever[m] Cloud[m] maxmaguire[m] kicker22004[m] grorg[m] Kimani[m] k4l1gr4[m] AkikoHimenokoji[ Kit[m] actartis[m] limabeans[m] AaronWeiss[m] keith[m] supersven[m] max3raza[m] chris[m]15 jennie[m] godzilla[m] alana[m]1 cyclops19[m] tinwood S007 rgh[m]2 Hakan[m] ManiacTwister paulus[m] scheming_around pdgwien pierrot averell jammar typedrat Ericson2314 kubrat nckx)
03:11:13 --- names: list (Bigcheese hexagoxel Cale nurupo sputny[m] xalek[m] haskelllisp[m] luminousnine[m] alex[m]14 MarquisKurt[m]1 akt[m] GregKNicholson[m kahuna[m] hackeryarn[m] Wizek[m] shanesveller[m] vk3wtf[m] javbit[m]1 tkots[m] mujx[m]1 vars[m] popo[m] shachiku[m] petrolifero[m] rinor[m] kapilp_ cemerick jorj nopf __4matter_ ski APic Jonno_FTW Nik05 furnost Eliel flogfr ecx86 runawayfive RoguePointer suzu rootmos zv stvc pacak stefan-__ Flonk gargawel_ shapr digia CindyLinz)
03:11:13 --- names: list (SlashLife qz swater rotaerk sbrg catern Ulrar arianvp Drezil charukiewicz dilinger wtw Tene ByronJohnson alp gspia [exa] arw scinawa jrslepak Someguy123 daissgr Ornedan cheater uberj dustinm- glamas opqdonut Taneb delYsid Bergle_1 kjak thjread oleks kark Putonlalla mimi_vx cchalmers Foritus dmiles hpc davean rodgzilla deni locallycompact connrs_ freusque Batholith sigmundv- travv0 ynyounuo Squarism jtcs Dykam kqr lpsmith qzo srhb tstat mupf nivpgir_)
03:11:13 --- names: list (jdevlieghere beka dyl_ reyu bollu noko_ DDR shadowdaemon SquidDev clynamen_ maerwald ftop divVerent Profpatsch sarahzrf gluegadget cheshircat vimto PtxDK erikd sw1nn runde benwr_ jackdk terrorjack__ RecursiveG koankeeper kraem ZoFLo cocreature ammar2 PHO c-rog dredozubov noctux apeyeoux _guios energizer_ Sparadox nonzen adamse ocharles lstdgtfp jbetz johnstein wayne deu evilmonads bcmiller fr33domlover tristanC bdw sm asm89 tsani Intensity Athas lugh heath)
03:11:13 --- names: list (zerokarmaleft jol madnight chindy a3Dman mxf thebnq implementation Jello_Raptor statusbot bsima xtsee flebron dan64 sea-gull Jacoby6000 michalisko jonge Remavas tsahyt jzl niklasb_ UserOO7 betawaffle sqrt2 dxtr mccoyc dave_uy DwarfMaster cyberlard sudden acro joeytwiddle iron_houzi markhuge jinblack djanatyn anderson avp sssilver luigy geal eldritch exio4 carbolymer coldpress Aleksejs [df] connrs- gambpang gsingh93 michalrus Phyx- exarkun Rembane bob_twinkles)
03:11:13 --- names: list (simon Heffalump greeny__ AkhILman Firedancer_ canta mikolaj_ Arguggi jvanbure TommyC stilgart Unode ion otulp waskell hjozwiak ap5 MatrixBot3 wadadli e2 artem Mo0O pcoutin rodlogic tms_ enemeth79 raoul troydm bind sterni rzmt wraithm telser xarian sdx23 mniip greymalkin seliopou jonatan a7250ag styledash ft fryguybob so M2tias mmaruseacph2 immae subfacto1 apoc kipras`away cross Zemyla Maxdamantus ereu lyxia gothos phadej zenzike Logio freeside cjay- spoonm)
03:11:13 --- names: list (polux7 abuss saidinwot1 sandman13 bengt_ bendo _ht Entroacceptor adadelta malthe bbear_ moocow_ duairc Robin_Jadoul Chousuke albel727 lkurusa Nikotiini oeblink Vtec234 yahb jix drewbarbs datajerk Sose Niamkik dqd Arahael rosalux sobhan PlasmaStar adamCS Deewiant exferenceBot lortabac bcoppens crooked d3lxa adarshaj Xandaros wz1000 fiatjaf pharaun kosmikus tchakka fiddlerwoaroof blackdog hodapp haveo johs pasukon Guillaum dfordivam ullbeking drdo JSharp koz_)
03:11:13 --- names: list (krystianbajno tureba Igloo epta zymurgy vktec yumh codedmart andromeda-galaxy Cathy nitrix myme topos cjh` lambdabot int-e mulk rotty micro abrar w1d3m0d3 forell Cthalupa zzz raek Bish bbear TMA pingiun theophil893 kav jwynn6 atle catsup ycheng gregberns lowryder Guest69260 mrus hsiktas Kneiva PierreM Tspoon_ mjrosenb jameekim relrod saurik bwe ambrosia_ SegFaultAX intelux matheus mikeplus64 Forkk arsdragonfly Hotbees Enigmagic bspar lexi-lambda haroldwu)
03:11:13 --- names: list (Guest39039 agrif infandum NightA typetetris_ PoliticsII_ idupree2 amatecha_ ab9rf tazjin nlofaro_ mitchellsalad_ eacameron phaazon thi_ jophish dsal_ azahi dumptruckman dani- ekleog absence Kiruwa dh statusfailed s94a84d2e wildsebastian VSpike jackhill adius silver_needles d0liver ghuntley metalrain tabaqui1 ebutleriv J_Arcane teehemkay affinespaces darthThorik benl23 ajmcmiddlin EduardoBautista runeks georgew kloeri solarus _flow_ sivs lurkless t36s jmsx)
03:11:13 --- names: list (vjoki twk- fiQ2 aristid amuck phlym leah2 Adeon Geekingfrog defanor vqrs dequbed akermu copypasteque maralorn uwap mingc lsix ryjm TallerGhostWalt_ liif newhoggy dexterfoo nh2_ riasue_ mjlee integral SrPx_ sebastianrkg verlet64 rootnode_ sethetter Jon Tristan-Speccy spamlessj Guest81022 ProofTechnique rizary_ dmj` cyjiao__ AndreasK tolt ibloom higherorder lightandlight spinda kip mankyKitty raid @ChanServ grumble @Sigyn nikivi bitonic alunduil iravid Lermex)
03:11:13 --- names: list (tehidiot epicallan Kamuela monad_cat alexelcu bradparker winny linoge nkaretnikov Nascha entel dpn` jsatk fredcy- hodlwave_ glowpelt trucy natim87 rubik sphalerite Remy^ yushyin obfusk__ Jaxan Blkt amosbird feuerbach_ glowcoil banjiewen mpickering rajivr___ quarters seventh__ michaelpj interruptinuse PyroLagus zabracks nuxdie Randy ryzokuken feepo unsymbol morgib dukedave nbouscal duncan Jabbslad joel135 elvishjerricco sebhoss sgraf simony AfC billstclair)
03:11:13 --- names: list (refreshing_drink ephemeron fingerzam rslima___ xnyhps heyj datapup_ sis7 jlpeters Firedancer raoulb devurandom srid Konehaltia jonrh scav Shun131 coot alexknvl NemesisD casdr_ ixian Ferdirand milessabin liquorice paf31_ edmundnoble christopher jesyspa aib bjobjo stylewarning bananagram `slikts mstruebing dxld griddle dgpratt bs zxrf m-renaud sclv kyagrd__ jetpack_joe Peter_Storm abbe Reisen lieven _6a68 xyggos tomjaguarpaw scivola dongcarl Netwolf andyo nyaomi)
03:11:13 --- names: list (Chobbes jstolarek hackage Digit recj _ashbreeze_ boj ysangkok dmwit c_wraith dibblego tnks angerman vk3wtf tdammers xstill dixie_ Clint tomku obiwahn strangeglyph Paks bandali pingu_ urdh dcoutts earthy hiredman DustyDingo lispy sud0 Ankhers comboy h30 Meanirelli ent tA- hsyl20 klugez mrsbear lavalike andjjj23 joeyh Nevoic yorick robogoat bitemyapp koala_man Annihitek Guest6007 jdt monokrome tumdedum noexcept_ crtschin_ arkeet` chirpsalot meck aldum)
03:11:13 --- names: list (keep_learning ahri xplat jlamothe s4msung leothrix rembo10 yitz Tuplanolla Ckat cgfbee tessier PragCypher valdyn sellout- net4all gilbertw1 aesi irclogger_com dminuoso Twey enragedjam vin-ivar sms Ranhir aplainzetakind jfredett joehillen Ring0` Mon_Ouie infinity0 lachenmayer nibbling_ mtjmullen brisbin umachan Hijiri pdxleif dashkal habbah Ke Philonous thallada stiell cpape lemald __name__ loc rkrishnan vodkaInferno chivay MasseR)
03:11:22 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:c4c1:368:ea0:e582) joined #haskell
03:11:38 <Phillemann> Okay, you convinced me to at least take a look at it again. My API is extremely simple, so maybe I'm lucky.
03:11:46 --- quit: doublex (Remote host closed the connection)
03:12:04 --- join: doublex (~doublex@c-73-117-89-215.hsd1.oh.comcast.net) joined #haskell
03:12:55 --- quit: kubek2k (Ping timeout: 245 seconds)
03:13:44 --- quit: xff0x (Quit: xff0x)
03:13:46 --- quit: jose_zap (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
03:15:09 --- join: durandal1 (~durandal1@2601:647:4900:43:1da0:610e:4160:a7c2) joined #haskell
03:15:20 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
03:15:23 --- quit: cybai (Ping timeout: 276 seconds)
03:15:25 --- quit: ub (Ping timeout: 264 seconds)
03:15:31 --- join: texasmynsted (~texasmyns@c-24-11-206-84.hsd1.tn.comcast.net) joined #haskell
03:15:58 --- quit: Silent_Alex (Read error: Connection reset by peer)
03:16:51 --- quit: freeman42x]NixOS (Quit: Leaving)
03:17:36 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
03:19:04 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:c4c1:368:ea0:e582) joined #haskell
03:19:11 --- join: Aquazi (uid312403@gateway/web/irccloud.com/x-enarormhsfifpmyd) joined #haskell
03:19:33 --- quit: imtravis (Ping timeout: 245 seconds)
03:19:56 --- quit: durandal1 (Ping timeout: 276 seconds)
03:20:49 --- join: kubek2k (~Jakub_Jan@213-241-3-97.static.ip.netia.com.pl) joined #haskell
03:22:10 --- quit: sagax (Remote host closed the connection)
03:25:06 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
03:25:50 --- quit: kubek2k (Ping timeout: 272 seconds)
03:27:40 <nbouscal> I'm in the middle of converting my production web app to PostgREST and am super happy with it, especially for simple APIs
03:28:14 <nbouscal> Haskell code is great but no code is better :)
03:28:21 <ClaudiusMaximus> is there a way in cabal to test for pkg-config --modversion to do conditional compilation (eg, support newer features if available)?
03:30:07 --- join: ubert (~ub@ip5b4094fc.dynamic.kabel-deutschland.de) joined #haskell
03:30:50 --- quit: revprez_anzio (Ping timeout: 245 seconds)
03:31:16 --- join: tsaka__ (~torstein@dslb-178-004-036-111.178.004.pools.vodafone-ip.de) joined #haskell
03:31:28 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:c4c1:368:ea0:e582) joined #haskell
03:31:47 --- join: revprez_anzio (~revprez_a@static-173-76-190-156.bstnma.ftas.verizon.net) joined #haskell
03:35:30 --- join: cybai (~cybai@210.160.37.89) joined #haskell
03:37:30 --- quit: boxscape (Ping timeout: 245 seconds)
03:39:08 --- join: Brekker (~brekker@131.170.239.13) joined #haskell
03:40:24 --- quit: cybai (Ping timeout: 272 seconds)
03:41:18 --- quit: vjoki (Quit: ...)
03:41:55 --- join: TheTruePotato (the_true_p@gateway/vpn/privateinternetaccess/thetruepotato/x-30559709) joined #haskell
03:41:56 --- join: Clough (~Cain@c122-107-197-171.eburwd5.vic.optusnet.com.au) joined #haskell
03:44:03 --- quit: plutoniix (Quit: Leaving)
03:45:08 --- quit: the_true_potato (Ping timeout: 268 seconds)
03:46:29 --- join: Guest_43 (a7dce8d9@167.220.232.217) joined #haskell
03:49:48 --- quit: cosimone (Quit: Leaving)
03:50:04 --- quit: zargoertzel (Ping timeout: 268 seconds)
03:51:11 --- join: blackspider76[m] (blackspide@gateway/shell/matrix.org/x-uwjvibpqrfsrmydi) joined #haskell
03:51:20 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
03:54:59 --- join: Wuzzy (~Wuzzy@p5790EDDD.dip0.t-ipconnect.de) joined #haskell
03:55:23 --- join: kubek2k (~Jakub_Jan@213-241-3-97.static.ip.netia.com.pl) joined #haskell
03:59:12 --- join: obihann (~textual@142.177.141.14) joined #haskell
03:59:20 --- join: rndd (~rndd@213.221.2.38) joined #haskell
03:59:39 --- join: solonarv (~solonarv@astrasbourg-653-1-173-254.w86-204.abo.wanadoo.fr) joined #haskell
04:00:03 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
04:01:38 <hvr> ClaudiusMaximus: kinda; there's `pkgconfig-depends` via which you can impose constraints on the modversion
04:01:57 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
04:02:05 <hvr> ClaudiusMaximus: so you can control the setting of an automatic cabal flag depending on the version of modversion
04:02:11 --- quit: Brekker (Quit: WeeChat 1.9.1)
04:02:45 --- join: oish (~charlie@85.159.94.30) joined #haskell
04:03:25 <hvr> and once you can do that, you can use on of the ways to perform conditional compilation (e.g. via CPP, or also at the .cabal level by swapping out modules)
04:04:47 --- quit: heatsink (Ping timeout: 276 seconds)
04:06:45 --- quit: fjellfras (Quit: Leaving)
04:08:16 --- quit: pie_ (Remote host closed the connection)
04:08:38 --- join: boxscape (86ab4836@gateway/web/cgi-irc/kiwiirc.com/ip.134.171.72.54) joined #haskell
04:08:43 <ClaudiusMaximus> hvr: cool, i think i can get that working
04:08:46 <ClaudiusMaximus> hvr: thanks
04:10:00 --- quit: skim_ (Ping timeout: 245 seconds)
04:10:44 <ClaudiusMaximus> but i guess it is a bad thing to make the exposed API depend on pkg-config modversion?
04:11:03 <ClaudiusMaximus> because flags can't be depended
04:13:22 --- quit: ph88 (Quit: Leaving)
04:15:23 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
04:15:43 --- quit: o1lo01ol1o (Remote host closed the connection)
04:16:18 --- join: al-damiri (uid142631@gateway/web/irccloud.com/x-tjtidmalwzurrznd) joined #haskell
04:17:22 --- join: theelous3 (~theelous3@unaffiliated/theelous3) joined #haskell
04:19:51 --- quit: imtravis (Ping timeout: 258 seconds)
04:19:53 --- join: and_pete (uid386199@gateway/web/irccloud.com/x-jimwvugpxahkvrlp) joined #haskell
04:20:54 --- quit: oish (Ping timeout: 268 seconds)
04:25:09 --- join: vyorkin (~user@83.220.239.196) joined #haskell
04:26:13 --- quit: knupfer (Ping timeout: 264 seconds)
04:27:46 --- quit: cfricke (Quit: WeeChat 2.5)
04:28:05 --- quit: ilikeheaps (Quit: Konversation terminated!)
04:28:49 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
04:31:21 --- quit: linarcx (Quit: WeeChat 2.5)
04:31:31 --- quit: and_pete ()
04:31:44 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
04:32:02 --- join: and_pete (uid386199@gateway/web/irccloud.com/x-xokhzgxfilmfmbft) joined #haskell
04:32:23 --- quit: linarcx (Client Quit)
04:32:40 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
04:33:20 --- join: machinedgod (~machinedg@134.41.46.111) joined #haskell
04:33:24 --- quit: linarcx (Client Quit)
04:33:51 --- quit: esrse (Ping timeout: 268 seconds)
04:35:14 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
04:37:30 --- quit: Amras0000 (Ping timeout: 248 seconds)
04:37:43 --- quit: boxscape (Remote host closed the connection)
04:38:25 --- join: ykm (~elysium@2405:204:2016:e4ad:3d2f:cb74:4472:5ce5) joined #haskell
04:39:19 --- join: DariusTh` (~user@cpc112685-nmal22-2-0-cust375.19-2.cable.virginm.net) joined #haskell
04:39:35 --- join: xkapastel (uid17782@gateway/web/irccloud.com/x-hwmtselggdgikxoj) joined #haskell
04:40:11 --- quit: ykm (Remote host closed the connection)
04:41:46 --- join: boxscape (86ab4836@gateway/web/cgi-irc/kiwiirc.com/ip.134.171.72.54) joined #haskell
04:42:21 --- quit: DariusTheMede (Ping timeout: 244 seconds)
04:42:30 --- quit: TheTruePotato (Ping timeout: 245 seconds)
04:44:17 --- join: flyingpancake (c1ae191e@NATWLAN.hs-fulda.de) joined #haskell
04:48:08 --- quit: flyingpancake (Remote host closed the connection)
04:50:18 --- join: Amras (~Amras@unaffiliated/amras0000) joined #haskell
04:50:23 --- join: OnkelTem (~onkeltem@unaffiliated/fantomas) joined #haskell
04:50:45 --- part: sghir_med[m] left #haskell
04:51:33 --- join: TheBrodmann (~TheBrodma@185.182.222.239) joined #haskell
04:51:54 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:e940:966c:6d7e:e30f) joined #haskell
04:54:25 <boxscape> Just discovered that the formatting tool brittany only indents `where` in a function by half an indent (and the line below it by another half indent, so a full indent together). Is that common practice? I don't think I've ever noticed it anywhere
04:55:08 --- join: xff0x (~fox@softbank126065153248.bbtec.net) joined #haskell
04:56:57 --- join: iomonad (~iomonad@unaffiliated/iomonad) joined #haskell
04:57:44 <boxscape> i.e. like this https://i.imgur.com/A4mMoe0.png
04:58:07 <boxscape> with only one space in front of where and an additional space before the following lile
04:58:10 <boxscape> s/lilie/line
04:58:11 <hpc> i do it sometimes
04:58:16 <boxscape> okay
04:58:41 --- join: zargoertzel (~zar@78-62-230-102.static.zebra.lt) joined #haskell
04:58:43 --- quit: Ckat (Changing host)
04:58:43 --- join: Ckat (~Ckat@xn--z7x.xn--6frz82g) joined #haskell
04:59:23 --- quit: jgt (Ping timeout: 276 seconds)
04:59:54 --- join: jgt (~jgt@2a02:a31b:8542:b480:208f:a9cc:189a:99a2) joined #haskell
05:00:23 --- quit: MarconM ()
05:00:47 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
05:01:06 <hexagoxel> boxscape: it is configurable inline via "-- brittany { lconfig_indentWhereSpecial: False }" or the same field in the config file
05:01:20 <boxscape> ah, that's good to know, thanks
05:02:20 --- join: cybai (~cybai@2400:4050:3122:900:2186:ed02:2c89:2ba1) joined #haskell
05:02:55 --- quit: lastmanstanding (Ping timeout: 245 seconds)
05:05:13 --- quit: jgt (Ping timeout: 264 seconds)
05:05:46 --- quit: actuallybatman (Ping timeout: 248 seconds)
05:05:53 <boxscape> hexagoxel Overall I'm impressed by it fwiw, nice work
05:05:53 --- quit: heatsink (Ping timeout: 276 seconds)
05:07:48 --- join: fphilipe (~phil@46-127-142-222.dynamic.hispeed.ch) joined #haskell
05:07:57 <hexagoxel> thanks!
05:08:53 --- join: __monty__ (~toonn@unaffiliated/toonn) joined #haskell
05:09:49 --- quit: MonkeyNOS (Quit: Textual IRC Client: www.textualapp.com)
05:10:06 --- quit: alanz (Remote host closed the connection)
05:11:15 --- join: TheTruePotato (~the_true_@dyn3213-187.wlan.ic.ac.uk) joined #haskell
05:11:38 --- join: TheBrodm1nn (~TheBrodma@185.212.171.53) joined #haskell
05:12:49 --- join: Kaivo (~Kaivo@ec2-35-182-108-102.ca-central-1.compute.amazonaws.com) joined #haskell
05:13:09 --- join: MonkeyNOS (~VladPutin@2604:2000:1484:26:5038:30be:7405:e37d) joined #haskell
05:13:09 --- quit: carlomagno (Remote host closed the connection)
05:13:38 --- join: the_true_potato (the_true_p@gateway/vpn/privateinternetaccess/thetruepotato/x-30559709) joined #haskell
05:14:28 --- join: actuallybatman (~sam@S010664777dafd303.cg.shawcable.net) joined #haskell
05:14:35 --- quit: TheBrodmann (Ping timeout: 245 seconds)
05:15:54 --- quit: TheTruePotato (Ping timeout: 248 seconds)
05:16:02 --- quit: matej58 (Quit: matej58)
05:16:18 --- join: matej58 (~Thunderbi@118.201.216.102) joined #haskell
05:16:26 --- quit: Guest_43 (Remote host closed the connection)
05:20:24 --- quit: matej58 (Remote host closed the connection)
05:20:29 --- join: skim_ (~zhangzhen@218.92.226.152) joined #haskell
05:21:17 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
05:21:28 --- join: aarvar (~foewfoiew@50.35.43.33) joined #haskell
05:23:08 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:e940:966c:6d7e:e30f) joined #haskell
05:23:57 --- quit: Insanity_ (Quit: Connection closed for inactivity)
05:26:46 --- quit: freeman42x]NixOS (Quit: Leaving)
05:27:42 * hackage hs-rqlite 0.1.2.0 - A Haskell client for RQlite  https://hackage.haskell.org/package/hs-rqlite-0.1.2.0 (kderme)
05:28:28 --- quit: zargoertzel (Ping timeout: 258 seconds)
05:28:53 --- join: o1lo01ol1o (~o1lo01ol1@a109-49-167-181.cpe.netcabo.pt) joined #haskell
05:29:58 --- join: fweht (uid344711@gateway/web/irccloud.com/x-tnjpvvrusmaxdcrn) joined #haskell
05:30:14 --- join: jgt (~jgt@2a02:a31b:8542:b480:208f:a9cc:189a:99a2) joined #haskell
05:31:39 <fweht> its fascinating that monads are just monoids in the category of endofunctors...  monoids always deemed me as simple object, but it took me some time to get used to monoids...  is it because the definition of monoids in monoidal categories cannot speak about objects and is therefore more intricate?
05:31:52 <fweht> anyway, not really a question, just wanted to share this feeling ;)
05:32:33 <fweht> s/get used to monoids/get used to monads
05:33:04 <ski> there's monoids, and there's monoid objects in monoidal categories. monads are monoid objects in particular monoidal categories
05:33:17 --- join: carlomagno (~carlomagn@inet-hqmc01-o.oracle.com) joined #haskell
05:33:27 <Cale> fweht: There's a generalisation of the definition of a monoid, so that it applies not just to the (monoidal) category of sets, with the cartesian product as the tensor product on objects, and a one-element set as the unit object, but to other monoidal categories as well
05:33:54 <Cale> If you look here, you can see that definition: https://en.wikipedia.org/wiki/Monoid_(category_theory)
05:34:06 <fweht> Cale: yes, i meant this one!
05:34:10 <ski> so "monads are just monoids in the category of endofunctors" should more accurately be "monads are just monoid objects in the monoidal category of endofunctors (equipped with functor identity and composition as the monoidal structure)"
05:34:19 <fweht> ski: i see
05:34:38 <Cale> If we replace tensor product with Cartesian product, and I with some one-element set, and take the objects to be sets, that's a definition of a monoid
05:34:47 --- quit: jgt (Ping timeout: 252 seconds)
05:35:02 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
05:35:08 <boxscape> can you have non-monoid objects in a monoidal category?
05:35:22 <ski> you i suppose people say "monoid in category `C'" as short for "monoid object in the monoidal category `C', with monoidal structure being specified in context, or taken in the most obvious way"
05:35:22 <Cale> yes
05:35:42 <Cale> If instead, we take the objects to be endofunctors on some category C, and the tensor product to be composition of functors, and the arrows to be natural transformations, then it becomes the definition of a monad on C.
05:36:04 --- quit: TheBrodm1nn (Quit: Lost terminal)
05:36:07 <Cale> I the identity functor as well
05:36:14 <fweht> Cale: yes!  i got that, i was just amazed, that you get from the definition of a monoid to the definition of a monad so easily (maybe the definition of monoid object is the non-trivial part)
05:36:47 <fweht> Cale:  but if i just look at the definition of monoid object and think about the category of sets, it seems pretty straightforward still
05:37:27 <ski> boxscape : an object being (taken as) a monoid object isn't a property. it's not yes/no. it's structure. so "non-monoid objects" doesn't really make sense. "monoid object" means "object, and also blahblahblah"
05:37:57 <boxscape> I see
05:38:18 <Cale> But also, there will tend to be many objects which have no monoid structure on them.
05:39:11 <Cale> But yeah, in the category of sets, every set can be made into a monoid in usually many different ways
05:39:33 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
05:39:38 <ski> boxscape : you have objects in your category (such as a monoidal one (the monoidal part there also being additional structure over the mere category)). then, for each such object, there may be one, or more than one, way to *equip* it with monoid structure (wrt the monoidal structure of the category). and possibly, for some objects in the category, there may be zero ways to equip it as a monoid object
05:40:02 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:bd2f:63e7:17b7:550b) joined #haskell
05:40:05 <boxscape> So "Monoidal category" means there are some prerequisited (e.g. associative bifuncor) that you need to be able to have monoid objects in it?
05:40:19 <boxscape> s/prerequisited/prerequisites
05:40:44 <ski> boxscape : i'm not sure to which extent this really makes sense, unless you have an idea about what "monoidal category" means, and then "monoid object in a monoidal category" means. but if have have enough of an idea, perhaps my elaboration helps
05:41:32 <ski> boxscape : in short, i'm not saying that you can't have "non-monoid objects" in your monoidal category. i'm saying that the question didn't make any sense
05:42:21 <boxscape> yeah it mostly makes sense
05:42:27 <Cale> A monoid object in the category of monoids ends up being a commutative monoid, for example, so there are lots of cases there where you can't equip a monoid with an additional monoid structure.
05:42:43 <fweht> boxscape: i would imagine you *could* also define monoid objects in a regular category, if you specify all the properties of MxM, e.g. you say a monoid object is an object M with an object MxM (just a name), an object I (again just a name) and then put all the relevant stuff in the definition of monoid object
05:42:43 <ski> boxscape : yes, an associative (at least up to isomorphis) bifunctor, with a neutral (upto isomorphism) object wrt it
05:42:51 --- quit: iuno (Quit: Leaving)
05:43:22 <fweht> but in monoidal categories its very straight forward since you already have the relevant structure at hand
05:44:40 <ski> fweht : "maybe the definition of monoid object is the non-trivial part" -- yes, or at least the one that may be unexpected
05:44:51 <Cale> fweht: You mean we can turn an arbitrary category into a monoidal category if products and a terminal object exists?
05:45:19 <Cale> (This is true)
05:45:43 --- join: lucasb (uid333435@gateway/web/irccloud.com/x-dgwnjgeiqvcnxfxo) joined #haskell
05:45:44 <Cale> But you need finite products for that to happen.
05:46:02 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
05:46:22 <Cale> However, not every monoidal category is one of that form.
05:46:39 <boxscape> How does this relate to a monoid in the sense of a category with a single object?
05:47:11 <Cale> boxscape: Those monoids are monoid objects in (Set, Ã—, 1)
05:47:22 <boxscape> ok, I see
05:47:37 <boxscape> 1 being the set with one element?
05:47:51 <Cale> yeah
05:47:53 <boxscape> ok
05:48:18 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:bd2f:63e7:17b7:550b) joined #haskell
05:48:58 --- join: jose_zap (~jose_zap@office.expressional.com) joined #haskell
05:49:21 <fweht> Cale: i meant more that i dont know if there is way to make formal sense of the statement 'you need monoidal structure to define monoid object', but that was not boxscape's point i now realize
05:49:33 --- quit: rruizt (Ping timeout: 245 seconds)
05:49:41 --- join: Clouclou (~Clouclou@184.75.223.235) joined #haskell
05:49:44 --- quit: td123 (Ping timeout: 246 seconds)
05:50:08 <fweht> like, if you want to lift some set level definition on category (or monoidal category) level, my impression was that there is no canonical way of doing so
05:51:17 * ski . o O ( <https://ncatlab.org/nlab/show/Lawvere+theory> )
05:51:28 <Cale> correct, there's not necessarily a canonical way of lifting every set theoretical definition (though there are some common strategies which tend to work, replacing requirements that an element exists with arrows from a 1-object set, and then generalising to an arrow from a terminal object, or the unit of a monoidal category)
05:51:38 --- quit: cur8or (Client Quit)
05:51:40 --- quit: freeman42x]NixOS (Ping timeout: 245 seconds)
05:52:16 --- join: rruizt (~rruizt@83-84-23-124.cable.dynamic.v4.ziggo.nl) joined #haskell
05:52:30 --- join: Gurkenglas (~Gurkengla@unaffiliated/gurkenglas) joined #haskell
05:52:30 --- quit: iomonad (Quit: [1]    28823 segmentation fault (core dumped)  weechat)
05:53:24 --- join: hyperisco (~hyperisco@d192-186-117-226.static.comm.cgocable.net) joined #haskell
05:53:31 <Cale> btw, we also have that a (small) strong monoidal category is a monoid object in Cat -- but that isn't very useful as an initial definition :D
05:53:45 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:bd2f:63e7:17b7:550b) joined #haskell
05:54:35 --- quit: obihann (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
05:54:36 <fweht> :D
05:54:40 --- join: oish (~charlie@85.159.94.30) joined #haskell
05:55:04 --- join: tomsen (~tomsen@2a02:908:1862:49e0::2) joined #haskell
05:55:31 <fweht> so now i go back to work to gain intuition about adjoints  functors as generalized inverses
05:55:40 --- join: reallymemorable (~reallymem@cpe-66-108-137-140.nyc.res.rr.com) joined #haskell
05:55:59 --- join: plutoniix (~q@125.24.64.45) joined #haskell
05:56:22 --- quit: cur8or (Client Quit)
05:56:56 <Cale> er, strict, not strong
05:59:03 --- quit: jneira (Remote host closed the connection)
05:59:10 --- quit: oish (Ping timeout: 245 seconds)
05:59:45 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:945c:c1b8:b4fd:d6ff) joined #haskell
06:00:11 --- join: liberiga (~liberiga@gateway/tor-sasl/liberiga) joined #haskell
06:00:48 --- quit: skim_ (Ping timeout: 268 seconds)
06:01:26 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
06:01:32 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
06:01:33 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
06:02:15 --- quit: cur8or (Client Quit)
06:02:16 --- quit: xff0x (Ping timeout: 272 seconds)
06:04:40 --- quit: linarcx (Quit: WeeChat 2.5)
06:05:03 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
06:06:20 --- quit: heatsink (Ping timeout: 276 seconds)
06:06:38 --- join: dima__ (~dima14@ppp-58-11-29-128.revip2.asianet.co.th) joined #haskell
06:07:29 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:945c:c1b8:b4fd:d6ff) joined #haskell
06:08:42 --- join: lastmanstanding (~arjoonn@111.92.49.63) joined #haskell
06:09:03 --- join: spew (uid195861@gateway/web/irccloud.com/x-bijhlcbredreczhj) joined #haskell
06:09:33 --- join: tromar (~tromar@n114-74-40-80.sbr2.nsw.optusnet.com.au) joined #haskell
06:11:13 * hackage boots 0.2 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.2 (leptonyu)
06:11:47 --- quit: Gurkenglas (Ping timeout: 246 seconds)
06:12:01 --- quit: nahra (Quit: ERC (IRC client for Emacs 25.1.1))
06:13:28 --- quit: pavonia (Quit: Bye!)
06:14:02 --- quit: machinedgod (Ping timeout: 248 seconds)
06:14:11 --- join: mac10688 (~mac10688@c-76-115-116-76.hsd1.or.comcast.net) joined #haskell
06:15:36 --- quit: laem (Ping timeout: 268 seconds)
06:17:53 --- quit: infandum (Remote host closed the connection)
06:18:12 * hackage boots-app 0.2 - Factory for quickly building an application  https://hackage.haskell.org/package/boots-app-0.2 (leptonyu)
06:18:35 --- join: laem (~laem@unaffiliated/laem) joined #haskell
06:18:56 --- join: dddddd (~dddddd@unaffiliated/dddddd) joined #haskell
06:19:01 --- join: captjakk (~captjakk@75-166-173-191.hlrn.qwest.net) joined #haskell
06:19:09 --- join: jeltsch (~wolfgang@4a0a-9cab-9398-445c-3e80-82b2-07d0-2001.dyn.estpak.ee) joined #haskell
06:19:29 --- quit: skim_ (Ping timeout: 244 seconds)
06:19:32 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
06:20:25 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
06:21:10 --- join: cur8or (~cur8or@2c0f:feb0:2c:5700:945c:c1b8:b4fd:d6ff) joined #haskell
06:21:13 * hackage boots-web 0.2 - Factory for quickly building a web application  https://hackage.haskell.org/package/boots-web-0.2 (leptonyu)
06:21:47 --- join: lally_ (uid388228@gateway/web/irccloud.com/x-lzhyapffotdfrfwz) joined #haskell
06:22:15 --- quit: lally_ (Client Quit)
06:22:33 --- join: lally_ (uid388228@gateway/web/irccloud.com/x-kbzvazrmsclvhqlo) joined #haskell
06:22:48 --- nick: lally_ -> lally
06:22:58 --- quit: lally (Client Quit)
06:23:12 --- quit: dansho (Quit: Leaving)
06:23:17 --- join: lally (uid388228@gateway/web/irccloud.com/x-ebyixnzohyygtihd) joined #haskell
06:24:13 * hackage boots-cloud 0.2 - Factory for quickly building a microservice  https://hackage.haskell.org/package/boots-cloud-0.2 (leptonyu)
06:24:21 --- join: jgt (~jgt@2a02:a31b:8542:b480:6dd3:8720:2652:4625) joined #haskell
06:24:48 --- quit: dima__ (Quit: This computer has gone to sleep)
06:25:46 --- quit: danpalmer (Quit: Connection closed for inactivity)
06:27:28 --- join: dima__ (~dima14@ppp-58-11-29-128.revip2.asianet.co.th) joined #haskell
06:27:30 --- join: Insanity_ (uid179350@gateway/web/irccloud.com/x-jtsnrjjukaoigqbe) joined #haskell
06:27:38 --- quit: reallymemorable (Quit: reallymemorable)
06:28:37 --- quit: Neo-- (Ping timeout: 264 seconds)
06:28:54 <dminuoso> boxscape: Consider the monoidal category of endofunctors equipped with endofunctor composition as its tensor. Some of these objects are monoids (exactly those endofunctors which are monads), and others that are not. If we take the Haskell perspective, then in that category Maybe is a monoid (e.g. its a monad), but others like ZipList do not yield monoids.
06:29:18 --- join: ziyourenxiang_ (~ziyourenx@unaffiliated/ziyourenxiang) joined #haskell
06:29:34 --- quit: ziyourenxiang (Read error: Connection reset by peer)
06:29:43 --- join: Azel (~Thunderbi@ppp-115-87-121-236.revip4.asianet.co.th) joined #haskell
06:29:50 <dminuoso> Oopos. I was not scrolled down it seems. :)
06:30:34 <boxscape> still, interesting perspective
06:31:37 <dminuoso> boxscape: It was in response to your "can you have non-monoid objects in a monoidal category?" message. I didn't see anything below that.
06:31:52 <boxscape> yeah, I thought so :)
06:32:38 <dminuoso> (And to be precise, by Haskell perspective Im considering the category of endofunctors over Hask, equipped with Compose/Identity for the monoidal structure.
06:33:39 <boxscape> so if I'm seeing this correctly, all monoid objects have something like pure and join, and just in the category of endofunctors they coincide with Monad's pure and join
06:34:55 --- join: osa1_ (~omer@haskell/developer/osa1) joined #haskell
06:35:23 --- quit: linarcx (Ping timeout: 245 seconds)
06:35:29 --- quit: shafox (Read error: Connection reset by peer)
06:35:33 --- join: neiluj[m] (suilujmatr@gateway/shell/matrix.org/x-xwcnhpdvwkjvlhqi) joined #haskell
06:36:01 --- join: shafox_ (~shafox@49.205.220.105) joined #haskell
06:36:16 <boxscape> hmm why is join not part of the Monad class, anyway? Would be nice to be able to define a Monad in terms of join instead of in terms of bind
06:36:27 <ski> boxscape : a monoid object `M' has `neut : I >---> M' and `comb : M (*) M >---> M'
06:36:30 --- join: yoeljacobsen (~yoel.jaco@89.237.106.229) joined #haskell
06:36:50 <dminuoso> boxscape: In CT we call them Î¼ and Î·
06:36:57 <boxscape> ok
06:36:57 --- join: Guest77422 (~jao@pdpc/supporter/professional/jao) joined #haskell
06:37:07 <ski> boxscape : for a monad `M', this becomes `eta : Identity >---> M' and `mu : M . M >---> M', yes
06:37:07 <dminuoso> boxscape: So Monad is the monoid where Î¼ is called join and Î· is called return
06:37:21 <boxscape> that makes sense
06:37:50 <dminuoso> boxscape: There's at least one other common monoid in the world of Haskell that you regularly use
06:38:36 <boxscape> ...what is it?
06:38:44 --- quit: tomsen (Quit: Leaving)
06:38:58 <dminuoso> boxscape: If we equip the category of endofunctors not with Compose/Identity (such that âŒœÎ¼ : forall m. Compose m m ~> mâŒ and âŒœÎ· : forall m. Identity a -> m aâŒ) which would give us Monad
06:39:10 <dminuoso> boxscape: We could equip it with some other tensors. One example is a tensor called Day.
06:39:30 <dminuoso> boxscape: And now, monoids in that monoidal category are applicative functors.
06:39:38 --- quit: DTZUZO (Ping timeout: 248 seconds)
06:39:41 --- join: ystael (~ystael@50-199-243-61-static.hfc.comcastbusiness.net) joined #haskell
06:39:51 <boxscape> hm, okay
06:39:55 --- quit: Guest77422 (Remote host closed the connection)
06:40:06 <dminuoso> And above, I should for consistency have written: âŒœÎ¼ : forall m. Compose m m ~> mâŒ and âŒœÎ· : forall m. Identity ~> mâŒ) 
06:40:09 --- quit: reactormonk (Ping timeout: 244 seconds)
06:40:12 <dminuoso> Where ~> denotes natural transformation
06:40:28 --- join: jao- (~jao@pdpc/supporter/professional/jao) joined #haskell
06:40:53 <boxscape> why is it called day?
06:41:30 <dminuoso> boxscape: It's properly called the Day convolution operation, after its discoverer Bryan Day.
06:41:43 <boxscape> I see
06:42:18 --- quit: mac10688 (Ping timeout: 248 seconds)
06:44:11 --- quit: shafox_ (Read error: Connection reset by peer)
06:44:17 --- quit: DariusTh` (Ping timeout: 244 seconds)
06:44:24 <dminuoso> boxscape: So Applicative can too be considered to come with some sort of "join" and "return". The join of Applicative would take the shape of: `join :: Applicative f => Day f f a -> f a` and `pure :: Applicative f => Identity a -> Day a`
06:44:50 --- join: DariusTh` (~user@cpc112685-nmal22-2-0-cust375.19-2.cable.virginm.net) joined #haskell
06:45:02 <dminuoso> Equivalently Monad would, if we are verbose, equipped with: `joinM :: Monad m => Compose m m a -> m a` and `return :: Monad m => Identity a -> m a`
06:45:20 --- join: shafox_ (~shafox@49.205.220.105) joined #haskell
06:45:23 <boxscape> okay
06:45:27 <dminuoso> Oops!  `pure :: Applicative f => Identity a -> f a`
06:45:27 <dminuoso> Of course. :)
06:45:51 <boxscape> right
06:46:29 <dminuoso> boxscape: Or, I personally prefer infix notation and ~>, then: âŒœjoinA :: Applicative f => f `Day` f ~> fâŒ and âŒœjoinM :: Monad m => m `Compose` m ~> mâŒ
06:46:37 --- quit: thc202 (Ping timeout: 264 seconds)
06:46:58 --- join: thc202 (~thc202@unaffiliated/thc202) joined #haskell
06:47:49 <dminuoso> we could then take one step further, and consider some: class EFMonoid t i f where Î¼ :: f `t` f ~> f; Î· :: i ~> f
06:47:53 <boxscape> so.. these are natural transformations over endofunctors over Hask (not sure about the prepositions here) and thus at the same time morphisms/functions within Hask, right?
06:48:21 --- join: chalkmonster (~chalkmons@unaffiliated/chalkmonster) joined #haskell
06:48:26 <dminuoso> boxscape: Well we are considering a category in which objects are endofunctors, and morphisms between them are natural transformations.
06:48:59 --- join: reallymemorable (~reallymem@cpe-66-108-137-140.nyc.res.rr.com) joined #haskell
06:49:25 <dminuoso> boxscape: In Haskell it follows from a free theorem that `forall a. F a -> F a` for any choice of F is a natural transformation
06:49:35 <dminuoso> Err
06:49:40 <dminuoso> `forall a. F a -> G a` :)
06:49:44 <dminuoso> If both F and G are endofunctors
06:49:58 <boxscape> okay, interesting
06:50:22 <dminuoso> boxscape: So by using ~> Im merely emphasizing on the natural transformation part, and showing that the choice of `a` is irrelevant there.
06:50:32 <boxscape> okay
06:50:46 <dminuoso> % :t join
06:50:46 <yahb> dminuoso: Monad m => m (m a) -> m a
06:51:23 <dminuoso> boxscape: If we pick some monad, say Maybe, then `join :: Maybe (Maybe a)` for *any* choice of a, it's irrelevant. join behaves uniformly for any choice.
06:51:47 <boxscape> ok
06:52:28 <dminuoso> boxscape: But at any rate, the naturality are conditions already imposed by the definition of a monoid, which stipulates that Î¼ and Î· must be natural transformations. :)
06:52:45 <boxscape> ah, right
06:52:47 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
06:53:20 --- quit: skim_ (Ping timeout: 245 seconds)
06:53:52 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
06:56:37 --- quit: captjakk (Remote host closed the connection)
06:56:56 --- join: Brekker (~brekker@103.209.252.26) joined #haskell
06:57:09 --- quit: Brekker (Client Quit)
06:57:37 --- join: Brekker (~brekker@131.170.239.13) joined #haskell
06:58:23 --- quit: sukbeom (Quit: The Lounge - https://thelounge.chat)
07:00:19 <maerwald> what do you call `f :: (Monad m, Monad n) => m a -> n b`?
07:01:29 <Cale> maerwald: Presumably you mean m a -> n a ?
07:01:31 <dminuoso> maerwald: A lie?
07:01:44 <maerwald> Cale: nope, n b
07:01:52 <maerwald> a hoist and then a map
07:01:52 --- nick: osa1_ -> osa1
07:02:05 <Cale> Is it really that polymorphic, or do you mean there are particular monads?
07:02:12 <maerwald> particular, probably
07:02:34 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
07:02:53 <dminuoso> I cant think of how that'd work out
07:02:54 <maerwald> was just wondering if there is a CT term for it
07:03:12 <maerwald> dminuoso: it's exactly what I want to do in streamly :P
07:03:14 --- quit: kubek2k (Ping timeout: 246 seconds)
07:03:15 <dminuoso> maerwald: If you merely constraint it by Applicative and constrain it by Contravariant, it exists
07:03:31 <Cale> Well, there's a notion of "monad homomorphism", but... usually that's a natural transformation
07:03:32 --- quit: Clough (Ping timeout: 258 seconds)
07:03:37 <dminuoso> Well or at least a resricted form
07:03:38 <maerwald> m a -> n a is already possible
07:03:41 --- join: sukbeom (~sukbeom@211.222.84.134) joined #haskell
07:03:49 <maerwald> but m a -> n b, no idea
07:03:55 <dminuoso> phantom :: (Functor f, Contravariant f) => f a -> f b
07:03:56 <dminuoso> Is a thing
07:04:19 <dminuoso> (This in effect has just a single instance in Haskell)
07:04:33 <maerwald> Cale: value non-preserving homomorphism?
07:04:34 --- quit: Brekker (Quit: WeeChat 1.9.1)
07:04:47 <dminuoso> maerwald: It wouldnt just be non-preserving, you'd have to make up values.
07:04:58 --- join: Brekker (~brekker@103.209.252.26) joined #haskell
07:05:09 <dminuoso> maerwald: Since it's monad, (>>=) demands that you somehow must be able to produce values of the inner type
07:05:25 --- quit: _vaibhavingale_ (Quit: Leaving.)
07:05:39 <maerwald> imagine: SerialT m Int -> SerialT n (Maybe Int)
07:05:48 <Cale> maerwald: It doesn't quite make sense that it would take any type to any other type there. Any such thing would produce _|_
07:05:53 <maerwald> where m could e something like ExceptT
07:05:56 <dminuoso> maerwald: Well yes. For concrete types that works
07:05:57 --- quit: pfurla (Quit: gone to sleep. ZZZzzzâ€¦)
07:06:05 <dminuoso> maerwald: But if you universally quantify over it, parametricity takes hold
07:06:10 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
07:06:22 <maerwald> haven't figured out how to do that in streamly yet, so was looking for pointers what to google, maybe
07:06:26 <dminuoso> You'd have to make some `n b` for *any* choice of b, including Void.
07:06:30 --- quit: ap5 (Ping timeout: 244 seconds)
07:06:31 <dminuoso> And you cant make values of Void
07:06:48 <dminuoso> And the reason you must be able to produce values, is because of how (>>=) works
07:07:06 --- join: p0lyph3m (~p0lyph3m@2a02:810d:640:776c:76d7:55f6:f85b:c889) joined #haskell
07:07:17 --- quit: heatsink (Ping timeout: 250 seconds)
07:07:21 --- quit: Brekker (Changing host)
07:07:21 --- join: Brekker (~brekker@unaffiliated/brekker) joined #haskell
07:07:33 <dminuoso> So indeed what Cale said. The only implementation for `f :: Monad m => Monad n => n a -> n b` is bottom.
07:10:12 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
07:10:27 <Cale> Well, you can do stuff with the monad structure on top of that, but it's like, some natural transformation composed with fmap (const undefined)
07:10:48 --- quit: tromar (Ping timeout: 245 seconds)
07:12:55 --- join: mycroftiv (~glen@45.76.231.16) joined #haskell
07:14:17 --- join: nschoe (~nschoe@80.215.202.130) joined #haskell
07:14:46 --- quit: Sk01 (Ping timeout: 244 seconds)
07:14:48 --- quit: the_true_potato (Ping timeout: 268 seconds)
07:15:32 --- join: geekosaur (42d52102@66.213.33.2) joined #haskell
07:15:38 --- join: durandal1 (~durandal1@2601:647:4900:43:1da0:610e:4160:a7c2) joined #haskell
07:17:10 --- join: jedws (~jedws@101.180.86.173) joined #haskell
07:17:25 --- quit: nschoe (Read error: Connection reset by peer)
07:19:01 <boxscape> % data T k (a :: k) = MkT k
07:19:01 <yahb> boxscape: 
07:19:08 <boxscape> % :t MkT 3
07:19:09 <yahb> boxscape: forall k (a :: k). Num k => T k a
07:19:20 --- quit: Brekker (Ping timeout: 246 seconds)
07:19:24 <boxscape> Is there any concrete, non-parametric type that I can give MkT 3?
07:19:35 --- join: ap5 (~ap5@85.184.161.18) joined #haskell
07:20:07 --- join: underikar (uid139442@gateway/web/irccloud.com/x-ecpevcbggqwiiyxv) joined #haskell
07:20:13 --- quit: durandal1 (Ping timeout: 264 seconds)
07:20:22 <boxscape> (I think that would only be possible if we had type-level Int literals?)
07:21:09 <boxscape> % :k T -- also I didn't know that this syntax actually already exists in ghci type signatures, that's neat
07:21:09 <yahb> boxscape: T -- also I didn't know that this syntax actually already exists in ghci type signatures, that's neat :: forall k -> k -> *
07:21:30 <boxscape> (i.e. forall k -> k -> *)
07:21:44 --- quit: laem (Quit: quit)
07:21:54 <boxscape> s/type/kind
07:23:27 --- join: laem (~laem@unaffiliated/laem) joined #haskell
07:23:29 --- join: cr3 (~cr3@107.159.37.11) joined #haskell
07:23:57 --- join: pie_ (~pie_@unaffiliated/pie-/x-0787662) joined #haskell
07:24:16 --- quit: Amras (Read error: Connection reset by peer)
07:25:18 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
07:26:28 --- join: Amras (~Amras@unaffiliated/amras0000) joined #haskell
07:27:16 --- quit: gentauro (Quit: leaving)
07:27:34 --- join: gentauro (~gentauro@185.107.12.141) joined #haskell
07:28:12 * hackage replace-megaparsec 1.0.1.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.0.1.0 (JamesBrock)
07:28:18 --- join: ap5_ (~ap5@85.184.161.18) joined #haskell
07:28:49 --- join: FreeBirdLjj (~freebirdl@180.172.138.136) joined #haskell
07:29:01 --- join: Brekker (~brekker@unaffiliated/brekker) joined #haskell
07:29:16 --- join: emptyflask (~jon@136.49.71.178) joined #haskell
07:29:40 --- quit: skim_ (Ping timeout: 272 seconds)
07:30:16 --- quit: ap5 (Ping timeout: 244 seconds)
07:30:26 --- quit: FreeBirdLjj (Client Quit)
07:32:25 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
07:32:50 --- quit: sQVe (Quit: Bye!)
07:33:49 --- join: ap5 (~ap5@85.184.161.18) joined #haskell
07:35:06 --- quit: ap5_ (Ping timeout: 248 seconds)
07:35:06 --- quit: dibblego (Ping timeout: 248 seconds)
07:35:18 --- join: machinedgod (~machinedg@96-30-133-33.eastlink.ca) joined #haskell
07:35:24 --- join: dibblego (~dibblego@122.199.1.30) joined #haskell
07:35:25 --- quit: dibblego (Changing host)
07:35:25 --- join: dibblego (~dibblego@haskell/developer/dibblego) joined #haskell
07:35:35 --- join: oish (~charlie@228.25.169.217.in-addr.arpa) joined #haskell
07:36:15 --- join: xff0x (~fox@softbank126065153248.bbtec.net) joined #haskell
07:38:59 --- nick: shafox_ -> shafox
07:39:39 --- join: voyons_osti (~dan@162.246.218.28) joined #haskell
07:42:23 --- quit: sshaaf (Remote host closed the connection)
07:43:23 --- join: sshaaf (~sysh@xd4ed8696.cust.hiper.dk) joined #haskell
07:44:24 --- join: cosimone (~cosimone@2001:b07:ae5:db26:9520:741c:a5e9:2223) joined #haskell
07:45:38 --- quit: lemmih (Ping timeout: 268 seconds)
07:45:38 <boxscape> anyway it seems kind of weird to be able to construct a value but not give it a concrete type
07:46:08 --- quit: raichoo (Quit: Lost terminal)
07:48:55 --- quit: sword865 (Quit: Connection closed for inactivity)
07:50:28 --- join: Gurkenglas (~Gurkengla@unaffiliated/gurkenglas) joined #haskell
07:51:54 --- join: wroathe (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) joined #haskell
07:52:13 --- quit: dima__ (Quit: This computer has gone to sleep)
07:53:14 --- quit: yoeljacobsen (Remote host closed the connection)
07:53:40 --- join: dmitri (~dima14@ppp-58-11-29-128.revip2.asianet.co.th) joined #haskell
07:53:59 --- join: tromar (~tromar@n114-74-40-80.sbr2.nsw.optusnet.com.au) joined #haskell
07:54:13 --- quit: rndd (Quit: WeeChat 2.4)
07:55:01 <boxscape> actually it's similar for things like
07:55:09 <boxscape> % :t MkT not
07:55:09 <yahb> boxscape: T (Bool -> Bool) a
07:55:22 <boxscape> I don't think this can be constructed without unsaturated type families being allowed
07:55:42 <boxscape> maybe I'm missing some way in which defunctionalization trickery could help though
07:56:02 <boxscape> well, it can be construced
07:56:09 <boxscape> it just cannot be given a concrete type
07:57:20 --- quit: sshaaf (Remote host closed the connection)
07:57:45 --- join: yoeljacobsen (~yoel.jaco@89.237.106.229) joined #haskell
07:58:00 --- join: sshaaf (~sysh@xd4ed8696.cust.hiper.dk) joined #haskell
07:58:13 --- quit: sshaaf (Max SendQ exceeded)
07:58:14 <dmwit> I don't think Bool -> Bool or Num k are special. You can't even do this with MkT True, right?
07:58:22 --- quit: yoeljacobsen (Remote host closed the connection)
07:58:28 <dmwit> Even though we have a lifted Bool, the lifted Bool and the unlifted Bool are not the same thing. Or are they?
07:58:38 --- join: sshaaf (~sysh@xd4ed8696.cust.hiper.dk) joined #haskell
07:58:54 <dmwit> % case MkT True :: T Bool True of _ -> "wow"
07:58:54 <yahb> dmwit: "wow"
07:59:05 <dmwit> Huh! Okay, then.
07:59:52 <mycroftiv> is there a good trick to change code back and forth from using Integer to Int? I have two versions of a program to compare performance and im wondering if i can parameterize this at the source level somehow
08:00:16 --- quit: Zer0xp (Ping timeout: 258 seconds)
08:00:22 <dmwit> mycroftiv: Use Integral + SPECIALIZE everywhere?
08:00:23 --- quit: Clouclou ()
08:00:27 --- join: pfurla (~pfurla@104.36.2.146) joined #haskell
08:00:36 <mycroftiv> i will look up what SPECIALIZE is, thanks
08:00:38 --- quit: chr15 (Ping timeout: 246 seconds)
08:00:42 --- quit: tromar (Ping timeout: 248 seconds)
08:03:12 * hackage generic-constraints 1.0.0 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.0.0 (YairChuchem)
08:03:14 --- quit: ravenous_ (Read error: Connection reset by peer)
08:03:20 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
08:03:28 --- quit: linarcx (Quit: WeeChat 2.5)
08:04:23 --- quit: reallymemorable (Quit: reallymemorable)
08:04:56 --- join: yoeljacobsen (~yoel.jaco@89.237.106.229) joined #haskell
08:05:03 --- join: tromar (~tromar@n114-74-40-80.sbr2.nsw.optusnet.com.au) joined #haskell
08:05:15 --- quit: skim_ (Ping timeout: 258 seconds)
08:05:29 --- quit: chele (Quit: Leaving)
08:05:50 --- join: pfurla_ (~pfurla@ec2-18-208-170-161.compute-1.amazonaws.com) joined #haskell
08:06:00 --- join: ravenous_ (~ravenousm@ptr-cud5aqddchpphxbl4q7.18120a2.ip6.access.telenet.be) joined #haskell
08:06:01 <boxscape> Actually it's not that weird - after all, you can make
08:06:13 <boxscape> % data D (a :: Void) = MkD
08:06:14 <yahb> boxscape: 
08:06:15 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
08:06:24 --- join: sagax (~sagax_nb@213.138.71.146) joined #haskell
08:06:27 <boxscape> but you certainly wouldn't want to be able to give that a concrete type
08:06:37 <boxscape> % :t MkD
08:06:37 <yahb> boxscape: D a
08:07:10 --- quit: pfurla (Ping timeout: 258 seconds)
08:07:16 --- quit: yoeljacobsen (Remote host closed the connection)
08:07:42 --- join: yoeljacobsen (~yoel.jaco@89.237.106.229) joined #haskell
08:07:57 --- quit: heatsink (Ping timeout: 250 seconds)
08:08:53 --- quit: encod3 ()
08:09:03 <boxscape> (excluding type level bottom)
08:09:13 <boxscape> (which would also work for the other examples)
08:10:41 --- join: max00 (~max@23-115-45-16.lightspeed.tpkaks.sbcglobal.net) joined #haskell
08:10:50 --- join: crobbins (~crobbins@198.11.8.226) joined #haskell
08:11:00 --- quit: skim_ (Ping timeout: 258 seconds)
08:11:09 --- join: encod3 (~encod3@89.20.162.146.static.ef-service.nl) joined #haskell
08:14:00 --- quit: oish (Ping timeout: 268 seconds)
08:15:12 --- quit: SrPx_ ()
08:15:52 --- join: SrPx_ (sid108780@gateway/web/irccloud.com/x-eougjyqnhsnktgcb) joined #haskell
08:16:18 --- join: nineonine (~nineonine@216.81.48.202) joined #haskell
08:17:09 --- nick: SrPx_ -> SrPx
08:17:47 --- join: Zer0xp (~Zer0xp@203.192.251.82) joined #haskell
08:17:49 --- quit: max00 (Quit: This computer has gone to sleep)
08:18:07 --- quit: yoneda (Quit: leaving)
08:18:13 * hackage generic-constraints 1.1.0 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.1.0 (YairChuchem)
08:18:28 --- join: max00 (~max@2600:1700:3ab0:4e40:c9c0:77ee:acc6:4069) joined #haskell
08:18:45 --- quit: dmitri (Quit: This computer has gone to sleep)
08:19:30 --- join: dale_ (~dale@unaffiliated/dale) joined #haskell
08:19:45 --- nick: dale_ -> dale
08:20:39 --- join: hoppfull (55e46384@c-8463e455.19-9-64736c10.bbcust.telenor.se) joined #haskell
08:20:43 --- join: chr15 (~chr15@223.237.205.177) joined #haskell
08:21:15 --- quit: max00 (Client Quit)
08:22:28 --- quit: Zer0xp (Ping timeout: 245 seconds)
08:22:43 --- join: max00 (~max@23-115-45-16.lightspeed.tpkaks.sbcglobal.net) joined #haskell
08:24:44 --- join: HarveyPwca (~HarveyPwc@70-89-216-161-il.hfc.comcastbusiness.net) joined #haskell
08:24:50 --- join: Zer0xp (~Zer0xp@223.237.205.177) joined #haskell
08:25:57 --- quit: imtravis (Ping timeout: 258 seconds)
08:26:13 * hackage BiobaseBlast 0.3.1.0 - BLAST-related tools  https://hackage.haskell.org/package/BiobaseBlast-0.3.1.0 (ChristianHoener)
08:26:15 --- quit: Ariakenom (Ping timeout: 245 seconds)
08:27:43 * hackage generic-constraints 1.1.1 - Constraints via Generic  https://hackage.haskell.org/package/generic-constraints-1.1.1 (YairChuchem)
08:28:44 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
08:29:21 --- join: pfurla (~pfurla@104.36.2.146) joined #haskell
08:30:23 --- quit: pfurla_ (Ping timeout: 245 seconds)
08:30:32 --- quit: encod3 (Remote host closed the connection)
08:30:58 --- part: apx[m] left #haskell
08:31:01 --- quit: kuribas (Quit: ERC (IRC client for Emacs 25.3.2))
08:32:32 --- part: excel_gate[m] left #haskell
08:32:55 --- part: gmind[m] left #haskell
08:33:03 --- quit: Guy[m]1 (Quit: Idle kick: User has been idle for 30+ days.)
08:33:26 --- quit: ineff (Quit: Idle kick: User has been idle for 30+ days.)
08:33:45 --- quit: tromar (Ping timeout: 245 seconds)
08:34:30 --- part: laniu[m]1 left #haskell
08:35:12 --- part: mobile_x[m] left #haskell
08:35:45 --- part: nullheroes[m] left #haskell
08:37:56 --- part: veeee[m] left #haskell
08:38:34 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
08:39:07 --- quit: boxscape (Remote host closed the connection)
08:39:19 --- quit: max00 (Quit: This computer has gone to sleep)
08:41:46 --- quit: vyorkin (Ping timeout: 248 seconds)
08:41:57 --- join: brandly (~brandly@c-24-61-240-6.hsd1.ma.comcast.net) joined #haskell
08:43:20 --- quit: skim_ (Ping timeout: 245 seconds)
08:43:26 --- join: lambda-11235 (~lambda-11@207.183.239.54) joined #haskell
08:43:30 --- quit: tomboy64 (Ping timeout: 260 seconds)
08:44:57 --- quit: jose_zap (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
08:44:58 --- quit: laem (Ping timeout: 245 seconds)
08:45:10 --- join: FreeBirdLjj (~freebirdl@180.172.138.136) joined #haskell
08:46:14 --- join: laem (~laem@unaffiliated/laem) joined #haskell
08:46:36 --- quit: gabiruh (Quit: ZNC - 1.6.0 - http://znc.in)
08:46:54 --- join: gabiruh (~gabiruh@2804:7f7:a6a3:63e7:74fc:e408:b277:8a63) joined #haskell
08:47:27 <hoppfull> Hello, at work we are creating what I'd call a typed computation tree. Currently all possible permutations are modeled with ADTs which is quite difficult to work with. Correctness is very important. I'm getting my feet wet with Haskell and I know there are usually well studied constructs to deal with most problems.
08:47:46 --- join: rah (~rah@139.28.218.198) joined #haskell
08:48:01 --- quit: ggole (Quit: Leaving)
08:48:09 --- join: tomboy64 (~tomboy64@gateway/tor-sasl/tomboy64) joined #haskell
08:48:13 --- quit: dale (Quit: My computer has gone to sleep)
08:48:19 <hoppfull> A requirement is that we should not only produce a result of the calculation but also represent that calculation as a tree of nodes that the end user can connect and disconnect.
08:49:29 --- join: max00 (~max@23-115-45-16.lightspeed.tpkaks.sbcglobal.net) joined #haskell
08:49:34 <hoppfull> So my mind has wandered to comonads, indexed monads and free monads but I thought I'd come by here, sometimes someone has and idea of something that I may not have thought of. I don't know if I've provided enough information.
08:50:52 --- join: arc- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
08:51:23 --- join: dale (~dale@unaffiliated/dale) joined #haskell
08:51:38 <hoppfull> In essence we're allowing an unskilled user to build up a calculation that is typed such that they can't make invalid connections. We're using haskell because correctness and reliability is of high priority.
08:51:45 --- join: brschkv (~brschkv@x4d037d7c.dyn.telefonica.de) joined #haskell
08:51:48 <lyxia> That all seems too vague.
08:52:09 <hoppfull> I can't say too much but I'll try and reformulate the problem.
08:52:41 --- quit: shiradz (Quit: shiradz)
08:53:06 --- quit: max00 (Client Quit)
08:53:30 --- quit: doublex (Ping timeout: 248 seconds)
08:53:44 --- join: max00 (~max@2600:1700:3ab0:4e40:c9c0:77ee:acc6:4069) joined #haskell
08:53:49 --- join: linarcx (~linarcx@151.242.171.118) joined #haskell
08:55:09 --- join: t7 (~tommo@2a00:23c5:1284:fc00:9953:a696:b91c:7f) joined #haskell
08:55:25 --- join: reallymemorable (~reallymem@cpe-66-108-137-140.nyc.res.rr.com) joined #haskell
08:55:31 --- quit: arc- (Ping timeout: 244 seconds)
08:55:59 --- join: arc- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
08:56:33 --- quit: arc- (Read error: Connection reset by peer)
08:57:38 --- join: alanz (~alanz@165.255.64.8) joined #haskell
08:58:17 --- quit: pie_ (Ping timeout: 252 seconds)
08:58:20 --- quit: jluttine_ (Ping timeout: 272 seconds)
08:58:24 --- join: arc- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
08:58:42 --- quit: arc- (Read error: Connection reset by peer)
08:58:53 --- join: arc-- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
08:59:36 --- quit: arc-- (Read error: Connection reset by peer)
09:00:58 --- join: arc- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
09:01:41 --- quit: arc- (Read error: Connection reset by peer)
09:02:08 --- quit: emptyflask (Ping timeout: 272 seconds)
09:02:16 --- join: arc- (~arc@p57B19E42.dip0.t-ipconnect.de) joined #haskell
09:02:30 <hoppfull> Let's say I want to build a function at runtime, I can just compose them together like ((* 2) . (+ 1) . (- 2) . (* 3)) but is there a way to represent this code as a datastructure that can be manipulated?
09:02:33 --- quit: arc- (Read error: Connection reset by peer)
09:03:01 <EvanR> yep
09:03:03 <hoppfull> Well, obviously there is, we are now but is there a simple way to do it? An ideomatic way to do it?
09:03:10 --- join: the_true_potato (~the_true_@cpc147822-brnt4-2-0-cust15.4-2.cable.virginm.net) joined #haskell
09:03:22 <EvanR> data Fun a b = Fun (a -> b)
09:03:24 <wroathe> Does anyone know if there's an easy way to conditionally enable these preprocessors based on a flag? https://www.haskell.org/cabal/users-guide/developing-packages.html#modules-and-preprocessors
09:03:29 --- join: emptyflask (~jon@66.64.40.21) joined #haskell
09:03:57 <wroathe> Moreover, is there a way to get Cabal to write the result of preprocessing into the source directory instead of the dist directory?
09:04:03 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
09:04:13 <glguy> hoppfull: You decide what syntax you want to be able to manipulate and then you define a new datatype with the constructors corresponding to the syntax you picked in the first step
09:04:29 <wroathe> Like if I want to cabal to run alex and write the output to src/foo/bar/Scanner.hs, but only if the "dev" flag is enabled
09:04:34 --- join: TheTruePotato (the_true_p@gateway/vpn/privateinternetaccess/thetruepotato/x-30559709) joined #haskell
09:04:53 --- join: teardown (~user@unaffiliated/mrush) joined #haskell
09:04:59 <phadej> wroathe: dev flag is a code-smell
09:05:04 <hoppfull> glguy: The syntax is a graphical user interface that is a node tree generated based on the computation.
09:05:11 <phadej> wroathe: use Makefile for preprocessing sources, if you want to
09:05:15 --- quit: the_true_potato (Read error: Connection reset by peer)
09:05:16 <wroathe> phadej: I'm open to alternatives
09:05:27 <phadej> (not have alex run all the time)
09:05:31 <glguy> hoppfull: No, graphical user iterface doesn't feature at this level
09:05:37 <hoppfull> ok
09:05:47 <EvanR> hoppfull: any data structure is a programming language if you look at it right
09:05:48 <wroathe> phadej: Ah, Make is usually my go to, but I was just exploring whether or not it was possible to do this entirely with Cabal
09:06:06 <wroathe> phadej: I'm wondering why Cabal even has the ability to run alex/happy
09:06:10 <EvanR> you are basically coming up with a small programming language
09:06:15 <hoppfull> yeah, I know
09:06:27 <wroathe> As it currently exists it seems pretty useless\
09:06:29 <phadej> wroathe: because it can, and it's simple. Iw onder why you don't want let Cabal to do preprocessing for you?
09:06:35 --- quit: max00 (Quit: This computer has gone to sleep)
09:06:44 <EvanR> the techniques for this in haskell reach to the moon
09:07:06 <hoppfull> I just want a nice way of building it up. One idea was to create a small algebra describing the operations and then create a free monad and build the datastructure like that.
09:07:32 <EvanR> you can just start with the AST
09:07:37 <wroathe> Well, as I understand it (and correct me if I'm wrong), if I publish a dist of my package that contains a Scanner.x file, then that causes whomever installs my package to have to run alex to generate the haskell sources
09:08:00 <phadej> yes, and that's completely fine!?
09:08:02 <wroathe> The packages that I've found that use alex all seem to do the preprocessing as part of a build of their package, and then go out of their way to make sure that Cabal doesn't run alex on the user's machine
09:08:09 --- join: max00 (~max@23-115-45-16.lightspeed.tpkaks.sbcglobal.net) joined #haskell
09:08:11 --- quit: Aquazi (Quit: Connection closed for inactivity)
09:08:15 <wroathe> even the Alex package does that
09:08:19 --- join: jluttine (~jluttine@109.204.147.177) joined #haskell
09:08:21 <hoppfull> Right now it's such a nightmare to unit test that no one wants to unit test. Too much of a pain.
09:08:26 <phadej> alex and happy are special packages as their bootstrapping is circular
09:08:32 <wroathe> http://hackage.haskell.org/package/alex-3.2.4/src/
09:08:33 <phadej> they are not good representatives of how to use either
09:08:43 <phadej> ghc is not "ordinary Cabal package" either
09:08:43 --- quit: Saulzar_ (Remote host closed the connection)
09:08:46 <phadej> for "reasons"
09:08:58 --- quit: TheTruePotato (Ping timeout: 248 seconds)
09:08:59 --- quit: heatsink (Ping timeout: 276 seconds)
09:08:59 <EvanR> with GADTs you can go farther and make the AST typed
09:09:31 <hoppfull> EvanR: I think we're using GADTs. Do you have any reading materal for what you describe?
09:09:34 --- join: Saulzar_ (~Saulzar@121.99.221.201) joined #haskell
09:09:58 <wroathe> phadej: Can you point me to a popular package that does require the user to preprocess the file with Alex? And what would be the advantage of doing that when you can just generate the haskell source at build time and check it into your repo?
09:10:02 --- quit: ubert (Quit: Leaving)
09:10:06 <EvanR> with HOAS you can go farther and use haskell functions to represent functions, which gives a speed boost and can be tricked into being serializable. 
09:10:15 <hoppfull> Sorry, I don't have a computer science degree. I understand if these questions are too annoying.
09:10:23 <phadej> wroathe: alex, cannot say for sure
09:10:28 <hoppfull> HOAS?
09:10:29 <phadej> but for happy: https://hackage.haskell.org/package/haskell-src-exts-1.21.0/src/
09:10:36 <EvanR> higher order abstract syntax
09:10:45 <EvanR> the universe of possibilities just keeps going
09:11:00 --- quit: Zer0xp (Ping timeout: 272 seconds)
09:11:25 <hoppfull> I think I have some reading material now. Thanks a ton, guys!
09:11:26 <tsahyt> can I safely refer to values contained in the result when using Data.Vector.generate? e.g. for lazy dynamic programming purposes. I know it works with array, but I'm not sure about vector
09:11:37 <wroathe> I just don't see the advantage to requiring the preprocessing at install time
09:12:05 <phadej> the fact that you distribute 
09:12:09 <phadej> "human readable sources"
09:12:16 --- quit: chr15 (Ping timeout: 272 seconds)
09:12:28 <phadej> and there are less opportunities for mistakes
09:12:36 <phadej> (e.g. forgetting to preprocess it before packaging)
09:12:40 <phadej> and it's convinient
09:13:21 <phadej> tasty-discover and hspec-discover are preprocessors as well, of a kind
09:13:30 <phadej> convinience
09:13:56 --- quit: yoeljacobsen (Remote host closed the connection)
09:14:23 --- join: yoeljacobsen (~yoel.jaco@89.237.106.229) joined #haskell
09:14:40 <Cale> wroathe: It's not install-time, it's build-time
09:15:12 --- quit: FreeBirdLjj (Remote host closed the connection)
09:15:29 <wroathe> Cale: Yes, sorry. Bad nomenclature.
09:15:38 --- join: Ariakenom (~Ariakenom@h-158-174-187-143.NA.cust.bahnhof.se) joined #haskell
09:15:48 --- quit: hoppfull (Remote host closed the connection)
09:16:37 <wroathe> In fact, it actually seems like requiring them to preprocess Alex/Happy files would open you up to MORE mistakes if you build-tool-depends a range, rather than an exact version of Happy/Alex that you know generates the correct Haskell module
09:16:47 <wroathe> (the chances of that becoming are low, but it is possible)
09:17:27 --- join: aretnap (~Mutter@185.242.5.249) joined #haskell
09:17:32 <wroathe> Publishing the preprocessed haskell module removes that possibility and absolves them of the need to have those two tools on their system
09:17:41 <Cale> wroathe: Well, any self-respecting build-tool should be able to run preprocessors for you...
09:18:04 <wroathe> Cale: I agree, but I don't see the value with these two particular preprocessors
09:18:13 --- quit: aretnap (Client Quit)
09:18:22 <Cale> You shouldn't need to have those things on your system just to install the package, I agree.
09:18:32 <Cale> (In particular, you ought to be able to get these things from binary caches)
09:18:45 --- quit: yoeljacobsen (Ping timeout: 245 seconds)
09:19:03 <tsahyt> apparently I can
09:19:07 <tsahyt> very nice
09:19:10 --- quit: rruizt (Ping timeout: 245 seconds)
09:19:35 <Cale> tsahyt: Ah, missed the question -- yeah, this works with boxed vectors
09:19:38 --- quit: td123 (Ping timeout: 248 seconds)
09:19:45 <tsahyt> ah but not with storable or unboxed?
09:19:59 <Cale> unboxed vectors/arrays specifically remove the facility that's required for lazy evaluation
09:19:59 <tsahyt> hm, it would make sense for that not to work
09:20:02 <tsahyt> yes
09:20:16 <tsahyt> well that is slightly annoying, although understandable
09:20:22 <wroathe> brb
09:20:26 --- quit: BoneTone (Ping timeout: 246 seconds)
09:21:43 --- join: boxscape (577bcb92@gateway/web/cgi-irc/kiwiirc.com/ip.87.123.203.146) joined #haskell
09:21:43 --- quit: wroathe (Read error: Connection reset by peer)
09:22:01 <tsahyt> Cale: so by extension, does this work for any data structure that is lazy in its values?
09:22:02 --- join: hamishmack (~textual@185.104.184.43) joined #haskell
09:22:11 <tsahyt> I think I've done it with IntMaps too at some point
09:22:17 <Cale> Yeah, you can typically define things recursively when they're lazy
09:22:25 --- join: pera (~pera@unaffiliated/pera) joined #haskell
09:22:27 <tsahyt> that is very nice
09:22:42 --- join: rruizt (~rruizt@83-84-23-124.cable.dynamic.v4.ziggo.nl) joined #haskell
09:22:47 --- quit: conal (Quit: Computer has gone to sleep.)
09:22:57 <tsahyt> unfortunately the restriction of having boxed values means that I can't actually apply it right now, but it's good to keep it in mind
09:23:01 --- quit: geekosaur (Ping timeout: 260 seconds)
09:23:49 <tsahyt> I'd need it in a vector with something on the order of 96 million floats in it. having a boxed vector for that sounds like it'd perform rather bad
09:23:50 --- join: jathan (~jathan@200.57.243.84) joined #haskell
09:23:52 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
09:24:23 --- join: conal (~conal@209.58.135.97) joined #haskell
09:25:09 --- join: gioyik (~gioyik@186.116.249.126) joined #haskell
09:25:10 --- quit: td123 (Client Quit)
09:25:18 --- join: Saukk (~Saukk@2001:998:c6:b739:74df:3819:121e:95ed) joined #haskell
09:25:42 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
09:25:45 --- quit: conal (Client Quit)
09:26:19 --- join: wroathe (~msgnickse@ip-99-203-48-231.pools.cgn.spcsdns.net) joined #haskell
09:26:19 --- quit: td123 (Client Quit)
09:26:29 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
09:26:44 --- quit: khisanth_ (Ping timeout: 246 seconds)
09:27:15 --- quit: asheshambasta (Ping timeout: 252 seconds)
09:27:39 --- join: geekosaur (42d52102@66.213.33.2) joined #haskell
09:28:04 <Ariakenom> not sure I'm being relevant but you can't define values depending on each other in a Data.Map
09:28:48 <Cale> hm?
09:28:51 <Cale> You can
09:29:20 <solonarv> you definitely can if you use the lazy functions, not sure about strict
09:31:09 --- join: pie_ (~pie_@unaffiliated/pie-/x-0787662) joined #haskell
09:31:16 <Cale> Yeah, if you use the functions in the .Strict module, you might force the evaluation too soon.
09:31:37 <Cale> Also, it's only possible to do with the values, not the keys
09:32:16 --- join: chrisdotcode (~chrisdotc@unaffiliated/chrisdotcode) joined #haskell
09:32:27 --- join: BoneTone (~BoneTone@unaffiliated/bonetone) joined #haskell
09:33:27 --- join: wroathe_ (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) joined #haskell
09:33:51 --- quit: drewr (Quit: ERC (IRC client for Emacs 26.2))
09:33:57 <Ariakenom> oh yeah. I was clumsy with words. I meant keys too
09:34:12 <tsahyt> both the Data.Maps are strict in their keys iirc
09:34:18 --- join: drewr (~drew@elastic/staff/drewr) joined #haskell
09:34:34 --- quit: wroathe_ (Read error: Connection reset by peer)
09:34:47 --- quit: drewr (Remote host closed the connection)
09:35:12 <Ariakenom> it's more about the structure of the map than the keys themselves
09:35:38 --- quit: pie_ (Ping timeout: 248 seconds)
09:36:21 --- join: wildtrees (~wildtrees@unaffiliated/wildtrees) joined #haskell
09:36:46 --- join: conal (~conal@209.58.135.97) joined #haskell
09:37:05 --- join: wroathe_ (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) joined #haskell
09:37:19 --- quit: wildtrees (Max SendQ exceeded)
09:37:21 --- quit: wroathe (Quit: -a- IRC for Android 2.1.54)
09:37:31 --- nick: wroathe_ -> wroathe
09:37:41 <wroathe> Back, sorry
09:37:51 --- join: wildtrees (~wildtrees@unaffiliated/wildtrees) joined #haskell
09:38:09 <wroathe> But yeah, phadej, I get your point about the build system needing to be able to run preprocessors generally
09:38:22 --- join: drewr (~drew@elastic/staff/drewr) joined #haskell
09:39:28 <geekosaur> maybe the more important point is needing to deal with packaged build artifacts is a major complication in build and deployment systems
09:39:55 --- quit: BoneTone (Quit: entropy)
09:40:06 <geekosaur> C dealt with it for years because yacc and lex were only available on Real Unix(tm) for a decade or so
09:40:17 --- join: khisanth_ (~Khisanth@pool-108-46-2-196.nycmny.east.verizon.net) joined #haskell
09:40:42 <wroathe> geekosaur: Yeah, I was just thinking about this in terms of Lex/Yacc
09:40:52 <geekosaur> and in many cases ony if you had the developer toolkit license
09:41:51 --- quit: max00 (Quit: This computer has gone to sleep)
09:42:27 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
09:42:31 --- join: turab (~turab@149-160-224-148.dhcp-bl.indiana.edu) joined #haskell
09:42:42 * hackage bytestring-progress 1.4 - A library for tracking the consumption of a lazy ByteString  https://hackage.haskell.org/package/bytestring-progress-1.4 (AdamWick)
09:44:06 --- join: Lord_of_Life_ (~Lord@unaffiliated/lord-of-life/x-0885362) joined #haskell
09:44:19 --- quit: mnrmnaugh (Remote host closed the connection)
09:44:34 --- quit: olligobber (Ping timeout: 272 seconds)
09:45:04 --- join: mnrmnaugh (~mnrmnaugh@unaffiliated/mnrmnaugh) joined #haskell
09:45:50 --- quit: heatsink (Remote host closed the connection)
09:46:40 --- quit: ziyourenxiang_ (Ping timeout: 244 seconds)
09:46:50 --- quit: Lord_of_Life (Ping timeout: 258 seconds)
09:46:53 --- join: falafel_ (~falafel@static-176-185-149-136.axione.abo.bbox.fr) joined #haskell
09:47:03 --- nick: Lord_of_Life_ -> Lord_of_Life
09:47:37 <wroathe> Now the question becomes, how I do tell Cabal to stop processing .x files in the event I want Scanner.x and Scanner.hs to reside in the same directory
09:48:23 --- join: zargoertzel (~zar@78-62-230-102.static.zebra.lt) joined #haskell
09:48:37 --- quit: chrisdotcode (Quit: chrisdotcode)
09:48:59 --- join: deviantfero (~deviantfe@ip168-243-230-189.intercom.com.sv) joined #haskell
09:49:40 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
09:51:05 --- join: max00 (~max@23-115-45-16.lightspeed.tpkaks.sbcglobal.net) joined #haskell
09:51:18 --- quit: hamishmack (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
09:52:11 --- join: kubek2k (~Jakub_Jan@2a02:a312:c83f:5080:9e7:50bf:6ce8:9d05) joined #haskell
09:52:22 --- quit: plutoniix (Quit: Leaving)
09:52:53 --- quit: geekosaur (Ping timeout: 260 seconds)
09:54:53 --- quit: texasmynsted (Ping timeout: 258 seconds)
09:59:08 --- quit: zargoertzel (Ping timeout: 272 seconds)
09:59:39 --- quit: heatsink (Remote host closed the connection)
10:00:49 --- join: doublex (~doublex@c-73-117-89-215.hsd1.oh.comcast.net) joined #haskell
10:03:10 --- quit: Brekker (Quit: WeeChat 1.9.1)
10:03:19 --- join: texasmynsted (~texasmyns@c-24-11-206-84.hsd1.tn.comcast.net) joined #haskell
10:03:22 --- quit: falafel_ (Ping timeout: 248 seconds)
10:05:32 --- quit: td123 (Ping timeout: 276 seconds)
10:06:18 --- join: Sheilong (uid293653@gateway/web/irccloud.com/x-lredjcwvkeamkrjo) joined #haskell
10:08:04 --- join: ub (~ubert@p200300ECDF1D69819DE815D2B37CE994.dip0.t-ipconnect.de) joined #haskell
10:08:33 --- quit: max00 (Quit: This computer has gone to sleep)
10:08:35 --- quit: ekleog (Quit: WeeChat 2.4)
10:09:30 --- quit: Kaivo (Quit: WeeChat 2.5)
10:09:50 --- quit: phreedom (Ping timeout: 260 seconds)
10:11:38 --- quit: emptyflask (Ping timeout: 245 seconds)
10:12:17 --- join: ekleog (~ii@prologin/ekleog) joined #haskell
10:12:48 --- join: Sk01 (~sky3@94.54.24.70) joined #haskell
10:14:46 --- quit: boj (Quit: nandeyanen)
10:15:01 <NemesisD> is there such a thing as a type-level non-empty list?
10:15:29 --- join: fendor_ (~fendor@178.115.129.25.wireless.dyn.drei.com) joined #haskell
10:17:34 <boxscape> NemesisD you might be able to just use (x : xs) as a type
10:17:43 <boxscape> this won't be unifiable with any empty lists
10:17:46 --- quit: fendor (Ping timeout: 248 seconds)
10:18:04 --- join: boj (~bojo@105-36-174-206.static.gci.net) joined #haskell
10:18:23 <boxscape> (actually not sure whether "unification" is the right term here)
10:19:13 --- join: vicfred (~vicfred@189.216.85.255) joined #haskell
10:19:24 <lyxia> NemesisD: NonEmpty
10:19:29 --- join: cur8or (~cur8or@41.113.96.154) joined #haskell
10:19:35 --- quit: Gurkenglas (Ping timeout: 246 seconds)
10:19:38 --- quit: liberiga (Ping timeout: 260 seconds)
10:19:48 <NemesisD> lyxia: oh wait, do you mean the constructors for Data.List.NonEmpty are already promoted?
10:19:53 --- quit: cur8or (Read error: Connection reset by peer)
10:20:33 <Geekingfrog> Hello there. I have a bunch of parsers (json): parseA, parseB, of type `Parser Foo`. I'd like to run all of them on the same object, and returns a list of successful parse: Parser [Foo]. I currently have something hideous: x <- sequence [(Just <$> parseA) <|> (pure Nothing), (Just <$> parseB) <|> (pure Nothing)]; catMaybes x. What would be a better way ?
10:20:46 --- join: geekosaur (42d52102@66.213.33.2) joined #haskell
10:21:19 <lyxia> NemesisD: all data types are promoted
10:22:17 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview
10:22:36 <glguy> Geekingfrog: catMaybes <$> traverse optional [parseA, parseB, ...]
10:22:39 <glguy> that ought to do it
10:22:53 --- quit: Sk01 (Ping timeout: 245 seconds)
10:23:25 <boxscape> NemesisD can I ask what you want to use it for?
10:23:31 <Geekingfrog> glguy, indeed, thanks.
10:24:11 --- quit: fphilipe (Read error: Connection reset by peer)
10:24:11 --- join: replay (~textual@pdpc/supporter/student/replay) joined #haskell
10:24:34 <dmwit> Even if NonEmpty weren't promoted, there's always (a, '[a])
10:24:44 --- join: cur8or (~cur8or@196.13.106.100) joined #haskell
10:24:45 --- join: yoeljacobsen (~yoel.jaco@2.53.35.112) joined #haskell
10:24:52 <NemesisD> boxscape: i'm creating a gadt with Cons and LastItem constructors that track each cons by adding to a type-level list, but it is not possible to have an empty type-level list
10:25:26 <boxscape> I see
10:26:32 --- join: revprez_stg (~revprez_s@static-173-76-190-156.bstnma.ftas.verizon.net) joined #haskell
10:28:19 <boxscape> Actually I'm slightly confused about my suggestion
10:28:27 <boxscape> % f :: Proxy (x:xs) -> Int; f = undefined
10:28:27 <yahb> boxscape: 
10:28:34 <boxscape> % f @(Proxy '[]) Proxy
10:28:34 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:162:31 in interactive:Ghci70
10:28:40 <boxscape> I'm not sure why this doesn't throw a type error
10:29:12 <NemesisD> i think maybe what i'm asking for isn't necessary. this type-level stuff is melting my brain and i probably should have read Sandy's book on it before starting lol
10:29:24 <jle`> boxscape: the type variables are x and xs
10:29:27 --- join: captjakk (~captjakk@c-65-50-169-164.hs.gigamonster.net) joined #haskell
10:29:35 <jle`> here:
10:29:42 <jle`> % :t f @(Proxy '[])
10:29:42 <yahb> jle`: Proxy (Proxy '[] : xs) -> Int
10:29:42 <koz_> NemesisD: jle`'s Introduction to Singletons is also massively useful.
10:29:49 <jle`> you're substituting x for Proxy '[]
10:29:59 <boxscape> oh, okay
10:30:00 <boxscape> thanks
10:30:10 <jle`> but this should error:
10:30:17 <jle`> % :t f (Proxy @'[])
10:30:18 <yahb> jle`: ; <interactive>:1:4: error:; * Couldn't match type '[] with `x0 : xs0'; Expected type: Proxy (x0 : xs0); Actual type: Proxy '[]; * In the first argument of `f', namely `(Proxy @'[])'; In the expression: f (Proxy @'[])
10:30:26 --- quit: DariusTh` (Ping timeout: 246 seconds)
10:30:28 <boxscape> yeah, ok
10:30:36 <jle`> remember that type applications doesn't supply the type of the first argument
10:30:45 <jle`> it supplies the type variables to be filled in
10:30:56 --- quit: fweht (Quit: Connection closed for inactivity)
10:31:11 <boxscape> maybe I should just get used to writing explicit foralls in all my typelevel stuff so I'm not confused by that
10:31:19 <jle`> % :t map @[]
10:31:19 <yahb> jle`: ; <interactive>:1:6: error:; * Expecting one more argument to `[]'; Expected a type, but `[]' has kind `* -> *'; * In the type `[]'; In the expression: map @[]
10:31:22 <koz_> boxscape: I do that and it helps a lot.
10:31:23 <jle`> % :t fmap @[]
10:31:23 <yahb> jle`: (a -> b) -> [a] -> [b]
10:31:31 <jle`> ^ you don't give it the (a -> b), but rather the f
10:31:39 <boxscape> yeah it makes sense
10:32:05 <koz_> It actually caught me doing silly things at least once already.
10:32:51 <koz_> Plus, it means you can make it easier for folks using TypeApplications by putting things most likely in need of explicit annotation first.
10:33:04 <koz_> (i.e. the ones that the user would most likely want to direct)
10:33:20 <koz_> s/user/caller/ I guess.
10:33:43 <jle`> NemesisD: if it helps, if you're looking for a vinyl Rec type thing but non-empty, i have one in my functor-products package
10:34:04 <jle`> NemesisD: Rec f '[a,b,c] is a tuple of f a, f b, f c
10:34:22 --- quit: vicfred (Quit: Leaving)
10:34:24 <jle`> so that package has NERec f (a ':| '[b,c])
10:34:52 --- quit: yoeljacobsen (Remote host closed the connection)
10:35:22 --- quit: brschkv (Ping timeout: 248 seconds)
10:35:25 --- quit: machinedgod (Ping timeout: 245 seconds)
10:35:27 --- quit: kubek2k (Ping timeout: 252 seconds)
10:35:32 --- join: yoeljacobsen (~yoel.jaco@2.53.35.112) joined #haskell
10:35:34 <boxscape> hm, IIRC you cannot use TypeApplication on inferred foralls (like if you just write "test = id" in ghci without annotation), because ghc changes might change the order of those in the future. But simply leaving off the top-level declaration doesn't count as "inferred", judging from :type +v, and also from the fact that you can use TA. What's the di
10:35:34 <boxscape> fference there? Couldn't the order of those change as well?
10:35:41 --- join: vicfred (~vicfred@189.216.85.255) joined #haskell
10:36:04 --- join: captjakk_ (~captjakk@178.128.232.240) joined #haskell
10:36:58 <boxscape> wait
10:37:22 <boxscape> instead of "leaving off top-level declaration"
10:37:30 <boxscape> it should read "not specifying the foralls yourself"
10:37:45 <boxscape> though it does make sense that there are rules in that case
10:37:57 <boxscape> I guess the foralls are just in the order that variables appear in the type?
10:38:08 --- quit: cur8or (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
10:38:36 --- join: Myhlamaeus2 (~Myhlamaeu@ip-109-41-65-57.web.vodafone.de) joined #haskell
10:39:29 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
10:39:35 --- quit: captjakk (Ping timeout: 245 seconds)
10:40:39 --- join: pie_ (~pie_@unaffiliated/pie-/x-0787662) joined #haskell
10:40:39 --- quit: wroathe (Read error: Connection reset by peer)
10:40:43 <jle`> yeah, that order is at least unambiguous
10:40:46 --- quit: yoeljacobsen (Ping timeout: 268 seconds)
10:40:47 <monochrom> No, explicit forall isn't necessary. I just tried.  Your "test = id" example admits two competing explanations and you haven't ruled out either.
10:40:56 --- join: eruditass (uid248673@gateway/web/irccloud.com/x-azwwbbgfmrgjwyif) joined #haskell
10:41:09 <boxscape> What are the two competing explanations?
10:41:09 --- quit: Saukk (Remote host closed the connection)
10:41:28 <monochrom> "no explicit forall" and "no type sig at all".  (Hey they rhyme!)
10:42:03 <boxscape> my current understanding is: Top level with forall -> everything's fine. Top level without forall -> ghc makes foralls in order of appearance. No top level -> type inferred, no TA possible.
10:42:08 <monochrom> As a scientist I tried "g :: a->a; g = id" to refute one of them.
10:43:33 <monochrom> . o O ( radio :: g a -> g a )
10:44:10 --- quit: skim_ (Ping timeout: 245 seconds)
10:44:33 --- quit: s4msung (Ping timeout: 245 seconds)
10:44:36 --- join: brschkv (~brschkv@x4d037d7c.dyn.telefonica.de) joined #haskell
10:45:29 --- quit: noctux (Ping timeout: 258 seconds)
10:46:01 --- quit: i7c (Ping timeout: 264 seconds)
10:46:05 --- quit: yushyin (Ping timeout: 252 seconds)
10:46:41 --- quit: ixian (Remote host closed the connection)
10:46:48 <monochrom> Your statement needs s/top level/type sig/
10:46:50 --- join: ixian (~mgold@2002:4a74:ba78:1701:0:ff:fe78:6269) joined #haskell
10:47:29 --- quit: o1lo01ol1o (Remote host closed the connection)
10:48:41 <boxscape> ah, ture
10:48:43 <boxscape> true
10:49:48 --- quit: imtravis (Ping timeout: 272 seconds)
10:49:50 --- quit: evanjs (Quit: Configuring ZNC, sorry for the joins/quits!)
10:50:09 --- join: evanjs (~evanjs@75.129.188.19) joined #haskell
10:50:26 --- join: u0_a144 (~user@2603:9000:a005:8e00:1d62:a7bb:1ade:a402) joined #haskell
10:53:12 --- quit: evanjs (Client Quit)
10:54:26 --- join: evanjs (~evanjs@75.129.188.19) joined #haskell
10:56:07 --- join: clarance (~saxe@183.103.72.80) joined #haskell
10:56:13 --- quit: cosimone (Quit: Leaving)
10:57:49 --- quit: ub (Ping timeout: 250 seconds)
11:00:06 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
11:00:24 --- quit: rah ()
11:02:10 --- quit: geekosaur (Remote host closed the connection)
11:02:15 --- part: clarance left #haskell
11:02:42 --- join: wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) joined #haskell
11:02:55 --- quit: turab (Ping timeout: 245 seconds)
11:04:19 --- quit: heatsink (Ping timeout: 250 seconds)
11:04:25 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
11:05:01 --- join: cosimone (~cosimone@2001:b07:ae5:db26:9520:741c:a5e9:2223) joined #haskell
11:05:26 --- quit: cosimone (Remote host closed the connection)
11:06:11 --- quit: alanz (Quit: Leaving)
11:07:27 --- quit: t7 (Quit: Konversation terminated!)
11:07:33 --- join: alanz (~alanz@165.255.64.8) joined #haskell
11:08:49 --- join: noctux (vAp9p78IzA@karif.server-speed.net) joined #haskell
11:08:50 --- join: yushyin (uL9EEWhYbt@karif.server-speed.net) joined #haskell
11:08:53 --- join: i7c (ypGtWTKoLv@unaffiliated/i7c) joined #haskell
11:09:26 --- quit: skim_ (Ping timeout: 272 seconds)
11:11:15 --- quit: rruizt (Ping timeout: 245 seconds)
11:11:56 <NemesisD> more stupid type-level questions incoming. this has me stumped: https://gist.github.com/MichaelXavier/7958576c4ee9be1c705c76c732b3426a
11:12:22 --- join: rruizt (~rruizt@83-84-23-124.cable.dynamic.v4.ziggo.nl) joined #haskell
11:12:41 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
11:12:51 <Cale> NemesisD: Perhaps it should be a type class function, since presumably it needs to be implemented differently for different types
11:13:39 --- join: kubek2k (~Jakub_Jan@2a02:a312:c83f:5080:4db3:589b:5a6:76af) joined #haskell
11:13:49 <nshepperd> isn't the relevant difference for TypeApplications between these two sorts of forall: g = id without a type sig gets 'forall {a}. a -> a'.  g :: a -> a; g = id gets 'forall a. a -> a'
11:14:27 <nshepperd> which you see if you :set -fprint-explicit-foralls and do :t +v g
11:14:58 <boxscape> yeah, my question was more or less isomorphic to "why are there no braces if you don't write explicit foralls", I guess
11:15:02 --- join: ratherforky (~ratherfor@cpc139346-aztw33-2-0-cust465.18-1.cable.virginm.net) joined #haskell
11:15:41 <NemesisD> Cale: i'm having a tough time figuring out the signature of that typeclass. i was hoping since NativeType was a closed type family from sql types to native types that i could only have to write one implementation
11:16:00 --- join: pi1 (~pi@dslb-094-221-126-043.094.221.pools.vodafone-ip.de) joined #haskell
11:16:31 <dmwit> NemesisD: What does $(singletons) give you?
11:16:36 <nshepperd> probably for hysterical raisins
11:16:43 <dmwit> If it gives you a singleton, presumably you can match on that in `uh`.
11:16:56 --- quit: reallymemorable (Quit: reallymemorable)
11:16:58 --- quit: pi__ (Ping timeout: 248 seconds)
11:17:05 --- quit: skim_ (Ping timeout: 245 seconds)
11:17:06 <dmwit> uh :: SQLTypeSing field -> SQLValue -> Maybe (NativeType field)
11:17:32 <NemesisD> i believe its from `Data.Singletons.TH`
11:17:33 --- join: Maqs1 (~Maqs@185.204.1.185) joined #haskell
11:18:01 <boxscape> (NemesisD Just an aside but as far as I can tell it looks like * will be deprecated in a couple years, personally I'd recommend getting used to Type instead)
11:18:03 <nshepperd> everything in base was written without explicit foralls when TypeApplications was invented (and still is), but people wanted to be able to use TypeApplications on them
11:18:52 <NemesisD> boxscape: oh, didn't know that. seems easy to switch
11:19:05 <nshepperd> and making the implicit foralls go in the same order that the type variables appear sort of works
11:19:08 <boxscape> here's the accepted proposal, fwiw https://github.com/ghc-proposals/ghc-proposals/pull/143
11:19:37 <boxscape> yeah that makes sense actually nshepperd
11:19:39 <Cale> I really dislike that property of TypeApplications, because it means that library authors need to be aware of TypeApplications even if they don't use it themselves
11:20:20 <Cale> If you explicitly quantify your type variables (e.g. to use ScopedTypeVariables), you have to be careful that you do it in the same order that GHC does it automatically
11:20:30 <boxscape> hm, is it possible to accidentally make a breaking change by changing the order of Constraints (assuming no foralls)?
11:20:40 <Cale> Or else you can break the code of people using TypeApplications
11:20:57 <dmwit> NemesisD: I agree it's from there. But that doesn't help me, because the documentation doesn't really say what it does; and the README it points to doesn't really, either.
11:21:09 <dmwit> NemesisD: I was hoping you knew.
11:21:59 <NemesisD> dmwit: i think this might be it: https://github.com/goldfirere/singletons/blob/master/README.md#definitions-used-to-support-singletons this is the thing i hate about TH though, it isn't clear what its defining
11:22:39 <dmwit> I read that already.
11:22:55 <boxscape> pretty sure the answer to my question is yes
11:22:57 <boxscape> that seems worrying
11:22:59 <NemesisD> the part that's breaking my brain is that i don't see how i could define a function at the value level that could handle all cases here
11:23:20 <NemesisD> since the `NativeType field` is dependent on the input
11:23:22 <nshepperd> boxscape: yeah. because it can change the order that the type variables are introduced
11:23:34 <dmwit> NemesisD: I recommend -ddump-splices. I bet the TH has produced a suitable data definition for pattern matching on.
11:23:58 <boxscape> I've read at least twice "changing the order of foralls is now a breaking change" but that's actually an understatement
11:24:34 --- join: dogui (~dogui@200.3.123.115) joined #haskell
11:26:13 * hackage postgres-options 0.1.0.1 - An Options type representing options for postgres connections  https://hackage.haskell.org/package/postgres-options-0.1.0.1 (JonathanFischoff)
11:26:55 --- quit: freeman42x]NixOS (Remote host closed the connection)
11:27:28 --- quit: actuallybatman (Ping timeout: 245 seconds)
11:27:58 <NemesisD> dmwit: do i need a typeclass or something to accomplish this?  even if i have a data definition to pattern match on, i don't see how one function body could produce `NativeType field`
11:28:09 --- join: t7 (~tommo@2a00:23c5:1284:fc00:2ddf:7489:89a1:4692) joined #haskell
11:28:30 --- join: nineonin_ (~nineonine@216.81.48.202) joined #haskell
11:28:35 --- join: yoeljacobsen (~yoel.jaco@2.53.35.112) joined #haskell
11:28:36 --- quit: nineonine (Read error: Connection reset by peer)
11:28:39 --- quit: HarveyPwca (Quit: Leaving)
11:28:56 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
11:29:16 --- join: cosimone (~cosimone@2001:b07:ae5:db26:9520:741c:a5e9:2223) joined #haskell
11:29:38 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
11:29:51 <Cale> NemesisD: Presumably if you're pattern matching on singletons (or on values of a GADT), the branches of the case expression all have different types, corresponding to the type index of the GADT constructors
11:30:31 <nshepperd> Maybe we could add a NoImplicitForAllIsVisible extension
11:30:45 <nshepperd> (together with ImplicitForAllIsVisible)
11:30:51 <NemesisD> oh right! i think i have to put `SQLValue` into the singletons splice too since it should give me a GADT
11:31:12 <boxscape> nshepperd there's a proposal for adding an extension that forces you to write forall, but maybe that's not quite the same thing
11:31:13 <nshepperd> which you could enable in your library to stop people from using TypeApplications except when explicit foralls are given
11:31:20 <dmwit> NemesisD: uh :: Sing field -> SQLValue -> Maybe (NativeType field); uh SSQLType_String (SQLValue_String s) = Just s
11:31:47 <dmwit> NemesisD: That typechecks. Add a case for SSQLType_Int, and a fallthrough that returns Nothing, and you should be good to go.
11:32:07 --- join: DariusTh` (~user@cpc112685-nmal22-2-0-cust375.19-2.cable.virginm.net) joined #haskell
11:32:08 --- join: knupfer (~Thunderbi@200116b82c8efe00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
11:32:39 --- join: oish (~charlie@228.25.169.217.in-addr.arpa) joined #haskell
11:32:42 --- quit: knupfer (Client Quit)
11:32:47 <nshepperd> after that, only changing explicitly forall'd type variables would be a breaking change
11:32:52 --- join: knupfer (~Thunderbi@200116b82c8efe00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
11:33:24 <dmwit> NemesisD: Minimal example included as a comment on your gist.
11:33:30 --- join: machinedgod (~machinedg@134.41.46.111) joined #haskell
11:33:36 <boxscape> hm actually I can't find the proposal anymore, strange
11:33:51 --- join: turab (~turab@149-160-224-148.dhcp-bl.indiana.edu) joined #haskell
11:34:43 <nshepperd> and if people ask for explicit type variables to make things usable for TypeApplications, you could do it on a case by case basis in a minor release
11:34:45 <dmwit> NemesisD: (I was right: -ddump-splices was very informative. I again heartily recommend you try it yourself.)
11:34:56 --- join: Gurkenglas (~Gurkengla@unaffiliated/gurkenglas) joined #haskell
11:35:32 <boxscape> nshepperd or, due to the current state of affairs without that extension, you could just leave off type annotations everywhere in your library to achieve a similar effect :P
11:35:38 --- quit: wroathe (Ping timeout: 248 seconds)
11:35:49 <nshepperd> a terrifying prospect
11:36:54 <NemesisD> dmwit: thank you! the part that i think i had a hard time understanding is you have a case of the function returning `(Just (s :: String))` and another case that returns `Just (n :: Int)`, which just feels so strange coming from normal value-level haskell
11:37:13 * hackage postgresql-simple-opts 0.4.0.0 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.4.0.0 (JonathanFischoff)
11:37:45 --- quit: cosimone (Quit: Leaving)
11:38:36 <dmwit> NemesisD: Yep. But in those cases, you have learned (from the pattern match on SSQLType_String/SSQLType_Int) that those are the appropriate types to return.
11:38:57 --- join: fendor__ (~fendor@178.115.129.25.wireless.dyn.drei.com) joined #haskell
11:39:15 --- join: sh_zam (~sh_zam@unaffiliated/sh-zam/x-8784764) joined #haskell
11:39:51 <NemesisD> dmwit: so basically it can be statically known that some of the cases of that function pattern match are unreachable, right? like if we know that we're matching `SSQLType_String`,  the compiler needn't consider the cases for `SSQLType_Int`?
11:40:52 --- quit: fendor__ (Remote host closed the connection)
11:41:15 --- quit: fendor_ (Ping timeout: 245 seconds)
11:41:46 --- join: titos (~falito@211.248.212.200) joined #haskell
11:43:25 --- join: fendor (~fendor@178.115.129.25.wireless.dyn.drei.com) joined #haskell
11:43:40 --- quit: yoeljacobsen (Ping timeout: 268 seconds)
11:45:17 --- join: yoeljacobsen (~yoel.jaco@2.53.35.112) joined #haskell
11:46:09 --- quit: sh_zam (Remote host closed the connection)
11:46:12 * hackage ghc-exactprint 0.6.2 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.2 (AlanZimmerman)
11:47:57 --- part: titos left #haskell
11:49:21 --- join: ub (~ubert@p200300ECDF1D69819DE815D2B37CE994.dip0.t-ipconnect.de) joined #haskell
11:51:15 --- quit: yoeljacobsen (Ping timeout: 245 seconds)
11:51:24 --- join: wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) joined #haskell
11:55:40 --- quit: fendor (Ping timeout: 272 seconds)
11:56:18 --- quit: wroathe (Ping timeout: 272 seconds)
11:57:09 --- join: andi- (~andi-@NixOS/user/andi-) joined #haskell
11:58:19 --- join: Guest55 (b1294571@gateway/web/cgi-irc/kiwiirc.com/ip.177.41.69.113) joined #haskell
11:58:30 --- join: Sk01 (~sky3@94.54.24.70) joined #haskell
11:58:48 <Guest55> How can I see the result of the application of a type family in ghci?
11:59:05 --- quit: al-damiri (Quit: Connection closed for inactivity)
11:59:45 <Guest55> I'm trying `:kind! MyTypeFamily ...` with no success, it only returns me this same expression.
12:00:23 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
12:00:26 --- join: actuallybatman (~sam@S010664777dafd303.cg.shawcable.net) joined #haskell
12:01:15 <Cale> Guest55: Are you certain there's an instance available for it to be able to reduce?
12:01:30 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
12:02:32 --- quit: kubek2k (Ping timeout: 276 seconds)
12:03:00 <Guest55> You're right, I think it doesn't.
12:04:52 --- join: yoeljacobsen (~yoel.jaco@2.53.35.112) joined #haskell
12:06:13 --- join: kubek2k (~Jakub_Jan@2a02:a312:c83f:5080:4987:c91b:6634:8062) joined #haskell
12:06:25 --- quit: heatsink (Ping timeout: 264 seconds)
12:06:38 --- join: jose_zap (~jose_zap@176-20-96-236-dynamic.dk.customer.tdc.net) joined #haskell
12:06:58 --- join: Zer0xp (~Zer0xp@223.237.247.194) joined #haskell
12:07:29 --- quit: tromp_ (Remote host closed the connection)
12:08:13 --- join: threewood (~threewood@cpe-24-55-6-224.austin.res.rr.com) joined #haskell
12:08:18 <boxscape> always seemed a bit strange to me that it doesn't throw a type error in those cases, but I guess irreducible type family applications are useful for something?
12:09:08 --- join: ChrisPenner[m] (chrispenne@gateway/shell/matrix.org/x-oxygfghymiqnutrj) joined #haskell
12:10:25 --- quit: brandly (Ping timeout: 245 seconds)
12:10:44 --- quit: mulk (Quit: ZNC - http://znc.in)
12:11:13 --- quit: DariusTh` (Remote host closed the connection)
12:11:31 --- join: DariusTh` (~user@cpc112685-nmal22-2-0-cust375.19-2.cable.virginm.net) joined #haskell
12:11:48 <Guest55> boxscape: given a (Rep a) I'd like to know if it "has" b.
12:11:48 --- join: chr15 (~chr15@223.237.212.26) joined #haskell
12:12:43 <boxscape> hmm, I'm not sure what that means or how to relate it to my question
12:12:48 <Guest55> i.e: `type family RepHas b (f :: k -> *) :: Bool where RepHas b U1 = 'False; RepHas b (M1 i t f) = RepHas b f ...`
12:13:15 <Guest55> But it's not quite working. hehe
12:13:35 --- join: talbot (~eldredge@125.135.147.237) joined #haskell
12:14:15 --- quit: talbot (K-Lined)
12:14:33 --- quit: osa1 (Ping timeout: 245 seconds)
12:14:34 --- quit: Azel (Ping timeout: 248 seconds)
12:15:28 <Guest55> Oh. I know what i did wrong. xd
12:17:00 --- join: weidar (~wendall@125.138.68.240) joined #haskell
12:17:11 --- quit: weidar (K-Lined)
12:18:20 --- quit: doublex (Ping timeout: 245 seconds)
12:19:04 --- join: Deide (~Deide@90.249.58.88) joined #haskell
12:19:11 <dmwit> NemesisD: Err?
12:19:21 <dmwit> NemesisD: I don't think so? We covered all the cases, no?
12:22:35 --- join: noumenon (~daemon@127.51-175-198.customer.lyse.net) joined #haskell
12:25:50 --- join: hiroaki (~hiroaki@2a02:908:4b14:d500:8d4c:a111:9cac:718b) joined #haskell
12:26:40 --- quit: yoeljacobsen (Ping timeout: 245 seconds)
12:26:53 --- quit: crobbins (Remote host closed the connection)
12:27:49 --- join: doublex (~doublex@2603:301f:a63:8000:99cb:51e8:196b:b6b1) joined #haskell
12:29:13 --- quit: td123 (Ping timeout: 264 seconds)
12:29:38 --- join: td123 (~td123@unaffiliated/td123) joined #haskell
12:30:25 --- quit: brschkv (Ping timeout: 245 seconds)
12:31:39 --- quit: jose_zap (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
12:32:29 <NemesisD> dmwit: i mean when `field` is made concrete, it can only hit a subset of the function's cases
12:33:28 --- join: fphilipe (~phil@2a02:168:f6c3:0:740c:7c18:d9cb:2fcb) joined #haskell
12:33:49 --- join: crobbins (~crobbins@2601:2c1:380:e8a:c483:731:b29e:cbf7) joined #haskell
12:33:59 --- quit: xkapastel (Quit: Connection closed for inactivity)
12:35:49 --- quit: blazered_ (Remote host closed the connection)
12:36:08 --- join: blazered_ (~blazered@2620:10d:c091:500::1:2dde) joined #haskell
12:36:13 <hololeap> i find it really unintuitive that [1,1..1] === [1..]
12:37:13 <hololeap> for instance, if i have range like [s,s+q..s+f*q], i have to manually check for the case of q=0, otherwise i suddenly get an infinite list
12:37:50 <Ariakenom> hololeap: what do you do to stop the infinite list?
12:38:35 <hololeap> well, in my code, it didn't stop and it took me a while to figure out what was causing the unexpected loop
12:38:58 <hololeap> % [1 .. 1]
12:38:58 <yahb> hololeap: [1]
12:39:02 <hololeap> % [1,1 .. 1]
12:39:08 <yahb> hololeap: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
12:39:12 <hololeap> it just seems unintuitive
12:39:14 --- quit: turab (Ping timeout: 244 seconds)
12:39:47 <Ariakenom> hololeap: oh you had an === instead of /= in your msg. I got confused
12:39:55 --- quit: doublex (Read error: Connection reset by peer)
12:40:03 --- join: doublex (~doublex@2603:301f:a63:8000:99cb:51e8:196b:b6b1) joined #haskell
12:40:16 <hololeap> what i meant was that [1,1..1] and [1..] create the same result
12:40:22 --- quit: cr3 (Quit: leaving)
12:40:28 <cocreature> Ariakenom: == is right, itâ€™s == [1..] and /= [1..1]
12:40:57 <Ariakenom> oh I see, yes
12:40:58 --- join: jose_zap (~jose_zap@176-20-96-236-dynamic.dk.customer.tdc.net) joined #haskell
12:41:08 * Ariakenom stops trying to read code for the night
12:41:57 --- quit: conal (Quit: Computer has gone to sleep.)
12:43:20 --- quit: DariusTh` (Ping timeout: 245 seconds)
12:44:15 <dmwit> NemesisD: Ah, yep.
12:45:07 --- join: tromp (~tromp@2a02:a210:1585:3200:5de5:33f8:3b1f:4be6) joined #haskell
12:45:26 <Ariakenom> I think that [..] example might behave better with exclusive ends
12:45:46 --- join: cosimone (~cosimone@2001:b07:ae5:db26:9520:741c:a5e9:2223) joined #haskell
12:45:51 <dmwit> hololeap: Interesting. I guess you can either specify [a,b..c] to say "once it produces c, it stops" or "it keeps going until the next thing it would produce would be over c".
12:46:04 <dmwit> hololeap: The former seems like it would be sort of unintuitive in case c<a.
12:46:38 --- quit: chalkmonster (Ping timeout: 245 seconds)
12:46:41 <dmwit> (I mean, even if you change it to say "once it produces something over c, it stops", you'd get lists with elements in them, which seems weird and probably usually wrong.)
12:46:51 <Ariakenom> dmwit: or when a+b*N never equals c
12:46:52 <dmwit> [1,2..0] should be [], not [1].
12:47:01 <dmwit> Ariakenom: See my fix in parentheses above.
12:47:36 <Ariakenom> yeah race condition
12:47:45 <dmwit> yeah =)
12:48:20 <hololeap> dmwit: fair enough, but i think there is an implied "this list will terminate" when you have something past the ellipsis
12:49:04 <hololeap> (would that be called an ellipsis?)
12:49:20 <boxscape> % [1..] == [1,1..1]
12:49:20 <yahb> boxscape: False
12:49:39 --- quit: tromp (Ping timeout: 252 seconds)
12:49:45 <hololeap> % [1..]
12:49:46 <boxscape> it sounded to me like you were saying this should be true but maybe I misunderstood?
12:49:51 <yahb> hololeap: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
12:49:53 <boxscape> s/should be/is
12:50:06 --- join: reallymemorable (~reallymem@mobile-107-107-62-97.mycingular.net) joined #haskell
12:50:13 --- quit: SCHAPiE (Quit: ZNC - https://znc.in)
12:50:27 --- quit: imtravis (Ping timeout: 258 seconds)
12:50:37 <hololeap> sorry, i stated that poolry at the beginning. my concern is that [1,1..1] creates an infinite list, which is unintuitive
12:50:42 <boxscape> okay
12:50:58 <boxscape> (I agree)
12:51:24 <hololeap> i was mostly asking in here to see if there was a good reason for the unintuitve semantics
12:51:37 --- join: tromp (~tromp@2a02:a210:1585:3200:61e2:3457:5def:1a6b) joined #haskell
12:51:58 <Ariakenom> again, my intuition is that inclusive ends are annoying like 1-indexing is annoying
12:52:13 <boxscape> they do seem kind of related
12:52:28 --- join: SCHAPiE (~schapie@unaffiliated/schaap137) joined #haskell
12:52:33 <boxscape> I think Dijkstra actually refers to both of them in his essay on 0-indexing
12:52:49 --- quit: blazered_ (Remote host closed the connection)
12:53:07 --- join: blazered_ (~blazered@2620:10d:c091:500::3:d4db) joined #haskell
12:53:13 --- join: tromp_ (~tromp@2a02:a210:1585:3200:c14f:1bf9:f791:b37d) joined #haskell
12:53:23 <bwe> for which reason is  randomIO :: IO Int  freezing on Mac OS X?
12:53:25 <boxscape> https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
12:53:44 <mycroftiv> my 'lifescore' of off-by-one errors i have written in code is probably getting close to 500,000
12:53:52 --- join: lenci (~omar@121.186.46.233) joined #haskell
12:54:07 <boxscape> I think you mean 499,999
12:54:11 --- join: gammastorm (~thorsten@HSI-KBW-095-208-058-174.hsi5.kabel-badenwuerttemberg.de) joined #haskell
12:54:12 <hololeap> ^
12:54:37 <gammastorm> noone is answering, so here something really off-topic :-) https://tarot-sessions.4lima.de/ 
12:55:12 <gammastorm> for sweetening your pc work
12:55:24 --- quit: lenci (K-Lined)
12:55:53 <Ariakenom> boxscape: I was about to link it :)
12:55:53 --- quit: tromp (Ping timeout: 252 seconds)
12:57:35 --- mode: ChanServ set +o dmwit
12:57:41 --- join: pernell (~bentlee@1.226.167.109) joined #haskell
12:57:43 --- quit: tromp_ (Ping timeout: 252 seconds)
12:58:02 --- quit: Guest55 (Remote host closed the connection)
12:58:14 --- quit: pernell (K-Lined)
12:58:16 --- mode: dmwit set +b *!*thorsten@*.hsi5.kabel-badenwuerttemberg.de
12:58:16 --- kick: gammastorm was kicked by dmwit (not answering is not license to spam)
12:58:28 --- mode: dmwit set -o dmwit
12:58:40 --- join: kupi (uid212005@gateway/web/irccloud.com/x-dmoujaaqptafarqz) joined #haskell
12:58:44 <Ariakenom> boxscape: I had the feeling Dijkstra was great for forming strong opinions on odd things. Can't think of another article right now though.
12:59:10 <boxscape> He introduced the whole "considered harmful" meme with goto
12:59:23 <boxscape> I guess that's not that odd though, at least today
12:59:31 --- join: zerotech1 (~zerotech@BSN-210-227-81.dynamic.siol.net) joined #haskell
12:59:34 <mycroftiv> as well as the whole 'simple languages harm the brain' meme if i recall
12:59:35 --- join: ais (~ais@86.100.110.212) joined #haskell
12:59:44 --- quit: u0_a144 (Ping timeout: 276 seconds)
12:59:47 <hololeap> maybe Haskell could take something from Ruby, which is [a..b] has an inclusive and [a...b] has an exclusive end
12:59:49 <Ariakenom> mod and rem for computing fits the bill though not by EWD https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
12:59:54 <boxscape> that sounds like the Sapir-Whorf hypothesis
13:00:06 --- quit: sagax (Quit: Konversation terminated!)
13:00:08 --- join: Guest_98 (a73cd3d5@r167-60-211-213.dialup.adsl.anteldata.net.uy) joined #haskell
13:00:09 <boxscape> (almost)
13:00:10 --- quit: vlatkoB (Remote host closed the connection)
13:00:15 --- quit: gioyik (Quit: WeeChat 2.5)
13:00:19 <mycroftiv> boxscape: i believe he has a quote about how teaching BASIC programming cripples the mind and should be forbidden :) lemme find it
13:00:23 --- join: sagax (~sagax_nb@213.138.71.146) joined #haskell
13:00:31 --- quit: Guest_98 (Remote host closed the connection)
13:00:47 <boxscape> hololeap hm I think i'd prefer syntax that's a little easier to distinguish
13:01:19 <Ariakenom> a man of taste, of course "Finally, in the specific comparison of Haskell versus Java, Haskell, though not perfect, is of a quality that is several orders of magnitude higher than Java" https://chrisdone.com/posts/dijkstra-haskell-java/
13:01:22 --- join: u0_a144 (~user@072-184-243-113.res.spectrum.com) joined #haskell
13:01:35 <mycroftiv> "It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration.The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offence." -djikstra
13:01:48 <dmwit> > [2^53-1, 2^53 .. 2^53+2]
13:01:50 <lambdabot>  [9007199254740991,9007199254740992,9007199254740993,9007199254740994]
13:02:01 <dmwit> > [2^53-1, 2^53 .. 2^53+2] :: [Double]
13:02:03 <lambdabot>  [9.007199254740991e15,9.007199254740992e15,9.007199254740992e15,9.0071992547...
13:02:36 <dmwit> hololeap: ^ That list is also infinite. So I don't think acting as if ellipsis implies termination is a good idea.
13:02:43 <boxscape> not sure why it would seem like a good idea to make Float and Double Enums
13:02:59 --- join: chr151 (~chr15@203.192.251.82) joined #haskell
13:03:15 <dmwit> hololeap: I can think of at least one more type where there is a sensible Enum instance whose .. may not terminate even though the endpoints are not equal.
13:03:23 <hololeap> dmwit: point taken. this should be taught early on in beginner haskell books/tutorials IMO =)
13:03:52 <hololeap> cuz yeah it kind of blidsided me
13:04:01 --- quit: howdoi (Quit: Connection closed for inactivity)
13:04:42 --- quit: Zer0xp (Ping timeout: 248 seconds)
13:04:44 <hololeap> especially because i'm not fully solid on how to correctly use laziness, so when my function didn't terminate, i felt like the potential problem could be anywhere
13:04:56 <dmwit> I can see this being frustrating.
13:05:35 --- quit: doublex (Ping timeout: 276 seconds)
13:05:45 --- join: chrisdotcode (~chrisdotc@unaffiliated/chrisdotcode) joined #haskell
13:05:48 --- quit: chr15 (Ping timeout: 245 seconds)
13:05:59 * hololeap really needs to learn how to do profiling in Haskell
13:06:27 <dmwit> I wonder what we would find unintuitive with the spec "when you are about to produce an element, use >= to decide whether to terminate and <= to decide whether to include it". (For increasing integral ..'s, with the obvious tweaks for decreasing ..'s.)
13:07:30 --- quit: ravenous_ (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
13:07:44 <dmwit> With this spec, [1,2 ..0] would be [] as desired, and [1,1 .. 1] would be [1], perhaps also as desired.
13:08:26 <hololeap> i think the problem is that not many people would even read the spec, because it seems so "simple", but the seemingly iron-clad patterns in how it behaves break down with certain edge-cases
13:09:31 --- join: Zer0xp (~Zer0xp@203.192.251.82) joined #haskell
13:09:39 --- join: ShalokShalom93 (b9110c15@gateway/web/cgi-irc/kiwiirc.com/ip.185.17.12.21) joined #haskell
13:09:41 --- quit: Sk01 (Ping timeout: 246 seconds)
13:10:18 <hololeap> oh, you're saying change its implementation :o
13:10:54 <hololeap> there's probably someone out there that relies on [1,1..1] instead of (repeat 1)
13:10:58 <hololeap> :p
13:11:05 <dmwit> I am dreaming about the counterfactual world in which I have a time machine which lets me go back and give advice to the Haskell Committee.
13:11:48 <dmwit> This proposed spec has the nice property that [1,x .. 1] = [1] for all x.
13:11:48 <ais> Is it normal/usual for `stack install somepackage` to throw "ExitFailure 1"? Today i have tried to install "cabal-install", "jack" and "reactive-jack". They all end up with "ExitFailure 1". 
13:12:08 <dmwit> No, it is not normal.
13:12:18 <dmwit> There should be detailed build logs somewhere for you to inspect.
13:12:25 --- quit: ShalokShalom93 (Remote host closed the connection)
13:12:33 <ais> i tried adding "--verbose"
13:13:01 <ais> but i'm not sure what is going on there
13:13:28 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
13:13:33 <ais> "jack> (>=0.118 && <1) || (>=1.9.8 && <2) is required but it could not be found"
13:13:51 --- quit: zerotech1 (Ping timeout: 244 seconds)
13:14:21 --- join: mulk (~mulk@p2E51BF96.dip0.t-ipconnect.de) joined #haskell
13:14:23 <dmwit> Is that the exact error, or may it have typos from hand-typing it into IRC?
13:15:37 <ais> https://paste.ubuntu.com/p/72T8QvzhPZ/
13:15:40 <dmwit> Oh, perhaps that's about the version of the C library. In which case it's likely a pkgconfig thing.
13:16:03 <dmwit> Do you have the jack C library installed properly?
13:16:15 --- quit: Zer0xp (Ping timeout: 245 seconds)
13:16:36 <ais> it's a new linux distro 
13:16:39 <ais> so i might not
13:17:24 --- quit: chr151 (Ping timeout: 268 seconds)
13:17:28 --- quit: reallymemorable (Ping timeout: 245 seconds)
13:17:55 --- quit: skim_ (Ping timeout: 245 seconds)
13:19:45 --- join: osa1 (~omer@haskell/developer/osa1) joined #haskell
13:20:08 --- join: leshow (~leshow@static-209-87-236-138.storm.ca) joined #haskell
13:20:25 --- quit: pie_ (Ping timeout: 245 seconds)
13:20:27 <ais> thanks, i installed "jack-audio-connection-kit-devel" and now it works
13:21:31 <leshow> say I have a typeclass class Mut m where { type Ref m :: Type -> Type; newRef :: a -> m (Ref m a); }  and I make an instance for IO
13:21:54 <leshow> instance Mut IO where { type Ref IO = IORef; newRef = newIORef; }
13:22:09 <leshow> how would I pass Mut polymorphically into a function?
13:22:39 <leshow> If I have a function, I want it to take any Mut thing, and have access to the newRef function
13:23:50 --- quit: baskebol` (Remote host closed the connection)
13:24:04 --- join: pie_ (~pie_@unaffiliated/pie-/x-0787662) joined #haskell
13:24:59 --- join: Kaivo (~Kaivo@ec2-35-182-108-102.ca-central-1.compute.amazonaws.com) joined #haskell
13:26:02 --- quit: freeman42x]NixOS (Ping timeout: 268 seconds)
13:27:59 <MarcelineVQ> leshow: You just have foo :: Mut m => ... As the most direct example: useMut :: Mut m => a -> m (Ref m a); useMut = newRef
13:28:38 <leshow> I wasn't aware you could use 'Ref' outside of the typeclass it was declared in
13:29:13 --- quit: evanjs (Quit: Configuring ZNC, sorry for the joins/quits!)
13:29:29 --- join: evanjs (~evanjs@75.129.188.19) joined #haskell
13:30:26 <hololeap> leshow: this works fine, not sure what else you want: http://dpaste.com/0ESQ0GP
13:31:16 --- quit: ais (Quit: leaving)
13:31:20 <leshow> I'm not using it practically for anything, I just read a blog post about typefamilies and this was used as an example, so I wanted to see what it would look like
13:31:22 <leshow> thanks
13:34:53 --- quit: noumenon (Remote host closed the connection)
13:35:12 --- join: imtravis (~imtravis@cpe-108-185-149-115.socal.res.rr.com) joined #haskell
13:35:45 --- join: Lord_of_Life_ (~Lord@unaffiliated/lord-of-life/x-0885362) joined #haskell
13:36:06 --- join: pavonia (~user@unaffiliated/siracusa) joined #haskell
13:36:38 --- quit: hololeap (Ping timeout: 245 seconds)
13:37:08 --- quit: Gurkenglas (Ping timeout: 268 seconds)
13:38:22 <vaibhavsagar> how do I update `configuration-ghc-8.8.x.nix`? I made a PR once but peti yelled at me because the file is automatically generated
13:38:39 --- quit: Ariakenom (Quit: Leaving)
13:38:54 --- quit: Lord_of_Life (Ping timeout: 272 seconds)
13:40:12 --- nick: Lord_of_Life_ -> Lord_of_Life
13:40:20 --- quit: Sigyn (Killed (tomaw (<No reason given>)))
13:40:31 --- join: Sigyn (sigyn@freenode/utility-bot/sigyn) joined #haskell
13:40:31 --- mode: ChanServ set +o Sigyn
13:40:34 --- join: fresheyeball (~isaac@c-71-237-105-37.hsd1.co.comcast.net) joined #haskell
13:41:50 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
13:41:55 --- join: xkapastel (uid17782@gateway/web/irccloud.com/x-xjgwncdxrcswopxn) joined #haskell
13:42:07 --- join: wroathe (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) joined #haskell
13:43:15 <fresheyeball> newtype OrdSet a = Ord a => OrdSet (Set a)
13:43:19 <fresheyeball> is it a Functor?
13:44:00 --- join: hololeap (~hololeap@unaffiliated/hololeap) joined #haskell
13:44:07 <mycroftiv> id watch that gameshow
13:44:30 --- quit: Sigyn (Killed (tomaw (<No reason given>)))
13:44:39 --- join: Sigyn (sigyn@freenode/utility-bot/sigyn) joined #haskell
13:44:39 --- mode: ChanServ set +o Sigyn
13:44:43 <fresheyeball> mycroftiv: and thats functorwang
13:45:24 --- quit: mulk (Quit: ZNC - http://znc.in)
13:45:27 --- join: falafel_ (~falafel@static-176-185-149-136.axione.abo.bbox.fr) joined #haskell
13:47:46 --- quit: osa1 (Ping timeout: 272 seconds)
13:47:54 <hololeap> Ein FunctorwÃ¤ng
13:48:06 --- join: mulk (~mulk@p2E51BF96.dip0.t-ipconnect.de) joined #haskell
13:49:24 <dmwit> fresheyeball: Did you try writing an instance and proving the Functor laws?
13:51:59 --- quit: kubek2k (Ping timeout: 252 seconds)
13:52:33 --- quit: freeman42x]NixOS (Ping timeout: 258 seconds)
13:53:47 --- quit: deviantfero (Ping timeout: 268 seconds)
13:55:12 --- join: deviantfero (~deviantfe@ip168-243-230-189.intercom.com.sv) joined #haskell
13:57:16 --- quit: oish (Ping timeout: 272 seconds)
13:58:45 --- join: reallymemorable (~reallymem@cpe-66-108-137-140.nyc.res.rr.com) joined #haskell
13:59:20 <jle`> fresheyeball: i'd try seeing if it's even possible to write an instance first ;)
14:00:23 --- quit: Maqs1 ()
14:00:24 --- quit: wroathe (Quit: Lost terminal)
14:00:36 <jle`> hopefully my winky face gives a clue to the result to expect
14:00:50 --- quit: Cale (Ping timeout: 276 seconds)
14:01:47 --- quit: leshow (Quit: WeeChat 1.6)
14:02:05 --- join: hermie (~jerrome@121.139.195.222) joined #haskell
14:02:45 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
14:03:04 --- join: max00 (~max@216.147.231.246) joined #haskell
14:03:15 --- join: fizbin (~fizbin@c-98-221-75-24.hsd1.nj.comcast.net) joined #haskell
14:03:22 --- quit: hermie (K-Lined)
14:03:41 --- join: o1lo01ol1o (~o1lo01ol1@152.80.136.95.rev.vodafone.pt) joined #haskell
14:03:42 --- join: brandly (~brandly@c-24-61-240-6.hsd1.ma.comcast.net) joined #haskell
14:03:54 --- quit: fizbin (Client Quit)
14:04:16 --- join: is_null (~jpic@pdpc/supporter/professional/is-null) joined #haskell
14:04:48 --- quit: inkbottle (Quit: Konversation terminated!)
14:05:13 --- join: inkbottle (~inkbottle@aaubervilliers-654-1-63-227.w86-212.abo.wanadoo.fr) joined #haskell
14:07:37 --- quit: heatsink (Ping timeout: 264 seconds)
14:08:23 --- quit: max00 (Quit: This computer has gone to sleep)
14:10:01 --- quit: crobbins (Remote host closed the connection)
14:12:43 --- join: Cale (~cale@2607:fea8:995f:fb71:41b1:8877:c5f6:6e57) joined #haskell
14:12:51 --- join: fweht (uid344711@gateway/web/irccloud.com/x-cvdrpigvimgbrbgj) joined #haskell
14:13:09 --- quit: sagax (Remote host closed the connection)
14:14:04 --- join: max00 (~max@216.147.231.246) joined #haskell
14:16:05 --- join: fendor (~fendor@178.115.129.25.wireless.dyn.drei.com) joined #haskell
14:17:51 --- quit: dxtr (Ping timeout: 258 seconds)
14:18:00 --- join: solirc (~solirc@141.98.102.235) joined #haskell
14:20:35 --- quit: hiroaki (Ping timeout: 252 seconds)
14:20:48 --- quit: net4all (Ping timeout: 245 seconds)
14:21:45 --- join: al-damiri (uid142631@gateway/web/irccloud.com/x-uxtjoxqttympxsxr) joined #haskell
14:23:41 --- join: crobbins (~crobbins@71-146-121-195.lightspeed.hstntx.sbcglobal.net) joined #haskell
14:23:47 --- quit: Jacoby6000 (Quit: ZNC 1.7.0 - https://znc.in)
14:24:03 --- join: DTZUZO (~DTZUZO@S0106bcd165662a4d.vs.shawcable.net) joined #haskell
14:26:36 --- join: milanj_ (~milan@178.220.178.4) joined #haskell
14:27:12 --- quit: milanj (Read error: Connection reset by peer)
14:27:15 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
14:28:28 --- quit: chrisdotcode (Quit: chrisdotcode)
14:28:29 --- quit: Sigyn (Killed (tomaw (<No reason given>)))
14:28:39 --- join: Sigyn (sigyn@freenode/utility-bot/sigyn) joined #haskell
14:28:39 --- mode: ChanServ set +o Sigyn
14:30:05 --- join: toblorone (~toblorone@162.246.216.28) joined #haskell
14:32:25 --- quit: deviantfero (Ping timeout: 258 seconds)
14:33:40 --- join: oish (~charlie@228.25.169.217.in-addr.arpa) joined #haskell
14:34:25 --- join: deviantfero (~deviantfe@ip168-243-230-189.intercom.com.sv) joined #haskell
14:34:59 --- quit: freeman42x]NixOS (Quit: Leaving)
14:35:04 --- join: merxc (be7322cc@190.115.34.204) joined #haskell
14:35:10 --- quit: max00 (Quit: This computer has gone to sleep)
14:36:13 * hackage ghc-datasize 0.2.1 - Determine the size of data structures in GHC's memory  https://hackage.haskell.org/package/ghc-datasize-0.2.1 (DennisFelsing)
14:36:25 --- quit: ub (Ping timeout: 264 seconds)
14:39:53 --- quit: toblorone (Remote host closed the connection)
14:40:26 --- join: toblorone (~toblorone@162.246.216.28) joined #haskell
14:40:39 --- quit: oish (Ping timeout: 268 seconds)
14:41:03 --- join: tromp (~tromp@2a02:a210:1585:3200:7c7e:6916:e395:5fa4) joined #haskell
14:42:04 --- join: Nd-969-m (~nend@109.72.55.146) joined #haskell
14:44:12 --- join: freeman42x]NixOS (~freeman42@89.137.217.223) joined #haskell
14:44:25 --- quit: alanz (Remote host closed the connection)
14:45:02 --- join: max00 (~max@216.147.231.246) joined #haskell
14:45:21 --- quit: lucasb (Quit: Connection closed for inactivity)
14:45:24 --- quit: toblorone (Ping timeout: 272 seconds)
14:47:50 --- join: doublex (~doublex@c-73-117-99-12.hsd1.oh.comcast.net) joined #haskell
14:48:17 --- quit: max00 (Client Quit)
14:48:18 --- quit: stepnem (Ping timeout: 245 seconds)
14:48:50 --- quit: merxc (Remote host closed the connection)
14:49:39 --- join: stepnem (~stepnem@185.112.167.114) joined #haskell
14:51:37 <maralorn> Iâ€˜d like to write a reflex application, where the webserver pushes changes in the displayed data to the browser and then the browser updates the display via reflex.
14:51:45 --- quit: Myhlamaeus2 (Remote host closed the connection)
14:52:03 <maralorn> I am wondering does it make sense to also use reflex in the backend for this? Would that even be feasible?
14:52:13 --- join: Myhlamaeus2 (~Myhlamaeu@ip-109-41-65-57.web.vodafone.de) joined #haskell
14:52:22 --- quit: tsaka__ (Ping timeout: 272 seconds)
14:52:35 <vaibhavsagar> sure
14:52:38 <Cale> Apart from the fact that Reflex is single threaded, I think it makes sense.
14:52:56 <vaibhavsagar> how are you planning to have the server push updates? most of the reflex apps I've seen use websockets
14:54:02 --- quit: stepnem (Ping timeout: 248 seconds)
14:54:10 --- quit: teardown (Ping timeout: 245 seconds)
14:54:49 --- join: stepnem (~stepnem@185.112.167.114) joined #haskell
14:55:00 --- join: conal (~conal@209.58.135.97) joined #haskell
14:55:56 <maralorn> I am still looking for a simple example on how to have a webserver and a reflex thread running in the backend.
14:56:58 <vaibhavsagar> `ob init`
14:57:01 <Cale> At Obsidian, we haven't really tried using Reflex on the backend
14:57:06 <maralorn> I found some resources for running a reflex network but it looked kinda complicated.
14:57:32 <Cale> You might want to look at reflex-vty for a well-commented example of how to set up a reflex host
14:57:56 --- join: max00 (~max@216.147.231.246) joined #haskell
14:58:09 <maralorn> Cale: Thanks, that looks interesting.
14:58:13 --- join: toblorone (~toblorone@162.246.216.28) joined #haskell
14:58:43 --- join: urodna (~urodna@unaffiliated/urodna) joined #haskell
14:58:50 <Cale> You might also want to start simpler, and just see if you can write the interaction you want on the backend in a more direct way. Where are the changes coming from in your case?
14:58:57 <maralorn> I tried obelisk and was a little put off by it trying to do all work for me, while I didnâ€˜t understand what work needed to be done.
14:59:36 <jackdk> see also: reflex-basic-host: https://github.com/qfpl/reflex-basic-host for a general-purpose host. I'm hoping its 0.2 release will happen soon
14:59:39 <Cale> Obelisk still gives you a way to get back down into Snap and write handlers directly on the backend.
14:59:40 <vaibhavsagar> maralorn: the fastest way to find out is to try using `reflex-platform` yourself
15:00:26 <maralorn> Cale: I guess the easiest way would be to trigger a reload from the underlying database (where also other software could have written to).
15:00:29 <Cale> But for serving the frontend, it sort of takes control of a lot of how that's done
15:00:55 <Cale> maralorn: We've often used postgres' NOTIFY/LISTEN to send ourselves messages
15:01:00 <maralorn> Next step could be to register a hook in the db, that the server is actually informed about changes.
15:01:00 <vaibhavsagar> sounds like you want our extremely new and shiny incremental view stuff
15:01:02 --- join: turab (~turab@2001:18e8:2:28b7:f000::87e) joined #haskell
15:01:26 <Cale> vaibhavsagar: Which sadly isn't quite ready yet
15:01:27 --- quit: o1lo01ol1o (Remote host closed the connection)
15:01:31 <maralorn> vaibhavsagar: Sounds intriguing.^^ Where do I find it?
15:01:37 <Cale> It's not available yet
15:01:41 <maralorn> Okay
15:01:44 --- join: wroathe (~wroathe@23-30-253-203-static.hfc.comcastbusiness.net) joined #haskell
15:01:55 <Cale> But Ryan's working on a way of consuming the postgres writeahead log directly
15:02:19 <maralorn> Well itâ€˜s just about a few todos. So I can probably get away to push all of them through the websocket.
15:02:21 <Cale> and has a first-order but highly concurrent FRP system of sorts for managing that
15:02:37 --- join: durandal1 (~durandal1@2601:647:4900:43:e42f:a574:b596:6c48) joined #haskell
15:02:39 <maralorn> The backend is sadly not postgres but taskwarrior.
15:02:49 --- quit: knupfer (Ping timeout: 264 seconds)
15:02:53 --- join: o1lo01ol1o (~o1lo01ol1@152.80.136.95.rev.vodafone.pt) joined #haskell
15:03:17 --- quit: durandal1 (Remote host closed the connection)
15:03:50 --- quit: evanjs (Quit: Configuring ZNC, sorry for the joins/quits!)
15:04:12 * hackage BlastHTTP 1.4.1 - Libary to interface with the NCBI blast REST interface  https://hackage.haskell.org/package/BlastHTTP-1.4.1 (FlorianEggenhofer)
15:04:33 --- quit: tromp (Remote host closed the connection)
15:06:08 --- join: evanjs (~evanjs@75.129.188.19) joined #haskell
15:06:08 --- quit: wroathe (Read error: Connection reset by peer)
15:06:25 --- quit: t7 (Quit: Konversation terminated!)
15:10:08 --- quit: involans (Quit: involans)
15:10:44 --- quit: linarcx (Ping timeout: 272 seconds)
15:11:17 --- quit: ratherforky (Quit: Leaving)
15:11:29 --- quit: ystael (Ping timeout: 246 seconds)
15:13:19 --- quit: acidjnk ()
15:13:43 * hackage haskell-ci 0.4 - Cabal package script generator for Travis-CI  https://hackage.haskell.org/package/haskell-ci-0.4 (phadej)
15:14:22 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
15:17:28 --- quit: m0rphism1 (Ping timeout: 245 seconds)
15:17:50 --- quit: wildtrees (Remote host closed the connection)
15:17:53 --- join: tromp (~tromp@2a02:a210:1585:3200:7c7e:6916:e395:5fa4) joined #haskell
15:18:53 --- quit: skim_ (Ping timeout: 244 seconds)
15:19:18 <jackdk> man I wish I saw Ryan speak at ZuriHac. Did his talk ever get online?
15:19:39 --- join: knupfer (~Thunderbi@200116b82c8efe00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
15:21:58 --- join: m0rphism1 (~m0rphism@149.172.82.115) joined #haskell
15:22:44 --- quit: turab (Ping timeout: 276 seconds)
15:25:31 --- quit: max00 (Quit: This computer has gone to sleep)
15:25:51 --- join: max00 (~max@216.147.231.246) joined #haskell
15:26:13 --- quit: conal (Quit: Computer has gone to sleep.)
15:28:20 --- quit: m0rphism1 (Ping timeout: 245 seconds)
15:29:07 --- quit: cosimone (Quit: Leaving)
15:29:42 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
15:30:06 --- quit: sfvm (Client Quit)
15:30:12 --- quit: laem (Quit: quit)
15:31:16 --- join: laem (~laem@unaffiliated/laem) joined #haskell
15:31:25 --- join: involans (~involans@cpc108959-cmbg20-2-0-cust162.5-4.cable.virginm.net) joined #haskell
15:31:55 --- join: d6e (~d6e@172.110.5.219) joined #haskell
15:32:04 --- quit: _ashbreeze_ (Remote host closed the connection)
15:33:04 --- quit: deviantfero (Ping timeout: 268 seconds)
15:33:17 --- quit: o1lo01ol1o (Remote host closed the connection)
15:33:56 --- join: _ashbreeze_ (~mark@72-161-51-160.dyn.centurytel.net) joined #haskell
15:34:28 --- quit: jose_zap (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
15:37:06 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
15:37:16 --- quit: sfvm (Client Quit)
15:38:03 --- join: m0rphism1 (~m0rphism@149.172.82.115) joined #haskell
15:39:26 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
15:39:49 --- join: wroathe (~wroathe@63.231.172.103) joined #haskell
15:41:46 --- quit: falafel_ (Ping timeout: 272 seconds)
15:46:03 --- join: skim_ (~zhangzhen@139.215.143.21) joined #haskell
15:48:07 --- quit: knupfer (Remote host closed the connection)
15:48:24 --- join: knupfer (~Thunderbi@200116b82c8efe00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
15:49:20 --- quit: __monty__ (Quit: leaving)
15:49:54 --- quit: Enigmagic (Quit: https://lice.muppetz.com)
15:51:21 --- quit: involans (Quit: involans)
15:53:00 --- quit: crobbins (Remote host closed the connection)
15:53:12 --- join: vinnie (~luca@39.113.253.241) joined #haskell
15:53:35 --- quit: vinnie (K-Lined)
15:53:50 --- quit: sfvm (Quit: off to the basement, mixing up the medicine)
15:56:28 --- quit: fendor (Quit: Leaving)
15:56:57 --- join: teratee (adefc721@173.239.199.33) joined #haskell
15:57:22 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
15:58:02 --- quit: sfvm (Client Quit)
15:59:33 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
15:59:51 <teratee> For straightforward parsing of huge files requiring non-lazy-io, without getting into Snoyman-esque conduits, what are the modern library suggestions equivalent to Parsec and Iteratee?  I noticed those but they seem really old.
16:01:02 --- quit: captjakk_ (Remote host closed the connection)
16:01:09 --- join: titos (~jeremias@61.74.82.46) joined #haskell
16:01:32 --- quit: sfvm (Client Quit)
16:01:42 --- quit: titos (K-Lined)
16:01:50 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
16:03:45 --- quit: pie_ (Ping timeout: 245 seconds)
16:04:03 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
16:05:12 --- quit: sfvm (Client Quit)
16:06:17 --- join: gioyik (~gioyik@152.201.33.118) joined #haskell
16:06:37 --- join: sfvm (~sfvm@37.228.244.135) joined #haskell
16:08:47 <teratee> I found pipes-attoparsec.  I think this is what I'm looking for.
16:08:53 --- quit: heatsink (Ping timeout: 276 seconds)
16:11:11 --- join: involans (~involans@cpc108959-cmbg20-2-0-cust162.5-4.cable.virginm.net) joined #haskell
16:11:21 --- quit: jathan (Quit: WeeChat 2.3)
16:13:03 --- quit: teratee (Remote host closed the connection)
16:15:23 --- quit: blazered_ (Ping timeout: 276 seconds)
16:16:06 --- join: liberiga (~liberiga@gateway/tor-sasl/liberiga) joined #haskell
16:16:42 --- quit: involans (Quit: involans)
16:17:30 --- quit: Myhlamaeus2 (Ping timeout: 245 seconds)
16:18:08 --- join: oliver__ (~Saulzar@121.99.221.201) joined #haskell
16:18:30 --- quit: suppi (Ping timeout: 272 seconds)
16:19:23 --- quit: Saulzar_ (Ping timeout: 246 seconds)
16:19:54 --- quit: aetherfreak (Ping timeout: 248 seconds)
16:20:07 --- join: suppi (~suppi@172.246.241.246) joined #haskell
16:20:16 --- quit: sfvm (Quit: off to the basement, mixing up the medicine)
16:20:56 --- join: aetherfreak (~logan@ak2.becroft.co.nz) joined #haskell
16:21:32 --- join: ebeneser (~berke@121.175.111.116) joined #haskell
16:22:36 --- quit: ebeneser (K-Lined)
16:23:40 --- join: the_true_potato (~the_true_@cpc147822-brnt4-2-0-cust15.4-2.cable.virginm.net) joined #haskell
16:23:45 --- join: ktonga (~quassel@gen-119-17-171-125.ptr4.otw.net.au) joined #haskell
16:24:08 --- quit: Nd-969-m (Ping timeout: 245 seconds)
16:26:15 --- join: Nd-969-m (~nend@109.72.55.146) joined #haskell
16:26:20 --- quit: tromp (Remote host closed the connection)
16:26:52 --- join: Tops2 (~Tobias@dyndsl-091-249-081-091.ewe-ip-backbone.de) joined #haskell
16:28:02 --- join: SciSan (~SciSan@dsl-trebng22-54f93b-101.dhcp.inet.fi) joined #haskell
16:29:08 --- quit: SciSan (Client Quit)
16:33:27 --- quit: max00 (Quit: This computer has gone to sleep)
16:33:43 --- quit: hyperisco (Ping timeout: 245 seconds)
16:37:05 --- quit: skim_ (Ping timeout: 245 seconds)
16:37:49 --- quit: u0_a144 (Ping timeout: 268 seconds)
16:40:00 --- quit: rruizt (Ping timeout: 245 seconds)
16:40:00 --- join: slack1256 (~slack1256@190-22-192-102.baf.movistar.cl) joined #haskell
16:40:43 --- join: max00 (~max@216.147.231.246) joined #haskell
16:41:33 --- quit: brandly (Ping timeout: 244 seconds)
16:42:32 --- join: rruizt (~rruizt@83-84-23-124.cable.dynamic.v4.ziggo.nl) joined #haskell
16:44:08 --- quit: the_true_potato (Ping timeout: 244 seconds)
16:44:38 --- join: plutoniix (~q@175.176.222.7) joined #haskell
16:45:54 --- join: falafel_ (~falafel@static-176-185-149-136.axione.abo.bbox.fr) joined #haskell
16:48:43 --- quit: max00 (Quit: This computer has gone to sleep)
16:50:13 --- quit: thc202 (Ping timeout: 264 seconds)
16:53:12 --- join: max00 (~max@216.147.231.246) joined #haskell
16:55:05 --- quit: freeman42x]NixOS (Ping timeout: 268 seconds)
16:55:19 --- quit: carif (Remote host closed the connection)
16:55:40 --- quit: milanj_ (Quit: Leaving)
16:56:07 --- join: danso (~dan@162.246.218.202) joined #haskell
16:57:30 --- join: sevensidedmarble (~marble@2601:402:500:53fc:9eb6:d0ff:fef3:3667) joined #haskell
16:58:12 --- join: phreedom (~quassel@gateway/tor-sasl/phreedom) joined #haskell
16:59:23 --- join: tromp (~tromp@2a02:a210:1585:3200:7c7e:6916:e395:5fa4) joined #haskell
16:59:34 --- quit: Insanity_ (Quit: Connection closed for inactivity)
17:00:23 --- quit: solirc ()
17:02:22 --- join: the_true_potato (~the_true_@cpc147822-brnt4-2-0-cust15.4-2.cable.virginm.net) joined #haskell
17:03:27 --- quit: max00 (Quit: This computer has gone to sleep)
17:03:45 --- quit: tromp (Ping timeout: 252 seconds)
17:04:04 --- quit: cybai (Remote host closed the connection)
17:05:17 --- join: heatsink (~heatsink@2600:1700:bef1:5e10:846f:c01b:9350:6e16) joined #haskell
17:05:50 --- join: egsp (~majortom@167.250.232.81) joined #haskell
17:06:46 --- join: max00 (~max@216.147.231.246) joined #haskell
17:07:38 --- join: Jeanne-Kamikaze (~Jeanne-Ka@c-73-158-52-126.hsd1.ca.comcast.net) joined #haskell
17:09:59 --- quit: heatsink (Ping timeout: 276 seconds)
17:12:05 --- quit: srhb (Ping timeout: 245 seconds)
17:12:23 --- join: srhb (~sarah@194.61.211.130.bc.googleusercontent.com) joined #haskell
17:13:45 --- quit: rodgzilla (Ping timeout: 245 seconds)
17:14:13 --- quit: knupfer (Ping timeout: 264 seconds)
17:14:56 --- join: rodgzilla (~rodgzilla@46.212.195.35.bc.googleusercontent.com) joined #haskell
17:15:06 --- quit: dddddd (Read error: Connection reset by peer)
17:16:28 --- quit: gioyik (Quit: WeeChat 2.5)
17:17:39 --- join: paulk-collins (~paulk-col@185.204.1.185) joined #haskell
17:17:47 --- quit: max00 (Quit: This computer has gone to sleep)
17:18:22 --- join: max00 (~max@216.147.231.246) joined #haskell
17:20:39 --- quit: xkapastel (Quit: Connection closed for inactivity)
17:20:44 --- quit: scinawa (Quit: WeeChat 1.6)
17:23:28 --- join: cybai (~cybai@2400:4050:3122:900:2186:ed02:2c89:2ba1) joined #haskell
17:24:18 --- quit: cybai (Remote host closed the connection)
17:25:18 --- quit: jwynn6 (Ping timeout: 268 seconds)
17:28:20 --- quit: m0rphism1 (Ping timeout: 245 seconds)
17:28:27 --- quit: pfurla (Quit: Textual IRC Client: www.textualapp.com)
17:29:33 --- quit: jeltsch (Ping timeout: 250 seconds)
17:32:39 --- join: xkapastel (uid17782@gateway/web/irccloud.com/x-vsipkuhzfxlqniop) joined #haskell
17:33:02 --- quit: replay (Quit: Textual IRC Client: www.textualapp.com)
17:34:34 --- quit: imtravis (Ping timeout: 248 seconds)
17:36:02 --- quit: the_true_potato (Remote host closed the connection)
17:36:10 --- quit: wroathe (Ping timeout: 248 seconds)
17:37:44 --- join: turab (~turab@2001:18e8:2:28b7:f000::87e) joined #haskell
17:38:51 --- join: pfurla (~pfurla@104.36.2.146) joined #haskell
17:39:09 --- join: ziyourenxiang_ (~ziyourenx@unaffiliated/ziyourenxiang) joined #haskell
17:41:30 --- join: cybai (~cybai@210.160.37.90) joined #haskell
17:41:37 --- join: wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) joined #haskell
17:43:16 --- quit: pera (Quit: leaving)
17:43:21 --- quit: pfurla (Client Quit)
17:44:29 --- join: YongJoon (~Thunderbi@121.67.187.140) joined #haskell
17:44:57 --- join: Gigabitten (~Somn@host-174-45-175-82.chy-wy.client.bresnan.net) joined #haskell
17:45:46 --- quit: cybai (Ping timeout: 248 seconds)
17:47:57 --- join: skim_ (~zhangzhen@114.242.122.150) joined #haskell
17:48:50 --- join: mud (~mud@unaffiliated/kadoban) joined #haskell
17:50:00 --- quit: wroathe (Ping timeout: 245 seconds)
17:50:00 --- join: teardown (~user@unaffiliated/mrush) joined #haskell
17:50:20 --- quit: machinedgod (Ping timeout: 272 seconds)
17:50:29 --- quit: nineonin_ (Remote host closed the connection)
17:50:37 --- join: afk (~afk@219.143.170.137) joined #haskell
17:50:43 --- quit: jchia (Quit: Leaving.)
17:51:26 --- join: knupfer (~Thunderbi@200116b82c9d3a00f69634fffef0b45f.dip.versatel-1u1.de) joined #haskell
17:52:28 --- join: eiGHttt (~eiGHttt@115.231.100.106) joined #haskell
17:53:23 --- quit: max00 (Quit: Leaving)
17:54:05 --- quit: afk (Client Quit)
17:56:03 --- quit: boxscape (Remote host closed the connection)
17:56:25 --- quit: Guest63612 (Changing host)
17:56:25 --- join: Guest63612 (kadobanmat@unaffiliated/kadoban) joined #haskell
17:56:25 --- quit: Guest63612 (Changing host)
17:56:25 --- join: Guest63612 (kadobanmat@gateway/shell/matrix.org/x-vbmeihebjaprmcty) joined #haskell
17:56:41 --- join: pfurla (~pfurla@104.36.2.146) joined #haskell
17:56:47 --- join: pipqw (~pqzx@unaffiliated/pqzx) joined #haskell
17:57:38 --- quit: Gigabitten (Remote host closed the connection)
17:57:47 --- join: jsomedon (~jsomedon@114.252.43.193) joined #haskell
18:00:09 --- quit: mud (Quit: bye)
18:01:28 --- quit: vicfred (Quit: Leaving)
18:04:35 --- quit: solonarv (Ping timeout: 245 seconds)
18:05:47 --- join: cabpa (~cabpa@110.54.200.162) joined #haskell
18:08:13 --- join: Involuntary (~Jeanne-Ka@193.148.18.251) joined #haskell
18:08:28 --- join: nineonine (~nineonine@216-19-190-182.dyn.novuscom.net) joined #haskell
18:09:08 --- quit: turab (Ping timeout: 276 seconds)
18:09:28 --- join: blankhart (~blankhart@pool-100-35-219-3.nwrknj.fios.verizon.net) joined #haskell
18:09:31 --- join: cybai (~cybai@240d:1b:42:7800:2cd8:ed7:bb4f:8372) joined #haskell
18:10:41 --- quit: Jeanne-Kamikaze (Ping timeout: 246 seconds)
18:10:50 --- join: jusss (~user@unaffiliated/jusss) joined #haskell
18:11:45 --- join: pie_ (~pie_@unaffiliated/pie-/x-0787662) joined #haskell
18:13:24 --- quit: nineonine (Ping timeout: 268 seconds)
18:16:46 --- quit: Tops2 (Read error: Connection reset by peer)
18:18:46 --- join: conal (~conal@209.58.135.97) joined #haskell
18:19:56 --- quit: conal (Remote host closed the connection)
18:20:35 --- join: conal (~conal@209.58.135.97) joined #haskell
18:20:53 --- join: mdunnio (~mdunnio@208.59.170.5) joined #haskell
18:22:47 --- quit: cabpa (Remote host closed the connection)
18:24:42 --- quit: doublex (Ping timeout: 248 seconds)
18:24:44 --- join: Gurkenglas (~Gurkengla@unaffiliated/gurkenglas) joined #haskell
18:27:15 --- quit: Deide (Quit: Seeee yaaaa)
18:28:16 --- join: darjeeling_ (~darjeelin@115.215.40.230) joined #haskell
18:30:54 --- join: tromp (~tromp@2a02:a210:1585:3200:7c7e:6916:e395:5fa4) joined #haskell
18:31:30 --- join: sveit (~sveit@2001:19f0:ac01:247:5400:ff:fe5c:689f) joined #haskell
18:32:01 --- join: simplegauss (~simplegau@2001:19f0:ac01:247:5400:ff:fe5c:689f) joined #haskell
18:33:03 --- join: freeman42x[m]2 (~freeman42@89.137.217.223) joined #haskell
18:33:56 --- join: jwynn6 (~justin@50.88.122.78) joined #haskell
18:34:57 --- join: turab (~turab@2001:18e8:2:28b7:f000::87e) joined #haskell
18:35:47 --- quit: tromp (Ping timeout: 276 seconds)
18:36:14 --- join: fphilipe_ (~phil@81.6.34.65) joined #haskell
18:36:17 --- join: Silent_Alex (~Alex@205.175.205.243) joined #haskell
18:37:59 --- quit: lambda-11235 (Quit: Bye)
18:38:43 --- quit: fphilipe (Ping timeout: 252 seconds)
18:44:30 --- join: sword865 (uid208942@gateway/web/irccloud.com/x-ourldyrivdsthbzj) joined #haskell
18:44:49 --- join: doublex (~doublex@c-73-117-99-12.hsd1.oh.comcast.net) joined #haskell
18:49:25 --- quit: danso (Quit: WeeChat 2.5)
18:51:38 --- quit: falafel_ (Ping timeout: 268 seconds)
18:52:07 --- join: athan (~athan@cpe-66-27-187-50.dc.res.rr.com) joined #haskell
18:52:23 --- join: Sgeo (~Sgeo@ool-18b98995.dyn.optonline.net) joined #haskell
18:54:10 --- quit: Sgeo_ (Ping timeout: 245 seconds)
18:54:12 * hackage hpack 0.32.0 - A modern format for Haskell packages  https://hackage.haskell.org/package/hpack-0.32.0 (SimonHengel)
18:57:40 --- join: alleyn (~leonerd@211.221.86.67) joined #haskell
18:58:39 --- quit: urodna (Quit: urodna)
18:59:35 --- quit: polman (Ping timeout: 245 seconds)
