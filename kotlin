#clear ByteArray

```
var aob = ByteArray(1024)
while (true) {
  try{
  size = client.inputStream.read(aob)
  }catch(e:Exception){
     client.close()
     client = re_connect_network()
   }
  recvMsg = String(aob.sliceArray(0 until size), Charsets.UTF_8)
  if recvMsg.contains(“something”) doSomthing
  ...
}
```
that’s how I handle it, but when the connection is disconnected without an exit signal, so this try-catch will work and make a new connection, but the last received recvMsg will still go through those next if-else, so that’s I wonder if there’s a way can clear aob the ByteArray?
also I find a way to solve this, just set size to 0, so sliceArray will not work, this can avoid those next if-else

It probably makes more sense to just throw away the old array and allocate a new one in the `catch` block: `aob = ByteArray(1024)`. It's likely that the overhead of the exception is far higher than the cost of re-allocating an array, and also zeroing an existing array in code might actually be slower.

//////////////////////////////////
it's AD 9102, java/kotlin not yet implemnet something like a=[1,2] or b={"a":1}
not even decorator, generator, and list comprehension, 
not even special stuff like macro and continuation in lisp, pattern matching in haskell
promise in js, future in python, I wonder why java/kotlin stay on 90's
//////////////////////////
instance variable
class T {
    fun gv(){
        val t = someClass or Method call
        return t
    }
    val t = gv()
    fun gv2(){
        print(t)
    }
}
///////////////
alist = []
class T:
    def __init__(self):
        alist.append(self)

fun main(){
    val allFoos = mutableListOf<Any>()
    class Foo{

        init{
            allFoos += this
        }
    }
}

java version

public class User(){
        public User(){
            Test2.list.add(this);
        }
}
 when User t = new User(), t will be stored in Test2.list

this case in python is used to handle websocket,
every new coming client will store to a global list,
so we can send messages to all the client
///////////////////////////////

class MyClass constructor(name: String) { var siteName = name }
this constructor (){ } is the primary constructor

constructor () {} inside the primary constructor is the secondary constructor

class MyClass constructor(){
    constructor(){
    }
}

instantiate with which constructor, with different parameters

var a:Array<Any> = arrayOf(1,"2")
a[1] is String
a[0] is Int

is equal isinstance in python

a += 3

////////////////////////////////////////////////

https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000156824-How-to-choose-main-class
https://stackoverflow.com/question/43307532/auto-errors-detection-in-intellij-idea/43319356#43319356
when you click `run` and it always pop up configuration, it's 'cause your `src` directory is not configured
as `Sources root`, and `src` is grey not blue, right click on `src` and set it as `Sources root`,
then you can run it normally

//////////////////////////////////////////////////////

the type is the class, the class is the type  in kotlin also python
the instance is the value, the value is the instance 

class Box<T>   Box is the type constructor, and T is the type variable like Maybe a

fun <T> f(x: Box<T>)  this x is an intance of class Box<T>, and its type is Box<T>, f's result type is <T>

/////////////////////////////////////////////////////

// update UI in coroutines, without runOnUiThread in Thread

package com.example.myapplicationpp

import android.support.v7.app.AppCompatActivity
import android.os.Bundle
import android.support.v7.app.AppCompatViewInflater
import android.view.View
import android.widget.TextView
import android.widget.Toast
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import org.w3c.dom.Text

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)


    }

    fun test(view: View) {
        GlobalScope.launch {
            withContext(Dispatchers.Main) {
                val im = findViewById<TextView>(R.id.text1)
                im.text = "what".toString()

            }

        }
    }
}


///////////////////////////////////////////////////////////

sudo pacman -S intellij-idea-community-edition
then run `idea`
it can install android plugin

1. click run, pop up configuration, no module, install gradle
2. v7 not resloved, classpath not resolved android.support.v7.app.compat whatever
https://stackoverflow.com/questions/18025942/how-do-i-add-a-library-android-support-v7-appcompat-in-intellij-idea/18026612#18026612
make sure you sdk api is installed, like api 27, and your project is android, 5.0 make it relate with the right api level,
and then in build.gradle's dependencies 
    
    compile 'com.android.support:appcompat-v7:+'

or

implementation 'com.android.support:appcompat-v7:27.1.1'

I. create a new project with android 5.0 api 21
II. make sure api 21 is fully insstalled, not patially installed
III. in MyApplication/app/build.gradle
dependencies{
    implementation 'com.android.support:appcompat-v7:+'
}
      

/////////////////////////

kotlinx.coroutines

// don't need the result
GlobalScope.launch {
    delay(1000)
    ...
}

// need the result
// async {} will return an instance of Deferred<T>, which has an await() function that returns the result of the coroutine

val deferred = GlobalScope.async { ... }
val sum = deferred.await()





//////////////////////////////////////

kotlinc is a repl on linux

jvm, javascript and native

val a: String = "Kotlin"   like const in js, short for value, final in java, immutable
var a: String = "Kotlin"  like a variable in other languages, share state

or val a = "Kotlin"  type inference

val a: Int
a=1

val sum: (Int) -> Int
sum = {x->x+1}

fun sum(x: Int, y: Int): Int { return x+y}

fun sum(x:Int, y:Int) = x+y

fun sum(x:Int, y:Int): Int = x+y

val sum: (Int,Int) ->Int = {x:Int, y:Int -> x+y}

val sum = {x:Int, y:Int -> x+y}

val sum: (Int, Int) -> Int = { x,y -> x+y}

"it seems only FP languages use = to define functions, Haskell and Kotlin use it,
but python doesn't, even js use it, and math use it"

test: (Country) -> Boolean

kotlin's parameter must be contain by (), and (a,b) is two parameters, not a tuple
test: (a,b) -> c   
equal to
test :: a->b->c  in haskell
but test :: (a,b) -> c  this (a,b) is a tuple in haskell

(a) -> ((a) -> Unit)  equal (a) -> a -> Unit    return a function

((a) -> a) -> Unit pass a function, just remember that contain by () is parameter

class method, class-name::method


val sum: (Int, Int) -> Int = { x,y -> x+y}
val sum: (Int) -> (Int) -> Int = { x -> {y -> x+y }}
fun sum(x:Int): (Int)-> Int = {y -> (x+y)}

fun schedule(sunny: Boolean, day: Day) = when (day) {
Day.SAT -> basketball()
else -> when {
    sunny -> library()
    else -> study()
    }
}


fun schedule(sunny: Boolean, day: Day) = when {
    day == Day.SAT -> basketball()
    sunny -> library()
    else -> study()
}

for (i in 1..10) println (i)

class Person{
    infix fun called(name:String) {
        println("my name is ${name}")
    }
}

val p = Persion()
p called "Shaw"

same as p.called("Shaw")

native string  (from python?)

val html = """ <html>
                    <body>
                        <p> Hello </p>
                    </body>
                </html>
            """

${ } can eval something in a string

== compare values
=== compare references

class Bird {
    val weight: Double = 500.0
    fun fly() {}
}

interface Flyer {
    val speed: Int
    fun kind()
    fun fly() {
        println("I can fly")
    }
    val height
        get() = 1000  // same like @property @abstractmethod f
}

val bird = Bird()
val bird = Bird(weight = 1000.0)

class Bird{
    weight: Double = 0.00
    val weight: Double
    init{
        this.weight=weight
    }
}

I think to use "package filename" in the filename.kt is for make this file as a module
that it can be other file import, and python doesn't have this because python has already
take files as modules by default

fun Bird(birth: DataTime) = Bird(getAgeByBirth(birth))

open class Bird {
    open fun fly() {
    }
}

class Pengui: Bird() {
    override fun fly() {
    }
}
    
use : to inherent, and you must use open to make it inherentable

final in java is default to use for kotlin, prevent inherent
another is sealed keyword
