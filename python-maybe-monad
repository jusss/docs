Java use null as failed IO computation, it's very good for Maybe 
Maybe(x) // \x -> xxx null failed //
just use lambda to wrap null, it no need to check if it's null every time
in haskell you have to check value and return Nothing, in python return None

bind is an advanced version fmap which can do if-else
Nothing <$> f = Nothing
Just a <$> f = Just (f a)

but bind can do more, not just detect Nothing, it can detect a specific Just a and
return Nothing

class Maybe:
    def __init__(self,a):
        self.a = a
    def fmap(self,ab):
        if self.a is None:
            return None
        else:
            return Maybe(ab(self.a))
    def ap(self, mamb):
        if self.a is None:
            return None
        else:
            return mamb(self.a)
    def bind(self, amb):
        if self.a is None:
            return None
        else:
            return amb(self.a)
    def from_maybe(self):
        return self.a

    
respone = request.post(...)
Maybe(respone.json())
    .fmap(lambda x: x.method())
    .bind(lambda x: None if x == "" else Maybe(doSometing(x)))
    .bind(lambda x: Maybe(doSometing(x)).bind(lambda y: Maybe(x+y)))
    .from_maybe()

----------------------------
bind x y = if x/= None then y x else None 
bind dict.get("a",None) \x -> you can use x or don't use x or x.method()
this avoid if xxx: if xxx: if xxx:
use object(x).bind(y).bind(z) implement infix expression
avoid bind(bind(x,y),z)
object(x) // y // z, python operator
toolz can do curry and compose

class Maybe:
    def __init__(self,x):
        self.x = x
    def __floordiv__(self,f):
        if (self.x == None):
            return Maybe(None)
        return Maybe(f(self.x))
    def fromMaybe(self):
        return self.x

maybe = Maybe(a_dict.get(key, None)) // (lambda v: use_v_or_not) // lambda v: v.method()
maybe.fromMaybe()

a < b     __lt__(a,b)
a <= b    __le__(a,b)
a == b   __eq__
!=      __ne__
>      __gt__
>=     __ge__
not    __not__
True   truth
is     is_
is not is_not
+  __add__
//     __floordiv__
~      __invert__
<<     __lshift__
%      __mod__
*      __mul__
@      __matmul__
-      __neg__
|      __or__
**     __pow__
>>     __rshift__
-      __sub__
/      __truediv__
^      __xor__
in     __contains__
&      __and__
