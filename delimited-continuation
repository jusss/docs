
continuation：接下来要做的所有的 or 接下来要做的一切 or 接下来所有要做的 or what the next to do
delimited continuation：接下来要做的所有的中的一部分要做的 or 接下来所有要做的中的一部分要做的 or a piece of what the next to do

scheme@(guile-user) [1]> (use-modules (ice-9 control))
scheme@(guile-user) [1]> (+ 1 (call/cc (lambda (k1)
				     (k1 (reset (+ 2 (shift k2 (k2 3))))))))
$3 = 6

捕捉(reset 到 (shift 之间的表达式做continuation. 这个continuation叫delimited continuation, 或者composable continuation

因为reset限定了界限,所以即使再次调用k也不会执行reset后面的表达式，而call/cc则会执行call/cc后面的表达式

scheme@(guile-user) [1]> (+ 1 (reset (+ 2 (shift k (begin (set! a k) (k 3))))))
$10 = 6
scheme@(guile-user) [1]> (a 3)
$11 = 5
当调用(a 3) reset后面那个+1不再求值 但call/cc会求值
reset至shift的那个continuation第一次会正常求值并把continuation的返回值作为(reset …)的返回值返回给后面，并执行reset后面的表达式，但第二次再调
用这个continuation时，reset后面的表达式就不再执行，而call/cc会依旧执行call/cc后面的，因为call/cc后面的表达式就是continuation，所以每次调
用call/cc的continuation就每次执行call/cc后面的表达式，这就是full continuation call/cc和 delimited continuation reset/shift的区别，一个捕捉
call/cc后面所有的表达式作continuation 一个捕捉reset-shift这一段的表达式做continuation 即使再调用也只执行这一段的表达式,这就是delimited continuation
,而call/cc捕捉了call/cc后面所有的表达式，再调用会执行call/cc后面所有的表达式,这就是full continuation.

call/cc把call/cc后面的表达式到再次调用continuation这中间的表达式全部捕捉做continuation，所以会形成循环loop
而reset-shift则只捕捉reset到shift的表达式作continuation，所以在reset后面再次调用continuation则只会执行reset里面的表达式，而不会再执行reset后面到再次调
用continuation这中间的表达式

(reset ((lambda (m) ...) (shift k (begin (set! a k) (k 5))))) 从reset到shift的整个lambda是continuation 而参数m是continuation所需要的参数而不是continuation
,k才是continuation, (k 5)返回continuation所需的参数，这才是m
而call/cc后面的所有表达式才是continuation,而call/cc的返回值即为continuation所需的参数, k为continuation, (k 5)为continuation所需的参数也为call/cc的返回值
而在reset shift中k为continuation而(k 5)为continuation所需的参数，这个continuation的返回值作为reset的返回值

-----------------------------------------------------------------------------------
call/cc coroutines

scheme@(guile-user)> (define b (lambda (x)
				 (display "2")
				 (set! x (call/cc x))
				 (display "4")
				 (call/cc x )))
scheme@(guile-user)> (define a (lambda (x)
				 (display "1")
				 (set! x (call/cc x))
				 (display "3")
				 (call/cc x)
				 (display "5")))
scheme@(guile-user)> (a b)
12345scheme@(guile-user)>

-----------------------------------------------------------------------------------
reset-shift coroutines

scheme@(guile-user)> (define a (lambda (x)
				 (display 1)
				 (reset ((lambda (x)
					   (display 3)
					   (reset ((lambda (x)
						     (display 5))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (define b (lambda (x)
				 (display 2)
				 (reset ((lambda (x)
					   (display 4)
					   (reset ((lambda (x)
						     (display 6))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (a b)
12345scheme@(guile-user)> (define a (lambda (x)
				 (display 1)
				 (reset ((lambda (x)
					   (display 3)
					   (reset ((lambda (x)
						     (display 5)
						     (x 0))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (a b)
123456scheme@(guile-user)>

在call/cc里k是未执行的, 在shift里k是未执行的
先执行call/cc里面的, 再执行call/cc外面的
先执行shift里面的, 再执行reset到shift之间的

real trick at the current position (another-k current-k) jump to another-k with current-k for jump back into the current position
在当前位置(another-continuation current-continuation)这样带着当前continuation跳到another-continuation之后，还可以在那边调用current-continuation再跳回
当前位置



绑定continuation但不求值

(reset ((lambda (x) (display 0)) (shift k (set! lk k))))
先执行shift里面的再执行reset-shift之间的
想要绑定continuation时不求值continuation, 就可以按上面这种做
因为先执行shift，而shift里没有调用(k whatever)去求值 reset-shift之间的continuation,
所以就绑定了continuation但没有求值continuation，不求值reset-shift之间的continuation但会求值shift里面的表达式

call/cc先执行call/cc里面的再执行call/cc后面的
call/cc里面除非有(k another-k)跳转可以导致后面的continuation无法求值，否则的话后面的continuation总会被求值.就像reset后面的总会被求值一样


call/cc里面的 相当于 shift里面的
call/cc外面的 相当于 reset 到 shift 之间的，但同时又可以相当于reset后面的，因为reset后面的总会被求值，因为执行完reset就会求值reset后面的because of求值顺序，而由于求值顺序导致call/cc后面也总会被求值,
call/cc后面的即是continuation又是按求值顺序接下来要求值的，所以总会被求值除非在call/cc里面调用别的continuation, 如果不求值后面的,到call/cc这就结束了

0scheme@(guile-user)> (define biu 
			(lambda ()
			  (define bs 0)
			  (call/cc (lambda (k)
				     (set! bs k)))
			  (display 0)))
scheme@(guile-user)> (biu)
0scheme@(guile-user)> (define miu
			(lambda ()
			  (define bs 0)
			  (reset ((lambda (x) (display 0)) (shift k (set! bs k))))))
scheme@(guile-user)> (miu)
scheme@(guile-user)> (miu)



call/cc 里面的总会执行，里面的返回值为call/cc的返回值
reset-shift中(shift k k)将把k作为reset的返回值，不执行reset里面的continuation，因为没调用k在shift中，(shift k (k k)) reset里面的continuation将执行

call/cc捕捉call/cc开始至结尾的表达式为continuation,
而reset只捕捉reset至shift之间的表达式做continuation
reset-shift捕捉的k在(k x)调用之后，会继续执行(k x)之后的表达式

(define bla
  (lambda ()
    (define k1 0)
    (reset ((lambda (x)
	      (display 1))
	    (shift k (set! k1 k))))
    (display 2)
    (k1 3)
    (display 5)))

(bla) => 215

reset-shift的k在(k x)调用之后继续(k x)之后的表达式

执行到call/cc或reset-shift就捕捉k存到栈上，并执行call/cc里面的和shift里面的表达式,然后
执行call/cc和reset后面的表达式，执行到再次调用k时(k x)，跳回栈上执行保存的动作，执行完了
，继续执行(k x)之后的表达式

reset-shfit捕捉到k只要在shift里面不用(k x)调用k，第一次捕捉时就不会被执行
但call/cc捕捉的k第一次捕捉时总会被执行，因为call/cc后面的表达式总会被求值，而call/cc后面的表达式又恰好是k, call/cc里面的总会被求值，后面的也总会被求值

shift里面的相当于call/cc里面的
shift外面的至reset里面的，加上reset后面的，才相当于call/cc后面的,因为call/cc后面的即为k且又为接下来要执行的，而reset后面的才为接下来要执行的，reset里面的为k

