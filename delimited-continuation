
continuation：接下来要做的所有的 or 接下来要做的一切 or 接下来所有要做的 or what the next to do
delimited continuation：接下来要做的所有的中的一部分要做的 or 接下来所有要做的中的一部分要做的 or a piece of what the next to do

scheme@(guile-user) [1]> (use-modules (ice-9 control))
scheme@(guile-user) [1]> (+ 1 (call/cc (lambda (k1)
				     (k1 (reset (+ 2 (shift k2 (k2 3))))))))
$3 = 6

捕捉(reset 到 (shift 之间的表达式做continuation. 这个continuation叫delimited continuation, 或者composable continuation

因为reset限定了界限,所以即使再次调用k也不会执行reset后面的表达式，而call/cc则会执行call/cc后面的表达式

scheme@(guile-user) [1]> (+ 1 (reset (+ 2 (shift k (begin (set! a k) (k 3))))))
$10 = 6
scheme@(guile-user) [1]> (a 3)
$11 = 5
当调用(a 3) reset后面那个+1不再求值 但call/cc会求值
reset至shift的那个continuation第一次会正常求值并把continuation的返回值作为(reset …)的返回值返回给后面，并执行reset后面的表达式，但第二次再调
用这个continuation时，reset后面的表达式就不再执行，而call/cc会依旧执行call/cc后面的，因为call/cc后面的表达式就是continuation，所以每次调
用call/cc的continuation就每次执行call/cc后面的表达式，这就是full continuation call/cc和 delimited continuation reset/shift的区别，一个捕捉
call/cc后面所有的表达式作continuation 一个捕捉reset-shift这一段的表达式做continuation 即使再调用也只执行这一段的表达式,这就是delimited continuation
,而call/cc捕捉了call/cc后面所有的表达式，再调用会执行call/cc后面所有的表达式,这就是full continuation.

call/cc把call/cc后面的表达式到再次调用continuation这中间的表达式全部捕捉做continuation，所以会形成循环loop
而reset-shift则只捕捉reset到shift的表达式作continuation，所以在reset后面再次调用continuation则只会执行reset里面的表达式，而不会再执行reset后面到再次调
用continuation这中间的表达式

(reset ((lambda (m) ...) (shift k (begin (set! a k) (k 5))))) 从reset到shift的整个lambda是continuation 而参数m是continuation所需要的参数而不是continuation
,k才是continuation, (k 5)返回continuation所需的参数，这才是m
而call/cc后面的所有表达式才是continuation,而call/cc的返回值即为continuation所需的参数, k为continuation, (k 5)为continuation所需的参数也为call/cc的返回值
而在reset shift中k为continuation而(k 5)为continuation所需的参数，这个continuation的返回值作为reset的返回值

-----------------------------------------------------------------------------------
call/cc coroutines

scheme@(guile-user)> (define b (lambda (x)
				 (display "2")
				 (set! x (call/cc x))
				 (display "4")
				 (call/cc x )))
scheme@(guile-user)> (define a (lambda (x)
				 (display "1")
				 (set! x (call/cc x))
				 (display "3")
				 (call/cc x)
				 (display "5")))
scheme@(guile-user)> (a b)
12345scheme@(guile-user)>

-----------------------------------------------------------------------------------
reset-shift coroutines

scheme@(guile-user)> (define a (lambda (x)
				 (display 1)
				 (reset ((lambda (x)
					   (display 3)
					   (reset ((lambda (x)
						     (display 5))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (define b (lambda (x)
				 (display 2)
				 (reset ((lambda (x)
					   (display 4)
					   (reset ((lambda (x)
						     (display 6))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (a b)
12345scheme@(guile-user)> (define a (lambda (x)
				 (display 1)
				 (reset ((lambda (x)
					   (display 3)
					   (reset ((lambda (x)
						     (display 5)
						     (x 0))
						   (shift k (x k)))))
					 (shift k (x k))))))
scheme@(guile-user)> (a b)
123456scheme@(guile-user)>

在call/cc里k是未执行的, 在shift里k是未执行的
先执行call/cc里面的, 再执行call/cc外面的
先执行shift里面的, 再执行reset到shift之间的

