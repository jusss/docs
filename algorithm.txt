19. 5 kyu Longest Common Subsequence
Write a function called LCS that accepts two sequences and returns the longest subsequence common to the passed in sequences.

Subsequence
A subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.

Example subsequence
Subsequences of "abc" = "a", "b", "c", "ab", "ac", "bc" and "abc".

LCS examples
lcs "a"         "b"         `shouldBe` ""
lcs "abcdef"    "abc"       `shouldBe` "abc"
lcs "132535365" "123456789" `shouldBe` "12356"
Notes
Both arguments will be strings
Return value must be a string
Return an empty string if there exists no common subsequence
Both arguments will have one or more characters (in JavaScript)
All tests will only have a single longest common subsequence. Don't worry about cases such as LCS( "1234", "3412" ), which would have two possible longest common subsequences: "12" and "34".
Note that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.

module LongestCommonSubsequence where
import Data.List
lcs :: String -> String -> String
lcs x y = (nub y) `intersect` (nub x)
-- lcs x y = maximum ((inits x) `intersect` (inits y))

---------------------------------------------------------
18. 6 kyu Simple Encryption #1 - Alternating Split
For building the encrypted string:
Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.
Do this n times!

Examples:

"This is a test!", 1 -> "hsi  etTi sats!"
"This is a test!", 2 -> "hsi  etTi sats!" -> "s eT ashi tist!"
Write two methods:

string Encrypt(string text, int n)
string Decrypt(string encryptedText, int n)
For both methods:
If the input-string is null or empty return exactly this value!
If n is <= 0 then return the input text.

This kata is part of the Simple Encryption Series:
Simple Encryption #1 - Alternating Split
Simple Encryption #2 - Index-Difference
Simple Encryption #3 - Turn The Bits Around
Simple Encryption #4 - Qwerty

Have fun coding it and please don't forget to vote and rank this kata! :-)

module AlternateSplit.JorgeVS.Kata where
import Data.List
-- import Data.Semigroup

encrypt :: String -> Int -> String
encrypt x n =
 if (x == "") then ""
 else if n <= 0 then x
 else encrypt (f2 x) (n - 1)

decrypt :: String -> Int -> String
decrypt x n =
 if x == "" then ""
 else if n <= 0 then x
 else decrypt (f2r x) (n - 1)


-- just [1,2,3,4,5,6] to [2,4,6,1,3,5]
-- "This is a test!", 2 -> "hsi  etTi sats!" -> "s eT ashi tist!"
-- f2 [0,1,2,3,4] == [1,3,0,2,4]
ttl (a,b) = [a,b]
f2r x = (mconcat . fmap reverse . transpose . ttl . splitAt (div (length x) 2)) x

-- f x = (fmap (x !!) [1,3..(length x)]) (<>) (fmap (x !!) [0,2..(length x)])
f2 x = map snd . uncurry (++) . partition (odd . fst) . zip [0..] $ x
-- f3 x = (mconcat . transpose . chunksOf 2) x
-------------------------------------------------------------------------------------------
17. 6 kyu Decode the Morse code
In this kata you have to write a simple Morse code decoder. While the Morse code is now mostly superceded by voice and digital data communication channels, it still has its use in some applications around the world.
The Morse code encodes every character as a sequence of "dots" and "dashes". For example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The Morse code is case-insensitive, traditionally capital letters are used. When the message is written in Morse code, a single space is used to separate the character codes and 3 spaces are used to separate words. For example, the message HEY JUDE in Morse code is ···· · −·−−   ·−−− ··− −·· ·.

NOTE: Extra spaces before or after the code have no meaning and should be ignored.

In addition to letters, digits and some punctuation, there are some special service codes, the most notorious of those is the international distress signal SOS (that was first issued by Titanic), that is coded as ···−−−···. These special codes are treated as single special characters, and usually are transmitted as separate words.

Your task is to implement a function that would take the morse code as input and return a decoded human-readable string.

For example:

decodeMorse ".... . -.--   .--- ..- -.. ."
--should return "HEY JUDE"
NOTE: For coding purposes you have to use ASCII characters . and -, not Unicode characters.

The Morse code table is preloaded for you as a dictionary, feel free to use it:

Coffeescript/C++/Go/JavaScript/PHP/Python/Ruby/TypeScript: MORSE_CODE['.--']
C#: MorseCode.Get(".--") (returns string)
Elixir: @morse_codes variable (from use MorseCode.Constants). Ignore the unused variable warning for morse_codes because it's no longer used and kept only for old solutions.
Elm: MorseCodes.get : Dict String String
Haskell: morseCodes ! ".--" (Codes are in a Map String String)
Java: MorseCode.get(".--")
Kotlin: MorseCode[".--"] ?: "" or MorseCode.getOrDefault(".--", "")
Rust: self.morse_code
Scala: morseCodes(".--")
C: provides parallel arrays, i.e. morse[2] == "-.-" for ascii[2] == "C"
All the test strings would contain valid Morse code, so you may skip checking for errors and exceptions. In C#, tests will fail if the solution code throws an exception, please keep that in mind. This is mostly because otherwise the engine would simply ignore the tests, resulting in a "valid" solution.

Good luck!

After you complete this kata, you may try yourself at Decode the Morse code, advanced.

module Codewars.Kata.DecodeMorse (decodeMorse) where
import Data.List.Split
import Data.List
import Codewars.Kata.DecodeMorse.Preload (morseCodes)
import Data.Semigroup
import Data.Map.Strict ((!))

decodeMorse :: String -> String
decodeMorse x = 
  let y = filter3Spaces x in 
    if isInfixOf "   " y then -- x == "a b   c d"
      (unwords . fmap (foldl1 (<>)) . fmap f . filterEmptyList . fmap words . splitOn "   ") y
      else if isInfixOf " " y then -- x == "a b c"
        foldl1 (<>) (f (words y))
        else morseCodes ! y -- x == "C"
      
ignoreSpaces x =
  if "    " `isInfixOf` x then
    foldl1 (<>) (filter (\a -> not ((length a) > 3 && (" " `isInfixOf` a)))  (group x))
    else x
    
filterEmptyList x = filter (not . Data.List.null) x    
      
      
-- filter spaces length > 3
filterSpaces x = if (" " `isInfixOf` x) && (length x > 3) then "   " else x

-- turn spaces more than 3 to 3 spaces
filter3Spaces x = (foldl1 (<>) . (fmap filterSpaces). group) x      
      
-- Your code
-- a = splitOn "   " ".... . -.--    .--- ..= -.. ." == [".... . -.--", ".--- ..= -.. ."]
-- b = fmap words a == [["....", ".", ...], [...]]
-- fmap f (fmap words (splitOn "   " x)) == [["H","E","Y"],["J","U","D","E"]]
f x = fmap (morseCodes !) x


---------------------------------------------------
16. 6 kyu
A Narcissistic Number is a number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits):

    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1634 (4 digits):

    1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634
The Challenge:

Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

Error checking for text strings or other invalid inputs is not required, only valid integers will be passed into the function.

module Narcissistic where
import Data.List
import Data.Semigroup

narcissistic :: Integral n => n -> Bool
narcissistic n = 
  let i = (f4 n) in foldl1 (+) (fmap (^(length i)) i) == n

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse $ f3 x
-------------------------------------------------------------
15. 5 kyu
Write a function called that takes a string of parentheses, and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.

Examples
"()"              =>  true
")(()))"          =>  false
"("               =>  false
"(())((()())())"  =>  true
Constraints
0 <= input.length <= 100

Along with opening (() and closing ()) parenthesis, input may contain any valid ASCII characters. Furthermore, the input string may be empty and/or not contain any parentheses at all. Do not treat other forms of brackets as parentheses (e.g. [], {}, <>).

module Codewars.Parentheses where
import Data.List

validParentheses :: String -> Bool
validParentheses x = 
  if Data.List.null (filter (>0) (fmap sum (inits (replace x)))) && (sum (replace x) == 0)
    then True
    else False

f '(' = -1
f ')' = 1
-- replace "(ab(cd)f)" == [-1,-1,1,1]
replace x = fmap f (fst (partition (`elem` "()") x))
------------------------------------------------------------------------
14. 6 kyu
Define a function that takes an integer argument and returns logical value true or false depending on if the integer is a prime.

Per Wikipedia, a prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

Example
is_prime(1)  /* false */
is_prime(2)  /* true  */
is_prime(-1) /* false */
Assumptions
You can assume you will be given an integer input.
You can not assume that the integer will be only positive. You may be given negative numbers as well (or 0).
There are no fancy optimizations required, but still the most trivial solutions might time out. Try to find a solution which does not loop all the way up to n.

module IsPrime where
import Data.List
import Data.Semigroup

isPrime :: Integer -> Bool
isPrime 0 = False
isPrime 1 = False
isPrime 2 = True
isPrime 3 = True

isPrime x = if x < 0 then 
  False
  else
  let y = floor (sqrt (fromIntegral x) :: Double) in (0 `notElem` (fmap (mod x) [2..y]))
-------------------------------------------------------------------

13. 6 kyu
Create a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.

Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.

Example:

solution 1000 -- should return "M"
Help:

Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Remember that there can't be more than 3 identical symbols in a row.

More about roman numerals - http://en.wikipedia.org/wiki/Roman_numerals


module RomanNumerals where
import Data.Map
import Data.List
import Data.Semigroup

solution :: Integer -> String
solution n = foldl1 (<>) (fmap (romanNum !) ((f5 . f4) n))
-- [100,20,3] -> [(100,"C"), (20,"XX"), (3,"III")] -> "CXXIII"
-- ["C","XX","III"] -> "CXXIII"

-- f5 [1,2,3] = [100,20,3]
f5 x = if (Data.List.null x) then [] else [(head x) * (10 ^ ((length x) - 1))] <> f5 (tail x)

-- f n = romanNum !! $ head (f4 n) * (10^ (length n))

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse (f3 x)

romanNum = fromList [(0,""),(3000, "MMM"),(2000,"MM"),(1000,"M"),(900, "CM"),(800, "DCCC"),(700, "DCC"),(600, "DC"),(500, "D"),(100, "C"),(200, "CC"),(300, "CCC"),(400, "CD"),(50, "L"),(60, "LX"),(70, "LXX"),(80, "LXXX"),(90, "XC"),(10, "X"),(20, "XX"),(30, "XXX"),(40, "XL"),(9, "IX"),(8, "VIII"),(7, "VII"),(6, "VI"),(5, "V"),(4, "IV"),(3, "III"),(2, "II"),(1, "I")]


--------------------------------------------------------------
12. 6 kyu
Your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.
Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
If the input string is empty, return an empty string. The words in the input String will only contain valid consecutive numbers.

"is2 Thi1s T4est 3a"  -->  "Thi1s is2 3a T4est"
"4of Fo1r pe6ople g3ood th5e the2"  -->  "Fo1r the2 g3ood 4of th5e pe6ople"
""  -->  ""

module Codewars.Kata.YourOrderPlease where
import Data.List
import Data.Semigroup
yourOrderPlease :: String -> String
yourOrderPlease x = 
    let m = words x in
        unwords ( snd <$> ( sortOn fst ( zip (filter (`elem` "123456789") <$> m) m)))
-----------------------------------------------------

11. Count the number of Duplicates
Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

"abcde" -> 0 # no characters repeats more than once
"aabbcde" -> 2 # 'a' and 'b'
"aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
"indivisibility" -> 1 # 'i' occurs six times
"Indivisibilities" -> 2 # 'i' occurs seven times and 's' occurs twice
"aA11" -> 2 # 'a' and '1'
"ABBA" -> 2 # 'A' and 'B' each occur twice

module Codwars.Kata.Duplicates where
import Data.List
import Data.Char
duplicateCount :: String -> Int
duplicateCount x = length $ filter ((>1) . length) $ group $ sort $ fmap toUpper x

--------------------------------------------------
10. In this kata, you must create a digital root function.

A digital root is the recursive sum of all the digits in a number. Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. This is only applicable to the natural numbers.

Here's how it works:
digital_root(16)
=> 1 + 6
=> 7

digital_root(942)
=> 9 + 4 + 2
=> 15 ...
=> 1 + 5
=> 6

digital_root(132189)
=> 1 + 3 + 2 + 1 + 8 + 9
=> 24 ...
=> 2 + 4
=> 6

digital_root(493193)
=> 4 + 9 + 3 + 1 + 9 + 3
=> 29 ...
=> 2 + 9
=> 11 ...
=> 1 + 1
=> 2

-- {-# LANGUAGE FlexibleContexts #-}
module DigitalRoot where
import Data.List
import Data.Semigroup

digitalRoot :: Integral a => a -> a
digitalRoot x = if (div x 10) == 0 then x else digitalRoot (f2 x)

f2 x = foldl1 (+) $ f3 x

-- f3 123 = [3,2,1]

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse $ f3 x
------------------------------------------
9. Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

It should remove all values from list a, which are present in list b.

difference [1,2] [1] == [2]
If a value is present in b, all of its occurrences must be removed from the other:

difference [1,2,2,2,3] [2] == [1,3]

module Difference where
import Data.List
import Control.Applicative
difference :: Eq a => [a] -> [a] -> [a]
difference x y = snd $ partition (`elem` y) x 
-----------------------------------------------------------

8. Given an array of ones and zeroes, convert the equivalent binary value to an integer.

Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.
Testing: [0, 0, 0, 1] ==> 1
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 0, 1] ==> 5
Testing: [1, 0, 0, 1] ==> 9
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 1, 0] ==> 6
Testing: [1, 1, 1, 1] ==> 15
Testing: [1, 0, 1, 1] ==> 11

module OnesAndZeroes (toNumber) where
import Prelude
toNumber :: [Int] -> Int
toNumber x = f2 x 0

f2 :: [Int] -> Int -> Int
f2 [] _ = 0
f2 x n = (last x) * (2 ^ n) + f2 (init x) (n + 1)

------------------------------------------------------------------------

7. Your task is to make a function that can take any non-negative integer as a argument and return it with its digits in descending order. Essentially, rearrange the digits to create the highest possible number.

module DescendingOrder where
import Data.List
descendingOrder :: Integer -> Integer
descendingOrder = \x -> read . reverse . sort . show $ x

-----------------------------------------------------------

6. Your task is to write a function maskify, which changes all but the last four characters into '#'.
maskify "4556364607935616" == "############5616"
maskify      "64607935616" ==      "#######5616"
maskify                "1" ==                "1"
maskify                 "" ==                 ""

-- "What was the name of your first pet?"
maskify "Skippy" == "##ippy"
maskify "Nananananananananananananananana Batman!"
     -- "####################################man!"

module Maskify where
import Data.List
maskify :: String -> String
maskify str = if (length str) < 5 then
  str
  else 
    let (a,b) = splitAt ((length str) - 4) str in
    uncurry (++) ((fmap (\_ -> '#') a), b)
----------------------------------------------------

5. Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.
uniqueInOrder "AAAABBBCCDAABBB" == "ABCDAB"
uniqueInOrder "ABBCcAD"         == "ABCcAD"
uniqueInOrder [1,2,2,3,3]       == [1,2,3]

module UniqueInOrder (uniqueInOrder) where
import Data.List
uniqueInOrder :: (Eq a, Ord a) => [a] -> [a]
uniqueInOrder = \x -> fmap head (group x)

-----------------------------------------------------------------------
4. Your task is to write a function that takes a string and return a new string with all vowels removed.

For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".

module Disemvowel where
import Data.List

disemvowel :: String -> String
disemvowel str = snd $ partition (`elem` "aeiouAEIOU") str
------------------------------------------------------------------------
3. An isogram is a word that has no repeating letters, consecutive or non-consecutive. Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.

isIsogram "Dermatoglyphics" == true
isIsogram "aba" == false
isIsogram "moOse" == false -- ignore letter case

module Isogram where
import Data.List
import Data.Char
isIsogram :: String -> Bool
isIsogram "" = True
isIsogram str = if (maximum . fmap length . group . sort . fmap toUpper $ str) > 1 then False else True

------------------------------------------------------------------------
2. output 26^6 squences of a to z from "aaaaaa" to "zzzzzz"

foldl1 (liftA2 (<>)) $ replicate 6 $ (:[]) <$> ['a'..'z']

--------------------------------------------------------------------------
1. get the greatest and unique number from a list

maximum . concat . filter ((==1) . length) . group . sort $ [1,2,3,5,3]
