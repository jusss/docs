
24. 5kyu Weight for weight
My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.

I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.

For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99. Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?

Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: "100 180 90 56 65 74 68 86 99"

When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers: 100 is before 180 because its "weight" (1) is less than the one of 180 (9) and 180 is before 90 since, having the same "weight" (9), it comes before as a string.

All numbers in the list are positive numbers and the list can be empty.

Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
Don't modify the input
For C: The result is freed.

module Codewars.G964.WeightSort where
import Data.List
import Data.Semigroup
import Data.Map

orderWeight :: [Char] -> [Char]
-- orderWeight string =   unwords (int2Str (mconcat (fmap innerSort (sortBySum (sortBy sortLT (str2Int (words string)))))))
orderWeight string =   (unwords . int2Str . mconcat . fmap innerSort . sortBySum . sortBy sortLT . str2Int . words) string



sortLT a b = if (foldl1 (+) a) < (foldl1 (+) b) then LT else GT

table = fromList (zip ['0'..'9'] [0..9])
str2Int l = fmap (fmap (\x -> table ! x)) l
-- l2 = str2Int $ words "56 65 74 100 99 68 86 180 90"
-- == [[5,6],[6,5],[7,4],[1,0,0],[9,9],[6,8],[8,6],[1,8,0],[9,0]]

-- l3 = sortBy sortLT l2
-- == [[1,0,0],[9,0],[1,8,0],[7,4],[6,5],[5,6],[8,6],[6,8],[9,9]]
-- groupBy (\a b -> if (foldl1 (+) a) == (foldl1 (+) b) then True else False) l3
sortBySum l3 =  groupBy (\a b -> if (foldl1 (+) a) == (foldl1 (+) b) then True else False) l3
-- == [[[1,0,0]],[[9,0],[1,8,0]],[[7,4],[6,5],[5,6]],[[8,6],[6,8]],[[9,9]]]

innerSort x = if length x == 1 then x else sort x
-- fmap innerSort [[[1,0,0]],[[9,0],[1,8,0]],[[7,4],[6,5],[5,6]],[[8,6],[6,8]],[[9,9]]]
-- l4 = [[[1,0,0]],[[1,8,0],[9,0]],[[5,6],[6,5],[7,4]],[[6,8],[8,6]],[[9,9]]]
-- l5 = mconcat l4 == [[1,0,0],[1,8,0],[9,0],[5,6],[6,5],[7,4],[6,8],[8,6],[9,9]]

reverseTable = fromList (zip [0..9] ['0'..'9'])
int2Str l = fmap (fmap (\x -> reverseTable ! x)) l
-- int2Str l5 == ["100","180","90","56","65","74","68","86","99"]
-- unwords $ int2Str l5 == "100 180 90 56 65 74 68 86 99"

---------------------------------------------------------------

23. 5kyu smallest unsolved!

https://www.codewars.com/kata/find-the-smallest

You have a positive number n consisting of digits. You can do at most one operation: Choosing the index of a digit in the number, remove this digit at that index and insert it back to another or at the same place in the number in order to find the smallest number you can get.

#Task: Return an array or a tuple or a string depending on the language (see "Sample Tests") with

1) the smallest number you got
2) the index i of the digit d you took, i as small as possible
3) the index j (as small as possible) where you insert this digit d to have the smallest number.
Example:

smallest(261235) --> [126235, 2, 0] or (126235, 2, 0) or "126235, 2, 0"
126235 is the smallest number gotten by taking 1 at index 2 and putting it at index 0

smallest(209917) --> [29917, 0, 1] or ...

[29917, 1, 0] could be a solution too but index `i` in [29917, 1, 0] is greater than 
index `i` in [29917, 0, 1].
29917 is the smallest number gotten by taking 2 at index 0 and putting it at index 1 which gave 029917 which is the number 29917.

smallest(1000000) --> [1, 0, 6] or ...
Note
Have a look at "Sample Tests" to see the input and output in each language

module Codewars.G964.Tosmallest where
import Data.List
import Data.Maybe
import Data.Semigroup

smallest :: Integer -> (Integer, Int, Int)
smallest n = let x = sm (fromInteger n) in extend (toInteger x) (p1 (f4 (fromInteger n)) (f4 x))

-- 1243 1234
-- 4231 1423 get the smallest element, move it to head, if the smallest is already first then the second smallest to head
-- check if all digits are sequenced by small to big, if not, ^, work on without 0, work on two digits before 0

-- 1 digit before 0, group 0, move the head to behind 0 part, use the first solution again

-- another method
-- it needs a function get all the permutations of every element may be the first
-- then sort, work on without 0, 2 digits before 0

deleteByIndex n xs = take (n) xs ++ drop (n + 1) xs

-- without 0 or 0 is at position 2
-- -- this will insert x into a list that list removed x itself, then insert it for sort

s x = let l = f4 x in let l2 = zip [0..] l in f2 (sort (fmap (\x -> insert (snd x) (deleteByIndex (fst x) l)) l2) !! 0)


-- 0 at position 1
sm x = let l = f4 x in 
    let gl = group l in
    if (l !! 1) == 0 then f2 (insert (head (head gl)) (mconcat (drop 2 gl)))
    else s x

-- f3 123 = [3,2,1]

f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse $ f3 x

-- l = [(0,1),(1,2),(2,3)]
-- l = (sortOn snd . zip [0..]) (f4 n)

-- f [1,2,3] 0 == 123
f :: [Int] -> Int -> Int
f [] _ = 0
f x n = (last x) * (10 ^ n) + f (init x) (n + 1)

f2 x = f x 0  

extend :: a -> (b, c) -> (a, b, c)
extend a (b, c) = (a, b, c)

-- get the index offset number
-- p1 [3,0,0,1,9] [1,3,9] == (0,3)
-- 
p1 l1 l2 = p (zip [0..] l1) (zip [0..] l2) l1 l2
p l1 l2 ol1 ol2 = 
    if (length l1) == (length l2) then
      if ol1 == ol2 then (0,0) else
        -- no 0
        if (snd (head l1)) /= (snd (head l2)) then
          if (snd (head l1)) == (snd (head (tail l2))) then 
            ( (fromJust (elemIndex (snd (head l2)) (drop ((length ol1) - (length l1)) ol1) )) + (length ol1) - (length l1)  , fromJust (elemIndex (snd (head l2)) ol2))
          else (0, (fromJust (elemIndex (snd (head l1)) ol2)))
        else p (tail l1) (tail l2) ol1 ol2
    else
        if (length l1) - (length l2) == 1 then
          -- one 0
          if (ol1 !! 1 /= 0) then
             if (snd (head l1)) /= (snd (head l2)) then (fst (head l1), 0) else p (tail l1) (tail l2) ol1 ol2
          else
            if (snd (head l1)) /= (snd (head l2)) then ( 0, fst (head l1)) else p (tail l1) (tail l2) ol1 ol2
         
        else
        -- more 0 than 1
        (0, fromJust ((snd (head l1)) `elemIndex` ol2) + (length l1) - (length l2))

----------------------------------------------------

22. 5kyu rot13
ROT13 is a simple letter substitution cipher that replaces a letter with the letter 13 letters after it in the alphabet. ROT13 is an example of the Caesar cipher.

Create a function that takes a string and returns the string ciphered with Rot13. If there are numbers or special characters included in the string, they should be returned as they are. Only letters from the latin/english alphabet should be shifted, like in the original Rot13 "implementation".

module Rot13 where

import Data.Char
import Data.Map
import Data.Semigroup

rot13 :: String -> String
rot13 xs = flip fmap xs (\x -> if (notMember x table) then x else (table ! x))
  
  
t1 = zip ['a'..'m'] ['n'..'z']
t2 = zip ['n'..'z'] ['a'..'m']
t3 = zip ['A'..'M'] ['N'..'Z']
t4 = zip ['N'..'Z'] ['A'..'M']
table = fromList (t1 <> t2 <> t3 <> t4)

----------------------------------------------------------------
21. 5kyu Josephus Survivor

In this kata you have to correctly return who is the "survivor", ie: the last element of a Josephus permutation.

Basically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements, like this:

josephus_survivor(7,3) => means 7 people in a circle;
one every 3 is eliminated until one remains
[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out
[1,2,4,5,7] => 6 is counted out
[1,4,5,7] => 2 is counted out
[1,4,5] => 7 is counted out
[1,4] => 5 is counted out
[4] => 1 counted out, 4 is the last element - the survivor!
The above link about the "base" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.

Notes and tips: using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.

module Codewars.G964.Josephus where
import Data.List
import Data.Semigroup
josephusSurvivor :: Int -> Int -> Int
-- josephusSurvivor n k = g k k [1..n]
josephusSurvivor n k = [1..n] !! (f n k)

-- l = [1,2,3,4,5,6,7]
-- splitAt 3 l == ([1,2,3],[4,5,6,7])

-- concatL $ splitAt 3 l == [4,5,6,7,1,2]
-- concatL (xs, []) = xs !! 1
concatL ([], xs) = init xs
concatL (xs, ys) = ys <> (init xs)

-- concatL $ splitAt k [1..n]
-- l = [1..n]
-- f n k l = if (length l) == k then l !! (mod n k) else f n k (concatL (splitAt k  l))

g ok k l
 | (Data.List.null (init l)) = head l
 | (k < (length l)) = g ok ok (concatL (splitAt k  l)) 
 -- | otherwise = g ok (k - (length l)) l
 | otherwise = g ok (mod k (length l)) l
 
f 1 _ = 0
f n m = ((f (n-1) m) + m) `mod` n

main = print $ josephusSurvivor 7 3

-- https://en.wikipedia.org/wiki/Josephus_problem
-- http://www.360doc.com/content/19/0212/18/32116899_814506447.shtml
-- https://maskray.me/blog/2013-08-27-josephus-problem-two-log-n-solutions
-- int s = 0; for (int i = 2; i <= n; i++) {s = (s + m) % i;}

---------------------------------------------------------
20. 4 kyu Range Extraction

A format for expressing an ordered list of integers is to use a comma separated list of either

individual integers
or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, '-'. The range includes all integers in the interval including both endpoints. It is not considered a range unless it spans at least 3 numbers. For example ("12, 13, 15-17")
Complete the solution so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format.

Example:

solution([-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]);
// returns "-6,-3-1,3-5,7-11,14,15,17-20"

module RangeExtractor.JorgeVS.Kata where
-- import Data.List.GroupBy
import Data.List
import Data.Semigroup

solution :: [Int] -> String
solution myList = f5 (f (groupBy' (\x y -> if (x - y) == -1 then True else False) myList))

-- f [[0,1,2],[5,6]] == ["0-2", "5,6"]
f l = fmap (\x -> if (length x) < 3  then f3 x else f4 x) l 

-- f3 [0,1,3,4] == "0,1,3,4"
f2 l = mconcat (fmap (++ ",") (init (fmap show l)))
f3 l = (f2 l) <> (show (last l))

-- f4 [0,1,2,3] == "0-3"
f4 l = (show (head l)) <> "-" <> (show (last l))

-- f5 ["0-2", "5,6"] == "0-2,5,6"
f5 l = mconcat (fmap (<> ",") (init l)) <> (last l)

groupBy' :: (a -> a -> Bool) -> [a] -> [[a]]
groupBy' _ [] = []
groupBy' p' (x':xs') = (x' : ys') : zs'
  where
    (ys',zs') = go p' x' xs'
    go p z (x:xs)
      | p z x = (x : ys, zs)
      | otherwise = ([], (x : ys) : zs)
      where (ys,zs) = go p x xs
    go _ _ [] = ([], [])
------------------------------------------------------------

19. 5 kyu Longest Common Subsequence
Write a function called LCS that accepts two sequences and returns the longest subsequence common to the passed in sequences.

Subsequence
A subsequence is different from a substring. The terms of a subsequence need not be consecutive terms of the original sequence.

Example subsequence
Subsequences of "abc" = "a", "b", "c", "ab", "ac", "bc" and "abc".

LCS examples
lcs "a"         "b"         `shouldBe` ""
lcs "abcdef"    "abc"       `shouldBe` "abc"
lcs "132535365" "123456789" `shouldBe` "12356"
Notes
Both arguments will be strings
Return value must be a string
Return an empty string if there exists no common subsequence
Both arguments will have one or more characters (in JavaScript)
All tests will only have a single longest common subsequence. Don't worry about cases such as LCS( "1234", "3412" ), which would have two possible longest common subsequences: "12" and "34".
Note that the Haskell variant will use randomized testing, but any longest common subsequence will be valid.

module LongestCommonSubsequence where
import Data.List
lcs :: String -> String -> String
lcs x y = (nub y) `intersect` (nub x)
-- lcs x y = maximum ((inits x) `intersect` (inits y))

---------------------------------------------------------
18. 6 kyu Simple Encryption #1 - Alternating Split
For building the encrypted string:
Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.
Do this n times!

Examples:

"This is a test!", 1 -> "hsi  etTi sats!"
"This is a test!", 2 -> "hsi  etTi sats!" -> "s eT ashi tist!"
Write two methods:

string Encrypt(string text, int n)
string Decrypt(string encryptedText, int n)
For both methods:
If the input-string is null or empty return exactly this value!
If n is <= 0 then return the input text.

This kata is part of the Simple Encryption Series:
Simple Encryption #1 - Alternating Split
Simple Encryption #2 - Index-Difference
Simple Encryption #3 - Turn The Bits Around
Simple Encryption #4 - Qwerty

Have fun coding it and please don't forget to vote and rank this kata! :-)

module AlternateSplit.JorgeVS.Kata where
import Data.List
-- import Data.Semigroup

encrypt :: String -> Int -> String
encrypt x n =
 if (x == "") then ""
 else if n <= 0 then x
 else encrypt (f2 x) (n - 1)

decrypt :: String -> Int -> String
decrypt x n =
 if x == "" then ""
 else if n <= 0 then x
 else decrypt (f2r x) (n - 1)


-- just [1,2,3,4,5,6] to [2,4,6,1,3,5]
-- "This is a test!", 2 -> "hsi  etTi sats!" -> "s eT ashi tist!"
-- f2 [0,1,2,3,4] == [1,3,0,2,4]
ttl (a,b) = [a,b]
f2r x = (mconcat . fmap reverse . transpose . ttl . splitAt (div (length x) 2)) x

-- f x = (fmap (x !!) [1,3..(length x)]) (<>) (fmap (x !!) [0,2..(length x)])
f2 x = map snd . uncurry (++) . partition (odd . fst) . zip [0..] $ x
-- f3 x = (mconcat . transpose . chunksOf 2) x
-------------------------------------------------------------------------------------------
17. 6 kyu Decode the Morse code
In this kata you have to write a simple Morse code decoder. While the Morse code is now mostly superceded by voice and digital data communication channels, it still has its use in some applications around the world.
The Morse code encodes every character as a sequence of "dots" and "dashes". For example, the letter A is coded as ·−, letter Q is coded as −−·−, and digit 1 is coded as ·−−−−. The Morse code is case-insensitive, traditionally capital letters are used. When the message is written in Morse code, a single space is used to separate the character codes and 3 spaces are used to separate words. For example, the message HEY JUDE in Morse code is ···· · −·−−   ·−−− ··− −·· ·.

NOTE: Extra spaces before or after the code have no meaning and should be ignored.

In addition to letters, digits and some punctuation, there are some special service codes, the most notorious of those is the international distress signal SOS (that was first issued by Titanic), that is coded as ···−−−···. These special codes are treated as single special characters, and usually are transmitted as separate words.

Your task is to implement a function that would take the morse code as input and return a decoded human-readable string.

For example:

decodeMorse ".... . -.--   .--- ..- -.. ."
--should return "HEY JUDE"
NOTE: For coding purposes you have to use ASCII characters . and -, not Unicode characters.

The Morse code table is preloaded for you as a dictionary, feel free to use it:

Coffeescript/C++/Go/JavaScript/PHP/Python/Ruby/TypeScript: MORSE_CODE['.--']
C#: MorseCode.Get(".--") (returns string)
Elixir: @morse_codes variable (from use MorseCode.Constants). Ignore the unused variable warning for morse_codes because it's no longer used and kept only for old solutions.
Elm: MorseCodes.get : Dict String String
Haskell: morseCodes ! ".--" (Codes are in a Map String String)
Java: MorseCode.get(".--")
Kotlin: MorseCode[".--"] ?: "" or MorseCode.getOrDefault(".--", "")
Rust: self.morse_code
Scala: morseCodes(".--")
C: provides parallel arrays, i.e. morse[2] == "-.-" for ascii[2] == "C"
All the test strings would contain valid Morse code, so you may skip checking for errors and exceptions. In C#, tests will fail if the solution code throws an exception, please keep that in mind. This is mostly because otherwise the engine would simply ignore the tests, resulting in a "valid" solution.

Good luck!

After you complete this kata, you may try yourself at Decode the Morse code, advanced.

module Codewars.Kata.DecodeMorse (decodeMorse) where
import Data.List.Split
import Data.List
import Codewars.Kata.DecodeMorse.Preload (morseCodes)
import Data.Semigroup
import Data.Map.Strict ((!))

decodeMorse :: String -> String
decodeMorse x = 
  let y = filter3Spaces x in 
    if isInfixOf "   " y then -- x == "a b   c d"
      (unwords . fmap (foldl1 (<>)) . fmap f . filterEmptyList . fmap words . splitOn "   ") y
      else if isInfixOf " " y then -- x == "a b c"
        foldl1 (<>) (f (words y))
        else morseCodes ! y -- x == "C"
      
ignoreSpaces x =
  if "    " `isInfixOf` x then
    foldl1 (<>) (filter (\a -> not ((length a) > 3 && (" " `isInfixOf` a)))  (group x))
    else x
    
filterEmptyList x = filter (not . Data.List.null) x    
      
      
-- filter spaces length > 3
filterSpaces x = if (" " `isInfixOf` x) && (length x > 3) then "   " else x

-- turn spaces more than 3 to 3 spaces
filter3Spaces x = (foldl1 (<>) . (fmap filterSpaces). group) x      
      
-- Your code
-- a = splitOn "   " ".... . -.--    .--- ..= -.. ." == [".... . -.--", ".--- ..= -.. ."]
-- b = fmap words a == [["....", ".", ...], [...]]
-- fmap f (fmap words (splitOn "   " x)) == [["H","E","Y"],["J","U","D","E"]]
f x = fmap (morseCodes !) x


---------------------------------------------------
16. 6 kyu
A Narcissistic Number is a number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits):

    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1634 (4 digits):

    1^4 + 6^4 + 3^4 + 4^4 = 1 + 1296 + 81 + 256 = 1634
The Challenge:

Your code must return true or false depending upon whether the given number is a Narcissistic number in base 10.

Error checking for text strings or other invalid inputs is not required, only valid integers will be passed into the function.

module Narcissistic where
import Data.List
import Data.Semigroup

narcissistic :: Integral n => n -> Bool
narcissistic n = 
  let i = (f4 n) in foldl1 (+) (fmap (^(length i)) i) == n

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse $ f3 x
-------------------------------------------------------------
15. 5 kyu
Write a function called that takes a string of parentheses, and determines if the order of the parentheses is valid. The function should return true if the string is valid, and false if it's invalid.

Examples
"()"              =>  true
")(()))"          =>  false
"("               =>  false
"(())((()())())"  =>  true
Constraints
0 <= input.length <= 100

Along with opening (() and closing ()) parenthesis, input may contain any valid ASCII characters. Furthermore, the input string may be empty and/or not contain any parentheses at all. Do not treat other forms of brackets as parentheses (e.g. [], {}, <>).

module Codewars.Parentheses where
import Data.List

validParentheses :: String -> Bool
validParentheses x = 
  if Data.List.null (filter (>0) (fmap sum (inits (replace x)))) && (sum (replace x) == 0)
    then True
    else False

f '(' = -1
f ')' = 1
-- replace "(ab(cd)f)" == [-1,-1,1,1]
replace x = fmap f (fst (partition (`elem` "()") x))
------------------------------------------------------------------------
14. 6 kyu
Define a function that takes an integer argument and returns logical value true or false depending on if the integer is a prime.

Per Wikipedia, a prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.

Example
is_prime(1)  /* false */
is_prime(2)  /* true  */
is_prime(-1) /* false */
Assumptions
You can assume you will be given an integer input.
You can not assume that the integer will be only positive. You may be given negative numbers as well (or 0).
There are no fancy optimizations required, but still the most trivial solutions might time out. Try to find a solution which does not loop all the way up to n.

module IsPrime where
import Data.List
import Data.Semigroup

isPrime :: Integer -> Bool
isPrime 0 = False
isPrime 1 = False
isPrime 2 = True
isPrime 3 = True

isPrime x = if x < 0 then 
  False
  else
  let y = floor (sqrt (fromIntegral x) :: Double) in (0 `notElem` (fmap (mod x) [2..y]))
-------------------------------------------------------------------

13. 6 kyu
Create a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.

Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.

Example:

solution 1000 -- should return "M"
Help:

Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Remember that there can't be more than 3 identical symbols in a row.

More about roman numerals - http://en.wikipedia.org/wiki/Roman_numerals


module RomanNumerals where
import Data.Map
import Data.List
import Data.Semigroup

solution :: Integer -> String
solution n = foldl1 (<>) (fmap (romanNum !) ((f5 . f4) n))
-- [100,20,3] -> [(100,"C"), (20,"XX"), (3,"III")] -> "CXXIII"
-- ["C","XX","III"] -> "CXXIII"

-- f5 [1,2,3] = [100,20,3]
f5 x = if (Data.List.null x) then [] else [(head x) * (10 ^ ((length x) - 1))] <> f5 (tail x)

-- f n = romanNum !! $ head (f4 n) * (10^ (length n))

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse (f3 x)

romanNum = fromList [(0,""),(3000, "MMM"),(2000,"MM"),(1000,"M"),(900, "CM"),(800, "DCCC"),(700, "DCC"),(600, "DC"),(500, "D"),(100, "C"),(200, "CC"),(300, "CCC"),(400, "CD"),(50, "L"),(60, "LX"),(70, "LXX"),(80, "LXXX"),(90, "XC"),(10, "X"),(20, "XX"),(30, "XXX"),(40, "XL"),(9, "IX"),(8, "VIII"),(7, "VII"),(6, "VI"),(5, "V"),(4, "IV"),(3, "III"),(2, "II"),(1, "I")]


--------------------------------------------------------------
12. 6 kyu
Your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.
Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
If the input string is empty, return an empty string. The words in the input String will only contain valid consecutive numbers.

"is2 Thi1s T4est 3a"  -->  "Thi1s is2 3a T4est"
"4of Fo1r pe6ople g3ood th5e the2"  -->  "Fo1r the2 g3ood 4of th5e pe6ople"
""  -->  ""

module Codewars.Kata.YourOrderPlease where
import Data.List
import Data.Semigroup
yourOrderPlease :: String -> String
yourOrderPlease x = 
    let m = words x in
        unwords ( snd <$> ( sortOn fst ( zip (filter (`elem` "123456789") <$> m) m)))
-----------------------------------------------------

11. Count the number of Duplicates
Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

"abcde" -> 0 # no characters repeats more than once
"aabbcde" -> 2 # 'a' and 'b'
"aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
"indivisibility" -> 1 # 'i' occurs six times
"Indivisibilities" -> 2 # 'i' occurs seven times and 's' occurs twice
"aA11" -> 2 # 'a' and '1'
"ABBA" -> 2 # 'A' and 'B' each occur twice

module Codwars.Kata.Duplicates where
import Data.List
import Data.Char
duplicateCount :: String -> Int
duplicateCount x = length $ filter ((>1) . length) $ group $ sort $ fmap toUpper x

--------------------------------------------------
10. In this kata, you must create a digital root function.

A digital root is the recursive sum of all the digits in a number. Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. This is only applicable to the natural numbers.

Here's how it works:
digital_root(16)
=> 1 + 6
=> 7

digital_root(942)
=> 9 + 4 + 2
=> 15 ...
=> 1 + 5
=> 6

digital_root(132189)
=> 1 + 3 + 2 + 1 + 8 + 9
=> 24 ...
=> 2 + 4
=> 6

digital_root(493193)
=> 4 + 9 + 3 + 1 + 9 + 3
=> 29 ...
=> 2 + 9
=> 11 ...
=> 1 + 1
=> 2

-- {-# LANGUAGE FlexibleContexts #-}
module DigitalRoot where
import Data.List
import Data.Semigroup

digitalRoot :: Integral a => a -> a
digitalRoot x = if (div x 10) == 0 then x else digitalRoot (f2 x)

f2 x = foldl1 (+) $ f3 x

-- f3 123 = [3,2,1]

-- f3 123 = [3,2,1]
f3 x = if (div x 10) == 0 then [x]
    else
        x - (div x 10) * 10 : [] <> f3 (div x 10)

-- f4 123 = [1,2,3]
f4 x = reverse $ f3 x
------------------------------------------
9. Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

It should remove all values from list a, which are present in list b.

difference [1,2] [1] == [2]
If a value is present in b, all of its occurrences must be removed from the other:

difference [1,2,2,2,3] [2] == [1,3]

module Difference where
import Data.List
import Control.Applicative
difference :: Eq a => [a] -> [a] -> [a]
difference x y = snd $ partition (`elem` y) x 
-----------------------------------------------------------

8. Given an array of ones and zeroes, convert the equivalent binary value to an integer.

Eg: [0, 0, 0, 1] is treated as 0001 which is the binary representation of 1.
Testing: [0, 0, 0, 1] ==> 1
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 0, 1] ==> 5
Testing: [1, 0, 0, 1] ==> 9
Testing: [0, 0, 1, 0] ==> 2
Testing: [0, 1, 1, 0] ==> 6
Testing: [1, 1, 1, 1] ==> 15
Testing: [1, 0, 1, 1] ==> 11

module OnesAndZeroes (toNumber) where
import Prelude
toNumber :: [Int] -> Int
toNumber x = f2 x 0

f2 :: [Int] -> Int -> Int
f2 [] _ = 0
f2 x n = (last x) * (2 ^ n) + f2 (init x) (n + 1)

------------------------------------------------------------------------

7. Your task is to make a function that can take any non-negative integer as a argument and return it with its digits in descending order. Essentially, rearrange the digits to create the highest possible number.

module DescendingOrder where
import Data.List
descendingOrder :: Integer -> Integer
descendingOrder = \x -> read . reverse . sort . show $ x

-----------------------------------------------------------

6. Your task is to write a function maskify, which changes all but the last four characters into '#'.
maskify "4556364607935616" == "############5616"
maskify      "64607935616" ==      "#######5616"
maskify                "1" ==                "1"
maskify                 "" ==                 ""

-- "What was the name of your first pet?"
maskify "Skippy" == "##ippy"
maskify "Nananananananananananananananana Batman!"
     -- "####################################man!"

module Maskify where
import Data.List
maskify :: String -> String
maskify str = if (length str) < 5 then
  str
  else 
    let (a,b) = splitAt ((length str) - 4) str in
    uncurry (++) ((fmap (\_ -> '#') a), b)
----------------------------------------------------

5. Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.
uniqueInOrder "AAAABBBCCDAABBB" == "ABCDAB"
uniqueInOrder "ABBCcAD"         == "ABCcAD"
uniqueInOrder [1,2,2,3,3]       == [1,2,3]

module UniqueInOrder (uniqueInOrder) where
import Data.List
uniqueInOrder :: (Eq a, Ord a) => [a] -> [a]
uniqueInOrder = \x -> fmap head (group x)

-----------------------------------------------------------------------
4. Your task is to write a function that takes a string and return a new string with all vowels removed.

For example, the string "This website is for losers LOL!" would become "Ths wbst s fr lsrs LL!".

module Disemvowel where
import Data.List

disemvowel :: String -> String
disemvowel str = snd $ partition (`elem` "aeiouAEIOU") str
------------------------------------------------------------------------
3. An isogram is a word that has no repeating letters, consecutive or non-consecutive. Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.

isIsogram "Dermatoglyphics" == true
isIsogram "aba" == false
isIsogram "moOse" == false -- ignore letter case

module Isogram where
import Data.List
import Data.Char
isIsogram :: String -> Bool
isIsogram "" = True
isIsogram str = if (maximum . fmap length . group . sort . fmap toUpper $ str) > 1 then False else True

------------------------------------------------------------------------
2. output 26^6 squences of a to z from "aaaaaa" to "zzzzzz"

foldl1 (liftA2 (<>)) $ replicate 6 $ (:[]) <$> ['a'..'z']

get all the permutations of 3 characters
foldl1 (liftA2 (<>)) $ replicate 3 $ (:[]) <$> ">=<!@$*"
replicateM 3 ">=<!@$*"

--------------------------------------------------------------------------
1. get the greatest and unique number from a list

maximum . concat . filter ((==1) . length) . group . sort $ [1,2,3,5,3]
