3. call/cc里面写不出循环用continuation, 除非里面再加个call/cc然后在里面那个call/cc外面
来个循环用continuation,这样就可以在call/cc里面用continuation写循环

;;; fibonacci with continuation
(define (fib n)
  (call/cc (lambda (k)
	     (if (= n 0) (k 0)
	       (if (< n 3) (k 1)
		 (let ((m n) (k2 0) (a 0) (b 1) (c 1))
		   (call/cc (lambda (s) (set! k2 s)))
		   (if (> m 2) (begin (set! a b)
				      (set! b c)
				      (set! c (+ a b))
				      (set! m (- m 1))
				      (k2 m))
		     (k c))))))))
_______________________________________________________________________

(define noname
	   (lambda (n)
	     (let ((m n))
	       ((lambda () (set! m (+ m 1)) m)))))
(noname 4)执行多少次都是5,因为每次执行都重新赋值在let里

racket@> (define n 3)
racket@> (define nob
	   (let ((m n))
	     (lambda ()
	       (set! m (+ m 1))
	       m)))
racket@> (nob)
4
racket@> (nob)
5
racket@> (define n 9)
racket@> (nob)
6
racket@> (nob)
7
racket@> 
用这种办法可以解决用let写closure时,let的参数是从外面某个变量里获取的而不是已知的,这样可以在第一次执行时绑定外面那个变量,即使外面变量变了也和这个closure没关系，因为它绑定了
第一次执行时这个变量的值,如果let在lambda里面的话,每次执行lambda都会重新用let赋值而无意义

(define display0
  (lambda (n)
    (call/cc (lambda (k)
	     
	       (define loop
		 (lambda (x)
		   (define goto 0)
		   (call/cc (lambda (s) (set! goto s)))
		   (x)
		   (goto 1)))

	       (define func
		 (let ((a n))
		   (lambda (x)
		     (if (> a 0) (begin (display 0) (set! a (- a 1)))
		       (x 0)))))
	     
	       (loop (lambda () (func k)))))))


		 
	       

		   
			  
