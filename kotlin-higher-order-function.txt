
:: pass reference itself

 val result2 = gson.fromJson(result, JsonResult2::class.java)
pass class JsonResult2 itself to gson.fromJson, so it can use the class not object

test2(::test1) pass function test1 itself to test2

fun main (){
    println(test2(test1_))
    println(test2(::test1))
}

fun test1(x: Int): Int = x +1
fun test2(f: (Int) -> Int): Int = f(2)
val test1_ = {x:Int -> x + 1}
-----------------------------------------------


    val reverse2 = {i: String -> i.reversed()}

    //1. function take function as parameter, function need to be defined with lambda expression?
    // fun reverse2(val x: String): String = x.reversed() is not take by fmap(f: (String) -> String)


or use inline function

inline fun inlined(block: () -> Unit) {
	println("before")
	block()
	println("after")
}

inlined { println("do something here") }

inline fun inlined won't create a function, only when inlined is called, then to expand it

in order to reduce the memory overhead of such higher-order functions or lambda expressions

it just replaces inline function call with its definition 
