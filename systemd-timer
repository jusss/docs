OnCalendar= 可以和 OnUnitActiveSec= 一起使用
OnCalendar= Sun 2017-04-02 08:2*:00  是错误的用法,因为2*
-----------------------------------
man systemd.timer
systemctl list-timers -all

OnActiveSec= timer激活之后的计时器,比如10s,就是这个systemd.timer激活10s之后再执行service
OnBootSec= 系统启动之后多长时间
OnStartupSec= systemd启动之后多长时间
OnUnitActiveSec= 最后一次激活之后(从运行开始的时间算,而不是运行结束的时间算),多长时间再次激活(比如指令运行10s后再次运行指令,但不管上次指令是否运行结束,如果是持续性service,最好用这个,因为不会管service是否运行结束)
OnUnitInactiveSec= 最后一次运行结束之后(从运行完成结束的时间算,而不是运行开始的时间算),多长时间再次激活(上次指令运行结束之后,再过多长时间再次执行指令)
AccuracySec=：Timer流逝的时间精度设置，默认为1分钟。若想更准确，可设置为1us。
Unit=：指定激活的单元名称。若未指定，将默认执行与timer同名的service单元。
Persistent=[true,fales]：设置是否保存服务单元上一次激活的时间。此设置项只在设置了OnCalendar之后有效。
http://www.tuicool.com/articles/3qANFv
------------------------------------------------------------
systemd.timer好像比cron好用一点点, cron好像不能设置每7分钟运行一次(被60整除不了
你要是直接用00:17,00:14,00:21...这样写也可以)
日历 OnCalendar=

星期 年-月-日 时:分:秒 时区

1. 星期可以省略,或用前3字母表示Mon Tue Wed Thu Fri Sat Sun
2. 年-月-日 与 时:分:秒 可省略其中之一,但不可全省略,省略年月日则表示当前
   省略时分秒,则表示00:00:00
3. 年省略2位数表示20xx年
4. 时区省略,使用本机时区,或 CET UTC CST

Thu,Fri 2012-*-1,5 11:12:13
表示： 2012年任意月份的1号或5号且为周三或周五的日子的11点12分13秒

星期部分可以使用 "," 依次列出多个日子， 也可以使用 ".." 表示一个范围
年月日与时分秒部分 *匹配任意值 ,分割多个值 ..表示范围 /以整数间隔跳跃
3/10等于3,13,23,33,43,53

特殊的日历事件关键字 "minutely"(每分钟), "hourly"(每小时), "daily"(每天), "monthly"(每月), "weekly"(每周), "yearly"(每年), "quarterly"(每季度), "semiannually"(每半年) 的精确定义 分别是： "*-*-* *:*:00", "*-*-* *:00:00", "*-*-* 00:00:00", "*-*-01 00:00:00", "Mon *-*-* 00:00:00", "*-01-01 00:00:00", "*-01,04,07,10-01 00:00:00", "*-01,07-01 00:00:00"

10-15 →  *-10-15 00:00:00
每年10月15号

w" 表示当前时间； "today", "yesterday", "tomorrow" 分别表示今天/昨天/明天的零点(00:00:00)。

除了接受上述语法之外，还可以使用一些相对时间表示法： 给一个时长(见上文)加上 "+" 前缀或者 " left" 后缀(注意有空格)， 表示以当前时间为基准向未来前进指定的时长； 给一个时长(见上文)加上 "-" 前缀或者 " ago" 后缀(注意有空格)， 表示以当前时间为基准向过去倒退指定的时长；

最后，给一个时长(见上文)加上 "@" 前缀表示相对于UNIX时间原点(1970-01-01 00:00:00 UTC)之后多长时间。
http://www.jinbuguo.com/systemd/systemd.time.html#
-----------------------------------------------------
启动就执行一次,用OnBootSec=
----------------------------------------------------
[Timer]
WakeSystem= yes
###当定时器到达触发的时间点时， 唤醒正在休眠的系统并阻止系统进入休眠状态。 注意， 此选项仅确保唤醒系统， 而不关心任务执行完成之后是否需要再次休眠系统。 默认值为 no
OnCalendar=
定义基于挂钟时间(wallclock)的日历定时器，值是一个日历事件表达式，这是与传统cron任务类似的定时器
OnActiveSec= 相对于该单元自身被启动的时间点；
OnBootSec= 相对于机器被启动的时间点， 也就是内核开始运行的时间点；
OnStartupSec= 相对于 systemd 被首次启动的时间点， 也就是内核启动init进程的时间点；
OnUnitActiveSec= 相对于匹配单元最后一次被启动的时间点；
OnUnitInactiveSec= 相对于匹配单元最后一次被停止的时间点；
us(微秒), ms(毫秒), s(秒), m(分), h(时), d(天), w(周)
------------------------------------------------------------------------
systemd timer需要有同名的service, 然后在service里调用程序ExecStart
但enable的却是timer, timer设定时间,service设定执行程序

systemd mount挂载后如果想运行别的指令,也需要同名service,然后在service里
Requires= .mount然后ExecStart执行想要执行的指令
enable的是service, mount设定挂载位置, service设定挂载后执行程序

type=  oneshot,执行一次就退出,  simple,正常执行

http://www.linuxidc.com/Linux/2014-10/107923.htm
假设你有一个脚本叫：/usr/local/bin/myscript ，你想要每隔一小时就运行一次。
myscript.service
[Unit]
Description=MyScript
[Service]
Type=simple
ExecStart=/usr/local/bin/myscript
注意，务必将Type变量的值设置为"simple"而不是"oneshot"。使用"oneshot"使得脚本只在第一次运行，之后系统会认为你不想再次运行它，从而关掉我们接下去创建的定时器(Timer)。jo
myscript.timer
[Unit]
Description=Runs myscript every hour
[Timer]
# 首次运行要在启动后10分钟后
OnBootSec=10min
# 每次运行间隔时间
OnUnitActiveSec=1h
Unit=myscript.service
[Install]
WantedBy=multi-user.target

授权并运行的是timer文件，而不是service文件。
systemctl start myscript.timer
systemctl enable myscript.timer
-----------------------------------------------------
在同一个Timer上运行多个脚本
现在我们假设你在相同时间想要运行多个脚本。这种情况，你需要在上面的文件中做适当的修改
Service 文件
像我之前说过的那样创建你的service文件来运行你的脚本，但是在每个service 文件最后都要包含下面的内容:
[Install]
WantedBy=mytimer.target
如果在你的service 文件中有一些依赖顺序，确保你使用Description字段中的值具体指定After=something.service和Before=whatever.service中的参数。

另外的一种选择是(或许更加简单)，创建一个包装脚本来使用正确的顺序来运行命令，并在你的service文件中使用这个脚本。
Timer 文件
你只需要一个timer文件，创建mytimer.timer，像我在上面指出的。
target 文件
你可以创建一个以上所有的脚本依赖的target文件。
mytimer.target
[Unit]
Description=Mytimer
# Lots more stuff could go here, but it's situational.
# Look at systemd.unit man page.
授权 / 启动
你需要将所有的service文件和timer文件授权。
systemctl enable script1.service
systemctl enable script2.service
...
systemctl enable mytimer.timer
systemctl start mytimer.service
