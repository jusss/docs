Either a, Maybe Monad's effect is break >>= computations, when >>= meet Left a or Nothing
-----------------------------------------------
about IO runtime Exception, use TimeOut to detect if connection is reset by peer
use PING/PONG or useless heartbeat package to keep connection alive
detect TimeOut to avoid IO Exception, and also read/write available on socket, return Left a or Nothing to avoid it

detect runtime Exception and use Either or Maybe to wrap them

<dminuoso> albet70: In general, it's better to encode a failure as `Maybe` or
           `Either s` rather than producing an error (like div does)    [17:12]

<albet70> so could we say traverse another version of fmap which it can do
          earlier exit?

>>= can do early exit, because >>= meet Nothing or Left a will break computation chain and return, it's >>='s definition in Control.Monad.Trans.Except
>>= can do it, >> can do it, *> can do it, <$> can't do it, because the type
>>= can do if-else, <$> can't do if-else
function based on >>= can do early exit

traverse (\i -> if odd i then Right () else Left i) [1..10]

traverse use sequence use liftM2 use >>=

Left a or Nothing could break whole computation chain, still need if else to make them, but >>= define break with it

use Left a or Nothing to wrap 1 div 0, avoid runtime error



---------------------------------------------
early return, based on the result not the condition
odd <$> [1..10]  -- when the result is False then return whole computation

takeWhile even [1..10] == [] 

forM_ [1..10] $ \i -> if odd i then Right() else Left i
Left 2

traverse (\i -> if odd i then Right() else Left i) [1..10]
Left 2

why? traverse would exit when meet Left 2?
because traverse defined with sequence, and sequence defined with liftM2
and liftM2 defined with >>=, and >>= meet Left a or Nothing will break whole computation chain and return immediately with it

foldl1 (.) listOfFunctions <$> data
foldr (>=>) pure    this is traverse

fmap can't do if-else then it can't do early exit, but >>= can do if-else, so it can do early exit
other function based on >>= can do early exit

if (result == False) return Left result 
else return Right result

this in >>= can do, and once it's Left, the whole computation after it will break, and return with Left result,
because >>= is defined that in Control.Monad.Trans.Except

----------------------------------------------------------

traverse (\i -> if odd i then Right () else Left i) [1..10] == Left 2
<dminuoso> guest719: `Either a`, like `Maybe`, models computations with exceptions.
<dminuoso> So a `Left err` or `Nothing` has the same semantics as an exception, it shortcircuits the entire computation
<lars8> if any argument is Left, entire computation is Left
<guest719> oh, Left 2 will break the computation chain in >>=
<dminuoso> Yes.
<guest719> dminuoso and why it's that? define in >>= ?
<dminuoso> guest719: Yes.
<dminuoso> The applicative and monadic interface of `Maybe` and `Either s`
           simply models exceptions.                                    [16:56]
<guest719> dminuoso except Left a and Nothing, is there other would break
           computation chain?
<dminuoso> There's no deeper reason than that.
<dminuoso> Sure there are others
<guest719> for examples?
<dminuoso> ExceptT                                                      [16:57]
<dminuoso> Though that's just an `Either s` in disguise


Left a or Nothing will break whole >>= computation chain and return with it immediately, that what Either a or Maybe Monad's effect

and there're two exceptions, one is Either a, that can avoid errors before running, like 1 div 0, read on non integer string,
and there's another one, runtime exception, for example IO socket,
peer disconnect without a signal, that's need to check with error code to detect if the connection is disconnected,

<dminuoso> These are value-level/user-defined exceptions
<dminuoso> guest719: We also have regular RTS exceptions as you know them
           inside IO.
<dminuoso> But in pure computations it might still be useful to have
           shortcircuiting semantics
<dminuoso> Like with traverse.
<dminuoso> Say you have a tree, and you want to process each node - but in a
           way that if you generate an error at any, that the entire
           computation is considered failed.                            [16:59]
<dminuoso> Then you can use `Maybe` or `Either s` (depending on whether you
           want to keep information about the error condition)
<dminuoso> Then producing `Nothing` is semantically equivalent to throwing an
           exception, except we can do this in pure code and without any
           special support from the runtime system.                     [17:00]
<dminuoso> data Maybe a = Nothin | Just a
<dminuoso> instance Monad Maybe where ...
<dminuoso> Voila! You have created exception semantics on your own, no
           exception primitive support needed in the language.

<albet70> can we think it as a failure computation?                     [17:03]
<albet70> what about 1/0?
<albet70> 1/0 is an Exception?
<albet70> IO failure is an Exception?                                   [17:04]
<albet70> fmap (+1) Nothing would be an Exception?                      [17:05]
<dminuoso> `Nothing` acts as an exception, yes.
<dminuoso> 1/0 is an interesting subject for several reasons
<dminuoso> albet70: ^- so you see, this is either Float or Double, at which
           point IEEE 754 semantics apply.
<dminuoso> Under which 1/0 is defined to be either positive or negative
           infinity (depending on the sign of 0)                        [17:08]
<dminuoso> So 1/0 is actually a well defined value, perhaps unintuitively.
<dminuoso> But, what you probably meant is:                             [17:09]
<dminuoso> % 1 `div` 0
<yahb> dminuoso: *** Exception: divide by zero
<albet70> yes, div 0
<dminuoso> albet70: ^- so yeah, this is a partial computation. We could have
           also made it non-partial and given it the type `div :: Integral a
           => a -> a -> Maybe a`, which produces Nothing for that case.


<dminuoso> albet70: In general, it's better to encode a failure as `Maybe` or
           `Either s` rather than producing an error (like div does)    [17:12]

<dminuoso> albet70: The reason is, you cant catch an `error` sensibly (its
           impossible in pure code, and you have imprecise error semantics if
           you try to do this from IO). error is really a sad part in Haskell.
<dminuoso> But you can catch a Nothing just fine (you just pattern match with
           case-of)
<dminuoso> Dont even need IO for that.
<albet70> but haskell does try catch to capture runtime errors like IO error
                                                                        [17:15]
<albet70> and IO socket error, how to use Either to detect?
<dminuoso> haskell does not try and catch runtime errors at all         [17:16]
<dminuoso> They blow up your entire program
<dminuoso> You have to explicitly catch them in IO                      [17:17]
<dminuoso> And it's subtly difficult to do this because of lazy evaluation
<dminuoso> Consider
<dminuoso> % :t evaluate
<yahb> dminuoso: a -> IO a
<dminuoso> This one only evaluates up until WHNF. You could still have errors
           lingering in not-yet-evaluated parts. There's tricks to get around
           this, but you need to be aware of this                       [17:18]

<dminuoso> It's why uses of `error` are highly discouraged, since it's
           completely unclear which library functions could possibly trigger
           an `error`. The most common one that regularly causes headaches for
           me is\                                                       [17:19]
<dminuoso> % :t read
<yahb> dminuoso: Read a => String -> a
<dminuoso> If you think about it, it should be dead obvious that this is
           *very* partial (by very I mean almost all strings produce an
           invalid result, only very few strings produce a parsable value)
<dminuoso> But this type of error quickly bubbles up and cant be reasonably
           caught anymore                                               [17:20]
<dminuoso> A way better function instead is:

<dminuoso> % import Text.Read (readMaybe)
<yahb> dminuoso: 
<dminuoso> % :t readMaybe
<yahb> dminuoso: Read a => String -> Maybe a


<guest719> dminuoso about traverse "<dminuoso> Say you have a tree, and you
           want to process each node - but in a way that if you generate an
           error at any, that the entire computation is considered failed."
           could we use foldr >=> pure here?                            [18:06]
<guest719> a bunch of function inside a list, then foldr
<guest719> apply on this tree, if one node failed, then return immediatly
<dminuoso> guest719: Firstly, `f >=> pure = f`
<dminuoso> guest719: And what you are thinking of already is traverse
           precisely.
<dminuoso> % :t traverse
<yahb> dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t
       b)
<guest719> dminuoso fmap can't do early exit because it's type, but >>= can do
           early exit                                                   [18:26]
<dminuoso> guest719: Yes, and traverse uses >> internally
<dminuoso> (So it's a bit more general even)
<guest719> dminuoso I remeber there're different between fmap and >>=
<dminuoso> % :t (>>)                                                    [18:27]
<yahb> dminuoso: Monad m => m a -> m b -> m b
<guest719> >>= can do if-else, and fmap can't do if-else
<dminuoso> Well, strictly speaking:
<dminuoso> % :t (*>)
<yahb> dminuoso: Applicative f => f a -> f b -> f b
<dminuoso> guest719: `traverse` can be thought to use (*>) internally, which
           is just an Applicative version of >>
<dminuoso> Roughly the idea is:                                         [18:28]
*** merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined channel #haskell
                                                                        [18:29]
<dminuoso> We take this function (a -> f b) (say `String -> IO Int`)from
           above, and we `fmap` over the structure (say `[String]`). Then,
           each value is replaced with a computation of some type (say `IO
           Int`), so the whole structure then is `[IO Int]`.
<dibblego> you might be thinking of traverse_
<dminuoso> Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
<dminuoso> Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs;
           sequence [] = pure []                                        [18:32]
<dminuoso> dibblego: Ah yeah. I guess that was wrong of me.
<dminuoso> While I was typing the definition, I realized my mistake.    [18:33]
<dminuoso> % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] =
           pure []
<yahb> dminuoso: 
<dminuoso> % :t mySequence
<yahb> dminuoso: Applicative f => [f a] -> f [a]
<dibblego> I think sequence is more obvious in the way you are trying to
           explain it, like this:
<dminuoso> % mySequence [Just 10, Just 20, Just 30]
<yahb> dminuoso: Just [10,20,30]
<dibblego> (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence
           xs; sequence [] = lift0 []                                   [18:34]
<dibblego> once liftA2 is understood conceptually, then (*>) is quite simply:
           const id with some liftA2-ness                               [18:35]

<albet70> so could we say traverse another version of fmap which it can do
          earlier exit?
<[exa]> "another" may be a weak label for the myriad of extra stuff it can do
        :]                                                              [19:21]

<dminuoso> albet70: Mmm, not just that. 
<dminuoso> albet70: Say you have a Tree of values, say of type String. For
           each string you want to query some database, and replace the string
           with some value you read from the database, say something of type
           User.
<dminuoso> then you can do: do { userTree <- traverse fetchUserFromString
           stringTree; ... }                                            [19:29]
<dminuoso> albet70: The key thing to realize is that Applicative/Monad encode
           certain.. "effects". For `Maybe/Either e` the effect is that of an
           exception, for IO it's outside world interaction, for list it's
           non-determinism, etc..
<dminuoso> So we map each element to an effectful computation, and then
           sequence them                                                [19:30]
<dminuoso> Important bit to notice, is that traverse fundamentally does not
           change the "shape" of that structure. So if you traverse over a
           tree, the shape of it remains (so you cant drop or create nodes)
<dminuoso> traverse on a list for example gives us a more generalized version
           of effectful loops. So a Python loop in which you do say database
           queries can be written with `traverse`                       [19:31]
<dminuoso> But `traverse` allows us to do even more, not just database queries
<dminuoso> And it works on not just lists, but also trees.              [19:32]

<dibblego> traverse is exactly fmap, if you use Identity in place of the
           general Applicative                                          [20:04]

<dibblego> but it also does other Applicative things, not just Identity

<Axman6> IO is pure, the execution of it may not be.
<[exa]> zangi: haskell is pure; the ugly impure execution of the IO action
        recipes written in haskell is only done by computers            [21:07]

---------------------------------------------------
ealier exit in map
map (+1) [1,2,3,5,7] 
how to let it once meet 3 then exit whole computation?
callCC ? ContT r [] a?
without map, recursion function can do that
in other languages's iteration, break and return can do that

but not all the languages support TCO except haskell and scheme

and kotlin doesn't too

 fun foo() {
        val t = run loop@{
            listOf(1, 2, 3, 4, 5).forEach {
                if (it == 1) return@loop 1 // non-local return from the lambda passed to run
                if (it == 3) return@loop 3 // non-local return from the lambda passed to run
            }
        }
        println(t)

    }
    foo()
