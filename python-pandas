join_list = lambda m: list(reduce(lambda x,y: x+y, m))

df = DataFrame(read_excel(file_path, sheet_name))
#column = list(df["Unnamed: 1"])
row = [[1,2],[5,6]]

get_data = lambda column_name, row: join_list([ list(df[column_name][x[0]:x[1]]) for x in row ])

data = get_data("Unnamed: 1", row)

liftA2_list = lambda f, xs, ys: [ f(x,y) for x in xs for y in ys ]

all_data = liftA2_list(lambda c, r: list(df[c][r[0]:r[1]]), ["Unnamed: 1", "Unnamed: 2"], row)



this case is good for Scheme's macro, but in python there's no macro, so use eval
there's a list like [0..100], you need to run code like obj.f(0).f(1)...f(100)
how to generate this code? use eval   

color_column_name = ['X1', 'X3'...]
color_column = {'X1': f1, 'X2': f2...}

    # new_df = new_df.style.apply(color_column['X1'], subset=['X1'], axis=1)\
    #                     .apply(color_column['X3'], subset=['X3'], axis=1)\
    #                     .apply(color_column['Y5'], subset=['Y5'], axis=1)\
    #     .apply(color_column['Y7'], subset=['Y7'], axis=1)\
    #     .apply(color_column['VX9'], subset=['VX9'], axis=1)\
    #     .apply(color_column['VX11'], subset=['VX11'], axis=1)\
    #     .apply(color_column['VY13'], subset=['VY13'], axis=1)\
    #     .apply(color_column['VY15'], subset=['VY15'], axis=1)\
    #     .apply(color_column['H17'], subset=['H17'], axis=1)\
    #     .apply(color_column['H19'], subset=['H19'], axis=1)\


    concat_str = "new_df.style"
    for i in color_column_name:
        concat_str = concat_str + f".apply(color_column['{i}'], subset=['{i}'], axis=1)"

    print(concat_str)
    new_df = eval(concat_str) 

or use reduce
    new_df = reduce(lambda obj,x: obj.apply(color_column[x], subset=[x], axis=1), [new_df.style] + color_column_name)

    reduce use return value as the first variable for next computation



color_column = {}
color_column["Unnamed: 1"] = [lambda x: ['background-color: ' + '#FFFFFF'], lambda x: ...]
color_column_name = ["Unnamed: 1"]

df = reduce(lambda obj, x: obj.apply(color_column[x], subset=[x], axis=1),
                [df.style] + color_column_name)

df.insert(1, "Unnamed: 2", [1,2])

----------------------------------------------------------------------
# color 
from pandas import *

df = DataFrame()
df.insert(0,'Test',[1,2,3])

# this is needed, otherwise, to_excel only do the original DataFrame
df = df.style.apply(lambda x: ["background-color:green"], axis=1)
df.to_excel("test.xlsx")

after df.style.apply() it will be a Styler object, not a DataFrame object
and df = df.style.apply() is needed
-------------------------------------

python pandas handle csv file
the csv file, it may contain headers info on its first line, and that can't be passed to pandas
use pandas.read_csv(input_file, skiprows=n) to skip the n lines
https://www.cnblogs.com/luckyplj/p/13193985.html
https://www.geeksforgeeks.org/ways-to-filter-pandas-dataframe-by-column-values/
https://stackoverflow.com/questions/36213383/pandas-dataframe-how-to-apply-function-to-a-specific-column


if __name__ == "__main__":
        input_file = "a.csv"

        dataset = pd.read_csv(input_file, skiprows=2) # skip 2 lines
        df = pd.DataFrame(dataset, columns=['id','x']) # only take id and x column

        result = df[df['x'] > 100] # filter row which x greater than 100 
        print(result)

