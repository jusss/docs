
remove_dup = lambda alist: [alist[i] for i in range(len(alist)) if alist[i] not in alist[i+1::]]
# print(remove_dup(result))

# [("a",1), ("b",2), ("a",3)...] to [("a",[1,3...]), ("b",[...])...]
# M.fromListWith (++) . fmap (fmap pure)
# M.fromListWith (<>) . map (fmap S.singleton)

r1 = remove_dup(result)

the_first_ones = remove_dup(list(map(lambda xy: xy[0], r1)))
print(the_first_ones)

# r2 :: [(String,[String])]
r2 = map(lambda first_one: (first_one, list(map(lambda xy: xy[1], filter(lambda xy: xy[0] == first_one, r1)))), the_first_ones)
# r2 = map(lambda first_one: (first_one, [ y for (x,y) in r1 if x == first_one ]), the_first_ones)


# for path, data in r1:
    # print(f'{path}\n{data}\n')

for path, data in r2:
    print(f'****** {path}')
    list(map(print, data))
    print('')
-------------------------------
check if all elements are equal in a list
allEqual :: (Eq a) => [a] -> Bool
allEqual xs = and $ zipWith (==) <*> tail $ xs

ap_func = lambda g, f: lambda x: g(x, f(x))
ap = ap_func
tail = lambda xs: xs[1:]
zipWith = lambda f, alist, blist: [ f(alist[i], blist[i]) for i in range(len(alist if len(alist) < len(blist) else blist)) ]
eq = lambda x, y: x == y
all_equal = lambda xs: all(ap(partial(zipWith, eq), tail)(xs))

---------------------------------
there're two list, alist ["a","b","c"] and blist ["awe", "bword", "ces", "de"]
print that blist's element which contain alist's element

in python it would be 

for a in alist:
    for b in blist:
        if a in b:
            print(b)

[ b for a in alist for b in blist if a in b ]

in haskell with list comprehension
[ e | i <- lista, e <- listb, elem i e ]

try fmap . fmap 

import Data.List

alist = ["a","b","c"]
blist = ["awe","bword","fc","wf","lp"]

getSeq :: String -> String -> Maybe String
getSeq x y = if x `isSubsequenceOf` y
                then Just y
                else Nothing

{- main = print $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist -}
{- [Just "awe",Just "bword",Just "fc"] -}
main = print $ foldl1 (<>) $ fmap (filter (/= Nothing)) $ fmap (\a -> fmap (\b -> getSeq a b) blist) alist

main = print $ filter (/= Nothing) $ liftA2 getSeq alist blist

fmap ((`fmap` blist) . getSeq) alist

fmap g . fmap f = fmap (g . f)

liftM2 == liftA2
liftA2 take one of alist and all of blist, until alist is over 
liftA2 getSeq alist blist = join (fmap (\a -> fmap (\b -> getSeq a b) blist) alist)

liftA2 (+) [1..3] [2..6] == [3,4,5,6,7,4,5,6,7,8,5,6,7,8,9]

liftA2 @((->)_) :: (a -> b -> c) -> (_ -> a) -> (_ -> b) -> _ -> c
liftA2 f g h = \x -> f (g x) (h x)

liftA2 f alist blist = join (fmap (\a -> fmap (\b -> f a b) blist) alist)

https://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free
@free reverse :: [a] -> [a]
$map f . reverse = reverse . $map f



----------------------------------------

replace a serial in a list by index range

replace_by_index_range = lambda f, alist, index_range: [alist[i] if i not in index_range else f(i)  for i in range(len(alist))]

zipWith = lambda f, alist, blist: [ f(alist[i], blist[i]) for i in range(len(alist if len(alist) < len(blist) else blist)) ]

join = list(reduce(lambda x,y: x+y, alist))

------------------------------------------------

findElementInList = lambda element, alist: [y for x, y in zip(alist, list(range(len(alist)))) if x == element]

print(findElementInList(3,[1,2,3,5,6,3])) == [2,5]


liftM2 one in alist, match all in blist, 
same as

[ f(i,m) for i in alist for m in blist ]
------------------------------
intersect = lambda alist, blist: [ i for i in alist if i in blist ]
------------------------------
groupby == alist in python

let a = 3, which can be [ for a in [3] ]

alist.sort()
[ [alist[i+1]] for i in range(len(alist)-1) if alist[i] == alist[i+1] ]

[ [alist[i]] + [alist[i+1]] if alist[i] in alist[i+1::] else [alist[i]] for i in range(len(alist)) ]

[ [alist[i]] + [alist[i+1]] if alist[i] in alist[i+1::] else [alist[i]] for i in range(len(alist)) ]




-------------------------------
let alist = ["ab","ef","ij"]; blist = ["cd","gh","kl"] in [ (alist !! n) <> (blist !! n) | n <- [0..(length alist)-1] ]

it is `zip`, but zip is using patter matching and recursive defined in haskell

but in python, we can define it with list comprehension

zip = lambda alist, blist: [ (alist !! n) <> (blist !! n) | n <- [0..(length alist)-1] ]

fmap (+) alist blist, it's zipWith, since fmap only work on one list
also there is liftM2 for one item in alist to match all items in blist
----------------------------------------------
remove duplicate elements in a list,
if element is not show up in the rest, then it is single
the list comprehension, express the question with list comprehension, and the anwser it is

alist=[1,1,3,5,6,3,9,2]

[alist[i] for i in range(len(alist)) if alist[i] not in alist[i+1::]]

[ alist !! n | n <- [0..(length(alist) - 1)], (alist !! n) `notElem` (drop (n+1) alist) ]

[x | (x:xs) <- tails alist, x `notElem` xs ]

------------------------------------------------
["ab","cd","ef"] ["gh","ij", "kl"] to get ["abgh", "cdij", "efkl" ]

[ alist[i] + blist[i] for i in range(len(alist)) ]

fmap (\x,y -> x+y) 


--------------------------------
[ f(x) for i in alist ]

map( f, alist) = [ f(i) for i in alist ]
map f alist = [ f i | i <- alist ]

haskell does not have list slice like python alist[i::]
but haskell has dropWhile takeWhile to do the same thing 

for example, get the a digit string from a string's end, 
"abc12" -> "12", "ab12c3" -> "3"
[ alist[i::] for i in range(len(alist)) if alist[i::].isdigit() ]

[ if (isDigit (drop n alist)) then (drop n alist) else [] | n <- [0.. (length alist)] ]

[ drop n alist | n <- [0..(length alist)], all isDigit (drop n alist) ]


[ a <> b | a <- alist, b <- blist ]
[ x + y for x in alist for y in blist ]

[ if ... then ... else ... | x <- alist, odd x ]
[ ... for i in alist if odd(i) ]

-----------------------------
toolz.groupby(len,["a","bc"])
{1: ['a'], 2: ['bc']}
-------------------
[ alist[i::] for i in range(len(alist)) if alist[i::].isdigit() ]
"abc12d56" == [ "56" ]
---------------------
use 'in' to do intersect
"ab" in "abc" == True
----------------------------------------------------
二面代码题
给进一个数组 找出三个下标不同的数，和为0。输出所有符合要求的元素组。
示例：
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]]

#blist = [[alist[x],alist[y],alist[z]] for x, y, z in range(len(alist)) if (alist[x] + alist[y] + alist[z] == 0) && (x!= y) && (y!=z)]
#list(set(blist))
#[blist[i] for i in range(len(blist)) if blist[i] not in blist[i+1::]]

[[x,y,z] for i in range(len(alist) - 2) for x in [alist[i]] for y in alist[i+1::] for z in alist[i+2::] if (x+y+z == 0)]
== [[-1, 0, 1], [-1, 2, -1], [-1, -1, 2], [0, 1, -1]]

blist = [[-1, 0, 1], [-1, 2, -1], [-1, -1, 2], [0, 1, -1]]

[ i.sort() for i in blist ]

blist == [[-1, 0, 1], [-1, -1, 2], [-1, -1, 2], [-1, 0, 1]]

[ blist[i] for i in range(len(blist)) if blist[i] not in blist[i+1::] ]
== [[-1, -1, 2], [-1, 0, 1]]

using list comprehension to express the question will get the anwser
---------------------------------------------------
remove duplicate elements in a list
list(set(alist))
alist=[1,1,3,5,6,3,9,2]
[alist[i] for i in range(len(alist)) if alist[i] not in alist[i+1::]]
[1, 5, 6, 3, 9, 2]

----------------------------------------------
get single element in a list

alist=[1,1,3,5,6,3,9,2]
[alist[i] for i in range(len(alist)) if alist[i] not in (alist[i+1::] + alist[:i:])]
[5, 6, 9, 2]

list slice [start:end:step] 
[::-1] is reverse
[:i:] is before i
[i::] is after i

alist.sort() will change alist itself, not return something

elemIndices = lambda elem, alist: [i for i in range(len(alist)) if alist[i] == elem]
elemIndices( 3, [1,3,32,3,4]) == [1, 3]

get the single element in a list
b=[1,3,32,3,4]
[i for i in b if len(elemIndices(i,b)) == 1]   ==   [1, 32, 4]

--------------------------------------------------
def decorator(func):
    def wrapper():
        doSomething
        func()
        doSomething
    return wrapper

@decorator
def afunc():
    ...

>> def f():
...     x=0
...     while True:
...             x=x+1
...             print(x)
...             yield x
... 
>>> f2=f()
next(f2) // 2

try:
   Business Logic here...
except "Invalid level!":
   Exception handling here...
else:
   Rest of the code here...

check file exists
file_exists = os.path.exists('readme.txt')

write file
with open('readme.txt', 'w') as f:
    f.write('readme')

list(filter(lambda x: x> 2, [1,2,3]))  ==   [3]

list(range(3))  [0, 1, 2]

alist=list(range(500))

functools.reduce(lambda x,y: x+y, alist)
124750

list(map (lambda x: x+1, [1,2]))
[2, 3]

--------------------------------
conversion in str and int

str(10) == '10'
int('10') == 10

-----------------------
list to string, "".join(list)
str to list, list(str)
--------------------------
bytecode.decode() to str
str.encode() to bytecode 
----------------------------

toolz.groupby(lambda x: x> 3, [1,2,3,5,6])   ==   {False: [1, 2, 3], True: [5, 6]}
