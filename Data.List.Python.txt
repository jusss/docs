
findElementInList = lambda element, alist: [y for x, y in zip(alist, list(range(len(alist)))) if x == element]

print(findElementInList(3,[1,2,3,5,6,3])) == [2,5]


liftM2 one in alist, match all in blist, 
same as

[ f(i,m) for i in alist for m in blist ]
------------------------------
intersect = lambda alist, blist: [ i for i in alist if i in blist ]
------------------------------
groupby == alist in python

let a = 3, which can be [ for a in [3] ]

alist.sort()
[ [alist[i+1]] for i in range(len(alist)-1) if alist[i] == alist[i+1] ]

[ [alist[i]] + [alist[i+1]] if alist[i] in alist[i+1::] else [alist[i]] for i in range(len(alist)) ]

[ [alist[i]] + [alist[i+1]] if alist[i] in alist[i+1::] else [alist[i]] for i in range(len(alist)) ]




-------------------------------
let alist = ["ab","ef","ij"]; blist = ["cd","gh","kl"] in [ (alist !! n) <> (blist !! n) | n <- [0..(length alist)-1] ]

it is `zip`, but zip is using patter matching and recursive defined in haskell

but in python, we can define it with list comprehension

zip = lambda alist, blist: [ (alist !! n) <> (blist !! n) | n <- [0..(length alist)-1] ]

fmap (+) alist blist, it's zipWith, since fmap only work on one list
also there is liftM2 for one item in alist to match all items in blist
----------------------------------------------
remove duplicate elements in a list,
if element is not show up in the rest, then it is single
the list comprehension, express the question with list comprehension, and the anwser it is

alist=[1,1,3,5,6,3,9,2]

[alist[i] for i in range(len(alist)) if alist[i] not in alist[i+1::]]

[ alist !! n | n <- [0..(length(alist) - 1)], (alist !! n) `notElem` (drop (n+1) alist) ]

[x | (x:xs) <- tails alist, x `notElem` xs ]

------------------------------------------------
["ab","cd","ef"] ["gh","ij", "kl"] to get ["abgh", "cdij", "efkl" ]

[ alist[i] + blist[i] for i in range(len(alist)) ]

fmap (\x,y -> x+y) 


--------------------------------
[ f(x) for i in alist ]

map( f, alist) = [ f(i) for i in alist ]
map f alist = [ f i | i <- alist ]

haskell does not have list slice like python alist[i::]
but haskell has dropWhile takeWhile to do the same thing 

for example, get the a digit string from a string's end, 
"abc12" -> "12", "ab12c3" -> "3"
[ alist[i::] for i in range(len(alist)) if alist[i::].isdigit() ]

[ if (isDigit (drop n alist)) then (drop n alist) else [] | n <- [0.. (length alist)] ]

[ drop n alist | n <- [0..(length alist)], all isDigit (drop n alist) ]


[ a <> b | a <- alist, b <- blist ]
[ x + y for x in alist for y in blist ]

[ if ... then ... else ... | x <- alist, odd x ]
[ ... for i in alist if odd(i) ]

-----------------------------
toolz.groupby(len,["a","bc"])
{1: ['a'], 2: ['bc']}
-------------------
[ alist[i::] for i in range(len(alist)) if alist[i::].isdigit() ]
"abc12d56" == [ "56" ]
---------------------
use 'in' to do intersect
"ab" in "abc" == True
----------------------------------------------------
二面代码题
给进一个数组 找出三个下标不同的数，和为0。输出所有符合要求的元素组。
示例：
Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]]

#blist = [[alist[x],alist[y],alist[z]] for x, y, z in range(len(alist)) if (alist[x] + alist[y] + alist[z] == 0) && (x!= y) && (y!=z)]
#list(set(blist))
#[blist[i] for i in range(len(blist)) if blist[i] not in blist[i+1::]]

[[x,y,z] for i in range(len(alist) - 2) for x in [alist[i]] for y in alist[i+1::] for z in alist[i+2::] if (x+y+z == 0)]
== [[-1, 0, 1], [-1, 2, -1], [-1, -1, 2], [0, 1, -1]]

blist = [[-1, 0, 1], [-1, 2, -1], [-1, -1, 2], [0, 1, -1]]

[ i.sort() for i in blist ]

blist == [[-1, 0, 1], [-1, -1, 2], [-1, -1, 2], [-1, 0, 1]]

[ blist[i] for i in range(len(blist)) if blist[i] not in blist[i+1::] ]
== [[-1, -1, 2], [-1, 0, 1]]

using list comprehension to express the question will get the anwser
---------------------------------------------------
remove duplicate elements in a list
list(set(alist))
alist=[1,1,3,5,6,3,9,2]
[alist[i] for i in range(len(alist)) if alist[i] not in alist[i+1::]]
[1, 5, 6, 3, 9, 2]

----------------------------------------------
get single element in a list

alist=[1,1,3,5,6,3,9,2]
[alist[i] for i in range(len(alist)) if alist[i] not in (alist[i+1::] + alist[:i:])]
[5, 6, 9, 2]

list slice [start:end:step] 
[::-1] is reverse
[:i:] is before i
[i::] is after i

alist.sort() will change alist itself, not return something

elemIndices = lambda elem, alist: [i for i in range(len(alist)) if alist[i] == elem]
elemIndices( 3, [1,3,32,3,4]) == [1, 3]

get the single element in a list
b=[1,3,32,3,4]
[i for i in b if len(elemIndices(i,b)) == 1]   ==   [1, 32, 4]

--------------------------------------------------
def decorator(func):
    def wrapper():
        doSomething
        func()
        doSomething
    return wrapper

@decorator
def afunc():
    ...

>> def f():
...     x=0
...     while True:
...             x=x+1
...             print(x)
...             yield x
... 
>>> f2=f()
next(f2) // 2

try:
   Business Logic here...
except "Invalid level!":
   Exception handling here...
else:
   Rest of the code here...

check file exists
file_exists = os.path.exists('readme.txt')

write file
with open('readme.txt', 'w') as f:
    f.write('readme')

list(filter(lambda x: x> 2, [1,2,3]))  ==   [3]

list(range(3))  [0, 1, 2]

alist=list(range(500))

functools.reduce(lambda x,y: x+y, alist)
124750

list(map (lambda x: x+1, [1,2]))
[2, 3]

--------------------------------
conversion in str and int

str(10) == '10'
int('10') == 10

-----------------------
list to string, "".join(list)
str to list, list(str)
--------------------------
bytecode.decode() to str
str.encode() to bytecode 
----------------------------

toolz.groupby(lambda x: x> 3, [1,2,3,5,6])   ==   {False: [1, 2, 3], True: [5, 6]}
