closure with map
what if we want a function that do different behavior on different index element on a list
for example, a list has [1,1,1]
then if the list position is 0, f add 1 on it
is 1, add 2
is 2, add 3

use closure or object to archive that

def gc():
        n=0
        def inner(x):
                nonlocal n
                n=n+1
                return x+n
        return inner
fwc=gc()
print(list(map(fwc,[1,1,1]))) == [2, 3, 4]

the fwc which is inner, it's changing after every call
---------------------------------------------------------
#!/usr/bin/env runhaskell

import Control.Monad.State

gc :: Integer -> State Integer Integer
gc x = do
  oldN <- get
  let newN = oldN + 1
  put newN
  return (x + newN)

main :: IO ()
main = do
  print (evalState (traverse gc [1,1,1]) 0)

-- in haskell, put whole code inside a State, and change it inside the State
