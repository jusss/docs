http://www.douban.com/note/66859771/

Consider the simple examples below.

(call/cc
  (lambda (k)
    (* 5 4))) ⇒ 20
(call/cc
  (lambda (k)
    (* 5 (k 4)))) ⇒ 4
(+ 2
  (call/cc
    (lambda (k)
      (* 5 (k 4))))) ⇒ 6

In the first example, the continuation is obtained and bound to k, but k is never used, so the value is simply the product of 5 and 4. In the second, the continuation is invoked before the multiplication, so the value is the value passed to the continuation, 4. In the third, the continuation includes the addition by 2; thus, the value is the value passed to the continuation, 4, plus 2.

continuation就是表达式求值之后的运算
continuation就是(call/cc (lambda (k) ...))之后的运算，而且这个continuation就是call/cc里面lambda的参数k
(+ 3 (call/cc (lambda (k) ...))) 这个continuation就是(+ 3 x), 一旦这个lambda求值之后，后面的运算就是加3, 加3这个运算就是continuation
就好比有个continuation k是(+ 3 x)即表示加3这个运算，然后通过(k 9)这种方式把9传递给continuation k,让它去加3, 这个加3的运算就是continuation

1. continuation k就是一个等待参数的运算(或者叫过程或函数)
2. (k 9)通过这种方式把参数9传递给continuation k

利用2的这个特性可以在(call/cc (lambda ...))里面的循环计算中退出来带着一个值，类似break + return
比如求出列表(1 2 3 4 5 6 7 8)最接近于6且大于6的数
创造一个啥也不计算的continuation,就是(call/cc ...)之后没有需要运算的表达式
(call/cc (lambda (k) (map (lambda (x) (if (> x 6) (k x) 1)) '(1 2 3 4 5 6 7 8))))   => 7

continuation : 等待参数的运算/过程/函数
一旦参数被传递，马上进行运算
(k 9)这种方式传递参数

http://community.schemewiki.org/?call-with-current-continuation

利用1的特性可以把continuation用作label然后通过传递参数给continuation来做goto重新运算

(define (bla)
        (define goto 0)
        (call/cc (lambda (k) (set! goto k)))
        (display 10)
        (goto 1))


还可以用来做循环无论是在call/cc里面还是外面
显示10个0
(define (bla)
        (define c 0)
        (define count 10)
        (call/cc (lambda (k) (set! c k)))
        (if (> count 0) (begin (display 0) (set! count (- count 1)) (c count))))

或者
先用一个continuation l做一个loop用goto
(define (loop exp exp1 exp2)
        (define goto 0)
        (call/cc (lambda (k) (set! goto k)))
        (exp exp1 exp2)
        (goto 1))

(define (compare x l)
        (if (> x 0) (dispaly 0) (l 1)))
        
然后再来个call/cc内部的循环去显示10个0

(define display0
  (lambda (n)
    (call/cc (lambda (k)
	     
	       (define loop
		 (lambda (x)
		   (define goto 0)
		   (call/cc (lambda (s) (set! goto s)))
		   (x)
		   (goto 1)))

	       (define func
		 (let ((a n))
		   (lambda (x)
		     (if (> a 0) (begin (display 0) (set! a (- a 1)))
		       (x 0)))))
	     
	       (loop (lambda () (func k)))))))

continuation可以做 break, return, goto, loop


3. call/cc里面写不出循环用continuation, 除非里面再加个call/cc然后在里面那个call/cc外面
来个循环用continuation,这样就可以在call/cc里面用continuation写循环

;;; fibonacci with continuation
(define (fib n)
  (call/cc (lambda (k)
	     (if (= n 0) (k 0)
	       (if (< n 3) (k 1)
		 (let ((m n) (k2 0) (a 0) (b 1) (c 1))
		   (call/cc (lambda (s) (set! k2 s)))
		   (if (> m 2) (begin (set! a b)
				      (set! b c)
				      (set! c (+ a b))
				      (set! m (- m 1))
				      (k2 m))
		     (k c))))))))
_______________________________________________________________________

(define noname
	   (lambda (n)
	     (let ((m n))
	       ((lambda () (set! m (+ m 1)) m)))))
(noname 4)执行多少次都是5,因为每次执行都重新赋值在let里

racket@> (define n 3)
racket@> (define nob
	   (let ((m n))
	     (lambda ()
	       (set! m (+ m 1))
	       m)))
racket@> (nob)
4
racket@> (nob)
5
racket@> (define n 9)
racket@> (nob)
6
racket@> (nob)
7
racket@> 
用这种办法可以解决用let写closure时,let的参数是从外面某个变量里获取的而不是已知的,这样可以在第一次执行时绑定外面那个变量,即使外面变量变了也和这个closure没关系，因为它绑定了
第一次执行时这个变量的值,如果let在lambda里面的话,每次执行lambda都会重新用let赋值而无意义

(define display0
  (lambda (n)
    (call/cc (lambda (k)
	     
	       (define loop
		 (lambda (x)
		   (define goto 0)
		   (call/cc (lambda (s) (set! goto s)))
		   (x)
		   (goto 1)))

	       (define func
		 (let ((a n))
		   (lambda (x)
		     (if (> a 0) (begin (display 0) (set! a (- a 1)))
		       (x 0)))))
	     
	       (loop (lambda () (func k)))))))

在call/cc里面continuation k可以用作break, return
在call/cc外面continuation k可以用作goto, loop

