
this case is good for Scheme's macro, but in python there's no macro, so use eval
there's a list like [0..100], you need to run code like obj.f(0).f(1)...f(100)
how to generate this code? use eval   

color_column_name = ['X1', 'X3'...]
color_column = {'X1': f1, 'X2': f2...}

    # new_df = new_df.style.apply(color_column['X1'], subset=['X1'], axis=1)\
    #                     .apply(color_column['X3'], subset=['X3'], axis=1)\
    #                     .apply(color_column['Y5'], subset=['Y5'], axis=1)\
    #     .apply(color_column['Y7'], subset=['Y7'], axis=1)\
    #     .apply(color_column['VX9'], subset=['VX9'], axis=1)\
    #     .apply(color_column['VX11'], subset=['VX11'], axis=1)\
    #     .apply(color_column['VY13'], subset=['VY13'], axis=1)\
    #     .apply(color_column['VY15'], subset=['VY15'], axis=1)\
    #     .apply(color_column['H17'], subset=['H17'], axis=1)\
    #     .apply(color_column['H19'], subset=['H19'], axis=1)\


    concat_str = "new_df.style"
    for i in color_column_name:
        concat_str = concat_str + f".apply(color_column['{i}'], subset=['{i}'], axis=1)"

    print(concat_str)
    new_df = eval(concat_str) 

or use reduce
    new_df = reduce(lambda obj,x: obj.apply(color_column[x], subset=[x], axis=1), [new_df.style] + color_column_name)

    reduce use return value as the first variable for next computation

