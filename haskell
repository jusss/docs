

adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html

2 -> (+3) 2 -> 5

Functor: apply a function to a wrapped value and get a wrapped value
fmap    (+3)   (Just 2) -> Just 5
fmap ::(a->b)-> f    a  ->  f   b

<$> is the infix version of fmap

(+3) <$> Just 2  is same to fmap (+3) Just 2

Applicatives: apply a wrapped function to a wrapped value and get a wrapped value
Just (+3)  <*>  Just 2  == Just 5

[(*2), (+3)] <*> [1,2,3]   ==    [2,4,6,4,5,6]

(*) <$> Just 5 <*> Just 3 == Just 15
liftA2 (*) (Just 5) (Just 3)  ==  Just 15        liftA2 does the same thing

Monad: apply a function to a wrapped value, but that function take unwrapped value and return a wrapped value, the function is >>=  and it's pronounced bind.

half x = if even x
         then Just (x `div` 2)
         else Nothing

Just 3 >>= half     == Nothing        use >>= to shove the wrapped value to the function

>>= :: m a -> (a-> m b) -> m b
      Just 3     half      Nothing
      Just 6     half     Just 3

Just 6 >>= half     == Just 3

λ> Just 20 >>= half >>= half >>= half
Just 5
λ> Just 20 >>= half >>= half >>= half
Nothing

IO Monad
getLine >>= readFile >>= putStrLn

λ> getLine >>= readFile >>= putStrLn
test.hs
module X where
half x = if even x
         then Just (x `div` 2)
         else Nothing
              

λ> 


######################################################

Either a b   use typeclass create a Int|String

f::Int -> Maybe Int

module module-name-for-other-files (export-function-name) where      where like {} after int main()

#!/usr/bin/runhaskell   in archlinux

or $runhaskell Main.hs

cabal package manager like pip in python

if ... then ... else ...
case ... of ...
let ... in ...

data Position = MakePosition Double Double
PointA :: Position
PointA = MakePosition 0 0

PointB :: Position
PointB = MakePosition 3 4

distance:: Position -> Position -> Double
distance p1 p2 =
         case p1 of
              MakePosition x1 y1 ->
                     case p2 of
                          MakePosition x2 y2 -> sqrt ((x1-x2)^2 + (y1-y2)^2)

use case...of... get value from a value create by value constructor
case x of
     pattern1 -> expression1
     pattern2 -> expression2

use let ... in ... can get the value
getX :: Position -> Double
getX p = let MakePosition x _ = p
         in x
pointFoo :: Position
pointFoo = MakePosition 3 4
getX pointFoo  will get 3

or just define a function

f::Position -> Double
f MakePosition x y = x

data Position = MakePosition a a 是错的，=右侧出现的type variable必须在=左侧出现过
但=左侧出现的type variable可以不出现在=右侧

data Position a = MakePosition Int Int
MakePosition 2 2 :: Position a
MakePosition 2 2 :: Position Char
MakePosition 2 2 :: Position Double
MakePosition 2 2 :: Position String     因为这个a是未知类型，没有明确指出类型或进行类型约束

data Maybe a = Just a | Nothing
Nothing :: Maybe a
Nothing :: Maybe Int
Nothing :: Maybe Char

module X where
import Text.Read
parseInt :: String -> Maybe Int
parseInt = readMaybe

λ> parseInt "3"
Just 3
λ> parseInt "abc"
Nothing


Either a b    a type can be Int or String

parseInt :: Maybe String -> Maybe Int    how to define this function?

################################################################

haskell的函数类型是什么? 返回值的类型? 为什么函数无法用于模式匹配?
codeHZ: 可以认为是 -> 类型构造器没有对应的值构造器,属于编译器特殊支持

module Test where
data Struct val =
                Empty
                | NonEmpty StructType val
data StructType =
                Exec1
                | Exec2
apply::Struct a -> String
apply (Empty) = "empty"
apply (NonEmpty exec struct) = "exec1 or exec2"                

                               
--apply Empty
--apply (NonEmpty Exec1 undefined)
--apply (NonEmpty Exec1 "aha")
--apply (NonEmpty Exec2 3)
--apply (NonEmpty Exec2 (\x -> 3 +x))
--apply (NonEmpty Exec2 ())
                
apply2::(Show a)=> Struct a -> String
apply2 (NonEmpty exec struct) = "exec1 or exec2"

--apply2 (NonEmpty Exec1 "a")                                
                                
apply3::(Show a)=> Struct a -> String
apply3 (NonEmpty exec _) = "exec1 or exec2"


<jusss> data Struct val = Empty | NonEmpty StrucType val;   data SturctType =
        Exec1 | Exec2;   apply::Struct a-> String;    apply (NonEmpty exec
        struct) ="exec1 or exec2"
<jusss> how I can use an expression to call it?  [13:35]
<jusss> apply NonEmpty ? ?   will get "exec1 or exec2"/
<jusss> apply NonEmpty Exec1 ?
 <slack1256> jusss: Can you use a paste service for that code?  [13:43]
<slack1256> jusss: apply (NonEmpty Exec1 undefined) should work  [13:44]
<jusss> slack1256 https://paste.ubuntu.com/p/RS7FtkHfFG/
<slack1256> jusss: I don't understand what you want to do
<jusss> slack1256 just an example from stackoverflow help me understand Value
        Constructor
<dmwit> jusss: Here are two examples of calls: `apply Empty` or `apply
        (NonEmpty Exec1 ())`  [14:09]
<dmwit> Just for fun, here's a third that may look a bit weirder to initiates
        of other languages: `apply (NonEmpty Exec2 (\x -> 3 + x))`  [14:10]
<jusss> dmwit: the question is how to handle that undefined type variable when
        it is called
<jusss> https://paste.ubuntu.com/p/s84KjsTtjH/
<dmwit> The caller of `apply` may choose any specific type they like to
        substitute for `a`.  [14:11]
<jusss> dmwit: wait a second, but function don't have a type I think,   [14:12]
<dmwit> In my three examples above, I left it unspecified (`Empty`), chose the
        unit type `()` (`NonEmpty Exec1 ()`), and chose a function type
        `Integer -> Integer` (`\x -> 3 + x`).
<jusss> dmwit: normal function has a type?
<dmwit> Certainly.
<dmwit> :t \x -> 3 + x  [14:13]
<lambdabot> Num a => a -> a
<dmwit> :t \name -> "Hello, " ++ name ++ "!"
<lambdabot> [Char] -> [Char]
<jusss> dmwit: so normal function can be used in pattern match?
<jusss> dmwit: value constructor is totally same with normal functions?
<dmwit> There are no interesting patterns which match functions.  [14:14]
<ggole> Variable patterns!
<dmwit> Yes, data constructors may be applied to functions.
<dmwit> ggole: Right. Variables and underscore. I consider these not
        interesting, because they can be used for *any* type.
<dmwit> There are no patterns which match functions but do not match every
        type.  [14:15]
<dmwit> (Hm. Maybe some view patterns, hey? Anyway that's an advanced topic
        for another time...)
<c_wraith> yeah, view patterns could, but that's a totally different thing,
           really  [14:16]
<ggole> Hmm, isn't there a pattern ascription extension?  [14:17]
<ggole> It might be better to think of functions not having any constructors
        with which to destructure function values, rather than talking about
        types.
<dmwit> You're right. I hereby steal that much better phrasing as my new
        definition of "interesting".  [14:20]
<jusss> this is really make me confused! so functions do have types? and they
        have types but can not be used in patter match?  [14:21]
<jusss> value constructor and normal function are same thing or not?  [14:22]
<jusss> can I call value constructor as function?
<slack1256> jusss: yep in the sense that they have types, but they are not of
            the same "kind"
<jusss> (Num a => a -> a) is one function's type? right?  [14:24]
<slack1256> % :t Just
<yahb> slack1256: a -> Maybe a
<c_wraith> jusss: functions don't actually have constructors.  But that's not
           conceptually any different from any other type that has
           constructors, but keeps them hidden someplace you can't import.
<slack1256> Just is a value constructor for Maybe and also a function that
            returns a Maybe  [14:25]
            
######################################

https://stackoverflow.com/questions/10893747/

data T a = V a

Value Constructor can be used to pattern match as parameter before '=' , but function can't

data Struct val = Empty | NonEmpty StructType val
data StructType = Exec1 | Exec2

apply :: Struct -> String
apply (Empty) =  "matched Empty"
apply (NoEmpty a _) = "matched Exec1 or Exec2"        a is Exec1 | Exec2, _ is val 

apply2 :: Struct val -> String
apply2 (Empty) = "matched Empty"
apply2 (NonEmpty Exec1 _) = "matched Exec1"
apply2 (NonEmpty Exec2 _) = "matched Exec2"

#######################################333

in repl
:t :type
let x=1
:t x
x::Num a => a     x的类型为Num类型类的实例,可以为Int或Integer Float Double

类型类 typeclass
Num 是个typeclass，它的实例类型有 Int Integer Float 和 Double
Eq 的 有== 和 /==
Ord 有 < > <= >=这些类型
Show 有 show类型,转换为字符串
=> 类型约束
typeclass => type variable
Num a => a      则a的类型只能是Int 或 Integer Flaot Double

max' :: (Ord a) => a -> a-> a     max'有两个参数，参数的类型为Ord的实例,返回也是同样的类型
max' a b
     | a < b = b
     | otherwise = a

:i x 显示identifier的信息
x::Num a => a

:l :load .hs file
:r :reload

1+1=3    pattern match
1+1 will return 3

in repl, there're three ways to run code

1.   :{ xxx
        xxx
     :}

2.  :l file.hs

3.  let x=y

add :: Int -> Int -> Int
add x y = x+y   这样的add 1.0 2.0会出错，因为1.0不是Int

add :: Num a => a -> a -> a   
add x y = x+y  这样可以add 1.0 2.0或 add 1 2

a->a->a 表示第二个参数的类型和第一个参数类型形同，结果类型也一样

中缀表达式  1 `add` 2     parameter `function` parameter

https://zhuanlan.zhihu.com/p/21338799

---------------------------------------------------------------

main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("hey" ++ name ++ ",you rock!")

do将这些I/O操作合为一体，成为一个I/O操作，类型为IO(), putStrLn I/O操作的返回类型为()即空元组unit
getLine的返回类型为String,所以name的类型为String
只有通过<-才能打开I/O的返回值

ghc --make file-name 可以把file-name.hs编译成native code

if there's error, try re-install ghc and ghc-libs first.

let _FirstName = map toUpper firstName
let用于函数返回值的绑定, <- 用于I/O返回值的绑定

------------------------------------------------------------------------------

Type Constructor and Value Constructor

data T a = V a   
w = V 3 则 w :: T Int
x::T String 则 V "whatever"的type是x, (T String)是一个type,而(V "whatever")是一个value

data A = B
A是Type Constructor, B是Value Constructor

data T a = V a 就定义了T和V

Elm里的Type相当于Haskell的data
而在haskell里type相当于elm的Type alias
type X = Int  X就可以代表Int

newtype相当于一个优化的data

newtype = 只允许有一个值的data

newtype X = X Int 定义了一个新的X类型和对应的俩构造器

data X = X Int 表示X这个值构造器接受一个Int返回一个X
X::Int -> X
haskell GADT

data X = Int 是没有这种写法的，只有 type X = Int 定义类型构造器的别名

data Y = Y
x = Y 这样是可以的

值构造器不是类型

Int是个类型构造器
data Int = 0|1|2|...|4294967295

Value Constructor可以当作一类特殊的函数，可以在模式匹配里用,match pattern,
但普通函数不能在模式匹配里用， 值构造器可以作为函数使用，也可以模式匹配
所以Haskell有类型构造器 值构造器 和函数,  其它语言里的Constructor一般是指Value Constructor
data E = X | Y
:type X
X :: E
:type Y
Y :: E
:type 1
1 :: Num p => p
:type 1 :: Int
1 :: Int :: Int
所以:1也是值构造器还是多态的

类型构造器和值构造器都可以没有参数
data Bool = True | False   Bool是个无参数的类型构造器, True和False是无参数的值构造器
data Maybe a = Nothing | Just a    Maybe是类型构造器，a是在等号左边是类型变量,a在等号右边是值变量，Just是值构造器

Haskell除了值，类型之外还有Kind
Int是Int::*
Maybe是*->*
Kind就是Type的Type,  Idris可以无限层级堆叠类型
Haskell最高只有两阶类型，所以没法表达所有集合的集合, 是data和typeclass之别，好像没问题，Elm 0.19还没有typeclass
https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/
C++好像也是两阶的
Kind就是描述类型构造器的类型的,
先用Type描述数字，data Nat这样用Nat Succ这样去描述数字
https://hackage.haskell.org/package/data-nat
data-nat: data Nat = Zero | Succ Nat

data T a = V a
x :: T Int 怎么把V 3里的3通过操作x提取出来？
得把x写成函数
x :: T Int -> Int
x (V boom) = boom
或者
x biu = case biu of
        (V boom) -> boom

Elm没有data,只有Type和Type alias, Elm的Type和Haskell的data功能一样, Elm的Type alias和Haskell的type功能一样或者newtype?
Haskell开LambdaCase之后可以这样写
:set -XLambdaCase
y = \case (V boom) -> boom
:type x
x :: T a -> a
:type y
y :: T a -> a

Module X where 这个where就是定义了一个块状区域，类似c系语言里的大括号把后面缩进的内容都包含进去了

t = map f  这个是curring柯里化也是pointfree写法
括号里有逗号就是tuple,没有逗号就是优先求值
x :: (Int, String, Int) -> Int 和 y :: Int->String->Int-> Int 后者是柯里化的

haskell没有一元tuple 但是有0元tuple,0元tuple就是()

module X where 就是指这个文件的名字是X.hs或X.elm, where类似C的大括号,这个文件可以作为模块给其它文件使用
也可以 module Main where, module Test where, module Whatever where, module就是把这个文件声明成了模块给其它文件使用
而在python里一个文件默认就是模块，test.py可以在同目录的其它python文件里直接import test去掉文件名后缀.py导入，但是为了防止在导入
test.py时求值里面的函数，所以一般就在test.py里把求值的函数都写在if __name__ == '__main__':里，这样在其它文件导入test.py时，
因为主文件的__name__才等于__main__,导入时test.py里的__name__不等于__main__这样test.py里的求值函数就不会求值，
因为python的执行顺序是从top到bottom,所以python的程序入口点entry point就是第一行，
而C的程序入口点是main(),  Elm和Haskell的程序入口点是main = 

#######################################

Geometry.hs the module must be Geometry


##########################################

association list, in scheme a-list in cl plist, in python dict
it doesn't have an order or sequence
simpe way to do a dict is use lists or tuple
phoneBook = [("betty","555-2938")
	    ,("bonnie", "452-2938")
	    ]

find an element in an empty list, it cause an runtime error,
use Maybe data type to avoid that, if it doesn't find what
you want, return Nothing, otherwise return Just something,
and something is that value associate to the key.

findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs)
    |key == k = Just v
    |otherwise = findKey key xs


####################################

find :: (a->Bool) -> [a] -> Maybe a
the type of Maybe a means its value may be one element or empty, if it failed to evaluate
Nothing means value is empty like empty list
Just "hey" a value has one element, it contains "hey"

############################################

module X where
main = print $ f 33
f :: Integer -> Integer
f x = x + x

main = program's entry point, like int main() in C

python's if __name__ == '__main__' is not the entry point, because python run from the top to bottom by sequence,
this if __name__=='__main__' is used for preventing evaulate when import,
but haskell doesn't run by that sequence, so you need give the entry point,

_name_ means current module's name, one file is one module,
if you import file a in file b, and run file b then the __name__ point
to file b, and a will be evaluated when it's imported, but if you put
that function call code in if __name__ == '__main__' in a, when a is imported
in b, a will not be evalated,

this if __name__=='__main__' only work for preventing the module you import to
be evaluted,
python's entry point is the first line
https://www.zhihu.com/question/49136398


#########################################

in ghci, you must define a function declaration after a function signature
so use :{  :} to handle multiple lines
:{
 f::Int->Int
 f x=x
 :}

or use let,
let f::Int->Int; f x=x

#####################################

M-x package-install haskell-mode
(add-to-list 'ac-modes 'haskell-mode)
open test.hs and haskell-mode should be enabled by default, and
M-x interactive-haskell-mode
then code in test.hs, and C-c C-l, it will load the code in the GHCi
https://wiki.haskell.org/Emacs/Keybindings_and_simple_usage

(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
(add-hook 'haskell-mode-hook 'haskell-indent-mode)
(add-hook 'haskell-mode-hook 'haskell-doc-mode)

https://opensourceforu.com/2014/01/getting-started-haskell-emacs/
#############################################

import Data.List
numUniques :: (Eq a) => [a] -> Int
numUniques = lenght . nub       pointless style meaning \xs -> lenght (nub xs)
:m + Data.List 
import Data.List (nub, sort)

Data.List any function,  it takes a condition and a list as parameters,
it tells us if there is an element fit the condition
any (> 4) [1,2,3]      False
any (=='F') "Frank Underwood"  True


########################################
x:xs means a list's head is x and the rest are xs, if the list have only one element then xs is an empty list
_ means multi-variables
head' :: [a] -> a
head' [] = error "empty"
head' (x:_) = x      _ must come with ()
#############################
point-free stype A.K.A pointless style

sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs

pointless
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
####################################

function application operator $
space split,left to right, f a b c == ((f a) b) c
$ make it right to left, sqrt (3+4+9) eq sqrt $ 3+4+9
it seems like $ in bash, expand variable and get its value, $a it means a's value
##########################
function composition
(f . g)(x) = f(g(x))
map (negate . abs) [5,-3,2,-19,24]     [-5,-3,-2,-19,-24]
map (negate . sum . tail) [[1..5], [3..6], [1..7]]      [-14,-15,-27]

###########################

foldl takes a two-parameter function, an initial value and a list
just like map, the difference is it has an initial value 
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
sum' [3,5,2,1]     11

fold list from left to right of a list, called foldl
from right to left, called foldr
foldll and foldrl don't need the initial value, they use the first or last as initial value

currying and map
what if currying on map?
g = map f
g alist

#######################
lambda 
\x -> x + 3
#################################

| means guard
catchall pattern like case
guard like if-else   bool

bmiTell :: Double -> String
bmiTell bmi
    | bmi <= 18.5 = "underweight"
    | bmi <= 25.0 = "normal"
    | bmi <= 30.0 = "fatty"
    | otherwise = "whale"
that after '=' it acctually can be a function

filter :: (a->Bool) -> [a] -> [a]    (a->Bool) a function takes a and return Bool
filter _ [] = []    if it's empty list then return empty list whatever the function it is
filter p (x:xs)
    | p x = x : filter p xs        if p x is true, put x to new list
    | otherwise = filter p xs

##########################
applyTwice :: (a -> a) -> a -> a
applyTwice       f        x =  f (f x)
(a->a) means this is a function and it takes a and return a

predicate function is a function whos return value is Bool type

map :: (a->b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs    this x:xs:[] == [x:xs] finally it returns []
############################
about partial function,
a function's curring, it doesn't evaluate something immediately, it just changes the form
f(x,y)   to f(x)(y)   f(x) will not evaluate immediately, it will wait for y, unless you 
change something in the function f inside, reference curring in javascript
###############################################3
max :: (Ord a) => [a] -> a
=> is type constraint, it declares type variable a is a instance of the typeclass Ord

(==) :: (Eq a) => a -> a -> Bool

typeclass: Eq, Ord, Show, Read, Enum, Bounded, Num, Floating, Integeral

"I think typeclass is used for specify the type of the type variable"
typeclass Floating has two type instance, Float and Double

#######################################################
pacman -S ghc

ghci

* + are called infix function, others are prefix function, split with space 

[john@moon lab2]$ cat test.hs 
doubleMe x = x + x 

###load file in ghci repl
Prelude> :l test.hs
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, one module loaded.
*Main> doubleMe 3
6


doubleSmallNumber x = if x > 100 then x else x*2
if must come with else , if-else is an expression not a statement in haskell

[1,2,3] ++ [9,2]    [1,2,3,9,2]   ++ only used in list, and string is a list of characters
cons operator :
'A' : " SMALL CAT"     "A SMALL CAT"
5:[1,2,3]    [5,1,2,3]

cons is short for construct!    constructor in JS construct object with function,
in python construct in class, in Elm construct data with type

[9.4, 33.2] !! 0     9.4  get value by offset 

[3,2,1] > [2,1,0] 

[1..20] is short for [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
['a'..'z']
['K'..'Z']
[2,4..20]
[3,6..20] [3,6,9,12,15,18]
[13,26..24*13]
take 24 [13,26..]
[x*2 | x <- [1..10]]     set comprehension  2x (1<=x<=10)
[x*2 | x <- [1..10], x*2 >= 12]  this x*2 >= 12 is a predicate expression, return a bool value, true or false

haskell support type inference, no need for type declare
:t 'a'     'a' :: Char
4 == 5 :: Bool

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

type must start with upper-case character
:t head    head :: [a] -> a       a is a type variable, a can be any type
a function which used type variable is polymorphic function

type is an instance of a typeclass,

