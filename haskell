
Type Constructor and Value Constructor

data T a = V a   
w = V 3 则 w :: T Int
x::T String 则 V "whatever"的type是x, (T String)是一个type,而(V "whatever")是一个value

data A = B
A是Type Constructor, B是Value Constructor

data T a = V a 就定义了T和V

Elm里的Type相当于Haskell的data
而在haskell里type相当于elm的Type alias
type X = Int  X就可以代表Int

newtype相当于一个优化的data

newtype = 只允许有一个值的data

newtype X = X Int 定义了一个新的X类型和对应的俩构造器

data X = X Int 表示X这个值构造器接受一个Int返回一个X
X::Int -> X
haskell GADT

data X = Int 是没有这种写法的，只有 type X = Int 定义类型构造器的别名

data Y = Y
x = Y 这样是可以的

值构造器不是类型

Int是个类型构造器
data Int = 0|1|2|...|4294967295

Value Constructor可以当作一类特殊的函数，可以在模式匹配里用,match pattern,
但普通函数不能在模式匹配里用， 值构造器可以作为函数使用，也可以模式匹配
所以Haskell有类型构造器 值构造器 和函数,  其它语言里的Constructor一般是指Value Constructor
data E = X | Y
:type X
X :: E
:type Y
Y :: E
:type 1
1 :: Num p => p
:type 1 :: Int
1 :: Int :: Int
所以:1也是值构造器还是多态的

类型构造器和值构造器都可以没有参数
data Bool = True | False   Bool是个无参数的类型构造器, True和False是无参数的值构造器
data Maybe a = Nothing | Just a    Maybe是类型构造器，a是在等号左边是类型变量,a在等号右边是值变量，Just是值构造器

Haskell除了值，类型之外还有Kind
Int是Int::*
Maybe是*->*
Kind就是Type的Type,  Idris可以无限层级堆叠类型
Haskell最高只有两阶类型，所以没法表达所有集合的集合, 是data和typeclass之别，好像没问题，Elm 0.19还没有typeclass
https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/
C++好像也是两阶的
Kind就是描述类型构造器的类型的,
先用Type描述数字，data Nat这样用Nat Succ这样去描述数字
https://hackage.haskell.org/package/data-nat
data-nat: data Nat = Zero | Succ Nat

data T a = V a
x :: T Int 怎么把V 3里的3通过操作x提取出来？
得把x写成函数
x :: T Int -> Int
x (V boom) = boom
或者
x biu = case biu of
        (V boom) -> boom

Elm没有data,只有Type和Type alias, Elm的Type和Haskell的data功能一样, Elm的Type alias和Haskell的type功能一样或者newtype?
Haskell开LambdaCase之后可以这样写
:set -XLambdaCase
y = \case (V boom) -> boom
:type x
x :: T a -> a
:type y
y :: T a -> a

Module X where 这个where就是定义了一个块状区域，类似c系语言里的大括号把后面缩进的内容都包含进去了

t = map f  这个是curring柯里化也是pointfree写法
括号里有逗号就是tuple,没有逗号就是优先求值
x :: (Int, String, Int) -> Int 和 y :: Int->String->Int-> Int 后者是柯里化的

haskell没有一元tuple 但是有0元tuple,0元tuple就是()

module X where 就是指这个文件的名字是X.hs或X.elm, where类似C的大括号,这个文件可以作为模块给其它文件使用
也可以 module Main where, module Test where, module Whatever where, module就是把这个文件声明成了模块给其它文件使用
而在python里一个文件默认就是模块，test.py可以在同目录的其它python文件里直接import test去掉文件名后缀.py导入，但是为了防止在导入
test.py时求值里面的函数，所以一般就在test.py里把求值的函数都写在if __name__ == '__main__':里，这样在其它文件导入test.py时，
因为主文件的__name__才等于__main__,导入时test.py里的__name__不等于__main__这样test.py里的求值函数就不会求值，
因为python的执行顺序是从top到bottom,所以python的程序入口点entry point就是第一行，
而C的程序入口点是main(),  Elm和Haskell的程序入口点是main = 

#######################################

Geometry.hs the module must be Geometry


##########################################

association list, in scheme a-list in cl plist, in python dict
it doesn't have an order or sequence
simpe way to do a dict is use lists or tuple
phoneBook = [("betty","555-2938")
	    ,("bonnie", "452-2938")
	    ]

find an element in an empty list, it cause an runtime error,
use Maybe data type to avoid that, if it doesn't find what
you want, return Nothing, otherwise return Just something,
and something is that value associate to the key.

findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs)
    |key == k = Just v
    |otherwise = findKey key xs


####################################

find :: (a->Bool) -> [a] -> Maybe a
the type of Maybe a means its value may be one element or empty, if it failed to evaluate
Nothing means value is empty like empty list
Just "hey" a value has one element, it contains "hey"

############################################

module X where
main = print $ f 33
f :: Integer -> Integer
f x = x + x

main = program's entry point, like int main() in C

python's if __name__ == '__main__' is not the entry point, because python run from the top to bottom by sequence,
this if __name__=='__main__' is used for preventing evaulate when import,
but haskell doesn't run by that sequence, so you need give the entry point,

_name_ means current module's name, one file is one module,
if you import file a in file b, and run file b then the __name__ point
to file b, and a will be evaluated when it's imported, but if you put
that function call code in if __name__ == '__main__' in a, when a is imported
in b, a will not be evalated,

this if __name__=='__main__' only work for preventing the module you import to
be evaluted,
python's entry point is the first line
https://www.zhihu.com/question/49136398


#########################################

in ghci, you must define a function declaration after a function signature
so use :{  :} to handle multiple lines
:{
 f::Int->Int
 f x=x
 :}

or use let,
let f::Int->Int; f x=x

#####################################

M-x package-install haskell-mode
(add-to-list 'ac-modes 'haskell-mode)
open test.hs and haskell-mode should be enabled by default, and
M-x interactive-haskell-mode
then code in test.hs, and C-c C-l, it will load the code in the GHCi
https://wiki.haskell.org/Emacs/Keybindings_and_simple_usage

(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
(add-hook 'haskell-mode-hook 'haskell-indent-mode)
(add-hook 'haskell-mode-hook 'haskell-doc-mode)

https://opensourceforu.com/2014/01/getting-started-haskell-emacs/
#############################################

import Data.List
numUniques :: (Eq a) => [a] -> Int
numUniques = lenght . nub       pointless style meaning \xs -> lenght (nub xs)
:m + Data.List 
import Data.List (nub, sort)

Data.List any function,  it takes a condition and a list as parameters,
it tells us if there is an element fit the condition
any (> 4) [1,2,3]      False
any (=='F') "Frank Underwood"  True


########################################
x:xs means a list's head is x and the rest are xs, if the list have only one element then xs is an empty list
_ means multi-variables
head' :: [a] -> a
head' [] = error "empty"
head' (x:_) = x      _ must come with ()
#############################
point-free stype A.K.A pointless style

sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs

pointless
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
####################################

function application operator $
space split,left to right, f a b c == ((f a) b) c
$ make it right to left, sqrt (3+4+9) eq sqrt $ 3+4+9
it seems like $ in bash, expand variable and get its value, $a it means a's value
##########################
function composition
(f . g)(x) = f(g(x))
map (negate . abs) [5,-3,2,-19,24]     [-5,-3,-2,-19,-24]
map (negate . sum . tail) [[1..5], [3..6], [1..7]]      [-14,-15,-27]

###########################

foldl takes a two-parameter function, an initial value and a list
just like map, the difference is it has an initial value 
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
sum' [3,5,2,1]     11

fold list from left to right of a list, called foldl
from right to left, called foldr
foldll and foldrl don't need the initial value, they use the first or last as initial value

currying and map
what if currying on map?
g = map f
g alist

#######################
lambda 
\x -> x + 3
#################################

| means guard
catchall pattern like case
guard like if-else   bool

bmiTell :: Double -> String
bmiTell bmi
    | bmi <= 18.5 = "underweight"
    | bmi <= 25.0 = "normal"
    | bmi <= 30.0 = "fatty"
    | otherwise = "whale"
that after '=' it acctually can be a function

filter :: (a->Bool) -> [a] -> [a]    (a->Bool) a function takes a and return Bool
filter _ [] = []    if it's empty list then return empty list whatever the function it is
filter p (x:xs)
    | p x = x : filter p xs        if p x is true, put x to new list
    | otherwise = filter p xs

##########################
applyTwice :: (a -> a) -> a -> a
applyTwice       f        x =  f (f x)
(a->a) means this is a function and it takes a and return a

predicate function is a function whos return value is Bool type

map :: (a->b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs    this x:xs:[] == [x:xs] finally it returns []
############################
about partial function,
a function's curring, it doesn't evaluate something immediately, it just changes the form
f(x,y)   to f(x)(y)   f(x) will not evaluate immediately, it will wait for y, unless you 
change something in the function f inside, reference curring in javascript
###############################################3
max :: (Ord a) => [a] -> a
=> is type constraint, it declares type variable a is a instance of the typeclass Ord

(==) :: (Eq a) => a -> a -> Bool

typeclass: Eq, Ord, Show, Read, Enum, Bounded, Num, Floating, Integeral

"I think typeclass is used for specify the type of the type variable"
typeclass Floating has two type instance, Float and Double

#######################################################
pacman -S ghc

ghci

* + are called infix function, others are prefix function, split with space 

[john@moon lab2]$ cat test.hs 
doubleMe x = x + x 

###load file in ghci repl
Prelude> :l test.hs
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, one module loaded.
*Main> doubleMe 3
6


doubleSmallNumber x = if x > 100 then x else x*2
if must come with else , if-else is an expression not a statement in haskell

[1,2,3] ++ [9,2]    [1,2,3,9,2]   ++ only used in list, and string is a list of characters
cons operator :
'A' : " SMALL CAT"     "A SMALL CAT"
5:[1,2,3]    [5,1,2,3]

cons is short for construct!    constructor in JS construct object with function,
in python construct in class, in Elm construct data with type

[9.4, 33.2] !! 0     9.4  get value by offset 

[3,2,1] > [2,1,0] 

[1..20] is short for [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
['a'..'z']
['K'..'Z']
[2,4..20]
[3,6..20] [3,6,9,12,15,18]
[13,26..24*13]
take 24 [13,26..]
[x*2 | x <- [1..10]]     set comprehension  2x (1<=x<=10)
[x*2 | x <- [1..10], x*2 >= 12]  this x*2 >= 12 is a predicate expression, return a bool value, true or false

haskell support type inference, no need for type declare
:t 'a'     'a' :: Char
4 == 5 :: Bool

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

type must start with upper-case character
:t head    head :: [a] -> a       a is a type variable, a can be any type
a function which used type variable is polymorphic function

type is an instance of a typeclass,

