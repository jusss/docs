

#GADTs
{-#LANGUAGE GADTs #-}

--ADT
data Maybe a =  
    Nothing |   
    Just a
--GADT
data Maybe a where
   Nothing  :: Maybe a
   Just :: a -> Maybe a

data T = I Int | B Bool
data T where
     I :: Int -> T
     B :: Bool -> T

#ADT #Algebraic Data Types

<jusss> how to make a type that can have Int or Bool, nothing else,  data T =
        Int | Bool  ???   (here Int is value constructor, has nothing with that type constructor Int, so it's not what you want here)                                              [09:32]
<jusss> dyl: data T = Either Int Bool? (this is not what you want too)
Prelude> :t (Either 3)
(Either 3) :: Bool -> T
<dyl> Yup. 
<dyl> Either A B is the dual of (A, B) [or Tuple A B if you prefer]
<dyl> Tuple is one of both (a product), Either is one or the other (a
      coproduct).
<jusss> dyl: and when I want to use this value, I should use Either 3 or I
        need Either 3 True?                                             [09:34]
<dyl> data Either A B = Left A | Right B.
<dyl> a b*
<jackdk> `data T = I Int | B Bool` or `type T = Either Int Bool`, depending on
         whether you want T to be a new type or an alias
<dyl> ^ 
<dyl> Tbh I would just use Either unless there’s a need to do otherwise as
      you get a lot of stuff for free.                                  [09:35]
<jusss> what is this Left and Right  ,  I and B here?
<jusss> just a Value Constructor? and meaningless?
<dyl> data Either a b = Left a | Right b
<dyl> They’re just the constructor for each case. 
<dyl> Pull up google on Data.Either.                                    [09:36]
<dyl> Hoogle*
<jusss> then I see, Int and Bool both are type constructor, so if they want to
        be a value , they need a value constructor, right?
<dlyang> use GADTs extension  data T a = where I :: a ->Int B:: a ->Bool
<JappleAck> data T a = where I :: a -> Int ; B :: a -> Bool
<JappleAck> but it still incorrect and supposed to be something like this:
            data T a where I :: a -> T Int ; B :: a -> T Bool           [09:43]
<jusss> data T a = I a | B a,   
<JappleAck> jusss: in your case you could have `I True' and `B 123'     [09:44]
<JappleAck> even this: data T a where I :: Int -> T Int ; B :: Bool -> T Bool
                                                                        [09:47]
<jusss> data T = Either a b
<jusss> data T = Either Int Bool                                        [10:14]
<jusss> Either 3 is ok , but Either True is not, so it must be Either 3 True?
in this case Either a value constructor, has nothing with that Either type constructor,
so it has to be (Either Int Bool), and (Either Int) is a partial form
<jusss> % :t Either 3
<yahb> jusss: Bool -> T
<geekosaur> % :t Either 3
<yahb> geekosaur: Bool -> T
<geekosaur> incomplete
<geekosaur> because it's partially applied                              [10:31]

<jusss> geekosaur: aha, so this 'Either' in 'data T = Either Int Bool' has no
        relationship with 'Either a b = Left a | Right b'?
<mniip> perhaps they wanted data T = C (Either Bool Int)
<geekosaur> here, you called it Either, which will be unrelated to the
            exxisting type Either
<geekosaur> % data T1 = MkT1 Int Bool -- same thing, different constructor
            name
<yahb> geekosaur: 
<mniip> jusss, correct, they live in different namespaces
<mniip> data A = B C                                                    [10:33]
<jusss> mniip: data T = C (Either Bool Int),  what this C construct?
<geekosaur> a value of this type T looks like C (Left True) or C (Right 4)
<geekosaur> the parentheses are required here, `C Left True` would attempt to
            apply a value (C Left) (which is a type error) as a function to
            the value True                                              [10:38]
<jusss> geekosaur: if the type constrctor to do a value, I should put a value
        constructor on it?                                              [10:48]
<jusss> do as
<geekosaur> ...what?
<jusss> data T = Maybe Int, this Maybe is nothing with type constructor Maybe
<jusss> this Maybe is value constructor here
<geekosaur> right, it's defining a data constructor, not a type constructor
                                                                        [10:49]
<jusss> but I can use data T = C (Maybe Int)
<jusss> and this Maybe is still that Maybe type constructor
<jle`> you can use both, but they mean two different things
<jle`> `data T = Maybe Int`, you're declaring a new data type T, with a value
       constructor Maybe
<jle`> that contains an Int
<geekosaur> data ATypeConstructor {- possibly some type parameters -} =
            ADataConstructor {- possibly some types for "contained'/associated
            values here -}
<jle`> with `data T = C (Maybe Int)`, you're declaring a new data type T, with
       value constructor C, that contains a (Maybe Int)
<jusss> ok                                                              [10:52]
<jle`> it's admittedly a little inconsistent because you flip back and forth
       between two levels of things                                     [10:53]
<jle`> that's one reason why a lot of people think GADT syntax is more
       consistent/easier to undersatnd in this regard                   [10:54]
<jle`> it's an alternative syntax to declaring new data types and constructors

(type constructor can not be a value constructor, otherwise, that same identifier is just 
a value constructor, nothing to do with type constructor, but you can make another identifier as value constructor, and use the type constructor as a value of it, that's ok)
data T = Maybe Int     not ok
data T = V (Maybe Int)      ok

#############################################

rule I. the return type in the type signature, it must be appeared befor the last one, otherwise it will be undefined, Eg :: a->b->c->a is ok, and Eg :: a->b->c is not ok, 'cause c is undefined.

rule II. in the data declaration, the variable in the right part of '=', it must be appeared in the left part of '=',  data T a = V a is ok, and data T = V a is not,


there're a set of function definition and type signature in the typeclass,
those function definitions describe the relationship among them, like how Function A change to
Function B, but not really Function A's definition.
in the instance definition, define the functions which type signatures defined in the typeclass's definition,
multiple instance with the one typeclass, and define the same function, it will make the function can take multiple type.

like isEqual True True = True
     isEqual Red Red = True
in two instances.

data Bool = True | False
data Color = Red | Green | Blue

class BasicEq a where
      isEqual :: a -> a -> Bool
      isEqual x y = not (isNotEqual x y)

      isNotEqual :: a -> a -> Bool
      isNotEqual x y = not (isEqual x y)

instance BasicEq Bool where
         isEqual True True = True
         isEqual False False = True
         isEqual _ _ = False

instance BasicEq Color where
         isEqual Red Red = True
         isEqual Green Green = True
         isEqual Blue Blue = True
         isEqual _ _ = False

t :: (BasicEq a)=> a -> a -> Bool
t x y = isEqual x y

λ> isEqual Red Red
True
λ> isEqual True True
True
λ> t Red Red
True
λ> t True True
True

typeclass is used to make the one function take multiple type signatures,
and use the typeclass constraint in other type signature, it makes the type concret and you can use the function defined in the typeclass.
like (BasicEq a) => a, so a can only be Bool or Color, and you can use isEqual apply on a.


https://rwh.readthedocs.io/en/latest/chp/6.html

{-# language MultiParamTypeClasses, FunctionalDependencies #-}
{-# language FlexibleInstances #-}
module X where

data T a = V a

class MyT a b | a -> b where
    value :: a -> b

instance MyT (T a) a where
    value (V a) = a

λ> value (V 3)
3



###################################################################w

Typeclass
use a type as a typeclass's instance and use it in the function of typeclass
like pass a type into typeclass's function

data Bool = True | False
class BasicEq a where
      isEqual :: a -> a -> Bool
      

a is instance of BasicEq, and BasicEq is a typeclass

instance BasicEq Bool where
         isEqual True True = True
         isEqual False False = True
         isEqual _ _ =False

use type Bool as a instance of typeclass BasicEq
so use the function's signature in typeclass as the signature of function in instance

######################################################################################


已知函数A和函数B的类型，就能通过类型推导得出(B A)的类型，通过换元法的代入和消除，haskell的类型推导就像在做中学的数学题，通过函数的类型签名还可以写出函数的定义，#神奇

通过函数的类型签名然后再用eta expand构造出在其它语言里的表达方式
map . map
= \f -> map (map f)
=\f -> map (\xs->map f xs)
=\f xss -> map (\xs->map f xs) xss
=(\f xss (map (\xs (map f xs) xss)))
=(lambda (f xss) (map (lambda (xs) (map f xs)) xss))

(map . map) (+1) [[1,2,5], [7,8]]会得到[[2,3,6], [8,9]] 绑定刚才那个scheme的lambda表达式为g (g (lambda (x) (+ x 1)) ‘((1 2 5) (7 8)))得到((2 3 6) (8 9)) #eta-expand和类型推导真是神奇！

通过已知的两个函数类型可以推导出组合之后的函数类型，然后根据这个函数类型还可以推出函数的定义，
甚至可以根据已知的两个函数类型,在组合之后进行eta-expand变成符合那两个类型的form, 就可以变成在其它语言里的表达方式 #mark

function's type is not same with the function's return value type!

id :: a->a
function id's type is a->a
and function's return value type is a

##################################################################################

<jusss> how to express map . map in other languages? like python or scheme
<Solonarv> or ugly, ugly lambdas, e.g. python: map(lambda xs: map(f, xs), xss)
<ski> jusss : i was about to say `(compose map map)', but that doesn't do what
      you wanted, try `(lambda (f lis) (map (lambda (lis) (map f lis)) lis))'
      instead ?
<ski> jusss : if you `(define ((curried-map) f) lis) (map f lis))', then you
      can say `(compose curried-map curried-map)' (adjust in the obvious way
      if you want to work on more than one list)
<ski> (the definition of `curried-map' may also need to be adjusted, if your
      Scheme doesn't support "curried" `define's)
<jusss> can I through the type signature to get the function's definition?
<Solonarv> jusss: sometimes
<ski> jusss : "through" ?
<Solonarv> roughly speaking, the more general the type signature is the more
           you can deduce about the implementation
<Solonarv> for the type of (map . map) there are many possible implementations
                                                                        [23:21]
<jusss> ski: const::a->b->a, id::a->a, so const id::b->a->a
<jusss> f:: const id,   f x y = y
<Solonarv> roughly speaking, the type of map.map is enough to figure out that
           elements in the result must come from the function argument being
           applied to elements in the input list
<ski> @djinn b -> a -> a
<lambdabot> f _ a = a
<ski> jusss : like that ^ ?  [23:23]
<Solonarv> but the type doesn't say anything about how the elements are
           arranged - they could be duplicated, or reshuffled in some
           arbitrary way, or stuff like that
<jusss> ski: yeah
<jusss> Solonarv: ski, how you think about map .map to express in other
        languages? I mean the transformation, is there a rule or something?
                                                                        [23:29]
<ski> what do you mean with "the transformation" or "rule" ?  [23:30]
<jusss> map . map == (map (lambda (lis) (map f lis)) lis)
<jusss> the procedure do that transform
<jusss> sorry for my Bad English
<Solonarv> basically just inline the definition of (.) and eta-expand
           everything until there are no partial applications left
<ski> jusss : `map' in Scheme is more like a `tupledMap' satisfying `tupledMap
      (f,xs) = map f xs' in Haskell
<ski> (well, `map' in Scheme also has the functionality of `zipWith',&c. ..)
<ski> (so there's some slight impedance mismatch you need to account for)
<jusss> Solonarv: that eta-expand apply on type signature or function's
        definition?  [23:40]
<Solonarv> definition
<Solonarv> so we go like this:  [23:43]
<Solonarv>             map . map
<Solonarv> = \f     -> map (map f)               -- 1. definition of (.)
<Solonarv> = \f     -> map (\xs -> map f xs)     -- 2. eta expand the inner
           'map' call
<Solonarv> = \f xss -> map (\xs -> map f xs) xss -- 3. eta expand outer 'map'
           call
<jusss> Solonarv: eta-expand is wonderful!
<ski> jusss : yea, it might be a good idea to practice it until it becomes
      second nature :)
<jusss> ski: through map's type signature we can know it takes two parameter,
        and through eta-expand, we can consturct (map . map) = \f -> map (map
        f) to a form that map with two parameter, and then we can get the
        expression in other language who support lambda, wonderful!
<ski> jusss : yep :)        

#######################################################


fmap :: (a->b) -> f a -> f b
when Functor is List, then fmap is map
fmap :: (a->b) -> List a -> List b
map :: (a->b) -> [a] -> [b]

when Functor is (->) e, then fmap is (.)
fmap :: (a->b) -> ((->) e a) -> ((->) e b)

and (->) e a == e->a
fmap :: (a->b) -> (e->a) -> (e->b)
(.) :: (a->b) -> (e->a) -> (e->b)
and Functor is (->) e


if 
(.) :: (a->b) -> (e->a) -> (e->b)
map :: (a->b) -> [a] -> [b]

so map . map :: ?

rule I. -> and . is infix expression, so ((->) e a) == (e->a) and map . map == (.) map map
rule II. -> is right associate
rule III. f g a == (f g) a
rule IIII. take function A's parameter type and return type as function B's parameter types in B's type signature, get function B's type signature with function A's type
rule V. (B A) A will take the first parameter position in B, so remove the type of the first parameter in B, it will get (B A)'s type

map . map == (.) map map
map1 :: (x1->y1) -> ([x1] -> [y1])
map2 :: (x2->y2) -> ([x2] -> [y2])

let (x1->y1) as a, and ([x1] -> [y1]) as b in (.)
so (.) :: ((x1->y1) -> ([x1]->[y1])) -> (e->(x1->y1)) -> (e->([x1]->[y1]))
and (.) map1, that map1 take the first parameter's position,
so (.) map1 :: (e->(x1->y1)) -> (e->([x1]->[y1]))

let (x2->y2) as e and ([x2]->[y2]) as (x1->y1) in (.) map1
so [x2] as x1, and [y2] as y1
so (.) map1 :: ((x2->y2) -> ([x2]->[y2]))  ->  ((x2->y2) -> ([[x2]] -> [[y2]]))
and (.) map1 map2, that map2 take the first parameter's position.
so (.) map1 map2 :: ((x2->y2) -> ([[x2]]->[[y2]]))

(.) map map :: (x2->y2) -> ([[x2]]->[[y2]])
map . map :: (x2->y2) -> [[x2]] -> [[y2]]


####################################################

const :: a->b->a
id :: a -> a

id :: x -> x
const :: (x->x) -> b -> (x->x)
const id :: b->(x->x)
const id :: b->a->a

f = const id
f :: b-> a -> a
f x y = y


####################################################################

use SVG or Canvas in html to replace pictures!

from abc import ABCMeta, abstractmethod
class Functor(metaclass=ABCMeta):
      @abcstractmethod
      def fmap(self, func):
          pass
class TT(Functor):
      pass

TT()  TypeError: Can't instantiate abstract class TT with abstract methods fmap

class TT(Functor):
      def fmap(self, f):
          return 1

@abstractmethod force sub-class to implement some methods!
this is for the typeclass in Haskell,like
class X where
      cc: XXXXX->XXX




def f(x) -> 123:
    return x

this -> in function definition is 'function annotations',it returns a int type value, not implemented.

you can use python's class to implement other things that are in other languages, like Functor in haskell


python type hints
https://sikasjc.github.io/2018/07/14/type-hint-in-python/
t: Tuple[int, float] = 0, 1.2
l: List[int] = [1, 2, 3]


from typing import Callable, TypeVar
from abc import ABCMeta, abstractmethod
a=TypeVar('a')
b=TypeVar('b')

class Functor(metaclass=ABCMeta):
    @abstractmethod
    def fmap(self, func):
        pass

class Maybe(Functor, metaclass=ABCMeta):
    @abstractmethod
    def fmap(self, f: Callable[[a],b]) -> "Maybe":
        pass

class Just(Maybe):
    def __init__(self,value):
        self._value=value
    def fmap(self, f: Callable[[a],b]) -> "Just":
        return Just(f(self._value))
    def __str__(self):
        return f"Just {self._value}"
    def __repr__(self):
        return self.__str__()

class Nothing(Maybe):
    def fmap(self, f: Callable[[a],b]) -> "Nothing":
        return Nothing()
    def __str__(self):
        return "Nothing"
    def __repr__(self):
        return "Nothing"

def fmap(func, f):
    return f.fmap(func)

print(fmap(lambda x: x+1, Nothing()))
print(fmap(lambda x: x+1, Just(123)))

"""
this is something sort of typeclass in python



@nasyx
as a Maybe, you need class Maybe(Monad, Monoid, Applicative, Functor): pass
so you need to implement Monad, Applicative, Monoid, Functor's metaclass first,

"""




#wrapper #monad #functor 
list class closure tuple set, they all can wrap value

一个是通过类这种方式，传unwrappped value进去实例化成对象，用对象来wrap value
然后在对象里面用method来操作里面的unwrapped value,并且每次操作完之后用值再次
实例化一个对象并返回，Maybe(unwrapped value).map(f).map(f)
另一种是用List来wrap value, 然后 Array.prototype.function= {}, 这种给原型添加
方法，并且这个方法返回的也是一个list, 这样就可以 [].function().function()

c(b(a(x)))   to    f(x).map(a).map(b).map(c)

class Maybe:
    def __init__(self, unwrapped_value):
        self.value = unwrapped_value

    def map(self, f):
        return Maybe(f(self.value)) if self.value else Maybe(None)

    def join(self):
        return self.value

add3 = lambda x: x+3
minus2 = lambda x: x-2
print(Maybe(5).map(add3).map(minus2).map(str).map(lambda x: x+"2k").join())

"""
join::m (m a) -> m a
join Just (Just a) = Just a

this is match pattern in haskell, you can do 1+1=3 
but in python, you need do visitor pattern with class for that,
it's complicated and not just one class

this match pattern is too easy for do DSL

"""


list and object can be wrapper!



javascript, half Orient Object, half Functional Programming,
OO is based on Prototype not Class, I wonder if there's a language based on Orient Closure

Orient Object: Prototype, Class
Orient Closure

use closure can do curry,  capture the parameter into a closure
f(x,y) = x+y
f(x) = return g(y) { x + y }

https://www.zhihu.com/question/19635359

list and object can be wrapper!

class Num{
       constructor (value) {
          this.value = value ;
       }      
       add5 () {
           return  new Num( this.value + 5)
       }
       double () {
           return  new Num( this.value * 2)
       }
    }
var num = new Num(2);
num.add5 ().double ()


class Num{
       constructor (value) {
          this.value = value ;
       }      
       map (fn) {
         return new Num(fn(this.value))
       }
    }
var num = new Num(2);
num.map(add5).map(double)

class Functor{
       constructor (value) {
          this.value = value ;
       }      
       map (fn) {
         return Functor.of(fn(this.value))
       }
    }
Functor.of = function (val) {
     return new Functor(val);
}

Functor.of(5).map(add5).map(double)

https://www.zhihu.com/question/19635359/answer/420267395

class Maybe{
       constructor (value) {
          this.value = value ;
       }      
       map (fn) {
          return this.value ? Maybe.of(fn(this.value)) : Maybe.of(null);
       }
    }
Maybe.of = function (val) {
     return new Maybe(val);
}

var a = Maybe.of(null).map(function (s) {
  return s.toUpperCase();
});

https://www.zhihu.com/question/19635359/answer/420267395

一个是通过类这种方式，传unwrappped value进去实例化成对象，用对象来wrap value
然后在对象里面用method来操作里面的unwrapped value,并且每次操作完之后用值再次
实例化一个对象并返回，Maybe(unwrapped value).map(f).map(f)
另一种是用List来wrap value, 然后 Array.prototype.function= {}, 这种给原型添加
方法，并且这个方法返回的也是一个list, 这样就可以 [].function().function()

###################################################

adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html

2 -> (+3) 2 -> 5

Functor: apply a function to a wrapped value and get a wrapped value
fmap    (+3)   (Just 2) -> Just 5
fmap ::(a->b)-> f    a  ->  f   b

<$> is the infix version of fmap

(+3) <$> Just 2  is same to fmap (+3) Just 2

Applicatives: apply a wrapped function to a wrapped value and get a wrapped value
Just (+3)  <*>  Just 2  == Just 5

[(*2), (+3)] <*> [1,2,3]   ==    [2,4,6,4,5,6]

(*) <$> Just 5 <*> Just 3 == Just 15
liftA2 (*) (Just 5) (Just 3)  ==  Just 15        liftA2 does the same thing

Monad: apply a function to a wrapped value, but that function take unwrapped value and return a wrapped value, the function is >>=  and it's pronounced bind.

half x = if even x
         then Just (x `div` 2)
         else Nothing

Just 3 >>= half     == Nothing        use >>= to shove the wrapped value to the function

>>= :: m a -> (a-> m b) -> m b
      Just 3     half      Nothing
      Just 6     half     Just 3

Just 6 >>= half     == Just 3

λ> Just 20 >>= half >>= half >>= half
Just 5
λ> Just 20 >>= half >>= half >>= half
Nothing

IO Monad
getLine >>= readFile >>= putStrLn

λ> getLine >>= readFile >>= putStrLn
test.hs
module X where
half x = if even x
         then Just (x `div` 2)
         else Nothing
              

λ> 


######################################################

Either a b   use typeclass create a Int|String

f::Int -> Maybe Int

module module-name-for-other-files (export-function-name) where      where like {} after int main()

#!/usr/bin/runhaskell   in archlinux

or $runhaskell Main.hs

cabal package manager like pip in python

if ... then ... else ...
case ... of ...
let ... in ...

data Position = MakePosition Double Double
PointA :: Position
PointA = MakePosition 0 0

PointB :: Position
PointB = MakePosition 3 4

distance:: Position -> Position -> Double
distance p1 p2 =
         case p1 of
              MakePosition x1 y1 ->
                     case p2 of
                          MakePosition x2 y2 -> sqrt ((x1-x2)^2 + (y1-y2)^2)

use case...of... get value from a value create by value constructor
case x of
     pattern1 -> expression1
     pattern2 -> expression2

use let ... in ... can get the value
getX :: Position -> Double
getX p = let MakePosition x _ = p
         in x
pointFoo :: Position
pointFoo = MakePosition 3 4
getX pointFoo  will get 3

or just define a function

f::Position -> Double
f MakePosition x y = x

data Position = MakePosition a a 是错的，=右侧出现的type variable必须在=左侧出现过
但=左侧出现的type variable可以不出现在=右侧

data Position a = MakePosition Int Int
MakePosition 2 2 :: Position a
MakePosition 2 2 :: Position Char
MakePosition 2 2 :: Position Double
MakePosition 2 2 :: Position String     因为这个a是未知类型，没有明确指出类型或进行类型约束

data Maybe a = Just a | Nothing
Nothing :: Maybe a
Nothing :: Maybe Int
Nothing :: Maybe Char

module X where
import Text.Read
parseInt :: String -> Maybe Int
parseInt = readMaybe

λ> parseInt "3"
Just 3
λ> parseInt "abc"
Nothing


Either a b    a type can be Int or String

parseInt :: Maybe String -> Maybe Int    how to define this function?

################################################################

haskell的函数类型是什么? 返回值的类型? 为什么函数无法用于模式匹配?
codeHZ: 可以认为是 -> 类型构造器没有对应的值构造器,属于编译器特殊支持

module Test where
data Struct val =
                Empty
                | NonEmpty StructType val
data StructType =
                Exec1
                | Exec2
apply::Struct a -> String
apply (Empty) = "empty"
apply (NonEmpty exec struct) = "exec1 or exec2"                

                               
--apply Empty
--apply (NonEmpty Exec1 undefined)
--apply (NonEmpty Exec1 "aha")
--apply (NonEmpty Exec2 3)
--apply (NonEmpty Exec2 (\x -> 3 +x))
--apply (NonEmpty Exec2 ())
                
apply2::(Show a)=> Struct a -> String
apply2 (NonEmpty exec struct) = "exec1 or exec2"

--apply2 (NonEmpty Exec1 "a")                                
                                
apply3::(Show a)=> Struct a -> String
apply3 (NonEmpty exec _) = "exec1 or exec2"


<jusss> data Struct val = Empty | NonEmpty StrucType val;   data SturctType =
        Exec1 | Exec2;   apply::Struct a-> String;    apply (NonEmpty exec
        struct) ="exec1 or exec2"
<jusss> how I can use an expression to call it?  [13:35]
<jusss> apply NonEmpty ? ?   will get "exec1 or exec2"/
<jusss> apply NonEmpty Exec1 ?
 <slack1256> jusss: Can you use a paste service for that code?  [13:43]
<slack1256> jusss: apply (NonEmpty Exec1 undefined) should work  [13:44]
<jusss> slack1256 https://paste.ubuntu.com/p/RS7FtkHfFG/
<slack1256> jusss: I don't understand what you want to do
<jusss> slack1256 just an example from stackoverflow help me understand Value
        Constructor
<dmwit> jusss: Here are two examples of calls: `apply Empty` or `apply
        (NonEmpty Exec1 ())`  [14:09]
<dmwit> Just for fun, here's a third that may look a bit weirder to initiates
        of other languages: `apply (NonEmpty Exec2 (\x -> 3 + x))`  [14:10]
<jusss> dmwit: the question is how to handle that undefined type variable when
        it is called
<jusss> https://paste.ubuntu.com/p/s84KjsTtjH/
<dmwit> The caller of `apply` may choose any specific type they like to
        substitute for `a`.  [14:11]
<jusss> dmwit: wait a second, but function don't have a type I think,   [14:12]
<dmwit> In my three examples above, I left it unspecified (`Empty`), chose the
        unit type `()` (`NonEmpty Exec1 ()`), and chose a function type
        `Integer -> Integer` (`\x -> 3 + x`).
<jusss> dmwit: normal function has a type?
<dmwit> Certainly.
<dmwit> :t \x -> 3 + x  [14:13]
<lambdabot> Num a => a -> a
<dmwit> :t \name -> "Hello, " ++ name ++ "!"
<lambdabot> [Char] -> [Char]
<jusss> dmwit: so normal function can be used in pattern match?
<jusss> dmwit: value constructor is totally same with normal functions?
<dmwit> There are no interesting patterns which match functions.  [14:14]
<ggole> Variable patterns!
<dmwit> Yes, data constructors may be applied to functions.
<dmwit> ggole: Right. Variables and underscore. I consider these not
        interesting, because they can be used for *any* type.
<dmwit> There are no patterns which match functions but do not match every
        type.  [14:15]
<dmwit> (Hm. Maybe some view patterns, hey? Anyway that's an advanced topic
        for another time...)
<c_wraith> yeah, view patterns could, but that's a totally different thing,
           really  [14:16]
<ggole> Hmm, isn't there a pattern ascription extension?  [14:17]
<ggole> It might be better to think of functions not having any constructors
        with which to destructure function values, rather than talking about
        types.
<dmwit> You're right. I hereby steal that much better phrasing as my new
        definition of "interesting".  [14:20]
<jusss> this is really make me confused! so functions do have types? and they
        have types but can not be used in patter match?  [14:21]
<jusss> value constructor and normal function are same thing or not?  [14:22]
<jusss> can I call value constructor as function?
<slack1256> jusss: yep in the sense that they have types, but they are not of
            the same "kind"
<jusss> (Num a => a -> a) is one function's type? right?  [14:24]
<slack1256> % :t Just
<yahb> slack1256: a -> Maybe a
<c_wraith> jusss: functions don't actually have constructors.  But that's not
           conceptually any different from any other type that has
           constructors, but keeps them hidden someplace you can't import.
<slack1256> Just is a value constructor for Maybe and also a function that
            returns a Maybe  [14:25]
            
######################################

https://stackoverflow.com/questions/10893747/

data T a = V a

Value Constructor can be used to pattern match as parameter before '=' , but function can't

data Struct val = Empty | NonEmpty StructType val
data StructType = Exec1 | Exec2

apply :: Struct -> String
apply (Empty) =  "matched Empty"
apply (NoEmpty a _) = "matched Exec1 or Exec2"        a is Exec1 | Exec2, _ is val 

apply2 :: Struct val -> String
apply2 (Empty) = "matched Empty"
apply2 (NonEmpty Exec1 _) = "matched Exec1"
apply2 (NonEmpty Exec2 _) = "matched Exec2"

#######################################333

in repl
:t :type
let x=1
:t x
x::Num a => a     x的类型为Num类型类的实例,可以为Int或Integer Float Double

类型类 typeclass
Num 是个typeclass，它的实例类型有 Int Integer Float 和 Double
Eq 的 有== 和 /==
Ord 有 < > <= >=这些类型
Show 有 show类型,转换为字符串
=> 类型约束
typeclass => type variable
Num a => a      则a的类型只能是Int 或 Integer Flaot Double

max' :: (Ord a) => a -> a-> a     max'有两个参数，参数的类型为Ord的实例,返回也是同样的类型
max' a b
     | a < b = b
     | otherwise = a

:i x 显示identifier的信息
x::Num a => a

:l :load .hs file
:r :reload

1+1=3    pattern match
1+1 will return 3

in repl, there're three ways to run code

1.   :{ xxx
        xxx
     :}

2.  :l file.hs

3.  let x=y

add :: Int -> Int -> Int
add x y = x+y   这样的add 1.0 2.0会出错，因为1.0不是Int

add :: Num a => a -> a -> a   
add x y = x+y  这样可以add 1.0 2.0或 add 1 2

a->a->a 表示第二个参数的类型和第一个参数类型形同，结果类型也一样

中缀表达式  1 `add` 2     parameter `function` parameter

https://zhuanlan.zhihu.com/p/21338799

---------------------------------------------------------------

main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("hey" ++ name ++ ",you rock!")

do将这些I/O操作合为一体，成为一个I/O操作，类型为IO(), putStrLn I/O操作的返回类型为()即空元组unit
getLine的返回类型为String,所以name的类型为String
只有通过<-才能打开I/O的返回值

ghc --make file-name 可以把file-name.hs编译成native code

if there's error, try re-install ghc and ghc-libs first.

let _FirstName = map toUpper firstName
let用于函数返回值的绑定, <- 用于I/O返回值的绑定

------------------------------------------------------------------------------

Type Constructor and Value Constructor

data T a = V a   
w = V 3 则 w :: T Int
x::T String 则 V "whatever"的type是x, (T String)是一个type,而(V "whatever")是一个value

data A = B
A是Type Constructor, B是Value Constructor

data T a = V a 就定义了T和V

Elm里的Type相当于Haskell的data
而在haskell里type相当于elm的Type alias
type X = Int  X就可以代表Int

newtype相当于一个优化的data

newtype = 只允许有一个值的data

newtype X = X Int 定义了一个新的X类型和对应的俩构造器

data X = X Int 表示X这个值构造器接受一个Int返回一个X
X::Int -> X
haskell GADT

data X = Int 是没有这种写法的，只有 type X = Int 定义类型构造器的别名

data Y = Y
x = Y 这样是可以的

值构造器不是类型

Int是个类型构造器
data Int = 0|1|2|...|4294967295

Value Constructor可以当作一类特殊的函数，可以在模式匹配里用,match pattern,
但普通函数不能在模式匹配里用， 值构造器可以作为函数使用，也可以模式匹配
所以Haskell有类型构造器 值构造器 和函数,  其它语言里的Constructor一般是指Value Constructor
data E = X | Y
:type X
X :: E
:type Y
Y :: E
:type 1
1 :: Num p => p
:type 1 :: Int
1 :: Int :: Int
所以:1也是值构造器还是多态的

类型构造器和值构造器都可以没有参数
data Bool = True | False   Bool是个无参数的类型构造器, True和False是无参数的值构造器
data Maybe a = Nothing | Just a    Maybe是类型构造器，a是在等号左边是类型变量,a在等号右边是值变量，Just是值构造器

Haskell除了值，类型之外还有Kind
Int是Int::*
Maybe是*->*
Kind就是Type的Type,  Idris可以无限层级堆叠类型
Haskell最高只有两阶类型，所以没法表达所有集合的集合, 是data和typeclass之别，好像没问题，Elm 0.19还没有typeclass
https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/
C++好像也是两阶的
Kind就是描述类型构造器的类型的,
先用Type描述数字，data Nat这样用Nat Succ这样去描述数字
https://hackage.haskell.org/package/data-nat
data-nat: data Nat = Zero | Succ Nat

data T a = V a
x :: T Int 怎么把V 3里的3通过操作x提取出来？
得把x写成函数
x :: T Int -> Int
x (V boom) = boom
或者
x biu = case biu of
        (V boom) -> boom

Elm没有data,只有Type和Type alias, Elm的Type和Haskell的data功能一样, Elm的Type alias和Haskell的type功能一样或者newtype?
Haskell开LambdaCase之后可以这样写
:set -XLambdaCase
y = \case (V boom) -> boom
:type x
x :: T a -> a
:type y
y :: T a -> a

Module X where 这个where就是定义了一个块状区域，类似c系语言里的大括号把后面缩进的内容都包含进去了

t = map f  这个是curring柯里化也是pointfree写法
括号里有逗号就是tuple,没有逗号就是优先求值
x :: (Int, String, Int) -> Int 和 y :: Int->String->Int-> Int 后者是柯里化的

haskell没有一元tuple 但是有0元tuple,0元tuple就是()

module X where 就是指这个文件的名字是X.hs或X.elm, where类似C的大括号,这个文件可以作为模块给其它文件使用
也可以 module Main where, module Test where, module Whatever where, module就是把这个文件声明成了模块给其它文件使用
而在python里一个文件默认就是模块，test.py可以在同目录的其它python文件里直接import test去掉文件名后缀.py导入，但是为了防止在导入
test.py时求值里面的函数，所以一般就在test.py里把求值的函数都写在if __name__ == '__main__':里，这样在其它文件导入test.py时，
因为主文件的__name__才等于__main__,导入时test.py里的__name__不等于__main__这样test.py里的求值函数就不会求值，
因为python的执行顺序是从top到bottom,所以python的程序入口点entry point就是第一行，
而C的程序入口点是main(),  Elm和Haskell的程序入口点是main = 

#######################################

Geometry.hs the module must be Geometry


##########################################

association list, in scheme a-list in cl plist, in python dict
it doesn't have an order or sequence
simpe way to do a dict is use lists or tuple
phoneBook = [("betty","555-2938")
	    ,("bonnie", "452-2938")
	    ]

find an element in an empty list, it cause an runtime error,
use Maybe data type to avoid that, if it doesn't find what
you want, return Nothing, otherwise return Just something,
and something is that value associate to the key.

findKey :: (Eq k) => k -> [(k,v)] -> Maybe v
findKey key [] = Nothing
findKey key ((k,v):xs)
    |key == k = Just v
    |otherwise = findKey key xs


####################################

find :: (a->Bool) -> [a] -> Maybe a
the type of Maybe a means its value may be one element or empty, if it failed to evaluate
Nothing means value is empty like empty list
Just "hey" a value has one element, it contains "hey"

############################################

module X where
main = print $ f 33
f :: Integer -> Integer
f x = x + x

main = program's entry point, like int main() in C

python's if __name__ == '__main__' is not the entry point, because python run from the top to bottom by sequence,
this if __name__=='__main__' is used for preventing evaulate when import,
but haskell doesn't run by that sequence, so you need give the entry point,

_name_ means current module's name, one file is one module,
if you import file a in file b, and run file b then the __name__ point
to file b, and a will be evaluated when it's imported, but if you put
that function call code in if __name__ == '__main__' in a, when a is imported
in b, a will not be evalated,

this if __name__=='__main__' only work for preventing the module you import to
be evaluted,
python's entry point is the first line
https://www.zhihu.com/question/49136398


#########################################

in ghci, you must define a function declaration after a function signature
so use :{  :} to handle multiple lines
:{
 f::Int->Int
 f x=x
 :}

or use let,
let f::Int->Int; f x=x

#####################################

M-x package-install haskell-mode
(add-to-list 'ac-modes 'haskell-mode)
open test.hs and haskell-mode should be enabled by default, and
M-x interactive-haskell-mode
then code in test.hs, and C-c C-l, it will load the code in the GHCi
https://wiki.haskell.org/Emacs/Keybindings_and_simple_usage

(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
(add-hook 'haskell-mode-hook 'haskell-indent-mode)
(add-hook 'haskell-mode-hook 'haskell-doc-mode)

https://opensourceforu.com/2014/01/getting-started-haskell-emacs/
#############################################

import Data.List
numUniques :: (Eq a) => [a] -> Int
numUniques = lenght . nub       pointless style meaning \xs -> lenght (nub xs)
:m + Data.List 
import Data.List (nub, sort)

Data.List any function,  it takes a condition and a list as parameters,
it tells us if there is an element fit the condition
any (> 4) [1,2,3]      False
any (=='F') "Frank Underwood"  True


########################################
x:xs means a list's head is x and the rest are xs, if the list have only one element then xs is an empty list
_ means multi-variables
head' :: [a] -> a
head' [] = error "empty"
head' (x:_) = x      _ must come with ()
#############################
point-free stype A.K.A pointless style

sum' :: (Num a) => [a] -> a
sum' xs = foldl (+) 0 xs

pointless
sum' :: (Num a) => [a] -> a
sum' = foldl (+) 0
####################################

function application operator $
space split,left to right, f a b c == ((f a) b) c
$ make it right to left, sqrt (3+4+9) eq sqrt $ 3+4+9
it seems like $ in bash, expand variable and get its value, $a it means a's value
##########################
function composition
(f . g)(x) = f(g(x))
map (negate . abs) [5,-3,2,-19,24]     [-5,-3,-2,-19,-24]
map (negate . sum . tail) [[1..5], [3..6], [1..7]]      [-14,-15,-27]

###########################

foldl takes a two-parameter function, an initial value and a list
just like map, the difference is it has an initial value 
sum' :: (Num a) => [a] -> a
sum' xs = foldl (\acc x -> acc + x) 0 xs
sum' [3,5,2,1]     11

fold list from left to right of a list, called foldl
from right to left, called foldr
foldll and foldrl don't need the initial value, they use the first or last as initial value

currying and map
what if currying on map?
g = map f
g alist

#######################
lambda 
\x -> x + 3
#################################

| means guard
catchall pattern like case
guard like if-else   bool

bmiTell :: Double -> String
bmiTell bmi
    | bmi <= 18.5 = "underweight"
    | bmi <= 25.0 = "normal"
    | bmi <= 30.0 = "fatty"
    | otherwise = "whale"
that after '=' it acctually can be a function

filter :: (a->Bool) -> [a] -> [a]    (a->Bool) a function takes a and return Bool
filter _ [] = []    if it's empty list then return empty list whatever the function it is
filter p (x:xs)
    | p x = x : filter p xs        if p x is true, put x to new list
    | otherwise = filter p xs

##########################
applyTwice :: (a -> a) -> a -> a
applyTwice       f        x =  f (f x)
(a->a) means this is a function and it takes a and return a

predicate function is a function whos return value is Bool type

map :: (a->b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs    this x:xs:[] == [x:xs] finally it returns []
############################
about partial function,
a function's curring, it doesn't evaluate something immediately, it just changes the form
f(x,y)   to f(x)(y)   f(x) will not evaluate immediately, it will wait for y, unless you 
change something in the function f inside, reference curring in javascript
###############################################3
max :: (Ord a) => [a] -> a
=> is type constraint, it declares type variable a is a instance of the typeclass Ord

(==) :: (Eq a) => a -> a -> Bool

typeclass: Eq, Ord, Show, Read, Enum, Bounded, Num, Floating, Integeral

"I think typeclass is used for specify the type of the type variable"
typeclass Floating has two type instance, Float and Double

#######################################################
pacman -S ghc

ghci

* + are called infix function, others are prefix function, split with space 

[john@moon lab2]$ cat test.hs 
doubleMe x = x + x 

###load file in ghci repl
Prelude> :l test.hs
[1 of 1] Compiling Main             ( test.hs, interpreted )
Ok, one module loaded.
*Main> doubleMe 3
6


doubleSmallNumber x = if x > 100 then x else x*2
if must come with else , if-else is an expression not a statement in haskell

[1,2,3] ++ [9,2]    [1,2,3,9,2]   ++ only used in list, and string is a list of characters
cons operator :
'A' : " SMALL CAT"     "A SMALL CAT"
5:[1,2,3]    [5,1,2,3]

cons is short for construct!    constructor in JS construct object with function,
in python construct in class, in Elm construct data with type

[9.4, 33.2] !! 0     9.4  get value by offset 

[3,2,1] > [2,1,0] 

[1..20] is short for [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
['a'..'z']
['K'..'Z']
[2,4..20]
[3,6..20] [3,6,9,12,15,18]
[13,26..24*13]
take 24 [13,26..]
[x*2 | x <- [1..10]]     set comprehension  2x (1<=x<=10)
[x*2 | x <- [1..10], x*2 >= 12]  this x*2 >= 12 is a predicate expression, return a bool value, true or false

haskell support type inference, no need for type declare
:t 'a'     'a' :: Char
4 == 5 :: Bool

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z

type must start with upper-case character
:t head    head :: [a] -> a       a is a type variable, a can be any type
a function which used type variable is polymorphic function

type is an instance of a typeclass,

