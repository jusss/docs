
https://www.emacswiki.org/emacs/PythonProgrammingInEmacs
自带的python-mode,再安装auto-complet就可以自动补全Python代码
还有个就是jedi插件 jedi.el
https://stackoverflow.com/questions/7138039/vim-autocomplete-for-python

https://stackoverflow.com/questions/25669809/how-do-you-run-python-code-using-emacs
自带的python-mode.el, 在python buffer里面
C-c C-z 打开个python shell
C-c C-c 运行这个buffer里的代码在已经打开的python shell里
C-c C-r 运行选中的代码 用mark标记的块

emacs自带的python-mode再安装auto-complete就能自动补全python代码，不一定非得用jedi,在python-mode里C-c C-z打开个python shell,然后C-c C-c就能直接运行buffer里的代码
----------------------------------------------------------------
python 使用()来用作函数调用
f=lambda x: x+1
f(3)
(lambda x: x+1)(3)

exit不能退出repl, 但是exit()可以退出repl
------------------------------------------------
检查object是否为str isinstance(object,str)
得到某object的所属的类 type("a") -> <class 'str'>

except Exception as e:   e is not str object, e is a Exception subclass
e.__str__() is str object, and e.args is tuple

https://docs.python.org/3/tutorial/errors.html?highlight=exception

The except clause may specify a variable after the exception name. The variable is bound to an exception instance with the arguments stored in instance.args. For convenience, the exception instance defines __str__() so the arguments can be printed directly without having to reference .args. One may also instantiate an exception first before raising it and add any attributes to it as desired.

>>> try:
...    raise Exception('spam', 'eggs')
... except Exception as inst:
...    print(type(inst))    # the exception instance
...    print(inst.args)     # arguments stored in .args
...    print(inst)          # __str__ allows args to be printed directly,
...                         # but may be overridden in exception subclasses
...    x, y = inst.args     # unpack args
...    print('x =', x)
...    print('y =', y)
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs

try:
...  a+b
... except Exception as e:
...  print(e.__str__())
...  print(type(e.__str__()))
... 
name 'b' is not defined
<class 'str'>

或者也可以用logging来存储这个异常进文件，当然也可以直接用e.__str__()来存异常进文件
import logging;
logger = logging.getLogger(__name__)

then in except clause:
   logger.critical('something bad happened', exc_info=True)

这个e多为异常的子类，e.args是异常信息，为tuple,也可以用e.__str__()直接输出字符串异常信息
元组tuple和列表list很像，区别就是tuple的元素不可更改，用()替代[]
a=("ad", "adb")
