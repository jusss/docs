

sudo rsync -RrvP IMG/ /mnt/ # this is like cp -r IMG/ /mnt/
-------------------------------------------------

<glguy> embed :: Functor f => f a -> (forall b. (a -> b) -> f b); embed x f =
        fmap f x
<glguy> unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a; unembed f
        = f id

<glguy> liiae: Looks like
        http://hackage.haskell.org/package/kan-extensions-5.2/docs/Data-Functor-Yoneda.html
        liftYoneda and lowerYoneda
<liiae> glguy: is it useful in real programming?                        [09:36]
<glguy> I've seen it used to help GHC optimize uses of Lens, and it comes up
        in a small way in the way my configuration schema library is
        implemented, among other places                                 [09:37]
<liiae> glguy: I've seen some articles about yoneda lemma, but I still have no
        idea what it's about
<glguy> liiae: two things really, making it more efficient to repeatedly use
        fmap on something
<glguy> and making it possible to use fmap on something at all when it isn't
        already a functor
<liiae> glguy: is it related to CPS?                                    [09:43]
<lambdabot> Axman6 said 38m 11s ago: You might find these slides useful for
            understanding Yoneda and a few other similar ideas. Sadly it
            doesn't look like it was
            recorded. https://slides.yowconference.com/                 [11:11]
<lambdabot>
            yowlambdajam2017/Humphries-ContinuationsAllTheWayDown.pdf?feature=oembed
            (talk info
            https://yowconference.com/talks/tim-humphries/yow-lambda-jam-2017/continuations-all-the-way-down-12518)
<liiae> are there some exercise to help beginner to learn parsec?       [11:10]
<hololeap> liiae: i would say play around with parseTest                [11:40]
<hololeap> you give it a parser and a string and it prints the result to
           stdout
<hololeap> % import qualified Text.Parsec as P                          [11:45]
<hololeap> % parseTest (string "hello" *> P.space *> string "world") "hello
           world"
<yahb> hololeap: "world"
<hololeap> liiae: it also helps to understand how Applicative works. parsec
           will help you develop a better intuition for
           Applicative/Alternative                                      [11:46]
<hololeap> % parseTest (string "hello" <* P.space <* string "world") "hello
           world"                                                       [11:48]
<yahb> hololeap: "hello"

-----------------------------------------------
#Sum of Facts
-- f n = 1! + 2! + 3! + 4! + 5! + .. + n!
fact 1 = 1
fact n = n * (fact (n-1))
f n = sum $ fmap fact [1..n]  -- O(n)

main = print $ f 3

--------------------------------------------------------
#debian #mirror
there're two mirrors, repo mirrors and cd mirrors
https://mirrors.tuna.tsinghua.edu.cn/debian/ and http://mirrors.aliyun.com/debian/ are repo mirrors,
http://www.debian.org/CD/http-ftp/#mirrors is cd mirror
-----------------------------------------------------------
forever, replicate and cycle

replicate 3 9 == [9,9,9]
cycle [3] == [3,3,3,3,3...]
replicateM 3 (print 3) -- will call 3 times `print 3` and return a result [(),(),()]
forever (print 3) -- will `print 3` forever

<jusss`> l <- async $ f1 v1; m <- async $ f2 v2; how to share that v1 and v2
         in both?
<jusss`> in f2 to visit that v1
<jusss`> Waldkauz: f1 and f2 both are loop functions                    [17:02]
<jusss`> Waldkauz: for example, f1 is that recv function about socket, it's a
         loop for recv something from internet
<jusss`> Waldkauz: and f2 is a send function, it needs that what f1 received
         data
<jusss`> so how I can get what f1 received in f2?                       [17:04]
<jusss`> since f1 and f2 both are loop functions, so I don't think await to
         get the result is a good way

1.

<jusss`> or make f1 and f2 aren't loop functions, use `wait` to get what f1
         received and pass it to f2, put f1 and f2 in one loop
         so f2 could use f1's result and f1 won't block f2 even f1 is blocking
         
        forever $ do {
         r1 <- async f1 
         do some other stuff
         result <- wait r1
         r2 <- async f2 result
         result2 <- wait r2
         }

2. 
use parsec to turn ":nick!~user@addr PRIVMSG #channel :words" to 
data IRCMsg = IRCMsg {nick :: String, user :: String, addr :: String, cmd :: String, channel :: String, word :: String}



--------------------------------------------------------
android-x86 8.1-r5, speaker and headphone jack both working at the same time,
use `alsa_amixer set Speaker 100 mute` to mute speaker
use `alsa_amixer set Speaker 100 unmute` to unmute speaker

or install alsamixer app on android

wifi reconnection fail issue, try `pkill wpa_supplicant` in chroot

-------------------------------------------------------------
about sdcard, you may choose UHS card to instead of SDHC card, and make it as internal storage
---------------------------------------------------
mount -t vfat /dev/block/mmcblk1p1 /sdcard/debian #mount esp to change grub
add `androidboot.selinux=permissive intel_idle.max_cstate=1` in EFI/Android/android.cfg linux line
umount /sdcard/debian/
after reboot, dmesg|grep idle to check
---------------------------------------------------------------
(debian, buster i386)  (img, 512k 7500 ext4) (sdcard, vfat-8k bs)

#dd if=/dev/zero of=debian.img bs=4096k count=2000       # 8G
dd if=/dev/zero of=debian.img bs=512k count=7500       # 3.7G
mkfs -t ext4 debian.img

if your update your system without reboot,
then your running kernel may not be your installed kernel,
then you may fail to mount

sudo mount -o loop debian.img /mnt/
su
#debootstrap --arch amd64 --foreign sid /mnt/ http://mirrors.aliyun.com/debian 
debootstrap --arch i386 --foreign buster /mnt/ http://mirrors.tuna.tsinghua.edu.cn/debian
cd /mnt
chroot . /bin/bash
/debootstrap/debootstrap --second-stage 
exit
cd
umount /mnt

now you can pass you debian.img to android


df -h # show where your sdcard mount on, like /mnt/media_rw/0435-FB6C/
su
mkdir /sdcard/debian
cd /sdcard/debian
mount -o loop /mnt/media_rw/0435-FB6C/debian.img ./debian
cd debian
mount -o bind /dev ./dev
mount -t proc /proc ./proc
mount -t sysfs /sys ./sys
mount -t devpts /dev/pts ./dev/pts
mount -t tmpfs tmpfs ./tmp

put that to mount.sh

chroot . /bin/bash
vim source.me
#!/bin/bash
export PATH=/sbin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
export TERM=vt100
source source.me
passwd root
su root
cd
useradd -m john
passwd john

vi /etc/group
inet:x:3003:root
net_raw:x:3004:root

su root
ping 192.168.1.1

vi /etc/resolv.conf
nameserver 8.8.8.8

when you use outline vpn in android,
you can't get network in chroot

vi /etc/apt/source.list
deb http://mirrors.aliyun.com/debian sid main non-free contrib

chroot . /bin/su - root

chmod 777 /etc/resolv.conf   # this is important! otherwise you can ping repo server, but apt can't resolve it
usermod -g inet _apt
groups _apt # check if inet is the primary group for user _apt
# https://wiki.debian.org/ChrootOnAndroid
su root

apt update

click Google Play -> menu -> Settings -> Play Store version several times to update it to latest version, just like that enable developer options

MX Player can play movies on amd64 android, and also it can rotate the screen

rotate who android screen by a player, what a surprise!

https://github.com/phusion/baseimage-docker/issues/58
dpkg-reconfigure debconf

./mount.sh
chroot . /bin/bash
source ./source.me
source /root/.bashrc
su root
su john
/bin/bash
cd
source ./bashrc

./umount.sh
/system/bin/umount ./tmp
/system/bin/umount ./dev/pts
/system/bin/umount ./dev
/system/bin/umount ./proc
/system/bin/umount ./sys

--------------------------------------------
android x86   
solve that after sleep by power button, you can't get back

These are properties, not kernel cmdline.
You may add them to /system/build.prop. 
You can just set the property: sleep.state=none 

https://groups.google.com/forum/#!topic/Android-x86/CVbQm8lq4Fo
https://groups.google.com/forum/#!topic/android-x86/_vU8nNLKicI
https://groups.google.com/forum/#!topic/android-x86/OOdwiY9XRKU

------------------------------------------------
about effects,
Maybe a has Just a and Nothing,
make any f work on Nothing, it returns Nothing
make any f work on Just a, it returns Just (f a)

keep the structure, and change its inside value,

you don't need to do if a == null stuff before
you want f work on a, 
if a is Nothing, f Nothing still is Nothing

fmap (+1) [None, 1, 2] will case error
fmap (+1) [Nothing, Just 1, Just 2] is ok
you needn't check every element is None/null anymore
because any f work on Nothing will get Nothing

null in Java has any type,
but Nothing in Kotlin would only have Maybe a type

concret null any type to one type
concret arbitrary type to one type

if you want different behaviors based on value,
you should use bind

[Nothing, Just 1, Just 2] >>= \x -> if x == Just 1 then return ((+1) <$> x) else return x

> fmap (div 9) [0,1,2]
<lambdabot>  [*Exception: divide by zero

fmap (Just (div 9) <*>) [Nothing, Just 1, Just 2] == [Nothing,Just 9,Just 4]

let mdiv x 0 = Nothing; mdiv x y = Just (div x y) in fmap (mdiv 9) [0,1,2]
[Nothing,Just 9,Just 4]

you still need to specify what 0 will return

Prelude> Just (+1) <*> Just 3
Just 4
Prelude> Nothing <*> Just 3
Nothing
Prelude> Nothing <*> Nothing
Nothing

Just (+1) <*> Just 3 <$> (+)

(+)  <$> ((+) <$> Just 3 <*> Just 3) <*> Just 3  this is anonying
Just 3 >>= \x -> return (+x) >>= \x -> return (+) (x 3) >>= \x -> return (x 3)

if there's a sequence function calls,
you pass Just 3 to it, you will get a Just result
you pass Nothing to it, you will get Nothing at beginning

if the parameter is Just (+1) then use <*> concat

Just (+1) -> f -> g -> h -> Just result
Nothing -> f -> g -> h -> Nothing

Just (+1) <*> Just 3    here it's Just 4, you can't <*> and <$>, because it's in the right parameter position, so >>= come to help

<liiae`> :t (<$>)
<lambdabot> Functor f => (a -> b) -> f a -> f b
<liiae`> :t (<*>)                                                       [18:08]
<lambdabot> Applicative f => f (a -> b) -> f a -> f b
<liiae`> :t (>>=)
<lambdabot> Monad m => m a -> (a -> m b) -> m b

<liiae`> Functor and Applicative, the first parameter are (a -> b) or f (a ->
         b)
<liiae`> but Monad's first parameter is m a
<liiae`> that's why we use >>= to concat a sequence calls stuff?
<Rembane> YEs

<liiae`> use <$> or <*> to chain will be ugly, (+)  <$> ((+) <$> Just 3 <*>
         Just 3) <*> Just 3
<liiae`> it's like h(g(f(a)))

but fmap can chain functions, like function composition
bind can chain values, or chain binary functions

1. Maybe's effect is two branches
2. Use fmap, Use Functor, Use >>=, Use Monad
3. >>= chain whole operations to one, give it Nothing, return Nothing, specify when return Nothing

------------------------------------------------------------
python has a list of symbol operators, but you can't make your own symbols
by define __rshift__() inside an object, so you can use >> on that object

class _Maybe(object):
      def __rshift__(self, function):
        if not isinstance(function, _Maybe):
            error_message = 'Can only pipeline monads.'
            raise TypeError(error_message)

        if not callable(function):
            function = lambda _ : function

        return self.bind(function)

so you can do Just(int)(7) >> add(Just(int)(8))

this >> is _Maybe.__rshift__()

you may use >= for >>= in python
https://docs.python.org/3/library/operator.html
https://bytes.yingw787.com/documents/2019/12/06/monads.py

a < b     __lt__(a,b)
a <= b    __le__(a,b)
a == b   __eq__
!=      __ne__
>      __gt__
>=     __ge__
not    __not__
True   truth
is     is_
is not is_not
+  __add__
//     __floordiv__
~      __invert__
<<     __lshift__
%      __mod__
*      __mul__
@      __matmul__
-      __neg__
|      __or__
**     __pow__
>>     __rshift__
-      __sub__
/      __truediv__
^      __xor__
in     __contains__
&      __and__

also there's existed library called toolz, can provide curry decorator

pip install toolz
from toolz import *
@curry
def add(x,y):
    return x+y

add(3)(4)

add1 = lambda x: x+1
multi2 = lambda x: x*2
t = compose(add1, multi2)
t(3) == 7

from toolz import *
curry and compose can from toolz

from toolz.curried import map, filter, reduce
list(map(add1)([1,2])) == [2,3]
add1OnList = map(add1)
list(add1OnList([1,2])) == [2, 3]

since map return an map object in python3, so use list() on it
[x] is a list with one item in it.
list(x) iterates over x and turns it into a list
so don't use [map(add1)([1,2])], use list(map(add1)([1,2]))

https://toolz.readthedocs.io/en/latest/api.html
toolz.functoolz.pipe(data, *funcs)
pipe(data, f, g, h) is equivalent to h(g(f(data)))

>>> names = ['Alice', 'Bob', 'Charlie', 'Dan', 'Edith', 'Frank']
>>> groupby(len, names)  # doctest: +SKIP
{3: ['Bob', 'Dan'], 5: ['Alice', 'Edith', 'Frank'], 7: ['Charlie']}

from toolz.compatibility import zip
list(zip([0,1],['a','b'])) == [(0, 'a'), (1, 'b')]

PyToolz is Data.List in Python!


###############################################################

python's type hint is just a poor of assert, it won't work very well
do type constraints in python? 
by assert every parameters's type at top of a function definition

assert isinstances(a,str)

--------------------------------------------------------------
#what case the compilers can't help

f :: Int -> Int
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
f(42) will take a long time, even ghc support TCO,
because this is not a tail call,
also this f(42) will expand to 
f(42) = f(41) + f(40)
      = f(40) + f(39) + f(39) + f(38)
      = f(39) + f(38) + f(38) + f(37) + f(38) + f(37) + f(37) + f(36)
      = ...
the inefficient bit isn't the call costs, it's the exponential asymptotics of the algorithm

------------------------------------------------------------------

it's AD 2020, java still doesn't support TCO, even first-class function, or
higher-order function,
higher-ranked type,
higher-kinded polymorphism,
type inference,
dependent type,
recursive type,
type family,
type application,
typeclass,
derive generic,

---------------------------------------------------------------------

kotlin arrow
https://www.raywenderlich.com/324105-functional-programming-with-kotlin-and-arrow-part-2-categories-and-functors
https://www.raywenderlich.com/9527-functional-programming-with-kotlin-and-arrow-getting-started
https://hltj.me/kotlin/2020/01/11/kotlin-trait-typeclass.html
https://hltj.me/lang/2017/08/01/modern-lang-static-type.html
https://hltj.me/kotlin/2017/08/25/kotlin-functor-applicative-monad.html
https://mattmoore.io/blog/arrow-io-monad


haskell f-algebra
https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/

haskell lens and arrow
https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Arrow.html

-------------------------------------------------------
vim
m a - mark as a
'a - goto back a
ea - append at end of word
> - shift right
< - shift left
e - jump to end of words
0 - (zero) start of line
https://www.worldtimzone.com/res/vi.html
-------------------------------------------------------------------------

#Functor
<liiae> > liftA (+1) [1,2,3]
<lambdabot>  [2,3,4]

#Applicative
<liiae> > liftA2 (+) [1,2,3] [2,5]                                      [14:47]
<lambdabot>  [3,6,4,7,5,8]

#Monad
<liiae> > [1,2,3] >>= (\x -> if x == 1 then return x else return (x+2))
<lambdabot>  [1,4,5]
<liiae> now I see

<liiae> Functor and Applicative, do the same behavior on the value inside a
        context without change their structures
<liiae> Monad, can do different behavior

when you need to operate on a value inside a context without change its structure,
make it as an instance of Functor, implement fmap

when you need to operate on one more values inside same contexts,
make it as an instance of Applicative, implement <*>

when you need to operate different behaviors based on the value,
make it as an instance of Monad, implement >>=


------------------------------------------------------------------------

<c_wraith> for applicative, the function being applied must be blind to the
           applicative context.  It's an (a -> b) function inside there.
<c_wraith> for monad, the function is (a -> m b)
<c_wraith> So you get to make decisions about what `m b` value to produce
           based on the `a` value.

<dibblego> Functor does liftA1, Applicative does liftA[0..N], Monad does (<=<)

<dminuoso> I like to think of monads as being about "sequencing" and
           applicatives as being about "branching off and joining together in
           a diamond"

<hololeap> another way to think about it is that Applicative allows you to
           combine multiple effects
<hololeap> :t \fa fb -> (,) <$> fa <*> fb                               [14:01]
<lambdabot> Applicative f => f a1 -> f a2 -> f (a1, a2)
<hololeap> and gives a way to lift something into a default "effectless"
           effect
<hololeap> :t pure
<lambdabot> Applicative f => a -> f a
<hololeap> while Monad allows you to take a "double-wrapped effect" and make
           it into a regular effect                                     [14:02]
<hololeap> :t (>>= id)
<lambdabot> Monad m => m (m b) -> m b
<dminuoso> I like to think of monads as being about "sequencing" and
           applicatives as being about "branching off and joining together in
           a diamond"
<dminuoso> (The fact that you get sequencing in applicatives can be imagined
           by "sequencing the left and right branches of the diamond onto each
           other, somewhat senselessly" 

fmap :: Functor f => (a -> b) -> f a -> f b
fmap can let you manipulate some values inside *without* changing
the structure of the thing.
<liiae> when I need to operate on `f a` with `(a -> b)` and return `f b`, I
        should make it as an instance of Functor

<liiae> :t liftA2
<lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
<liiae> when I need to operate on two `f a` or more, I should make it as
        instance of Applicative

<dibblego> do a <- x; b <- f a; ... -- here, a is named on the left of <- and
           then used on the right of <- in the following expression
<dibblego> liiae: you needed monad for that, applicative is not enough
<dminuoso> Can you see how this is a mix between Monad and Applicative? :)
<dminuoso> (The idea is, the first effect can produce Left or Right, and if
           its a *Left* then the second effect is run)
<dminuoso> So you have sort of "dynamic" decidability which effects should be
           run, but statically analyzable (since you can just look at the tree
           and combine all the possible effects)

Just 5 >>= \x -> Just 4 >>= \y -> return $ x + y

--------------------------------------------------------------
#mapTree #binaryTree
-- there's a list [1,2,[3,4],[3,[5,6,[7]]]], who to let every element in it plus 1?
-- <Cale> jusss`: All the elements of a Haskell list must have the same type
-- <Cale> jusss`: If we want a tree, we'll use a tree data type

data Tree a = Nil | Cons a (Tree a) | Subtree (Tree a) (Tree a) deriving (Show)

v :: Tree Int
v = Cons 1 (Cons 2 (Subtree (Cons 3 (Cons 4 Nil)) (Subtree (Cons 3 (Subtree (Cons 5 (Cons 6 (Subtree (Cons 7 Nil) Nil))) Nil)) Nil)))

instance Functor Tree where
    fmap f = g
        where
            g Nil = Nil
            g (Cons x t) = Cons (f x) (g t)
            g (Subtree t t') = Subtree (g t) (g t')

main = print $ fmap (+1) v

-- Cons 2 (Cons 3 (Subtree (Cons 4 (Cons 5 Nil)) (Subtree (Cons 4 (Subtree (Cons 6 (Cons 7 (Subtree (Cons 8 Nil) Nil))) Nil)) Nil)))

--data Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)
--mapTree :: (a->b) -> Tree a -> Tree b
--mapTree f (Leaf x) = Leaf (f x)
--mapTree f (Node xl xr) = Node (mapTree f xl) (mapTree f xr)

v = [1,2,[3,4],[3,[5,6,[7]]]]
def plus1(l: list): 
    return [ plus1(i) if type(i) is list else i + 1 for i in l ]
print(plus1(v))
# [2, 3, [4, 5], [4, [6, 7, [8]]]]


def g(x):
    if (x == []): return []
    if (not isinstance(x, list)):
        return x+1
    else:
        return [g(x[0])] + g(x[1:])

# the point here is waiting its result, so it won't return too early
# return f(list[0]) + f(list[1:]), but f(list[0]) is a Int, and f(list[1:]) is a [], so [f(list[0])] + f(list[1:])
        
print(list(map(g,v)))

def g2(f,x):
    if (x == []): return []
    if isinstance(x,list):
        return [g2(f,x[0])] + g2(f,x[1:])
    else:
        return f(x)

f_ = lambda x: x+3
result = map(lambda x: g2(f_,x), v)
print(list(result))


-----------------------------------------------------------

#recursive type

newtype Consumer a = C (a -> IO (Consumer a))
runConsumer :: Consumer a -> a -> IO (Consumer a)
runConsumer (C f) x = f x
f :: Show a => Consumer a; 
f = C (\x -> do print x; return f)

-- main = do 
--     f' <- runConsumer f 3; 
--     f'' <- runConsumer f' 4; 
--     f''' <- runConsumer f'' 5; 
--     return f'''
-- 
main = do
    f <- runConsumer f 3
    f <- runConsumer f 4
    f <- runConsumer f 5
    return f

------------------------------------------------------------------
there's no way to extend a typeclass in haskell, like requrie a new function
implement in that existed typeclass,
but you can make a new typeclass which is a subclass of that typeclass,
like Applicative is a sub typeclass of Functor
every Applicative instances must be instances of Functor,

(Functor f) => forall a. f a

not just that a could be replaced, that f could be replaced too,
so Maybe Int, Maybe String you may see,
also Maybe Int, [Int]
so (Functor f) => f Int or f String is valid

g :: (Functor f) => f Int -> f (Int -> String) -> f String
this can't use Functor,
<Cale> You need Applicative f if you want the sensible thing. You could also
ignore the first argument and do something like g _ x = fmap ($ 0) x

<Cale> Functor doesn't let you do anything to combine values of f-typed things

f Int could be Maybe Int, [Int], Either a Int

f and a in `f a` both can be replaced

we can constrain types which has * with typeclass,
also we can constrain types which has * -> * with typeclass
make a new typeclass IS, make Int and String as its instances
IS a => a this a only can be Int or String
and IS can ony have Int and String now, * -> * can only be IS
even you can do (Functor f, IS a) => f a, so it only can f Int, or f String

Java/Kotlin can't do type constraints for existed types like Int or String,
they can create a new super class for type constraints if new subclasses to inherit it.
but they can use an enum class doing type constraints for existed types,
like Either<String, Int>, enum, union, sealed, whatever you call it

<Cale> It's polymorphic in a choice of functor f
<jusss> typeclass can do type constraints, require specific function
        implements and function overloading, that OOP langauges don't have
        those at the same time
<jusss> they may have generics, interfaces and class extensions, but they're
        three stuff
<jusss> dmwit: so when I see kotlin's arrow code, it's really weird to me
        about higher-kinded polymorphism,
<jusss> they may concrete the `a` in `f a`, and replace that `f`, I never saw that in haskell
<jusss> like that `f Int` or `f String`
<jusss> `f Int` may be `Maybe Int` `[Int]` `Either a Int` ...  
<jusss> but we may just use `f a`...
<jusss> or make a new typeclass for Int and String, then do type constraints
        on that `f a`                                                   [13:52]
<jusss> those static type languages give me a feel that they want do something
        freely as dynamic languages, and with type system protection?
<dmwit> Hm. That could be one way to understand it. =)
<Cale> Type classes let you do things that would be essentially impossible in
       dynamically-typed settings
<jusss> dmwit: do you like that recursive type? function return function
        itself is normal in dyanmic languages which haskell doesn't support
<Cale> The instance of a type class to be used can depend on the result type
       of the operation for example, which is usually something you can't
       easily do in a dynamically typed setting
<jusss> Cale: but type is alive on run-time?
<Cale> jusss: hm?
<Cale> jusss: Types aren't around at runtime
<dmwit> jusss: I like recursive types. Haskell can have a function that
        returns a function (even recursively) with minimal fuss; at most some
        newtype nonsense.
<Cale> They're erased by compilation
<Cale> (at least in Haskell)        
<dmwit> % newtype Weird a = Weird (a -> Weird a)
<yahb> dmwit: 
<dmwit> % f :: Weird a; f = Weird (\x -> f)
<dmwit> jusss: ^ no matter how many arguments you feed to `f`, it will still
        return yet another function.                                    [14:02]
<dmwit> % feed :: Weird a -> a -> Weird a; feed (Weird f) x = f x
<dmwit> % :t feed (feed f 3) 4
<yahb> dmwit: Num a => Weird a
<c_wraith> that's possible, but not very useful.  :P
<dmwit> Sure. But more useful things are possible with the same trick.
<c_wraith> variations of it are very useful, though
<dmwit> It is pedagogical.
<jusss> dmwit, aha, js: const f = _ => {console.log(_); return f}  how about
        to implement this  in haskell?
<c_wraith> don't forget the surprisingly useful newtype Hyper a b = Hyper
           (Hyper b a -> b)                                             [14:04]
<c_wraith> doesn't look useful.  actually is!
<dmwit> :t \f _ -> putStr "" >> return f -- jusss, this?
<lambdabot> b -> p -> IO b
<dmwit> I don't know js. So.
<dmwit> (`b` can be chosen to be the type of a function, no problem)    [14:05]
<dmwit> jusss: I am going to bed. Keep asking questions. Others here can also
        help you.                                                       [14:06]
<jusss> c_wraith: do you know a little js?                              [14:07]
<jusss> const f = _ => {console.log(_); return f}  could express in haslell?
<c_wraith> which would end up like \a b -> print b >> return a
<jusss> f 3 should print 3, f 3 4 should print 3 and 4, f 3 4 5 should print 3
        4 5                                                             [14:10]
<jusss> in other languages, f(3), f(3)(4), f(3)(4)(5)
<jusss> if python support multiple lambdas, it should be `f = lambda x:
        print(x);return f`                                              [14:11]
<jusss> so f(3)(4)(5) and f(3) and f(3)(4) have the same return value, which
        is f itself
<Cale> jusss: Evaluation of a function can't usually print anything in Haskell
<jusss> koz_: c_wraith \f _ -> putStr "" >> return f is that?
<Cale> If it's allowed to produce an IO action which must be executed to give
       you the function, that's easier though.                          [14:13]
<jusss> which is?                                                       [14:14]
<Cale> You'll need a recursive newtype to make this work, since if you think
       about it, we'll need something like  Show a => a -> IO t  where t = a
       -> IO t
<jusss> code? :)                                                        [14:15]
<Cale> So in order to make that happen, we can define  newtype Consumer a = C
       (a -> IO (Consumer a))
<Cale> runConsumer :: Consumer a -> a -> IO (Consumer a)                [14:16]
<Cale> runConsumer (C f) x = f x
<Cale> and then have  f :: Show a => Consumer a; f = C (\x -> do print x;
       return f)                                                        [14:17]
<Cale> So, then you can write stuff like:                               [14:18]
<Cale> do f' <- runConsumer f 3; f'' <- runConsumer f' 4; f''' <- runConsumer
       f'' 5; return f'''
<Cale> Of course, with this particular f, that's a little silly         [14:19]
<Cale> But if we had an f which was producing a different consumer in its
       result than itself, then chaining like this would be meaningful
<Cale> In Haskell, we don't have a type t for which t is *actually* equal to a
       -> IO t, but with this newtype, we get one for which t is isomorphic to
       a -> IO t
<jusss> Cale: f' <- runConsumer f 3;     f'' <- runConsumer f' 4;     f''' <-
        runConsumer f'' 5;  we couldn't have f <- runConsumer f 3?
<Cale> You could, but that would shadow the f which was in scope, which is
       just confusing
<jusss> Cale: how it could like be?
<jusss> I just wonder, of course this may not be meaningful
<Cale> Not sure I understand that question
<jusss> Cale: "You could, but that would shadow the f which was in scope,
        which is just confusing"
<Cale> Yeah, the code you wrote is valid, it's just not advisable, since you
       won't be able to refer to the old f any longer. Perhaps that's what you
       want, but shadowing like that is also confusing to readers usually.
<jusss> could you show me how?                                          [14:30]
<Cale> I don't know what you're asking me to show
<Cale> You wrote the code, I'm saying that's valid
<Cale> You could replace the occurrences of f' and f'' and f''' in the code I
       wrote with f                                                     [14:31]
<Cale> and it would mean the exact same thing
<Cale> It's just a more confusing way to write the same code
<dminuoso> I think they're rather hoping for something like mdo         [14:32]
<jusss> Cale: I see
<Cale> dminuoso: mdo wouldn't make sense here, because then there's nothing to
       determine any part of f                                          [14:35]
<dminuoso> Oh I know Cale, it's just an educated guess based on the many
           previous conversations I've had with them.
<dminuoso> Consider their example of `const f = _ => {console.log(_); return
           f}`                                                          [14:36]
<dminuoso> Im not saying it makes any particular sense, it's more probably
           jusss has some gaping confusion in their head. :)            [14:37]
<Cale> Well, we took a fixed point originally when defining f, sure
<jusss> dminuoso: I just wonder can we do something freely as dynamic
        languages                                                       [14:38]
<dminuoso> With crutches and tricks we can mimic dynamic languages, yes.
<dminuoso> Is it a good idea? Most likely not.
<Cale> This kind of recursive continuation-y thing can be useful
<Cale> A lot of early arrowized FRP systems are based on a slightly more
       elaborate version of this trick
<Cale> You can get "local state" by having parts of the computation which
       replace themselves. I suppose a lot of the stream processing libraries
       like pipes and conduit also apply                                [14:40]
<jusss> "recursive continuation-y" I wonder if there's "fixed-point
        continuation" and what it would be?                             [14:43]
<Cale> In which particular case?                                        [14:45]
<Cale> Usually that's a reasonable way of expressing infinite loops     [14:46]
<jusss> I don't know yet                                                [14:47]
<jusss> just a random combine term                                      [14:48]
<jusss> goto = callCC \out -> fix out, that is interesting              [14:49]
<Cale> That's not really goto, but the thing which would make a label
<Cale> (and then you'd execute the label to jump back to there)         [14:51]
<jusss> it has take me a few days to learn Cont Monad and higher-kinded
        polymorphism in arrow-kt, and I'm still not clear about them,   [14:53]
<Cale> We don't really use the Cont monad a whole lot                   [14:54]
<Cale> Cont can clean up a very particular kind of mess, but it's one that
       doesn't show up too often
------------------------------------------------------
kotlin's companion object is that skeleton in java,
it just means you can call this class like an object
object C { ... } you can call C.xxx
or class C { companion C } you still can call C.xxx also
this class C could have an instance
----------------------------------------------------------
_ is only used in pattern matching, out of pattern matching, _ would be an error

<Axman6> _ when not used in a pattern causes a specific kind of error. its not
really poart of HAskell, since no program can be compiled if it still
contains _ in an expression

<jusss> so if there're "null" and "Object" in haskell?
<jusss> Void correspoinds that value doesn't exist
--------------------------------------------------------------

I think the benefits about FP are referential transparency and immutable data,
the benefits about static languages are type constraints on generics,
it can detect type errors on compile time, not run-time
typeclass, trait, concepts?
they're just group some specific types, and do ad-hoc polymorphism
but python could do `assert isinstance("3",str)` to check type
with decorator, it will be more powerful

Dependent Type is a popular topic now, 
but I wonder when languages that have CoC type system would be popular

----------------------------------------
#Sum #ad-hoc polymorphism
union, enum, sealed class can implement Sum type

Sum type is not ad-hoc polymorphism
Bool is a sum type, but not polymorphic
typeclass Monad is ad-hoc polymorphism
not parametric polymorphism, id is.
ad-hoc polymorphism just a group of specific types, not all types

but Sum type and ad-hoc polymorphism both can solve same problem,
they can do type constraints,

if Int and String are instances of typeclass IS,
then f :: IS a => a -> a
this a only can be Int or String,

f :: Either String Int -> Either String Int
this a only can be Left String or Right Int

they both can do type constraints
but typeclass would ask specific implement functions
Sum type doesn't

####################################3

interface NIS<T> {fun T.fmap():T}
sealed class NIIS<T>: NIS<T>
data class NIntIS(val x: Int): NIIS<Int>(){
   override fun Int.fmap(): Int{
       return this+x+1
   }
}

data class NStringIS(val x: String): NIIS<String>(){
    override fun String.fmap(): String{
        return (this+x).reversed()
    }
}
fun <T>g3(x: NIIS<T>):Any{
    if (x is NIntIS){
       with(NIntIS(0)) {
           return NIntIS(x.x.fmap())
       }
    }
    if (x is NStringIS){
        with(NStringIS("")){
            return NStringIS(x.x.fmap())
        }
    }
    return x
}


fun main(){
    println(g3(NIntIS(3)))
    val gg =g3(NStringIS("321"))
}

////////////////////////////////////////////////
generics constraints(type variable constraints)
+ interface(require specific function implements)
+ class extension(function overloading)
== typeclass

kotlin couldn't make existed class to inherit other interface
Int can do class extension, but Int can't inherit new interfaces

kotlin use a new way to do that,
define a interface IS<T>, it requires function T.f,
then implement object ISI inherit IS<Int> and ISS inherit IS<String>
now you declare a value x has IS<T>
and it could be IS<Int> or IS<String>
and inside IS<T>, the value x has function f,
use `with(ISI) { 3.f() }`
or `ISI.run { 3.f() }`

interface Functor<T>, require T.fmap
sealed class Maybe<A>: Functor<T>
data class Just<A>: Maybe<A>() implement fmap
object FS: Functor<String> implement String.fmap

so when you declare x: Functor<T>
you can pass Just<A> or Functor<String> instances
those instances have fmap function

also you can do class extension for interface,
so that class which inherit that interface would have that functions

interface WithLength<T> {val T.length: Int}
object StringWithFakeLength: WithLength<String> { override val String.length get() = 128 }
fun <T, U: WithLength<T>> U.printLength(t: T) = println(t.length)
StringWithFakeLength.run { printLength("hltj.me") }

there's no such thing like F<A> in kotlin,
this F<A> is just F, not F<A>,
kotlin doesn't support higher-kinded polymorphism,
KEEP 87 is not approved yet,
and arrow-kt has Kind<F,A> to simulate higher-kinded polymorphism,
by
interface Monad<F> : Applicative<F> {
  fun <A, B> Kind<F, A>.flatMap(f: (A) -> Kind<F, B>): Kind<F, B>
  ...
}
interface Kind<out F, out A>
typealias Kind2<F, A, B> = Kind<Kind<F, A>, B>
typealias Kind3<F, A, B, C> = Kind<Kind2<F, A, B>, C>

you can just image that simulation Kind<F,A>, F :: * -> *

I would call that <A,B> quantified types in fun <A,B> Kind<F,A>
just like forall a. in haskell

# define functor, not possible yet, because lack of hihger-kinded polymorphism support
interface Functor<C<*>> {
    fun <T, R> C<T>.fmap(f: (T) -> R): C<T>
}

-- so we can have this within arrow

interface Kind<out F, out A>
interface Functor<F> {
    fun <T, R> Kind<F, T>.fmap(f: (T) -> R): Kind<F, R>
}

//then we define Maybe Functor
class ForMaybe private constructor()

sealed class Maybe<out T> : Kind<ForMaybe, T> {
    object `Nothing#` : Maybe<Nothing>() {
        override fun toString(): String = "Nothing#"
    }
    data class Just<out T>(val value: T) : Maybe<T>()
}

fun <T> Kind<ForMaybe, T>.fix(): Maybe<T> = this as Maybe<T>

object MaybeFunctor : Functor<ForMaybe> {
    override fun <T, R> Kind<ForMaybe, T>.fmap(f: (T) -> R): Maybe<R> = when (val maybe = fix()) {
        is Maybe.Just -> Maybe.Just(f(maybe.value))
        else -> Maybe.`Nothing#`
    }
}

fun main() = with(MaybeFunctor) {
    println(Maybe.Just(5).fmap { it + 1 })
    println(Maybe.`Nothing#`.fmap { x: Int -> x + 1 })
}
https://www.ituring.com.cn/article/509017
//////////////////////////////////////////////

interface IS<T> { fun T.f(): T}
class IntIS(): IS<Int> {
     override fun Int.f(): Int {
        return this+1
    }
}

class StringIS(): IS<String> {
    override fun String.f(): String{
        return this.reversed()
    }
}
fun <T> g(x: T):Any? {
    if (x is Int) {
        with(IntIS()){
            return x.f()
        }
    }
    else if (x is String) {
        with(StringIS()){
            return x.f()
        }
    }
    else return x
}
#ad-hoc polymorphism
fun <T> g2(x: T):Any? {
    if (x is Int) return x+1
    else if (x is String) return x.reversed()
    else return x
}

fun main(){
    println(g(2))
    println(g("123"))
    println(g2(3))
    println(g2("2323"))
}


///////////////////////////////////////////////////////////

#kotlin #lambda
f({ x -> x}) in kotlin, it can be f { it }
f( { x -> g(x) } ) could be f { g(it) }
return {x -> x} could be return { it }
-------------------------------------------------------
Change project name
1. close android studio, change the root directory name of the project
2. open android studio then open the project
3. Build - Clean Project
4. just keep the package name
5. res/values/strings.xml, app name
6. settings.gradle, delete rootProject.name = 'Your project name' this line

https://stackoverflow.com/questions/18276872/change-project-name-on-android-studio
-------------------------------------------------------

#ADB #Android 

set this 
%LOCALAPPDATA%\Android\sdk\platform-tools
on $PATH on windows 10, if you have installed android studio,
then you already have this adb tools,
cmd - adb tcpip 5555; adb connect deviceIp:5555
then you in device, enable adb on development mode and accept this connection
then in you android studio, just click run, it will show the connection

----------------------------------
#isomorphic #Cont #Continuation #CPS
<Cale> jusss: X and Y are isomorphic types if there exist functions f :: X -> Y and g :: Y -> X such that f . g = id and g . f = id

#Reader
(do x <- (+1); y <- (+2); return (x+y)) 3

<int-e> jusss: You're missing an r, I think. Cont r a and (a -> r) -> r are
        isomorphic as types but they have fundamentally different Monad
        instances associated with them.
<int-e> jusss: The Monad instance would be that for (->) (a -> r), so a
        (somewhat strange) reader.     

<int-e> jusss: There's a Monad instance for  ReaderT m r  which implies one
        for Reader r. There's a separate instance for (->) r. They are
        behaviorally the same.

r -> a and Reader r a = Reader {runReader ::r -> a} have the same behavior
r -> a and Reader are ismorphic

(->) a could be call Reader Monad, they have same instances
but (a->r) -> couldn't be call Cont Monad, they don't have same instances

##########################################
when you want to get a function's original code so that to change it,
that's reflection, get that function's describe, and comment code in it.
when you want people to redefine their own function, that's interface

#####################################################

<jusss> dminuoso: I tried to implement that Fix f type in kotlin, and Fix
        Maybe can't be implement
<jusss> dminuoso: make Maybe as a class with a parameter, Just and Nothing is
        another class inherit it
<jusss> dminuoso: but Fix <Maybe> couldn't exist, because Maybe need a A
<jusss> Fix<Maybe<A>> is ok
<jusss> but in haskell, we have Fix Maybe, not Fix (Maybe a)
<jusss> sealed class Maybe<A>; data class Just<A>(val x:A): Maybe<A>();  data
        class Nothing: Maybe<Any>()                                     [16:10]
<jusss> sealed class Fix<F>; data class MkFix<F:Fix<F>>(val x:F): Fix<F>(); 
<jusss> there couldn't be an object has Fix<Maybe>
<dminuoso> jusss: Most type systems are fairly limited in expressiveness.
<jusss> but we could have Fix Maybe in haskell, that's where I don't know
<jusss> dminuoso: so I wonder how they implement Fix type in their type system
<jusss> dminuoso: Kotlin, Java, other static type languages             [16:15]
<dminuoso> jusss: I reckon they cant.
<jusss> dminuoso: fix combinator is a common stuff on value level, even python
        can have that
<jusss> fix and const
<jusss> we could have fix combinator on value level in python, but in type
        level, I don't know                                             [16:24]

##################################################
use eta-conversion to do 'thunk' for that turn call-by-name function to call-by-value function
to avoid eval immediatly
fix f = f (fix f) this fix f will eval immediatly in call-by-value eval stratege,
use eta-conversion to do thunk, fix f = \x -> f (fix f) x, this won't eval immediatly in call-by-value

#FixedPoint #python #fix #eta
<jusss> Axman6: I tried that fix f = f (fix f), it won't work in python, does
        haskell do some magic on it?
<jusss> fix = lambda f: f(fix(f))                                       [09:54]
<jusss> reverse__ = lambda f: lambda l: [] if l == [] else f(l[1:]) + [l[0]]
<dolio> Python is call-by-value, so you'd need to use a different combinator.
<dolio> `fix f x = f (\y -> fix f y) x` or something along those lines.
<dolio> It's probably only important to guard the fix call.
<dolio> jusss: Yes. Call-by-value will just keep calling fix forever
        immediately.
<dolio> So you need to eta expand around the call to fix, and it can't work
        for values.
<dolio> Or, non-functions.
<jusss> dolio: you're right! fix = lambda f,x: f((lambda y: fix(f,y)),x)
<jusss> reverse_ = lambda f,l: [] if l == [] else f(l[1:]) + [l[0]]
<jusss> print(fix(reverse_,[3,8,9]))
<ski>   (define fix (lambda (f) (lambda (x) ((f (fix f)) x))))  ; or this, if
      you just want to support passing one argument to `f'
<ski>   fix = lambda f: lambda x: f(fix(f))(x)
<ski>   reverse = fix(lambda f: lambda l: [] if l == [] else f(l[1:]) + [l[0]])
<jusss> f = partial(fix,reverse_)
<ski>   print(reverse([3,8,9]))                                         [10:15]
<ski> jusss : are you sure something like that ^ doesn't work ?
<jusss> ski: yes, it will work, 
<ski> so, Python does "support currying"                                [10:16]
<jusss> "The obvious definition of the Y combinator (\f-> (\x -> f (x x))
        (\x-> f (x x))) cannot be used in Haskell because it contains an
        infinite recursive type (a = a -> b). Defining a data type (Mu) allows
        this recursion to be broken. "                                  [10:17]
<jusss> https://rosettacode.org/wiki/Y_combinator#Haskell
<jusss> is that true?
<ski> oh, and `(cons (f (cad l)) (car l))' in your Scheme version ought to be
      `(append (f (cdr l)) (list (car l)))' (and i'd rather use `(null? l)' as
      the condition)                                                    [10:18]
<ski> jusss : yes. you can do it with `ocaml -rectypes', though
<ski> (but there's a reason why neither Haskell, nor OCaml (by default)
      supports equi-recursive types, aka "infinite types" or "cyclic types")
<jusss> dolio: "<dolio> `fix f x = f (\y -> fix f y) x` or something along
        those lines." you did twice eta-conversion?
<jusss> fix f = f (fix f); fix f x = f (fix f) x                        [10:20]
<jusss> fix f x = f (\y -> fix f y) x
<ski> jusss : "It's probably only important to guard the fix call."
<jusss> ski: by how?                                                    [10:21]
<ski> huh ?
<ski> (i don't understand the question)
<jusss> I don't understand "guard the fix call"
<ski> (that's what i wrote in my Scheme and Python versions, anyway)
<ski> jusss : but, this is assuming a strict language (otherwise no eta is
      needed)
<ski> jusss : so, in the definition `fix = lambda f: f(fix(f))', eta-expanding
      `f(fix(f))' there yeilds `fix = lambda f: lambda y: f(fix(f))(y)'
<jusss> ski: fix f = f (fix f) = \y -> f (fix f) y = f (\y -> fix f y)?
<jusss> outsider and inner eta-conversion
<ski> hm, yes. so i ought to have said that `fix f x = f (fix f) x' is
      enough. sorry about that                                          [11:13]
<jusss> ski: oh, I see
<ski> you want the call `fix f' to not immediately call `fix' again     [11:14]
<monochrom> It is easy to lose track and forget that Haskell is merely a
            programming language.
<ski> so, if you define `fix f' to be `\y -> (...) y', then that lamda will
      "guard" the `fix' call inside `...', which here is `f (fix f)'
<ski> next, when you actually supply an input `y' to `fix f', you don't want
      the body `f (fix f) y' to run away into an infinite loop. but since `fix
      f' here will compute (say) `\z -> (...) z' (renaming `y' to `z', just
      for clarity), that call to `fix' won't cause any further immediate
      expansion. only when `f' decides to call its argument function, with
      some input `z', will that `...' inside the argument function `\z ->
      (...) z' happen
<ski> and so on ..
<ski> jusss : does that make any sense ?
<jusss> ski: this trick is related to that trampoline?
<ski> jusss : not really
<monochrom> Completely unrelated to trampoline.
<ski> (at least not that i'm aware of)
<monochrom> Instead, this is how to fake call-by-name in a call-by-value
            language, by raising every basic value to the function level.
<ski> trampolines can be used to implement tail-calls on top of a system which
      doesn't provide them                                              [11:21]
<monochrom> You want "1+1" to be evaluated later not sooner? Turn it into a
            function, \() -> 1+1.
<ski> (such a function is often called a "thunk")
<jusss> ski: someone tell me that eta-conversion could be really help when do
        reduction in CPS, he suggest me to read <On One-Pass CPS
        Transformations>
<ski> hm, i don't recall if i've read that one
<jusss> and I have no idea what that is now...
<jusss> by Oliver Danvy
<ski> jusss : but you might perhaps have some use, reading either "Abstracting
      Control" or "Representing Control" (i forgot which), by Olivier Danvy &
      Andrzej Filinski
<ski> hah, doesn't surprise me that that was Danvy                      [11:23]
<ski> and yes, strategic eta-expansions are helpful for that
<d34df00d> Is there any combinator that's reasonably close?             [11:24]
<jusss> ski: I will take a little time to think about this, and thank you

<lambdabot> fix f = let x = f x in x
<Axman6> jusss: fix f = f (fix f)
from functools import partial

reverse = lambda l: [] if l == [] else reverse(l[1:]) + [l[0]]
#print(reverse([1,2,3]))

reverse_ = lambda f,l: [] if l == [] else f(l[1:]) + [l[0]]
#print(reverse_(reverse,[1,2,3]))

reverse__ = lambda f: lambda l: [] if l == [] else f(l[1:]) + [l[0]]

#fix f = f (fix f)   
#fix = lambda f: f(fix(f)) //won't work in call-by-value eval strategy
#fix f = f (fix f) = \y -> f (fix f) y = f (\y -> fix f y) // outsider and inner eta-conversion

#fix f x = f (\y -> fix f y) x   //do twice eta-conversion
fix = lambda f,x: f((lambda y: fix(f,y)),x)  #will work in call-by-value

#fix f x = f (fix f) x  //do once eta-conversion is enough
fix2 = lambda f: lambda x: f(fix2(f))(x)

rev1 = partial(reverse_, reverse)
rev2 = partial(reverse_, rev1)
print(reverse_(rev2,[1,2,3]))

const = lambda x, _: x
_reverse = partial(const, reverse)
print(_reverse(_reverse(reverse))([1,2,3]))
print(fix(reverse_,[3,8,9]))
print(fix2(reverse__)([3,9,2]))


"""
const x _ =  x
f' = const f
f = fix (const f)
f' f = f

-- any function could be a fixed point of other functions, recursive or not
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

reverse' f [] = []
reverse' f (x:xs) = f xs ++ [x]

main = print $ reverse' (reverse' reverse) [1,2,3]


f2 = lambda f, n, accum: accum if n==1 else f ((n-1), (n* accum))
f2NoRecur = lambda n, accum: accum if n ==1 else f2 (f2NoRecur, (n-1), (n* accum))
print(f2NoRecur(990,1))

"""

#######################################################################

newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }

runReaderT . ReaderT = id
runReaderT $ ReaderT f = f

ask :: ReaderT r m r
asks :: (r->a) -> ReaderT r m a
<- ask will get r from ReaderT r m a
<- asks f will get (f r)

data Environment = Env
  { firstName :: String
  , lastName :: String
  } deriving (Show)

helloworld :: Reader Environment String
helloworld = do
  f <- asks firstName
  l <- asks lastName
  return ("Hello " ++ f ++ l)

runHelloworld :: String
runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"

data Environment = Env
  { firstName :: String
  , lastName :: String
  } deriving (Show)

t2 :: Environment -> String
-- t2 :: Reader Environment String
t2  = do
  x <- firstName
  y <- lastName
  return $ "Hello " ++ x ++ y

--main = putStrLn (t2 $ Env "John " "Doe")
-----------------------------------------

#Random #unsafePerformIO

System.IO.Unsafe.unsafePerformIO
System.Random

unsafePerformIO (newStdGen >>= \x -> return $ randomR (0,999999) x)

<wavemode_> it's for when the thing you're doing with it is actually pure
            (i.e. calling some C code which is pure). generating random
            numbers is not pure                                         [14:16]
<wavemode_> using it with something impure is very unsafe
------------------------------------------------------
interface can do communication between class in kotlin
interface can do ad-hoc polymorphism in haskell
ad-hoc or overload, one function take different type parameter,
do different behaviors
interface, generic in java

----------------------------------------------------------
#Kotlin #Interface #Class #Communication

to visit part attributes of an class in another class, not whole

type has functions, class has functions,
when B pass itself with type A to instance C,
so C only can visit type A's attributes which is implement function a

interface A, class B, class C,
make an interface A and implement function a,
make class B implement that interface A, 
and call B's attributes in function a in B,
then instance C with B's instance in B, with B's type is A,
and within C, C only can visit that attributes of 
B in function a, C can't visit whole attributes of B

interface A { fun a () }
class B : A {
  val b = 1
  val b2 = 2
  override fun a () {
    return b
  }
  val c = C(this)
  print(c.getBattr())
}

class C internal constructor(val b: A) {
  fun getBattr () {
    print(b.a()) // here C can only visit B.b
  }
}

-----------------------------------------------------------

#Kotlin #Coroutine
https://kotlinlang.org/docs/reference/coroutines/basics.html#coroutine-basics
GlobalScope.launch { // launch a new coroutine in background and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println("World!") // print after delay
    }
this GlobalScope.launch {} is non-blocking
GlobalScope mean lifetime is whole application
you should try CoroutineScope

runBlocking {     // but this expression blocks the main thread
        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive
        // this delay is blocking
    } 

fun main() = runBlocking<Unit> { // start main coroutine
    GlobalScope.launch { // launch a new coroutine in background and continue
        delay(1000L)
        println("World!")
    }
    println("Hello,") // main coroutine continues here immediately
    delay(2000L)      // delaying for 2 seconds to keep JVM alive
}

delay in GlobalScope.launch is non-blocking
delay in runBlocking is blocking

val job = GlobalScope.launch { // launch a new coroutine and keep a reference to its Job
    delay(1000L)
    println("World!")
}
println("Hello,")
job.join() // wait until child coroutine completes

fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine in the scope of runBlocking
        delay(1000L)
        println("World!")
    }
    println("Hello,")
}
runBlocking will block whole main wait for the coroutine ending,
and launch in runBlocking is non-blocking

runBlocking and coroutineScope may look similar because they both wait 
for its body and all its children to complete. The main difference between 
these two is that the runBlocking method blocks the current thread for waiting, 
while coroutineScope just suspends,

there shouldn't be two GlobalScope in the code, there's conflicted
but there could be two coroutineScope

import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { 
        delay(200L) //non-blocking
        println("Task from runBlocking")
    }
    
    coroutineScope { // Creates a coroutine scope
        launch {
            delay(500L)  // non-blocking
            println("Task from nested launch")
        }
    
        delay(100L) // blocking
        println("Task from coroutine scope") // This line will be printed before the nested launch
    }
    
    println("Coroutine scope is over") // This line is not printed until the nested launch completes
}

Task from coroutine scope
Task from runBlocking
Task from nested launch
Coroutine scope is over


fun main() = runBlocking {
    launch { doWorld() }
    println("Hello,")
}

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}
Suspending functions can be used inside coroutines just like regular functions,
they can use additional feature in coroutine, here is delay


fun main() = runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(1000L)
            print(".")
        }
    }
}
It launches 100K coroutines and, after a second, each coroutine prints a dot.

Dispatchers.Main is for UI, Dispatchers.IO is for IO, there're also Default and Unconfined
https://stackoverflow.com/questions/54671817/update-ui-async-call-with-coroutines

Dispatchers.Main is A coroutine dispatcher that is confined to the Main thread operating with UI objects. 
Usually such dispatchers are single-threaded.

https://developer.android.com/kotlin/coroutines
In Kotlin, all coroutines must run in a dispatcher, even when they're running on the main thread. 
Coroutines can suspend themselves, and the dispatcher is responsible for resuming them.

To specify where the coroutines should run, Kotlin provides three dispatchers that you can use:

    Dispatchers.Main - for UI, change TextView
    Dispatchers.IO - for IO, network, socket, file writing
    Dispatchers.Default - for computation, parsing json

call withContext(Dispatchers.IO) to create a block that runs on the IO thread pool.

https://stackoverflow.com/questions/53079234/how-to-update-ui-in-coroutines-in-kotlin-1-3
https://medium.com/swlh/how-can-we-use-coroutinescopes-in-kotlin-2210695f0e89

private var viewModelJob = Job()
private val uiScope = CoroutineScope(Dispatchers.Main + viewModelJob)

uiScope.launch {
            withContext(Dispatchers.IO) {
                //Do background tasks...
                withContext(Dispatchers.Main){
                    //Update UI
                }
            }
        }
------------------------------------------------------

update TextView in other class than MainActivity.kt

"there's a TextView in activity_main.xml, I can use findViewById to update text 
on that TextView in MainActivity.kt, but findViewById is not resolved in other file like AnotherClass.kt"

Er Imran4u  3 days ago
findViewById you will not get in other class. if you have to use textview in other class, then pass textview object in that class

Olenyov Kirill  3 days ago
Or you need to have another activity/fragment in your AnotherClass.kt inflated with activity_main.xml

one way is get the TextView by findViewById in MainActivity and passing it to another ClassB by Class initialize
another way is via interface, make an interface A, and function B within it, 
make MainActivity implement that interface, and do findViewById stuff in that function B,
then use `this` pass MainActivity to Class B by Class B initialize in MainActivity, 
so class B can use function B to operate that TextView
https://stackoverflow.com/questions/46217551/communication-between-class-and-activity-via-interface

#One Way

class MainActivity : RobotActivity(), RobotLifecycleCallbacks {

    lateinit var  showTextView: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Register the RobotLifecycleCallbacks to this Activity.
        setContentView(R.layout.activity_main)

        showTextView = findViewById<TextView>(R.id.text1)
    }

    override fun onRobotFocusGained(qiContext: QiContext) {
        val qnAChatbot = QnAChatbot(qiContext,showTextView)
     }
}

class QnAChatbot internal constructor(context: QiContext?, val showAnwser: TextView) : BaseChatbot(context) {

    override fun replyTo(phrase: Phrase, locale: Locale): StandardReplyReaction? {
        if (phrase.text.isNotEmpty()){
            val response = mainNLP(phrase.text)
               showAnwser.text = response
        }
    }
}

#Another Way
class MainActivity : QnAChatbot.UpdateTextView, RobotActivity(), RobotLifecycleCallbacks {
    override fun changeTextView(x: String) {
        val showTextView = findViewById<TextView>(R.id.text1)
        showTextView.text=x
    }
}

class QnAChatbot internal constructor(context: QiContext?, mac: UpdateTextView) : BaseChatbot(context) {
    interface UpdateTextView {
        fun changeTextView(x: String)
    }
lateinit var n : UpdateTextView
    init {
         n = mac
    }

    override fun replyTo(phrase: Phrase, locale: Locale): StandardReplyReaction? {
        if (phrase.text.isNotEmpty()){
            val response = mainNLP(phrase.text)
            n.changeTextView(response)
}}}

----------------------------------------------------------

#Kotlin #Constructor #Parameter #Class #init #self
class Another (val a: TextView) {
      fun runText() {
          a.text = "a"
      }
}

this a can be resolved when using `val` in the constructor,
if it's 
class Another (a : TextView) {
      fun runText() {
          a.text = "a"   // this a is not resolved
      }
}

but there's another way
class Another (a : TextView) {
      lateinit var an: TextView
      init {
           an = a
           }
      fun runText() {
          an.text = "a"
      }
}
or 
class Another (a: TextView) {
      val an = a
      fun runText(){
          an.text = "a"
      }
}

https://stackoverflow.com/questions/52567108/why-to-put-val-or-var-in-kotlin-class-constructors
-----------------------------------------------------------

monoid is not a monad
monoid has kind *
monad has kind *->*
Maybe is a monad, has kind * -> *
Maybe Int is not a monoid, because Int is not a monoid
Maybe String is a monoid because String is a monoid
semigroup with a empty value (the unit) is monoid
return is the unit in >>=
Just 3 >>= return

-----------------------------------------------
fix f = f (fix f)
data Fix f = f (Fix f)
value need a value constructor
data Fix f = V (f (Fix f))
this Fixed Point type need work with a sum type
data Maybe a = Just a | Nothing is a sum type
data P = P Int String is a product type
this sum type need a bottom value for return,
here is Nothing

data Expr a = Add a a | Const Int | Multi a a
Const Int is the bottom value here for return
Const Int :: Expr a :: Expr (Fix Expr)
V (Const 3) :: Fix Expr
Add (V (Const 3)) (V (Const 3)) :: Expr (Fix Expr)
V (Add (V (Const 3)) (V (Const 3))) :: Fix Expr
Add (V (Const 3)) (V (Add (V (Const 3)) (V (Const 3)))) :: Expr (Fix Expr)
V (Add (V (Const 3)) (V (Add (V (Const 3)) (V (Const 3))))) :: Fix Expr

eval :: Expr Int -> Int
eval (Add x y) = x + y
eval (Const x) = x
eval (Multi x y) = x * y

runFix :: Fix f -> f (Fix f)
runFix (V x) = x

eval2 :: Fix Expr -> Int
eval2 = eval . fmap eval2 . runFix
-------------------------------------------------------
import Control.Monad.Writer
import Data.Time

-- :info! WriterT to get WriterT's definition
-- :t writer (3, "3") :: Writer String Int 
-- that'll let you test such hypotheses

-- data Writer w a = Writer { runWriter :: (a, w) }
-- newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }
-- type Writer w = WriterT w Identity

half :: Int -> Writer String Int
half x = do
     tell ("halved " <> (show x) <> ",")
     return (x `div` 2)  -- context is Writer ( ,String)

-- main = print $ runWriter (half 16 >>= half >>= half)  

--main = print $ runWriter $ writer (16, "16 ")

-- Writer isn't an instance of MonadIO, so liftIO can't lift IO into it
-- WriterT is an instance of MonadIO, which liftIO can lift IO into
halfWriter :: WriterT String IO Int -> WriterT String IO Int
halfWriter x = do
    v2 <- (liftIO getCurrentTime)
    v <- x
    tell ((show v) <> "," <> (show v2) <> ",")
    return (v `div` 2)

main = do
    l <- runWriterT $ halfWriter (writer (16, ""):: WriterT String IO Int)
    l2 <- runWriterT $ halfWriter (writer l :: WriterT String IO Int)
    print l2

-- main = print =<< (runWriterT $ halfWriter (writer (16, ""):: WriterT String IO Int))
    

-- == (2,"halved 8,halved 4,")

--main = print $ runWriter ( writer ("3", 3 :: Sum Int))
--main = print $ runWriter ( writer ("3", Just "3"))

--------------------------------------------------
<lortabac> 'data MaybeInt = Nothing | Just Int' is correct
<liiae> lortabac: only before Int is defined before this
<liiae> everything comes from some where
<liiae> lortabac: Just 3 :: Maybe Int, in your definition, Just 3 :: MaybeInt
<liiae> lortabac: Just 3 is a value, Maybe Int is a type, and yes , there
        could be Just Int in data definition, what we should call it?
<liiae> data P = P Int
<liiae> P 3 :: P
<liiae> what we should call `P Int`?
<Cale> Yeah, that "Just Int" that potentially appears in a data declaration is neither an expression nor a type. It's a data declaration constructor clause, I guess.
<liiae> in the right side of =, P is a value constructor, and Int is a type,
        what we call P Int?
<Cale> It's just a thing that defines a new data constructor, things of that
       sort only appear in data declarations and define data constructors
<liiae> Cale: yes, but why people didn't split it or give it a new name so it won't confused beginners
<liiae> if a show up in the left of = in the type definition, it can show up
in the right side, and a can't show in the right side if a didn't show up in the left side unless a is defined in somewhere else

<liiae> Cale: what's the different between `type IS = Either Int String` and
        `data IS = Either Int String`?
<liiae> oh, I see, this Either in the second is not that Either in the lib

type IS = Either Int String
:t (Left 3) :: IS

<liiae> newtype Fix f = Fix (f (Fix f)), this value constructor Fix in the
 right side of = has nothing to do with the second Fix in the right of =
<Cale> The first and third Fix are the same thing, the second Fix is a
       different thing
<liiae> the second Fix in the right side of = is that left Fix
<Cale> It might be less confusing to write like:
<Cale> newtype Fix f = MkFix (f (Fix f))
<liiae> right
------------------------------------------------------------

Monad, MonadIO, MonadTrans are typeclass
IO is type

lift is for MonadTrans, lift a monad into other monad context, combine to a new one for multiple effects

liftIO is for MonadIO, lift an IO into other monad context,
MonadIO is about access to IO, lift other type into IO

instance (Monoid w, MonadIO m) => MonadIO (WriterT w m) where
  liftIO = lift . liftIO

WriterT w m is an instance of MonadIO only when m is an instance of MonadIO,
and IO is an instance of MonadIO

Writer is a monad, not a monadIO, Writer doesn't have the access to IO
but WriterT has the access to IO

<liiae> MonadIO is the type who can access IO?
<liiae> what about MonadTrans, MonadTrans is for multiple effects to combine
        monad?
<liiae> to an giant one or new one

------------------------------------------------

ghci, think ghci is a whole IO,
so `l <- (getCurrentTime :: IO UTCTime)` is ok
but `s <- Just 3` is ok in ghci
:info! WriterT to get WriterT's definition
:t writer (3, "3") :: Writer String Int 
that'll let you test such hypotheses


Writer is a logger, it can log function every call like time or parameters, store the log in its value
Reader is an environment, 
State is both
Maybe is a option, 
Either is a advance Maybe
Cont is a jump
IO do everything with outside world
[] is a store
() is another store


import Control.Monad.Writer
--data Writer w a = Writer { runWriter :: (a, w) }
half :: Int -> Writer String Int
half x = do
     tell ("halved " <> (show x) <> ",")
     return (x `div` 2)  -- context is Writer ( ,String)

main = print $ runWriter (half 16 >>= half >>= half)  

tell is for concat w in Writer w a
return is for computate value a in Writer w a
writer is for make a Writer w a, writer (16, "16 ")

runWrite (Writer w a) :: (a, w), then fst can get a from Writer w a

halfWriter :: Writer String Int -> Writer String Int
halfWriter x = do
    v <- x
    tell ((show v) <> ",")
    return (v `div` 2)
main = print $ runWriter $ ((halfWriter (writer (16, ""))) >>= half)


<liiae> Maybe a is a monoid when a is a monoid, and Maybe is a monad
monoid has kind *
monad has kind *->*
Maybe Int is not a monoid
Maybe String is a monoid
a monoid is a semigroup with a unit
<dsal> a monoid is a semigroup with an empty value.
<dsal> > Just "hi" <> mempty

[] is a monad has kind *->*
[a] is a monoid, even [Int] is a monoid

mtl and transformers two packages for monad transformers
transformers is old one
Control.Monad.Writer is from transformers
and it points to Control.Monad.Trans.Writer.Lazy

w is short for writer, a is short for the value of computation, like Just a
w need to be a monoid type,
see the >>= definition for Writer or WriterT, that w need to be <>
so it needs to be a mnoid instance

<liiae> Maybe a is a monoid when a is a monoid, and Maybe is a monad
Maybe Int is not a monoid

writer ("3", 3) 3 is Int not a monoid type, 
change it to writer ("3", 3 :: Sum Int)
Sum is from Data.Monoid.

String [] are monoid, Int is not

<liiae> 0 is a unit in (+)
<awpr> the second one is fairly right: 0 and (+) form a monoid (lower-case
       monoid) over integers
<awpr> `Sum` is a type that has a `Monoid` (upper-case) instance implementing that 0 and (+) behavior
<dsal> A monoid is any type that has a binary operator (think: "combine") and an empty value.
<liiae> Cale: the logs is w, and result is a, in Writer w a
<Cale> liiae: yeah
<liiae> w is a monoid instance, so it can be concatenated
<Cale> yep

newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }
type Writer w = WriterT w Identity


import Control.Monad.Writer
main = print $ runWriterT (WriterT (Just ('3', 3)))

WriterT (Just ('3',True)) :: WriterT Bool Maybe Char

writer (3, "3") :: Writer String Int :: WriterT String Identity Int

:t writer (3, "3") :: Writer String Int 
that'll let you test such hypotheses


---------------------------------------------------
newtype Fix f = MkFix (f (Fix f))
MkFix :: f (Fix f) -> Fix f
when f ~ Maybe
MkFix :: Maybe (Fix Maybe) -> Fix Maybe
Nothing :: Maybe (Fix Maybe)
MkFix Nothing :: Fix Maybe
Just $ MkFix Nothing :: Maybe (Fix Maybe)
MkFix (Just (MkFix Noting)) :: Fix Maybe
MkFix (Just (MkFix (Just (MkFix Nothing)))) :: Fix Maybe


data ExprF a = Const Int | Add a a
Const 3 :: ExprF a == ExprF (Fix ExprF)
MkFix (Const 3) :: Fix ExprF
Add (MkFix (Const 3)) (MkFix (Const 3)) :: ExprF (Fix ExprF)
MkFix $ Add (MkFix (Const 3)) (MkFix (Const 3)) :: Fix ExprF

data ExprF a = Const Int | Add a a | Mult a a
this is related to parser or eval something

F-Algebras

https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/
----------------------------------------------------------------
#Fixed Point
https://up.monade.li/sL34es
`fix` allows you to delegate away recursion, so given a recursive definition like

    f x y = ..f..x..y..

you can write the same function as

    f = fix (\f x y -> ..f..x..y..)

So, given

    reverse l = rev l []
        where
            rev [] a = a
            rev (x:xs) a = rev xs (x:a)

you can see that `reverse` itself isn't recursive, but its helper function `rev` is. So defining `reverse` as a fixed point isn't particularly useful, but you can do

    reverse l = fix rev' l []
        where
            rev' rev [] a = a
            rev' rev (x:xs) a = rev xs (x:a)

Note that rev' is the (\f x y -> ..f..x..y..) abstraction from earlier.

https://blog.forec.cn/2016/10/08/haskell-fixit/
http://www.vex.net/~trebla/haskell/fix.xhtml

https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
in this question, get the reverse and foldr definition from hackage.haskell.org, and they're not recurisve, turn them to recursive then use
the mechanical process to get reverse' and foldr'

and of course, the shortest anwser would be
reverse' = const reverse
foldr' = const foldr

GHC.List.reverse not recursive, rev is recursive
reverse l =  rev l []
  where
    rev []     a = a
    rev (x:xs) a = rev xs (x:a)

the tail recursive function need one more argument than non-tail recursive

recursive one
reverse [] = []
reverse (x:xs) = (reverse xs) ++ [x]

reverse' f [] = []
reverse' f (x:xs) = f xs ++ [x]

any function could be a fixed point of other functions, recursive or not

f' = const f
f = fix (const f)
f' f = f

reverse' = const reverse
<awpr> `fix (const x) === x` for any `x`, so you can always find a `g` such that `fix g === f`, namely `const f
<liiae> awpr https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
<awpr> `const reverse` is technically an answer; there are many possible answers`

<liiae> MarcelineVQ: GHC.List.reverse's definition is not recursive, right?
<liiae> MarcelineVQ: https://hackage.haskell.org/package/base-4.14.0.0/docs/src/GHC.List.html#reverse
<MarcelineVQ> correct. reverse does not call reverse, so it is not recursive
         by the normal definition
<MarcelineVQ> however, rev calls rev. rev is recursive.
<liiae> MarcelineVQ: but that non-recursive reverse still could be a fixed
        point of reverse', right?
<MarcelineVQ> I'm really really sure this was said earlier though..
<liiae> fix (const f) = f
<liiae> const f = f'
<liiae> MarcelineVQ: so that codewars anwser can be "import Data.List.reverse; reverse' = const reverse"
<dminuoso> Oh boy, this is just about codewars?
<liiae> dminuoso: fixed point on codwars
<liiae> dminuoso: https://www.codewars.com/kata/5443dd2d7fc4478154000ac6
<MarcelineVQ> There's a reason I said mere minutes ago that const wasn't relevant to the codewars problem. That's not the answer they're trying to get you to write.
<dminuoso> fix allows you to turn explicit recursion into implicit recursion
<liiae> awpr: sorry, I didn't pay more attension on your anwsers, you're right, there's always f' = const f
<liiae> reverse' = const reverse
<dminuoso> fix (const f) = f
<dminuoso> % :t (fix . const)
<yahb> dminuoso: c -> c
<liiae> dminuoso: id == fix . const?
<[exa]> liiae: why not
<liiae> [exa]: wow, id is simple and fix is not simple in my view, and they're the same, is magic
<[exa]> liiae: you instantly "kill" the fix complexity by passing in a function that discards it

let x = 1: x in x
x = 1: x
fix (1:)

fix (const 3) == 3
fix (const reverse) [1,2,3] == [3,2,1]
reverse = fix (const reverse)
reverse' = const reverse

f' = const f
f' f = f
fix f' = f
fix (const f) = f
(fix . const) f = f

id == fix . const

#######################################################################

Fixed-Point

fix f = x
f x = x
f (fix f) = fix f 

fix work on f to get f's fixed point, 
fixed point is where x in f x = x
some functions's fixed point are constant numbers
some are functions

y = x is the line, for single x fuction, 
f x = 3 is a line function which y always be 3, 
it is `const x 3`
and 3 is the only fixed point on f x = 3

f xs = 3:xs, [3,3,3,3...] is xs, is the fixed point on f xs = 3:xs
'cause f [3,3,3...] = 3:[3,3,3...]

a constant number 3 or a list or a function, they all can be fixed point

fix $ scanl (+) 0 . (1:)  this scanl (+) 0 . (1:)'s fixed point is fibonacci sequence

recursion and fixed point, find the function f is which function's fixed point

--foldl f z [] = z
--foldl f z (x:xs) = foldl f (f z x) xs

gg _foldl f z [] = z
gg _foldl f z (x:xs) = _foldl f (f z x) xs
foldl' f z [] = z
foldl' f z (x:xs) = gg foldl' f (f z x) xs
-- 1. based on foldl defintion
-- 2. get gg from foldl = fix gg, which means gg foldl = foldl
-- 3. re-write foldl with gg, get foldl'

-- main = print $ foldl' (+) 0 [1..3]

-- f2 n accum = if n == 1 then accum else f2 (n-1) (n * accum)
f2' f2 n accum = if n==1 then accum else f2 (n-1) (n* accum)
--f2N n accum = if n ==1 then accum else f2' f2N (n-1) (n* accum)
f2N n accum = if n ==1 then accum else fix f2' (n-1) (n* accum)
--main = print $ f2N 10 1

reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

reverse' f [] = []
reverse' f (x:xs) = f xs ++ [x]
--main = print $ reverse' (reverse' reverse) [1,2,3]

--const x _ =  x
--f' = const f
--f = fix (const f)
--f' f = f
-- any function could be a fixed point of other functions, recursive or not
reverse'' = const reverse
main = print $ reverse'' reverse [1,2,3]

#meaning #used for
if f2 is f1's fixed point function,
fix f1 = f2
f1 f2 = f2
so do recursion in f2 like `f2 x`, it can be `f1 f2 x`
this is not recursive,
f2 x = f1 f2 x

on the type level, we can get
data Fix f = MkFix f (Fix f)

#n!
f n = foldl1 (*) [1..n]

###############################################

#lazy evaluation

[a,b,c,d] = map (*2) [1,a,b,c]
d == 16
a = 2, b =2 a, c=2b, d=2c, this only can happen on lazy evaluation
it would be "a is not defined" in JS

#Prime
let primes = 2 : filter isPrime [3,5..]; 
    isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)
    in primes


let s (x:xs) = x : s [ i | i <- xs , mod i x /=0] in s [2..]

#Fibs
let fibs = 0: 1: zipWith(+) fibs (tail fibs) in fibs

fibs = 0 : scanl (+) 1 fibs
fix $ (0:) . scanl (+) 1

fix $ scanl (+) 0 . (1:)   -- eta conversion
fix (\xs -> scanl (+) 0 (1:xs))
let xs = scanl (+) 0 (1:xs) in xs

<awpr> `newtype Fix f = Fix (f (Fix f))` is the common definition, and it
       gives you (modulo newtype constructors) `f (f (f (f (f (f ...)))))))`

#Even
let as = map (*2) (1:as) in as

#############################################
<liiae> what this `.' in scanl (+) 0 . (1:)?                            [14:59]

<xerox_> @src (.)
<lambdabot> (f . g) x = f (g x)
<xerox_> aka function composition
<sshine> (1:) = \x -> 1:x                                               [15:01]
<sshine> > fix (\xs -> scanl (+) 0 (1:xs))                              [15:03]
<lambdabot>
            [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...

<liiae> sshine: why fixed-point is related to fibonacci?                [15:09]
<Cale> liiae: The fixed point that fix gives you can be used to define
       anything recursive                                               [15:10]
<Cale> fix (\x -> ... x ...) is the same as  let x = ... x ... in x     [15:11]
<Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
<lambdabot>  3628800
<Cale> > product [1..10]
<lambdabot>  3628800
<Cale> > fix (\ones -> 1 : ones)                                        [15:12]
<lambdabot>
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
<Cale> > let ones = 1 : ones in ones
<lambdabot>
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
<Cale> fix f = let x = f x in x

<liiae> Cale:
        https://www.quora.com/Why-doesnt-Haskell-implement-infinite-types

<liiae> Cale: we can turn that infinite type to fixed-point stuff?
<awpr> you can write a type family that acts sort-of like `fix`, but it will
       just ruin GHC's day; or, you can write a newtype that acts slightly
       less like `fix` and get recursively-defined but not infinite types
                                                                        [15:15]
<Cale> Which infinite type?
<Cale> But yeah, if you run into a case where you'd otherwise want an infinite
       type, you can generally turn it into a recursively defined type  [15:16]
<awpr> `newtype Fix f = Fix (f (Fix f))` is the common definition, and it
       gives you (modulo newtype constructors) `f (f (f (f (f (f ...)))))))`


################################################

#reflection
reflection is used to get the inside messages of a class
like get variables and functions name of a class

fun isOdd(x:Int ) = x%2 != 0
val s = {it:Int -> it%2 != 0 }
val n = listOf(1,2,3)
println(n.filter(::isOdd))
print(n.filter(s))

::isOdd == s?

######################################3
#extension function

fun Int.foo() {...}
so you can call `5.foo()`

fun foo(): Int {...} is a function return a Int value

also you can do
fun Int.foo(): Int { return this + 1 }

The extension method would work for Int and 
all subclasses of Int, although Int is not an open class 
and therefore cannot be subclassed.

#this expression
in Java, this can do like self in python
class Builder {
 setA(A a){
        return this;
 }
 setB(B b) {
        return this;
 }
}
new Builder().setA(a).setB(b)
this `this` here is current instance, so it can make chainsaw call

this.var = var , like python self.var = var
return this("parameter") for make a new instance

class A {
      inner class B {
            fun Int.foo() {
                var a = this@A   // A's instance
                var b = this@B  // B's instance
                var c = this  // foo()'s receiver is 5, 5.foo(), same as `var c = this@foo`
                var c1 = this@foo // c1 is the caller itself, 5.foo(), then c1 is 5

                // receiver.foo()
                val funLit = lambda@ fun String.(): String {
                        val d = this // funLit's receiver is "a", "a".funLit(),  
                                return d
                                }

            val funLit2 = { s: String ->
                // foo()'s receiver, since enclosing lambda expression doesn't have any receiver
                val d1 = this
                }
}}}

##################################################################

@label

fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // (non-local return),  foo() 
        print(it)
    }
    println("this point is unreachable")
}  // just print 1 2

fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // (local return),  lambda , here is forEach
        print(it)
    }
    println("this point is reachable")
} // print 1 2 4 5 this point is reachable

local return and non-local return, non-local return is return to the whole function's caller
local return is return to this current scope's caller, return@caller
return@to-the-calller

print(3) :: Unit

fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach print(3)
        print(it)
    }
    println("this point is reachable")
} // print 1 2 3 4 5 this point is reachable

return@caller parameter, here `return@forEach print(3)`
when it == 3, return to the caller forEach and make print(3) as forEach's return to outside



#########################################3

#Main Class #Kotlin #Config #Module
package com.aldebaran.ks

this src\main\kotlin\com.aldebaran.ks\server5.kt
"kotlin" should  Make directory as Source Root, a blue tag
and Main class is com.aldebaran.ks.Server5Kt
classpath of module is current project name like KotlinServer

if src\com.sun.k2p\Robot.kt,
then Make "src" as Source Root, Main class is com.sun.k2p.RobotKt

Make package's previous directory as Source Root
and Main Class start with package's name

################################################################

#Kotlin  #constructor
variables in Class but out of function, that's instance variables in other languages
class f {
 var a=0
 fun f() {
    print(a)
    }
}

second constructor in a class is for polymorphic,
constructor for different class parameters

class f(a:Int)
class f(a:Int, b:String)
so that f(3) and f(3,"a") can generate different instances

str.run {
        it.xxx
}
here it mean str itself, see scope functions
sometime it means the parameter itself

this@

in a member of a class, this mean current object of the class
same as java or python's self.



##############################################

use >> to combind IO actions

t = print 1 >> print 2
t will print 1 and 2 at once

sequence $ fmap print [1,2]

sequenceA
sequenceA_

mapM print [1..10]

print "a" <> print "b"

getLine <> getLine 
which will read two lines of input, and produce the result of concatenating them

<Cale> liiae`: It's important to remember that fmap just applies a function to the results of an action
<Cale> It can't be used to combine multiple actions

forM xs f = mapM f xs
main = forM [1..3] $ \n -> do
   print n
   getLine

##############################################
#network #linux #port #check
sudo lsof -i -P -n|grep LISTEN



#enable #android #studio #network #permission #gradle
write those into Manifest.xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
##########################################
Cygwin, MSYS2, WSL2,
wsl is not available for windwos 10 32 bit,
##################################################

FOL, First order logic,
 for all
 exist
 or
 and
 not
 then, same as , x =2  x^2 = 4
 x + 5 = y + 2  x + 3 = y
 xor, a  b is true, a and b both can not be true
 unconditionally true
 unconditionally false
! there's exactly one exist
 definition


######################################################





partial  U+2202
the character  is a stylized cursive d, mainly used as a mathematical symbol

##################################################
<Solonarv> broadly speaking a "parser" is a program (or part of a program)
           that takes any text as input, and if that text conforms to a
           certain format, the parser produces a data structure representing
           the information in the input more abstractly                 
<albet70> Solonarv so can we say Data.Text.words is a parser?
<Solonarv> albet70: yes! a very simple one
<albet70> Solonarv I find there's a parser called happy , what it used for?
<phadej> it's a parser generator, think yacc/bison
<Solonarv> albet70: that's more properly a parser *generator*; you write code
           in some special-purpose language ( I think it's a superset of
           Haskell? ), and happy produces ordinary Haskell code which
           implements a parser
Related to Template Haskell? 
<Solonarv> it's not really directly related, no - the only similarity is that
           both generate Haskell code
DSL? 
<Solonarv> sure, the language you describe your parser with (i.e. the input to
           happy) is a DSL

<albet70> Solonarv related to FFI?
<Solonarv> no, not really

DSL -> parser -> Haskell code
###########################################

toText = En.decodeUtf8With lenientDecode

libghc-utf8-string-dev package Data.ByteString.Lazy.UTF8

Data.ByteString.Lazy.UTF8> words $ " "

char8 is not utf-8. It's just... char8.
It truncates chars to 8 bits.
Remember, ByteString is not an encoding.  How do you determine what a "word" is if you don't have an encoding?
Data.ByteString.map can work on ByteString with Word8, but this Word 8 code is get from encoding's codepoint

#######################################
install scala on intellij idea
Settings - Plugins - search Scala and install
New Project - IDEA (not sbt) - Scala SDK Create - Download - choose latest - 
or just install sbt from scala-lang.org
then when create Scala Project, choose that installed-directory as Scala SDK


###################################################

multiple monadic actions need to be in one do notation,

else
        let msgList = tokenise "\r\n" msg -- msgList :: [ByteString]
        -- ["abcd","PING :xxxx","efgh",""]
        let getPING = Prelude.filter (D.isPrefixOf "PING") msgList
        if not (Prelude.null getPING) then
will have an error on parse `let'
just put those monadic actions into one do notation

else do
     let ...
     let ..
     if ... then do
        ...

#############################################
there's no splitOn in Data.ByteString
but there's decodeUtf8 :: ByteString -> Text in Data.Text.Encoding

Data-ByteString-Lazy-UTF8
toString :: ByteString -> String
fromString :: String -> ByteString

Convert a UTF8 encoded bytestring into a Haskell string. Invalid characters are replaced with '\xFFFD'.
####################################################33

#unicode operator
 - U+03BB, C-x 8 RET 03BB RET

:set -XUnicodeSyntax
 f :: a. a -> a
 f = id
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntaxw

a letter can't be a operator in haskell
characters in alphabet are letters
'f' is a letter, 'f' can't be an operator,
you can't do `3 f 2`
 is a letter too, it can't be an operator
so f = a -> a is wrong

\ isn't an operator, it's syntax

() = Data.List.intersect
[1,2]  [3] 
 is an unicode symbol, it can be an operator 

() = (/=)
3  2

() = elem
Prelude Data.List> 3  [1,2]
False
Prelude Data.List> 3  [1,2,3]

 () = union
[1,2]  [2,3]
[1,2,3]

#########################################

<Welkin> id :: forall a. a -> a
<oats> ah, yes, the hidden forall!                                      [10:14]
<jusss> actually, I did notice that keyword forall, but I haven't see a
        article tell me what it is
<Welkin> there is an implicit forall in every type that contains all type
         variables                                                      [10:15]
<nitrix> Universal quantification. `a` being a type variable, it has to come
         from somewhere. Something introduces `a`.
<nitrix> This becomes more important when you start nesting polymorphic type
         signatures, they have their own scopes (:                      [10:16]
<nitrix> e.g. `forall a. a -> (forall b. b -> b) -> a`
<Welkin> that's existential quantification then, right?                 [10:20]
<Welkin> for the b -> b
<nitrix> Yeah. Going towards Rank-2 and such.       

#RankNTypes #rank

rank 1 type is `forall a. T a`
rank 2 type `(forall a. T a) -> B`
f :: (forall a. Maybe a) -> Bool is rank 2 type
f :: (forall a. Maybe a) is rank 1 type
`forall a. a -> (forall b. b -> b) -> a` is rank 2
id :: forall a. a -> a is rank 1
const :: forall a b. a -> b -> a

https://gist.github.com/merijn/77e3fa9757658e59b01d

RankNTypes is used for higher-order function, which parameter is a polymorphic function
the higher-order function don't know pick what concrete type for polymorphic function, so there will be errors, unless enable RankNTypes

data Foo = Foo Int | Bar Double

mangle :: Num a => (a -> a) -> Foo -> Foo
mangle f (Foo i) = Foo (f i)
mangle f (Bar d) = Bar (f d)

mangle don't know pick what concrete type for polymorphic function f,
so there's an error: Could not deduce (a ~ Int) from the context (Num a)

f :: forall a. Num a => a -> a
f = id
f 3.5 == 3.5
f 3 = 3

f is ad-hoc polymorphic, it can works on Int or Double which are instances of Num
when f as a parameter to mangle, mangle can't pick a concrete type for f,
if mangle picks "Int" for f, then f can't work on a "Double"
that's why we need to enable RankNTypes

about type variables, it needs to be claimed in agda,
but in haskell, it is auto-claimed, but in rankNType you need forall,
it can make function A receive a polymorphic function B

"it has to come from somewhere"
#######################################
#ad-hoc polymorphism #parametric polymorphism

for all a, that is parametric polymorphism, call "generic" in other languages,

for some a with a constraint, like typeclass, that's ad-hoc,

lookup :: (Eq a) => a -> [(a,b)] -> Maybe b 
exhibits both parametric (in b) and ad-hoc (in a) polymorphism.

class Foo a where { f :: a -> a };
instance Foo Int where { f = (+1) };
instance Foo String where { f = id };  
this f is ad-hoc, it's only work on Int or String, not all types
and id is parametric polimorphism, id works on any type

https://wiki.haskell.org/Polymorphism
######################################
#polymorphic #type #function

polymorphic function,
f :: Int -> Int
f = (+1)
f :: String -> String
f = id

it needs a typeclass to do that,

types have functions, `data P = V Int`, you can't `print (V 3)`, 'cause data type P doesn't have function print, unless you make P as an instance of Show

data P = V Int deriving Show
print (V 3) will show V 3

or `instance Show P where { show (V x) = "V " <> show x }`
print $ V 9 will print V 9

or 
printP :: P -> String
printP (V x) = show x
instance Show P where { show = printP }
print $ V 3 will print 3

so make Int and String as intances of one same typeclass, then implement f for both of them

class Foo a where { f :: a -> a }
instance Foo Int where { f = (+1) }
instance Foo String where { f = id }

you need to enable FlexiableInstances, 'cause String is [Char]
and it is type variable a in Foo, [Char] is not variable, [a] is,
so use FlexiableInstances

:set -XFlexibleInstances

f "a" == "a"
f (3 :: Int) == 4

there're also other polymorphic functions, like id, id is polymorphic over everything, also const and flip
------------------------------------------

fixed-point
http://www.vex.net/~trebla/haskell/fix.xhtml
https://www.codewars.com/kata/5443dd2d7fc4478154000ac6/train/haskell

#unicode 

 - U+03BB, C-x 8 RET 03BB RET
 - for all - upside down A (u+2200)
 - bottom - "non-terminating computation" in haskell it's called undefined
 - That means exists
~> maybe "natural transformation"
-> is function type, not kleisli arrow
the kleisli arrow for a monad M is _ -> M _


https://twitter.com/Iceland_jack/status/1220326760589471744
build :: ( b. (a -> b -> b) -> b -> b) -> [a] 
destroy :: [a] -> ( b. (b -> Maybe (a,b)) -> b -> c) -> c 
 in destroy should be an  
Build a = (b. (a->b->b) -> b -> b) 
Destroy a = (b. (b->Maybe(a,b), b) 
build :: Build ~> [] 
destroy :: [] ~> Destroy

https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0287-simplify-subsumption.rst

https://text-symbols.com/upside-down/
https://www.rapidtables.com/math/symbols/Basic_Math_Symbols.html

#natural transformation
https://stackoverflow.com/questions/58363868/what-is-a-natural-transformation-in-haskell

A natural transformation, without getting into the category theory behind it, is really just a polymorphic function.
Prelude> :set -XRankNTypes
Prelude> :set -XTypeOperators
Prelude> type (~>) f g = forall x. f x -> g x

The ~> operator maps a type constructor to another type constructor, in such a way that it works for any given argument to the first type constructor.

Prelude| m2l :: Maybe ~> []
Prelude| m2l Nothing = []
Prelude| m2l (Just x) = [x]

Prelude> m2l Nothing
[]
Prelude> m2l (Just 3)
[3]
Prelude> m2l (Just 'c')
"c"

----------------------------------------------

use parser to write a transpiler for transform one language to another language,
does that count for new language?
or use meta-programming write a DSL, (lisp's macro, C++'s template, Haskell's template, etc...)
write a compiler is too difficult

------------------------------------
big O notation, time related,
It shows how an algorithm scales based on input size.
---------------
O(n)
elemIndex

for (i=1; i<n; i++) x++; O(n)

O(n): known as Linear complexity
1 item: 1 second
10 items: 10 seconds
100 items: 100 seconds
----------------
O(n^2)
for (i=1; i<=n; i++) 
    for (j=1; j<=n; j++)
        x++; 
n^2

O(n^2): known as Quadratic complexity
1 item: 1 second
10 items: 100 seconds
100 items: 10000 seconds
---------------------
O(n!)
n!
Data.List.permutations
10! == 3628800
a list that has 10 elements,
it has 3628800 possible permutations
-----------------------------

O(1) 
f x = x
id
[1..10] 

O(1): known as Constant complexity
1 item: 1 second
10 items: 1 second
100 items: 1 second
-------------------------------
O(log n): known as Logarithmic complexity
dict, map, hash table
1 item: 1 second
10 items: 2 seconds
100 items: 3 seconds
--------------------------


f(n) is O(f(n))

https://stackoverflow.com/questions/487258/what-is-a-plain-english-explanation-of-big-o-notation

-------------------------------------------------------

Coq, Agda, Idris, Haskell, Ocaml, Scala
Proof Assistant: Coq, Agda
Coq : CoC
Haskell is System F, Lambda-2

https://www.codewars.com/kata/a-plus-b-equals-b-plus-a-prove-it
1 kyu A+B=B+A? Prove it!
-------------------------------------------------

Lambda cube

Lambda -> Simple typed lambda calculus
Lambda-2 -> System F (doesn't have dependent type)
Lambda-P -> STLC + dependent types
Lambda-P2 -> System F + dependent types
Lambda-P-Omega-Bar -> CoC the Calculus of Constructions
lambda-Omega -> System F-omega
LC 
Lambda-P-Omega
Lambda-Omega-Bar -> STLC + higher-kinded type operators

https://cstheory.stackexchange.com/questions/36054/how-do-you-get-the-calculus-of-constructions-from-the-other-points-in-the-lambda
https://en.wikipedia.org/wiki/Lambda_cube
-------------------------------------------------------
let x = 3 
    y = 2
in x + y

let x = 1 in let z = x+y in z + 1
let x=1; z=x+y in z + 1

x + y 
where
    x = 3
    y = 2            


pattern matching
f [] = []
f (x:xs) = x

but if it's x<0 then 
you can't have f (x<0) = 1; f x = 2

use guards
f x
  | x<0 = 1
  | otherwise = 2

`guards` in haskell, `cond` in scheme,
`case` in javascript, 
also haskell has `case .. of..`

but if-then-else can implement them all

pattern matching, guards |, case..of, if-then-else

using pattern matching to define if-then-else
if' True a _ = a
if' False _ b = b
if' (1 < 2) "yeh" "nah" == "yeh"
if' ("foo" == "bar") "yeh" "nah" == "nah"

https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#multi-way-if-expressions

MultiWayIf since 7.6.1
if | guard1 -> expr1
   | ...
   | guardN -> exprN

---------------------------------------------------------
#lambda #anonymous #recursive #fixed-point
x = c x
eta-convertion
x y = c x y
call `x y` in `c x y` will implement recursive of `c x y`
--------------------------------------------------
common functions
https://www.jianshu.com/p/9ba09fe14208
Data.List Data.Char Data.Prelude Data.Map Data.Set

zipWith (,) "abc" "123" = [('a','1'),('b','2'),('c','3')]
liftA2 (,) "abc" "123" = [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c','2'),('c','3')]
(,) <$> "abc" <*> "123" = [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c','2'),('c','3')]
head [1,2] = 1
tail [1,2] = [2]
take 1 [1,2] = [1]
drop 1 [1,2] = [2]
last [1,2] = 2
init [1,2,3] = [1, 2]
reverse [1,2,3] = [3,2,1]
length [1,2] = 2
lines "1\n2" = ["1","2"]  -- split with "\n" but not "\r\n"
unlines ["1","2"] = "1\n2\n"
filter (/= '\r') "1\r2" = "12"
lines . filter (/= '\r') $ "1\r\n2\r\n" = ["1","2"]
show 1234 = "1234"
break (> 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
all odd [1,3,5] = True
any odd [1,2,3] = True
isPrefixOf [2] [2,4] = True
isSuffixOf "24" "23t3" = False
isInfixOf "24" "23243" = True
zip [1,2,3] [4,5] = [(1,4),(2,5)]
words "1 2 3" = ["1","2","3"]
unwords ["1", "2"] = "1 2"
map toUpper "abc" = "ABC"
map (dropWhile isSpace) [" a","f"," e"] = ["a","f","e"]
zip3 "foo" "bar" "quux" = [('f','b','q'),('o','a','u'),('o','r','u')]
concat 
elem 'f' ['a'..'z'] = True
find (== 'f') "gasd" = Nothing
find (== 'f') "gasdf" = Just 'f'
elemIndex 1 [1,2,3] = Just 0
elemIndices 1 [1,2,3,1] = [0,3]
findIndices (=='f') "gasdgfdf" = [5,7]
-- find a string index in another string
findIndices ("ab"`isPrefixOf`) (tails "casabwefabwe") = [3,8]
inits [1,2,3] = [[],[1],[1,2],[1,2,3]]
tails [1,2,3] = [[1,2,3],[2,3],[3],[]]

nub [1,2,1] = [1,2] -- remove the duplicate elements, but not itself, use length . group . sort to get the unique elements list

tails "fas" = ["fas","as","s",""]
init . tails $ "fas" = ["fas","as","s"]
inits . tails $ "fas" = [[],["fas"],["fas","as"],["fas","as","s"],["fas","as","s",""]]

reduce = foldl -- but foldl need a init value, reduce doesn't.
foldl (+) 0 [1,2,3] = 6
foldr (*) 3 [1,2,3] = 18
-- scanl is like foldl, but it records every step.
scanl (+) 0 [1,1,2,3,5] = [0,1,2,4,7,12] 
scanr (+) 0 [1,1,2,3,5] = [12,11,10,8,5,0]


isControl, isSpace, isLower, isUpper, isAlpha, isAlphaNum
, isPrint, isDigit, isOctDigit, isHexDigit isLetter, isNumber
, isPunctuation, isSymbol, isAscii, generalCategory
digitToInt 'f' = 15
intToDigit 15 = 'f'
ord '%' = 37
chr 97 = 'a'

encode shift msg = map chr . map (+ shift) . map ord $ msg
encode 1 "abc" = "bcd"
encode (-1) "bcd" = "abc"
encode 13 "abcz" = "nop\135"
encode (-13) "nop\135" = "abcz"

rot13Map = zip [1..26] ['a'..'z']
indexT n (x,y) = if (n == x) then y else '_'
filter (/= '_') . fmap (indexT 3) $ rot13Map = "c"

Data.Map.lookup ! and !? get value by key in Map k v
fromList :: [(k,a)] -> Map k a
lookup 3 . fromList . zip [1..26] $ ['a'..'z'] = Just 'c'
(fromList . zip [1..26] $ ['a'..'z']) !? 3 = Just 'c'
(fromList . zip [1..26] $ ['a'..'z']) ! 3 = 'c'
insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
Data.Map.null (empty)           == True
singleton 1 'a'        == fromList [(1, 'a')]
Data.Map.insert 5 'x' $ Data.Map.singleton 1 'a' = fromList [(1,'a'),(5,'x')]

am = fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
Data.Map.lookup 2 am = Just 4
Data.Map.member 2 am = True
Data.Map.map (*100) am = fromList [(2,400),(3,300),(4,200),(5,400),(6,400)]
Data.Map.map (>0) am = fromList [(2,True),(3,True),(4,True),(5,True),(6,True)]
Data.Map.filter (>3) am = fromList [(2,4),(5,4),(6,4)]
Data.Map.fromListWith max [(2,3),(2,4),(2,1)] = fromList [(2,4)]
Data.Set is similiar with Data.Map

compare 2 3 = LT
compare True False = GT
compare :: Ord a => a -> a -> Ordering
GT :: Ordering
data Ordering = LT | EQ | GT

data Week = Monday | Tuesday | Wedsday deriving(Enum, Show)
succ Monday = Tuesday
pred Tuesday = Monday

max 3 2 = 3
div 4 2 = 2
mod 4 3 = 1
negate 2 = -2
abs (-2) = 2
replicate 3 'f' = "fff"
[0,1,2] !! 1 = 1
"abc" !! 2 = 'c' -- index
concat [[1,2,3], [5,7]] = [1,2,3,5,7]
concat ["abc", "efg"] = "abcefg"
sum [0..100] = 5050
fst (1,2) = 1
snd (1,2) = 2
transpose [[1,2], [3,4], [5,6]] = [[1,3,5],[2,4,6]]
transpose ["ab", "cd", "ef"] = ["ace","bdf"]
transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] = [[0,10,8],[3,0,5],[5,0,1],[9,9,-1]]
splitAt 3 "01234567" = ("012","34567")
splitAt 3 "abcdefg" = ("abc","defg")
takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1] = [6,5,4]

get the greatest and unique number in a list
maximum . concat . filter ((== 1) . length) . group . sort $ [1,2,3,77,22,77,21,5] = 22 
listToMaybe . maximum . filter (null . drop 1) . group $ [1,2,3,77,22,77,21,5]

takeWhile (>3) [6,5,4,2,1] = [6,5,4]
filter (>3) [6,5,4,2,1] = [6,5,4]
partition (>3) [6,5,4,3,2,1] = ([6,5,4],[3,2,1])
span (/= 'i') "this" = ("th","is")
break (== 'i') "this" = ("th","is")
sort [14,3,2,14] = [2,3,14,14]
reverse $ sort [14,3,2,14] = [14,14,3,2]
group ["1","1","3"] = [["1","1"],["3"]] -- group the same element when they're near
group [1,1,3] = [[1,1],[3]]
group [1,3,1] = [[1],[3],[1]]
zip [1,2,5] [3,4] = [(1,3),(2,4)]
partition (`elem` "AB") "BOBsidneyMORGANeddy" = ("BBA","OsidneyMORGNeddy") -- filter characters from a string
-- split a string with another string
splitOn "CD" "ABCDEFGHIJCDKL" = ["AB","EFGHIJ","KL"]

zipWith (+) [1,2,3] [4,5,2,2] = [5,7,5]

nub [1,3,2,4,3,2,1,2,3,4,3,2,1] = [1,3,2,4]
nub "Lots of words and stuff" = "Lots fwrdanu"
delete 'h' "hey there ghang!" = "ey there ghang!"

-- remove a string from a string
concat $ splitOn "he" "hey there" = "y tre"
-- just remove the first one matched string
stripPrefix "he" "hey there" = Just "y there"

-- delete the smae elements in the first list, but only delete once
[2,3,4] \\ [1,2] = [3,4]
[2,2,3,4] \\ [1,2] = [2,3,4]
[2,2,3,4,1] \\ [1,2] = [2,3,4]

union [1,2,3] [1,2,3] = [1,2,3]
union [1,2,3] [1,5] = [1,2,3,5]
[1,2,3] `intersect` [2,3,4] = [2,3]
[1,2,3] `intersect` [5] = []

insert 2 [1,2,3] = [1,2,2,3]
insert 2 [3] = [2,3]
insert 2 [1] = [1,2]

groupBy (/=) [1,1,2] = [[1],[1,2]] -- group the elements they're near and different
groupBy (/=) [1,1,2,1,2] = [[1],[1,2],[1,2]]

-- group the elements they're near and equal
groupBy (==) [1,1,2,1,2] = [[1,1],[2],[1],[2]]

groupBy (\x y -> if (x+y) > 3 then True else False) [1,1,2,3,3]
= [[1],[1],[2,3,3]]

-- group only group same and near elements
group [1,1,2] = [[1,1],[2]]
groupBy (==) [1,1,2] = [[1,1],[2]]
group [1,1,1,2] = [[1,1,1],[2]]
group = groupBy (==)

let sortGT a b = if a< b then GT else LT
sortBy sortGT [2,-1,4,7,3,3] = [7,4,3,3,2,-1]
sortBy compare [2,-1,4,7,3,3] = [-1,2,3,3,4,7]
sort = sortBy compare

<mniip> an isomorphism f : X -> Y is a morphism that has an inverse: some
        morphism g : Y -> X such that g.f = id and f.g = id
<a1c`> mniip: what's Curry-Howard isomorphism?
<mniip> it's called Curry-Howard correspondence                      
<mniip> calling it an isomorphism is a bit of a terminology abuse
`Reader r a` and `r -> a` are isomorphic.
<a1c`> mniip: runReader . Reader = id?
<mniip> a1c`, runReader is the inverse of Reader
<mniip> 'Reader r a' is isomorphic with 'r -> a'
<Ailrun[m]> by `Reader` and `runReader`         
<Ailrun[m]> a1c`: it is `id`
<a1c`> Ailrun[m]:  runReader and Reader are isomorphic?
<Ailrun[m]> a1c`: no, as mniip said, they are the inverse of each other.

mniip: let splt xs ys | Just zs <- stripPrefix ys xs = []:splt zs ys; splt (x:xs) ys = case splt xs ys of { (rs:rss) -> (x:rs):rss }; splt [] ys = [[]]
splt "hey there" "he" = ["","y t","re"]

there is a twisted version of mine, 
https://github.com/jusss/code/blob/bla2/Haskell/SplitList.hs
https://github.com/jusss/code/blob/bla2/lisp/string-library.rkt

partition (`elem` "AB") "BOBsidneyMORGANeddy" = ("BBA","OsidneyMORGNeddy")
<oats> a1c`: in infix notation, the argument on the right side is the second
       argument of the function, not the first.
<a1c`> `f` a = \b -> b `f` a
<a1c`> oats: it filters A and B character from this string              [10:46]
<a1c`> partition put 'B' from "BOB..." to `elem` "AB" to check if it's true,
       if it's true then put in the left, then 'O', then 'B'...
<a1c`> true, put into the left, false, put into the right
<oats> > foldl (\(l,r) c -> if elem c "AB" then (c:l,r) else (l,c:r)) ("","")
       "ABCABCD"                                                        [10:55]

split a string with a string
<oats> > splitOn "CD" "ABCDEFGHIJCDKL"                                  [11:03]
<lambdabot>  ["AB","EFGHIJ","KL"]

<dmwit> > findIndices ("ab"`isPrefixOf`) (tails "casabwefabwe")
<lambdabot>  [3,8]
<MarcelineVQ> > tails [1,2,3]
<lambdabot>  [[1,2,3],[2,3],[3],[]]
<iqubic> > inits [1,2,3]                                                [12:08]
<lambdabot>  [[],[1],[1,2],[1,2,3]]

<a1c`> all those powerful functions are from Data.List and Prelude? any other modules? 
<dmwit> a1c`: Given the questions I've seen so far, you might want to check out a parser combinator library.
<dmwit> megaparsec or regex-applicative are fairly non-controversial ones, if you don't know where to start.
<a1c`> dmwit: like?
* dmwit predicts the future

##################################################

<a1c> (\out -> let fn = out fn in fn) :: (t -> t) -> t                  [09:31]
<a1c> callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
<a1c> callCC ((ContT r m b -> ContT r m b) -> ContT r m (ContT r m b)) ->
      ContT r m (ContT r m b)
<a1c> a ~ ContT r m b

in 

{-# LANGUAGE ScopedTypeVariables #-}

import qualified Control.Monad.Trans.Cont  as C
import           Control.Monad.Trans.Class (lift)
import           System.Random             as R

--simple goto
goto = C.callCC $ \out -> let fn = out fn
                          in return fn

-- we can also provide back other arguments, in this
-- case some number, to allow more intelligent looping:
gotoC = C.callCC $ \out -> let fn num = out (fn, num)
                           in return (fn, 0)
-- based on the output of a random number generator,
-- we either go back to marker1, marker2, or finish
gotoEx1 = flip C.runContT return $ do

    marker1 <- goto
    lift $ putStrLn "one"

    marker2 <- goto
    lift $ putStrLn "two"

    (num :: Int) <- lift $ R.randomRIO (0,2)

    if num < 1 then marker1
    else if num < 2 then marker2
    else lift $ putStrLn "done"

-- loop back some number of times before continuing on:
gotoEx2 = flip C.runContT return $ do

    (marker1,num) <- gotoC
    lift $ putStrLn ("count: "++show num)

    if num < 10 then marker1 (num+1)
    else lift $ putStrLn "done"

main = gotoEx1

-- simple goto
-- goto = C.callCC $ \out -> let fn = out fn
                          in return fn
-- fn is the fixed-point on out
-- goto :: m a
-- a is fn here

#goto #callCC #fixed-pioint #Cont #Continuation #CPS

https://jsdw.me/posts/haskell-cont-monad/
https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads
https://slbkbs.org/toys/callfront.txt
http://www.vex.net/~trebla/haskell/cont.xhtml
https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#callCC
http://matt.might.net/articles/by-example-continuation-passing-style/
https://2ality.com/2012/06/continuation-passing-style.html
http://matt.might.net/articles/cps-conversion/
https://wiki.haskell.org/MonadCont_under_the_hood
http://www.haskellforall.com/2012/12/the-continuation-monad.html
http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
https://blog.poisson.chat/posts/2019-10-26-reasonable-continuations.html#many-monads-in-one
https://stackoverflow.com/questions/32145000/continuations-as-meaningful-comprehensions
http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
https://medium.com/twelve-days-of-monad/day-12-cont-spaghetti-6483bfdf7c6e


###################################################################

#Cont Monad js

// m a ~ (a->r)->r
// pure :: a -> m a
const pure = x => cb => cb(x)

// bind :: m a -> (a -> m b) -> m b
const bind = ma => amb => cb => ma(a => amb(a)(cb))

// delay(1000)("hello") :: m a
const delay = d => v => cb => setTimeout(() => cb(v), d)

// callcc :: ((a->m b) -> m a) -> m a
// f :: ((a->m b)->m a)
// cc :: (a->r)
// callcc f :: m a
// m ~ (a->r)->r
// callcc f cc :: r
const callcc = f => cc => f( x => _ => cc(x))(cc)

// f :: (a-> m b) -> m a
// f :: (a -> (b -> r) -> r) -> (a->r)->r
// k ::  a -> (() -> r) -> r
// _ :: () -> r
const f = k => _ => k(3)(_)
// f is for callcc, callcc f :: m a
// k is the escape function, k's first parameter is the result of f

const cont = bind(callcc(f))( a => pure(a+2))
// cont(console.log) == 5
// bind(cont)( a => pure(a+3))(console.log) == 8

const gf = x => k => _ => k(x)(_)
// gf is short for generate function f for callcc, like pure for >>=
// callcc $ gf a :: m a

const cont2 = bind(callcc(gf("hello")))( a => delay(1000)( a + ", world"))
// cont2(console.log) == hello, world
// callcc(f)(console.log) == 3

const format = x => y => `${x}, ${y}!`
const hello = delay(1000)("hello")
const world = delay(1000)("world")

// liftA2 is another version of fmap
// liftA2 :: (a->b->c) -> f a -> f b -> f c
const liftA2 = f => ma => mb => bind(ma)(a => bind(mb)(b => pure(f(a)(b))))
// liftA2(format)(hello)(world)(console.log) == hello, world

// fmap :: (a->b) -> f a -> f b
const fmap = f => ma => bind(ma)( a => pure(f(a)))
// fmap( x => x + ", world")(hello)(console.log) == hello, world
// fmap( x => "replace")(hello)(console.log) == replace

###############################################33

return and >>= make monads different!

###############################################33

k is \x -> \_ -> cc x
and id is cc

callcc f = \cc -> f ( \x -> \_ -> cc x) cc
f k cc = k 3
callcc f (+1) 2
callcc f (+1) ()

f2 k cc = k 3 ()
callcc f2 id

f3 k cc = k 3 cc
callcc f3 id

in pointless, f3 k = k 3

f4 k = k 3
callcc f4 id

f5 cc = \_ -> cc 5
callcc f5 id ()

f6 x cc = cc x
callcc (f6 6) id

cc is waiting for f's result in `callcc f cc`, and cc want to apply on f's result
inside f, f use (k v) to return v as result in `f k cc`

f7 k _ = if (1<0) then k 1 else k 2
callcc f7 id ()

f8 k _ = if (1<0) then (k 8 ()) else (k 9 ())
callcc f8 (+1), it won't eval anything until give (+1) to callcc f8
and in `f8 k () = ...` (k a) will escape, and a is the result of f8, and (+1) apply on a


f9 k _ = k k will cause infinite type

you can not use () in the left of = of a function, it's identifier in the left, not constant value like () in the left

f10 k _ = k 3 ()
callcc f10 (+9)

f11 k a = k 3 a
callcc f11 (+2)


in function definition
() can be left of =
_ can be right of =


const callcc = f => cc => f( x => _ => cc(x))(cc)
const f = k => _ => k(3)(_)
callcc(f)(console.log)

const callcc2 = f => cc => f( x => cc(x))
const f2 = k => k(3)
callcc2(f2)(console.log)
f2(console.log)


(callcc f) :: m a >>= a -> m b

#####################################################

callCC f cc = f (\x _ -> cc x) cc
this cc is current continuation
exit f with cc, 
callCC's effect is that use cc to exit f

callCCex1 = do
    val <- callCC $ \exit -> do

        exit True
        undefined

    return val

runCont callCCex1 kn, kn will apply on val
'cause callCCex1 :: Cont r a
so return val = \x -> x val
kn apply on val
and exit True will exit with True, so val is True
kn will apply on True

kn :: Bool -> String
kn True = "it's true"
kn False = "it's false"

main = print $ runCont callCCex1 kn

it's same to
callCCex1 = callCC $ \exit -> do
        exit True
        undefined

'cause undefined never reached so
it's equal to

callCCex1 = callCC $ \exit -> exit True

callCC :: ((a->m b) -> m a) -> m a
so exit :: (a->m b) -> m a 

\exit -> exit True :: (a->m b) -> m a

f = \exit -> exit True
callCCex1 :: m a = (callCC :: ((a->m b)->m a) ->m a) f
so f :: (a->m b) -> m a

(+1) :: Int -> Int
3 :: Int = (+1) (2 :: Int)


\exit -> exit True :: (a->m b) -> m a
exit :: a -> m b
exit = \a -> \_ -> _ a

this kn is runCont callCCex1 kn

callCCex1 = exit True = \_ -> _ True
callCCex1 kn = kn True

runCont (callCC $\cc -> cc True) cc
the outside cc is the cc in \cc

main = print $ runCont (callCC $ \cc -> cc True) kn
kn is the cc



############################################

#Cont #CPS #callCC #ContT #continuation

there're five parts,
1. Cont https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
2. ContT and >=> with ContT http://www.haskellforall.com/2012/12/the-continuation-monad.html
3. >>= with Cont "c >>= f = \k -> c (\a -> f a k)"
4. callcc f = \cc -> f ( \x -> \_ -> cc x) cc; f10 k _ = k 3 (); callcc f10 (+9)
5. callCC implement goto https://jsdw.me/posts/haskell-cont-monad/

Cont is from Control.Monad.Cont
ContT is from Control.Monad.Trans.Cont

<wonderC>  m >>= k  = ContT $ \ c -> runContT m (\ x -> runContT (k x) c)
<wonderC> equal to "c >>= f = \k -> c (\a -> f a k)"                    
<wonderC> callCC f = ContT $ \ c -> runContT (f (\ x -> ContT $ \ _ -> c x)) c
callCC :: ((a -> m b) -> m a) -> m a 
callCC f = \c -> f (\x -> \_ -> c x) c

function callcc (f,cc) { 
  f(function(x,k) { cc(x) },cc)
}

callcc f cc = f (\x k -> cc x) cc

Scheme:
(define call/cc (lambda (f cc) (f (lambda (x k) (cc x)) cc)))

Javascript:
callcc = f => cc => f(x => k => cc(x), cc)

here this cc is undefined in the first parameter of f,
a typical letrec issue, cc is the second parameter of f,
and in the first parameter it uses its second parameter

Haskell:
callCC f = \c -> f (\x -> \_ -> c x) c
callCC f cc = f (\x -> \_ -> cc x) cc
callCC f cc = f (\x _ -> cc x) cc

#################################################

#Understand #Cont #Monad #JS #Haskell #continuation
let's assume that continuation :: (a->r)->r
that unary function :: a->r

e.g:  "c >>= f = \k -> c (\a -> f a k)"

``` #continuation #Cont
const pure = x => cb => cb(x)
const bind = amb => ma => cb => ma(a => amb(a)(cb))
const lift2 = f => ma => mb => bind(a => bind(b => pure(f(a)(b)))(mb))(ma)

const delay = d => v => cb => setTimeout(() => cb(v), d)

const hello = delay(1000)("hello")
const world = delay(1000)("world")
const format = x => y => `${x}, ${y}!`
const main = lift2(format)(hello)(world)

main(result => { console.log(result) })
// after a couple seconds, logs "hello, world!"
```
const _bind = ma => amb => cb => ma(a => amb(a)(cb))
const callcc = f => cc => f( x => _ => cc(x))(cc)
const f = k => _ => k(3)(_)
callcc(f)(console.log)

const amb2 = a => pure(a + ", world")
bind(amb2)(delay(1000)("hello"))(console.log)


world2 = a => delay(1000)(a+"world")
bind(world2)(hello)(console.log)

const _bind = ma => amb => cb => ma(a => amb(a)(cb))
_bind(hello)(world2)(console.log)

again = a => delay(1000)(a + "again")
_bind(_bind(hello)(world2))(again)(console.log)
with infix notation, not this prefix notation
it would be 
(hello >>= world2 >>= again) console.log

this delay is a continuation (a->r)->r function,
let's call that (a->r) as an unary function
f(a,cb){ ... cb(r)} this is a continuation
it's a extense version of pure a = \cb -> cb a
no matter how you do something with a, like turn it to b
but you will apply cb on that b in the final

pure2 a = \cb -> cb $ a + 2

this pure2 a is still a continuation, which has (a->r)->r

delay(1000)("hello") >>= (a => delay(1000)(a+"world"))
you can always operate the result by and >>= a->m b,
util you give it a->r to get the final result r,
we chain Cont Monad with >>=, ContT with >=>

lift2 is liftA2, is another version of fmap
lift2 will take a binary function, m a and m b,
then it needs an unary callback function to apply on binary(a)(b)'s result

you can always append >>= a->m b to the previous m a to work on that a,
until you give it an unary function a->r to get the final result r,
and the whole chain won't evaluate till you give it a->r,
the whole chain becomes one Cont, waiting for a->r

use >>= to chain Cont
use >=> to chain ContT

<wonderC[m]> \a -> f a k, this with f and k, construct a unary function for m a
<wonderC[m]> f is a-> m b
<wonderC[m]> c >>= f
<wonderC[m]> phanimahesh[m] and you were right, it is eval m a first then m b
<wonderC[m]> \a -> f a k, give f the unary k, this will be an unary function
             for m a, and that \a is the value that m a hold
<wonderC[m]> and yes, \a is the a in m a                                [20:41]
<wonderC[m]> give f::a->m b an unary, so it becomes another unary function,
             pass that unary to m a, and that unary's parameter is the value
             that m a holding, so a in m a is the a in \a -> f a k      [20:43]
<wonderC[m]> f a k products the final result                

<jacks2> > liftA2 (+) (Just 10) (Just 20)                               [19:39]
<lambdabot>  Just 30

a continuation we said has (a->r)->r, not a->r
we call a->r as an unary function

that lift2 is just liftA2

and that delay function create a continuation, which is the expand version of return,
every function with f(a,cb){... cb(finalResult)} is a continuation

lift2(format)(hello)(world) will create a new continuation
which result is "hello" <> "world" 
so console.log can get it out, also the effect stay, like setTimeout effect

#################################################

#emoji #haskell #unicode #ByteString

{-# LANGUAGE OverloadedStrings #-}
Data.ByteString.putStrLn $ Data.Text.Encoding.encodeUtf8 "\128308"

"\128308" is an emoji

em = Data.Text.Encoding.encodeUtf8 "\128308"
this em is the ByteString of emoji

from
https://unicode.org/emoji/charts/full-emoji-list.html
we can get the hex number of an emoji
then 
https://www.rapidtables.com/convert/number/hex-to-decimal.html
turn hex to decimal 
so U+1F600 is 1f600 is 128512
Data.ByteString.putStrLn $ Data.Text.Encoding.encodeUtf8 "\128512"

128309 is the blue one

########################################

>>= :: m a -> (a -> m b) -> m b
>>= :: Cont r a -> (a -> Cont r b) -> Cont r b

r = (cont $ \k -> k 9) >>= \x -> (cont $ \k -> k x)
runCont r (+2) == 11


##########################################################

Cont http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
ContT http://www.haskellforall.com/2012/12/the-continuation-monad.html
      
      don't fear the type, every type is inhabited by value!

#############################################################

#ContT

unitAttack :: Target -> (Target -> IO ()) -> IO ()
unitAttack target todo = do
           ...
           todo target

unitAttack target todo :: IO ()
so we can use do-notation in the right side of '='

todo is the k, the continuation, todo :: Target -> IO ()
continuation has the type a -> m r

and it same to 
unitAttack :: Target -> Cont (IO ()) Target
unitAttack target = Cont $ \todo -> do   --:: IO (), 'cause todo::Target->IO()
           ...
           todo target

same to
unitAttack :: Target -> ContT () IO Target

newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }

k :: Target -> IO ()
runContT (unitAttack target) k :: IO ()


#Sum #Polymorphic

Sum type can implement Polymorphic 

if it needs to take two continuations, and they haven't the same type

data Hole = Swing Int | Attack Target

unitAttack :: Target -> ContT () IO Hole

damage :: Target -> IO ()
swingBack :: Int -> IO ()

continue :: Hole -> IO ()
continue (Swing n) = swingBack n
continue (Attack t) = damage t

runContT (unitAttack target) continue :: IO ()

even we can do
data Hole = Hole1 Arg1 Arg2 | Hole2 | Hole3 Arg3 | Hole4

ContT () IO Int have a value ContT (f :: (Int -> IO ()) -> IO ())
and Int -> IO () is the type of k
ContT $ \k -> do ...  this do-notation has IO () type

don't fear the type, every type is inhabited by value!

newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }

ContT () IO Target is a type
ContT (Target -> IO ()) -> IO () is not a type or a value
ContT (f :: (Target -> IO ()) -> IO ()) is a value

#inhabited #type #value 
Just Int is not a value, Just (3 :: Int) is a value

unitAttack :: Target -> ContT () IO Target
halfAssedCompletion :: Target -> ContT () IO Int
>=> :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
unitAttack >=> halfAssedCompletion :: Target -> ContT () IO Int

The Cont monad is all about chaining these kinds of partial completions together until all the holes are finally filled.


from Callback to Continuation

use Kleisli arrow to chain those continuations

largeProgram :: IO ()

largeProgram :: () -> ContT () IO Hole
nextContribution :: Hole -> ContT () IO NextHole
secondContribution :: NextHole -> ContT () IO SecondHole

largeProgram >=> nextContribution :: () -> ContT () IO NextHole
largeProgram >=> nextContribution >=> secondContribution :: () -> ContT () IO SecondHole

handler :: SecondHole -> IO ()

r = runCont ((largeProgram >=> nextContribution >=> secondContribution) ()) handler :: IO ()

put this whole line to main so it will run
main = r

http://www.haskellforall.com/2012/12/the-continuation-monad.html

#######################################################

the mother of all monads

https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads


import Control.Monad.Cont

-- retun x = cont (\_ -> _ x)
-- return 1 = cont (\k -> k 1)
-- a <- return 1   a is 1

ex2 = do
    a <- cont (\x -> x 1)
    --    b <- cont (\k -> k 10 ++ k 20)
    --    b <- cont (\k -> concat [k 10, k 20])
    b <- cont (\k -> [10, 20] >>= k)
    -- b <- cont [10,20]
    return $ a+b

-- test2 = runCont ex2 show
test2 = runCont ex2 return

-- i is k, i is call/cc
i x = cont (\fred -> x >>= fred)

run m = runCont m return

test9 = run $ do
    a <- i [1, 2]
    b <- i [10,20]
    return $ a+b

main = print test9


--    main = print test2
-- https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
-- http://blog.sigfpe.com/2008/12/mother-of-all-monads.html

#####################################################

#wechat robot #debian buster 

https://github.com/wechaty/wechaty

apt install nodejs chromium
apt install npm
apt remove npm
re-install npm from
curl https://www.npmjs.com/install.sh | sudo sh

mkdir del
cd del
npm init
npm install wechaty
npm mybot.js

const { Wechaty } = require('wechaty') // import { Wechaty } from 'wechaty'

Wechaty.instance() // Global Instance
.on('scan', (qrcode, status) => console.log(`Scan QR Code to login: ${status}\nhttps://api.qrserver.com/v1/create-qr-code/?data=${encodeURIComponent(qrcode)}`))
.on('login',            user => console.log(`User ${user} logined`))
.on('message',       message => console.log(`Message: ${message}`))
.start()


visit that qrcode link via browser
then use wechat to scan it to login


##############################################

Fira Font
https://github.com/mozilla/Fira/tree/master/ttf

;;; Shift-Tab back for four whitespace
(defun jusss/back-by-4 () (interactive)
          ;;;(backward-delete-char-untabify 4)
          (backward-char 4)
)
          
(global-set-key (kbd "<S-tab>") 'jusss/back-by-4)

(defun my-turn-indentation-off ()
  (interactive)
  ;;; disable tab indent
  (local-set-key (kbd "<tab>") 'tab-to-tab-stop)
  ;;; enable indent for previous line
 ;;;(local-set-key (kbd "<tab>") 'indent-relative)
 (setq tab-width 4)
)

;;; disable all the tab indent
(dolist (hook '(perl-mode-hook
                c-mode-hook
                haskell-mode-hook
                java-mode-hook))
  (add-hook hook 'my-turn-indentation-off))


#############################################

;;; Shift-Tab back for four whitespace
(defun jusss/back-by-4 () (interactive)
          ;;;(backward-delete-char-untabify 4)
          (backward-char 4)
)
          
(global-set-key (kbd "<S-tab>") 'jusss/back-by-4)

(defun my-turn-indentation-off ()
  (interactive)
  ;;; disable tab indent
  ;;;(local-set-key (kbd "<tab>") 'tab-to-tab-stop)
  ;;; enable indent for previous line
 (local-set-key (kbd "<tab>") 'indent-relative)
 (setq tab-width 4)
)

;;; disable all the tab indent
(dolist (hook '(perl-mode-hook
                c-mode-hook
                haskell-mode-hook
                java-mode-hook))
  (add-hook hook 'my-turn-indentation-off))

##################################

Arial font show 1111 and jjjjjjjj the same length
so use a normal Monospace font
Monospace font is necessary for indentation
Helvetica is another non-monospace font

(set-default-font "Consolas Bold-10")

#########################################

#auto complete #vim #emacs #indent

in vim 8.x, C-n or C-p will auto complete for some words you already typed, that's wonderful

emacs turn all indent off

(defun my-turn-indentation-off ()
  (interactive)
  ;;; disable tab indent
  ;;;(local-set-key (kbd "<tab>") 'tab-to-tab-stop)
  ;;; enable indent for previous line
  (local-set-key (kbd "<tab>") 'indent-relative)
)

(dolist (hook '(perl-mode-hook
                cperl-mode-hook
                c-mode-hook
                haskell-mode-hook
                c++-mode-hook
                java-mode-hook))
  (add-hook hook 'my-turn-indentation-off))

https://www.emacswiki.org/emacs/TurnAllIndentingOff

#########################################################################

https://github.com/quchen/articles/blob/master/cont_monad.md
https://jsdw.me/posts/haskell-cont-monad/
https://stackoverflow.com/questions/9050725/call-cc-implementation
https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html
https://blog.oyanglul.us/grokking-monad/part2

import Control.Monad.Trans.Cont

(Cont inC) >>= fn = Cont $ \out -> inC (\a -> (runCont (fn a)) out)
m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c

pure val = Cont $ \out -> out val
return a = Cont ($ a)


https://2ality.com/2012/06/continuation-passing-style.html
http://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Cont.html#Cont
http://matt.might.net/articles/by-example-continuation-passing-style/
https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:withAsync
https://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Monad-STM.html
https://www.zhihu.com/question/40806617?sort=created
https://stackoverflow.com/questions/3322540/how-and-why-does-the-haskell-cont-monad-work
https://www.youtube.com/watch?v=wSg1vIAOCO8
https://jsdw.me/posts/haskell-cont-monad/
https://stackoverflow.com/questions/9050725/call-cc-implementation
https://stackoverflow.com/questions/3322540/how-and-why-does-the-haskell-cont-monad-work
https://dev.to/yelouafi/algebraic-effects-in-javascript-part-3---delimited-continuations-42hj
https://www.jianshu.com/p/9ba09fe14208
https://blog.oyanglul.us/grokking-monad/part2
#Cont #Continuation #continuation #monad #Monad

#####################################

#backend #webserver #webframe #scotty #sql

http://hackage.haskell.org/package/scotty-0.11.5/docs/Web-Scotty.html#t:ScottyM
https://taylor.fausak.me/2014/10/21/building-a-json-rest-api-in-haskell/
http://seanhess.github.io/2015/08/19/practical-haskell-json-api.html
https://ocharles.org.uk/posts/2014-08-07-postgresql-simple-generic-sop.html
http://www.lambda-land.com/posts/2017-11-16-postgresql-simple
http://hackage.haskell.org/package/postgresql-simple-0.6.2/docs/Database-PostgreSQL-Simple.html
http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html

################################################

typeclass as instance of typeclass

data Dict p where Dict :: p => Dict p; data a :- b = Sub (a => Dict b); class Class b h | h -> b where { cls :: h :- b }; 
instance Class () (Class b a) where cls = Sub Dict; instance Class () (Eq a) where cls = Sub Dict -- etc

####################################3

communicate within two loops

1. forkIO and killThread
2. async and withAsync
3. Systemd to handle the exit and restart or bash script
4. Continuation


del.hs

import System.Exit
import Control.Concurrent
sleep = threadDelay . ceiling . (*1000000)
main = do
  sleep 5
  exitWith $ ExitFailure 22

I2T5.sh
#!/bin/bash
while :
do
  echo "re-run"
  sleep 2
  ./del
done


<dsal> There's also some friendly variants  that work with UnliftIO which is
       handy for doing concurrency in the middle of transformer stacks.
<jusss> dsal: IORef is not recommend to use ,right?
<dsal> If you're doing concurrency, just use STM.
<dsal> It's pretty easy to get right and many dumb things are impossible.
<dsal> async to make concurrent tasks.  STM transactions to manage state
       across them.  Super easy.                                        [11:13]

https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:withAsync
#########################################

#ffmpeg ##ffplay

ffplay -vf subtitles=filename=input.mkv input.mkv

ffplay -vf subtitles=401.srt 401.mkv

################################################

re-install npm from
curl https://www.npmjs.com/install.sh | sudo sh



##########################################3

install WSL on windows 10
https://docs.microsoft.com/en-us/windows/wsl/install-win10

run `Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux` in Powershell with administrator
then resstart,
install Debian in Windwos Store and Windows Terminal

#########################################

<dminuoso> data Cont r a = Cont { runCont :: (a -> r) -> r }

###############################################

https://www.cs.utah.edu/~mflatt/past-courses/cs6520/public_html/s02/cps.pdf

(define (map f l)
  (if (null? l)
    '()
    (cons (f (car l)) (map f (cdr l)))))

add k
(define (map2 f l k)
  (if (null? l)
    (k '())
    (k (cons (f (car l)) (map2 f (cdr l))))))

lift (f (car l))
(define (map2 f l k)
  (if (null? l)
    (k '())
    (f (car l) (lambda (v) (k (cons v (map2 f (cdr l))))))))

lift (map2 f (cdr l))
(define (map2 f l k)
  (if (null? l)
    (k '())
    (f (car l) (lambda (v) (map2 f (cdr l) (lambda (v2) (k (cons v v2))))))))

(map2 (lambda (x k) (k (+1 x))) '(1 2 3) (lambda (x) x))


(define rember8
  (lambda (ls)
    (cond
      [(null? ls) '()]
      [(= (car ls) 8) (cdr ls)]
      [else (cons (car ls) (rember8 (cdr ls)))])))

(define rember8
  (lambda (ls k)
    (cond
      [(null? ls) (k '())]
      [(= (car ls) 8) (k (cdr ls))]
      [else (rember8 (cdr ls) (lambda (x) (k (cons (car ls) x))))])))


#CPS #continuation

import sys
sys.setrecursionlimit(5500000)
cons = lambda x,l: [x] + l
car = lambda l: l[0]
cdr = lambda l: l[1:]

isEmpty = lambda l: True if l == [] else False

map2 = lambda f, l, k: k([]) if isEmpty(l) else f(car(l),
                                                  lambda v: map2(f, cdr(l),
                                                                 lambda v2: k(cons(v,v2))))


print(map2(lambda v,k: k(v+1),  range(999), lambda x: x))

###############################################

id a = a
idCPS1 a k = k a
idCPS2 a k1 = \k2 -> k1 a k2

but `k a` = `\x -> k a x`  based on the eta-conversion of lambda

k a = k a
k = \a -> k a
k a = \x -> k a x
\x -> k a x = k a

################################################################

<jusss> merijn: about last day's continuation talk, when a function can be a
        continuation? what's the condition?                             [10:05]
<jusss> merijn: inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)
        from  https://jsdw.me/posts/haskell-cont-monad/      do you think this
        inC is a continuation?                                          [10:06]
<jusss> based on this article, the continuation should be a function f, which
        take a function g, and call g in the final of f                 [10:07]
<jusss> f = k1 >>= \v -> return k2; f g will call g in k1, and v is the result
        that g in k1, then it make a new continuation k2, and call g again in
        that k2                                                         [10:10]
<jusss> g is passing in the chain                                       [10:12]


#############################################3<=8

maybe any function could be a continuation

https://wiki.haskell.org/Continuation
https://en.wikipedia.org/wiki/Continuation
https://jsdw.me/posts/haskell-cont-monad/

<heatsink> find f (x:xs) = if f x then Just x else find f xs; find f [] = Nothing
<heatsink> With continuation-passing style, find wouldn't return to its
           caller.  Instead, its caller would tell find what to do next.
<heatsink> find f (x:xs) cont = if f x then cont (Just x) else find f xs cont;
           find f [] = cont Nothing

<jusss> heatsink: I think continuation is a funciton f, which take another
        function g as its parameter, call g in f, and g never go back in f
<heatsink> That's right                                                 [14:39]
--that f may be a CPS function, a Cont (a->r)->r, also a continuation

<heatsink> Without continuation-passing, it was foo = print (find (<0) [1,
           -2])
<heatsink> With continuation-passing, it is foo cont = find (<0) [1, -2] (\x
           -> print x cont)
<heatsink> This means, call "find"; tell "find" that when it's done, it should
           call "print", and tell print that when it's done, it should call
           "cont"                                                       [14:41]
<heatsink> I'm assuming that this "print" was also converted to
           continuation-passing style
<heatsink> To make a continuation monad, you would need to write return and
           >>= for continuation-passing style                           [14:45]
<jusss> heatsink: inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)
        from https://jsdw.me/posts/haskell-cont-monad/
<heatsink> bind fn inC out = inC (\inCval -> fn inCval out)
<heatsink> inC and fn are functions that are in continuation-passing style.
           Their last parameters are continuations.
<jusss> so inC is not a continuation?
<heatsink> Right, it is not a continuation                              [14:50]
<jusss> heatsink: so here inC and fn both are functions, they take
        continuation, and `out' is a continuation?
<heatsink> The call `inC cont` means to call inC and tell it to call cont when
           it's finished.
<heatsink> right
<heatsink> So, this will call inC.  When it's finished, it will call that
           lambda.                                                      [14:53]
<heatsink> That lambda will call fn.  When fn is finished, it will call out.
<jusss> heatsink: but that lambda is a continuation?                    [14:55]
<heatsink> yes
<heatsink> Cont values are not continuations.  They are continuation-passing
           functions.  The continuation-passing part is hidden inside the
           monad.                                                       [15:01]
<jusss> inC is a Cont values right?
<doublex> @unmtl Cont r a                                               [15:02]
<lambdabot> (a -> r) -> r
<heatsink> right
<jusss> but a->r is continuation?                                       [15:03]
<heatsink> The example that you showed is teaching about Cont.  So it is not
           actually using the Cont type, but it's basically doing the same
           thing as Cont.
<heatsink> (a -> r) is the type of a continuation                       [15:04]
<doublex> if a direct-style function produces an `a`, a
          continuation-passing-style function instead passes an `a` to its
          continuation                                                  [15:05]
<doublex> the Cont monad allows you to thread together CPS functions with >>=
<jusss> doublex: it means in the continuation-passing-style function, the
        function take a continuation, and pass its within value to its
        continuation?                                                   [15:11]
<jusss> err. now I'm confused about continuation-passing-style function and
        continuation...

<jusss> a funciton f, which take another function g as its parameter, call g
        in f, and g never go back in f, f is a continuation-passing function,
        g is the continuation, right?
<dminuoso> "continuation-passing function" is not really a term Ive heard.
<dminuoso> "continuation-passing" is a coding style.
<dminuoso> jusss: And no, f might do things after g.
<dminuoso> For example `withConnection :: (Connection -> IO a) -> IO a`
           usually does resource cleanup after the continuation is done.
<jusss> dminuoso: then it's against the "and g never go back in f"      [16:38]
<dminuoso> jusss: Right.
<jusss> dminuoso: so f won't do thing after g
<dminuoso> jusss: Well "after" is a difficult term.
<jusss> dminuoso: may use "call g in the last code in f"?
<jusss> of f
<dminuoso> jusss: If we are talking about `withConnection`, what such a
           continuation would usually do, is prepare a connection handle,
           provide it to your continuation, and then close the connection
           using `finally`
<dminuoso> (The finally is done to ensure that the resource is released even
           if your continuation throws an exception)                    [16:40]
<jusss> dminuoso: how you describe the function f :: (a->r) -> r?
<jusss> if (a->r) is the type of a continuation                         [16:41]
<jusss> Cont r a >>= ...   this Cont r a is a continuation?             [16:42]
<dminuoso> jusss: Id call it a continuation handler, maybe.
<jusss> err, wait, there's no Cont r a, right?                          [16:43]
<dminuoso> jusss: Sure there is.
<jusss> type Cont r = ContT r Identity
<jusss> Cont is defined by ContT
<jusss> type Cont r = ContT r Identity
<kuribas> jusss: that's fabricating an 'a' out of thin air.
<dminuoso> jusss: It turns out that Cont and ContT are the same thing. :)
<dminuoso> kuribas: Nope.
<dminuoso> kuribas: type aliases can be defined to be non-saturated on the
           RHS.                                                         [16:44]
<jusss> dminuoso: wait a sec, Cont is a Monad, ContT is a Monad Transformer
<dminuoso> jusss: Try implementing the monad instance for both. It's an
           interesting excercise.
<jusss> dminuoso: I even don't know the data type of Cont...
<jusss> I can't find its definition on the haskell.org                  [16:45]
<kuribas> dminuoso: "(a implies r) implies r", is the same as "a" is true,
          logically
<jusss> it's defined by ContT

<dminuoso> data Cont r a = Cont { runCont :: (a -> r) -> r }

<dminuoso> equivalently
<dminuoso> data ContT r m a = Cont { runCont :: (a -> m r) -> m r }     [16:46]
<dminuoso> Err
<dminuoso> data ContT r m a = ContT { runContT :: (a -> m r) -> m r }
<dminuoso> :)
<jusss> dminuoso: it reminds me about Reader...                         [16:47]
<jusss> there's a Kleisli arrow in its type
<kuribas> dminuoso: right, it's a clojure containing some a, which is passed
          to the continuation
<dminuoso> It's quite unlike Reader.
<kuribas> dminuoso: closure                                             [16:48]
<dminuoso> kuribas: Might not be a closure.
<dminuoso> kuribas: A closure is a particular type of implementation.
<dminuoso> I'd just call it a continuation handler.
<dminuoso> It knows how to handle/run a continuation.                   [16:49]
<kuribas> dminuoso: it must get an a from somewhere
<jusss> >>= :: Cont r a -> (a -> Cont r b) -> Cont r b
<jusss> >>= :: ContT r m a -> (a -> ContT r m b) -> ContT r m b?
<jusss> data Cont r a = Cont (a->r) -> r;  x :: Cont r a;  x is the
        `continuation handler'?
<jusss> it needs a (a->r) to extract the r?                             [16:53]
<kuribas> jusss: x is a continuation, which is a function which accepts the
          result of the previous computation.
<jusss> kuribas: wait, x >>= \...    this x is a continuation?
<kuribas> jusss: yes                                                    [16:55]
<jusss> "<heatsink> Cont values are not continuations.  They are
        continuation-passing functions.  The continuation-passing part is
        hidden inside the monad.
        [15:01]"
<mycroftiv> continuations are a really deep subject,
            http://okmij.org/ftp/continuations/ has a ton of material
            including some introductory/tutorial code                   [16:56]
<kuribas> jusss: well, technically it's the continuation, with the previous
          value already filled in.
<kuribas> jusss: so it's the part which computes a new value, and passes it to
          the next continuation                                         [16:59]

<jusss> kuribas: then what's the context? what's the effect?
<kuribas> jusss: I'd say the context is the next continuation, the effect is
          passing the computed value to the next continuation.

<jusss> kuribas: but some people said Cont Monad doesn't have an effect...
                                                                        [17:01]
<jusss> not all Monads have effects...
<kuribas> jusss: indeed, not a real effect, like in IO
<kuribas> jusss: it's like emulating non-local jumps in imperative language,
          though it's more powerful than that.                          [17:02]
<jusss> kuribas: err.. is there a clear definition of `continuation'? not
        something about CPS and callCC?
<kuribas> jusss: continuations are linked to CPS and callCC
<jusss> kuribas: if even there's no CPS and callCC, continuation still exists
<kuribas> jusss: having a continuation implies doing CPS, or having a low
          level primitive (like in scheme)
<jusss> even from https://wiki.haskell.org/Continuation,  it's talk about CPS
        and callCC, not really about what exactly is a continuation
<jusss> scheme provide call/cc to capture continuation
<kuribas> jusss: loosely, you could say, a continuation is a function which
          you accept, which you pass the computed value.  It represents "the
          rest of the computation".                                     [17:07]
<jusss> kuribas: (+2) is a continuation?
<kuribas> jusss: could be
<kuribas> jusss: it implies that you never return a value.
<jusss> kuribas: f = \x -> (x 2)   this f is a continuation?            [17:08]
<kuribas> jusss: sure
<merijn> jusss: any function can be a continuation
<merijn> jusss: So "is 'f' a continuation?" is always "yes" if 'f' is a
         function
<jusss> kuribas: but (+2) :: Int -> Int,  it return a Int
<merijn> jusss: 'f' is not continuation passing style, but it can be a
         continuation                                                   [17:09]
<kuribas> jusss: the first google link on scheme gives me a definition:
          https://courses.cs.washington.edu/courses/cse341/04wi/lectures/15-scheme-continuations.html
<jusss> merijn: kuribas ok, so (+2) could be a continuation, but it's not a
        continuation-passing style function?
<jusss> do we have the term continuation-passing style function?        [17:12]
<jusss> or just continuation-passing style will be fine?
<kuribas> jusss: no, because then it would also take a continuation
<kuribas> jusss: like \v k -> k (v+2)
<jusss> kuribas: this k is continuation?                                [17:17]
<jusss> f = \v k -> k (v+2)       this f is continuation?
<kuribas> jusss: yes
<jusss>  kuribas: both are continuations?
<kuribas> jusss: <merijn> jusss: any function can be a continuation



###############################################

callBack, call then back, it's a callback,
f(g) call g in f, then return to f with its result then do other things
that g is a callback function,
but continuation it never be back, f(g) call g in f, and that's it,
g won't back to f, f don't do something with g's result,

continuation is a function f, which take another function g as a parameter,
call g in the continuation f, and g won't be back

(+2) is not a continuation, 'cause (+2) take a Int and return a Int
f = \x -> (x 2)
f is a continuation,
f (+2) would be 4, f id would be 2
the result ends within the function (+2) or id, not f


about callback hell, 'cause it's always waiting callback functions's back with result
and it stucks the process
but continuation doesn't have that, it always jump to another function's execute stack with everything it needs through function call, won't jump back, no other things wait it, it's always jumping

###################################################

same like docker

config sshd inside a chroot env,
vim /etc/ssh/sshd_config in chroot env, change the port,
make it not as same as the host's,
then /etc/init.d/ssh start, don't use systemctl start ssh
'cause systemd won't allow that
then on the client side, just ssh that port, it will be ok.

######################################################
-- get a random number based on a string

import System.Random
import System.Random.Shuffle

-- _find :: [a] -> [(a,b)] -> [[a]]
_find str keyPair = fmap (f keyPair) str
     where
        f k c = fmap (\(x,y) -> if x == c then y else 0) k



_match str keyPair =
     sum $ _find str keyPair >>= (return . sum)



genKeyPair seed = zipWith (,) (['a'..'z'] <> ['A'..'Z'] <> ['0'..'9'] <> ['_']) $ shuffle' [1..63] 63 (mkStdGen seed)

keyPair = genKeyPair 42


main = print $ _match "aha" keyPair

################################################

map f alist; if f is a binary function, this won't work
use zipWith
<doublex> > zipWith (,) "abc" "123"
<lambdabot>  [('a','1'),('b','2'),('c','3')]
<doublex> every-to-every (i.e. concatMap) is the list Applicative       [10:18]
<doublex> > (,) <$> "abc" <*> "123"
<lambdabot>
            [('a','1'),('a','2'),('a','3'),('b','1'),('b','2'),('b','3'),('c','1'),('c',...

###########################################################

import System.Random
import Data.Tuple
import System.Environment

randomSequence :: RandomGen g => [a] -> g -> Int -> [a] -> [a]
randomSequence = \l g count result ->
               if count > 0 then
                  let s = (randomR (0, length l - 1) g) in
                             randomSequence l  (snd s)  (count - 1) $ ((!!) l $ fst s) : result
               else
                  result

l = "abcdefghijklmnopqrstuvwxyz0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ"

getRandomString _number randomNumber = randomSequence l (mkStdGen randomNumber) _number ""

main = do
  args <- getArgs
  let i = read $ head args :: Int
  let ii = read $ head $ tail args :: Int
  putStrLn $ getRandomString i ii

-- ./getRandomString 22 111111111111111111112222222222222222222222222222222218888888888888888866666666666666

######################################################################


double exclamation marks !! indexes lists.
it takes a list and an index, and return the item at that index.
(!!) [1,2] 0 will return 1

generate random strings from a list
pick a random item from a list

<dsal> > let rs a = (a !!) <$> randomRs (0, length a - 1) (mkStdGen 104) in
       take 37 $ rs "abc123"

take 37 $ rs "abc123" where
     rs a = fmap (a !!) (randomRs (0, length a - 1) (mkStdGen 42))

System.Random

don't write StdGen by hand, use `mkStdGen'
class RandomGen g
data StdGen = StdGen !Int32 !Int32  is an instance of RandomGen
call it generator


randomR :: RandomGen g => (a, a) -> g -> (a, g)
random :: RandomGen g => g -> (a, g)

this a is from class Random a where { random :: RandomGen g => g -> (a, g);
      ... }

randomRs :: RandomGen g => (a, a) -> g -> [a] 
mkStdGen :: Int -> StdGen
getStdGen :: IO StdGen
newStdGen :: IO StdGen

newStdGen >>= print   will generate different numbers every time

randomSequence :: RandomGen g => [a] -> g -> Int -> [a] -> [a]
randomSequence = \l g count result ->
               if count > 0 then
                  let s = (randomR (0, length l - 1) g) in
                             randomSequence l  (snd s)  (count - 1) $ ((!!) l $ fst s) : result
               else
                  result

randomSequence "abcdefg123" (mkStdGen 42) 22 ""


instance Functor ((,) a) where
    fmap f (x,y) = (x, f y)

#tuple #set #SteGen

(a,g) is 2-tuple,  (1,2,3) is 3-tuple

we use mkStdGen to get a x::StdGen,
we use fromList :: [a] -> Set a to get a `Set a', not write it by hand

fromList [1,2,1,3,2] will get fromList [1,2,3]    -- fromList is a "smart constructor"

import Data.Tuple
fmap swap $ random (mkStdGen 42)


#####################################################################

#symbol

slash /
backslash \
vertical bar |
period .
horizontal
quote "
single quotation mark '
question mark ?
exclamation mark !
comma ,
colon :
semicolon ;
tilda ~
at sign @
number sign #
ellipsis ...
dollar sign $
percent sign %
hyphen -
caret ^
dash --
ampersand &
asterisk *
parenthesis ()
square brackets []
brackets {}
angle brackets <>
underscore _
plus sign +
minus sign -
equals =
less-than <
greater-then >
semantic

###########################################################

root@CASE:~/yesod# cat TPG.hs
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromRow
import Data.Int
import Web.Scotty
import Data.Text.Internal.Lazy as DL
import Data.Text.Lazy as D
import Control.Monad.IO.Class
import Data.Aeson (FromJSON, ToJSON, encode, decode)
import GHC.Generics
import Control.Monad (void)

-- table dialog_update
data DialogUpdate = DialogUpdate { updateVersion :: Text, updateAddress :: Text } deriving (Show, Generic)

-- table post_data
data PostData = PostData { deviceId :: Text, updateTime :: Text } deriving (Show, Generic)

instance FromRow DialogUpdate where
        fromRow = DialogUpdate <$> field <*> field
instance FromRow PostData where
        fromRow = PostData <$> field <*> field

instance ToJSON PostData
instance FromJSON PostData
instance ToJSON DialogUpdate
instance FromJSON DialogUpdate

getDialogUpdate :: IO DialogUpdate
getDialogUpdate = do
        conn <- connectPostgreSQL "host='localhost' port=5432 dbname=test_db user=test_user password=p"
        l <- query_ conn "SELECT * FROM dialog_update" :: IO [DialogUpdate]
        return $ Prelude.head l

insertPostData :: PostData -> IO Int64
insertPostData = \(PostData i t) -> do
        conn <- connectPostgreSQL "host='localhost' port=5432 dbname=test_db user=test_user password=p"
        executeMany conn "insert into post_data (device_id, update_time) values (?,?)" [(i,t):: (Text, Text)]

main = scotty 80 $ do
        get "/" $ do
                html . updateVersion =<< liftIO getDialogUpdate
        post "/" $ do
                r <- jsonData :: ActionM PostData
                liftIO $ print r
                liftIO $ insertPostData r
                liftIO getDialogUpdate >>= json



>>> import requests
>>> url='http://robot.huadin.net/'
>>> m={'deviceId':'a06', 'updateTime':'20191115'}
>>> g=requests.post(url,json=m)
>>> g.content
'{"updateAddress":"http://robot.huadin.net/dialog_update.top","updateVersion":"20191115"}'
>>>

###########################################################

#1 in do-notation, only the last line can concret the type of whole do-block
     in the other lines, they can share the same context, but without same type

#2 a monadic action is a do-notation, Just 3 = do r<- Just 3; return r

#3 about IO a in other context, how we operate on that a?
lift that IO a with liftIO into that context, and then use <- get a in that context
'cause <- will get a from m a which m is an instance of MonadIO

use >>= in the other context will be fine, or make a new do-block

lift IO a into ReaderT r IO a,
data ReaderT r m a = ReaderT { runReaderT :: r -> m a }
but in do-notation , we can get a with <-, or >>= , =<< from ReaderT r IO a
'cause ReaderT r IO is a Monad too, not just a MonadIO
also we can get m a by runReaderT r

so there're two ways to get a from IO a
one is using <- within do-notation or >>= , =<<
another one is liftIO that IO a into a MonadIO, then use <-, >>=, =<<

##############################################################################

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromRow
import Data.Int
import Web.Scotty
import Data.Text.Internal.Lazy as DL
import Data.Text.Lazy as D
import Control.Monad.IO.Class
import Data.Aeson (FromJSON, ToJSON, encode, decode)
import GHC.Generics

data Result = Result { id :: Int64, name :: Text, age :: Int64 } deriving (Show)
instance FromRow Result where
        fromRow = Result <$> field <*> field <*> field

getData :: IO [Result]
getData =  do
        conn <- connectPostgreSQL "host='localhost' port=5432 dbname=test_db user=test_user password=p"
        -- executeMany conn "insert into emp2 (name, age) values (?,?)" [("John",49):: (Text, Int64)]
        query_ conn "SELECT * FROM emp2" :: IO [Result]

        --mapM_ print result
        -- print result
        --return $ seq (map print result) ()

--f :: IO () -> ()
--f _ = ()

data PostData = PostData { emp2Op :: String, emp2Table :: String, emp2Name :: String, emp2Age :: Int64 } deriving (Show, Generic)
instance ToJSON PostData
instance FromJSON PostData

main = do
        r <- getData
        -- print l
        scotty 80 $ do
                get "/" $ do
                       html . D.pack . show $ r
                post "/" $ do
                        --r <- request
                        r <- body



>>> m={'emp2Op':'insert', 'emp2Table':'emp2', 'emp2Name':'Jesse', 'emp2Age':49}
>>> x=requests.post(url,json=m)

#####################################################

{-# LANGUAGE OverloadedStrings #-}

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromRow
import Data.Int
import Web.Scotty
import Data.Text.Internal.Lazy as DL
import Data.Text.Lazy as D

data Result = Result { id :: Int64, name :: Text, age :: Int64 } deriving (Show)
instance FromRow Result where
        fromRow = Result <$> field <*> field <*> field

getData :: IO [Result]
getData =  do
        conn <- connectPostgreSQL "host='localhost' port=5432 dbname=test_db user=test_user password=p"
        -- executeMany conn "insert into emp2 (name, age) values (?,?)" [("John",49):: (Text, Int64)]
        query_ conn "SELECT * FROM emp2" :: IO [Result]

        --mapM_ print result
        -- print result
        --return $ seq (map print result) ()

main = do
        r <- getData
        -- print l
        scotty 3000 $ do
                get "/" $ do
                       html $ D.pack . show $ r

###################################################

#postgresql-simple

{-# LANGUAGE OverloadedStrings #-}

import Database.PostgreSQL.Simple
import Database.PostgreSQL.Simple.FromRow
import Data.Int
data Result = Result { id :: Int64, name :: String, age :: Int64 } deriving (Show)
instance FromRow Result where
        fromRow = Result <$> field <*> field <*> field
main =  do
        conn <- connectPostgreSQL "host='localhost' port=5432 dbname=test_db user=test_user password=p"
        executeMany conn "insert into emp2 (name, age) values (?,?)" [("John",49):: (String, Int64)]
        result <- query_ conn "SELECT * FROM emp2" :: IO [Result]

        --mapM_ print result
        -- print result
        --return $ seq (map print result) ()

########################################

#IO #MonadIO #Reader #ReaderT #MonadReader

irc27313: IO is about affect the outside world, what MonadIO is used to?
irc27313: /time
:karatkievich.freenode.net 391 irc27313 karatkievich.freenode.net :Wednesday November 13 2019 -- 13:41:11 +00:00
Uniaika: irc27313: MonadIO is a typeclass that you can use to constraint an `m`
Uniaika: IO ()  MonadIO m => m ()
Uniaika: note that not all types involving IO are isomorphic to a version that replaces IO with a constrained m, though.
Uniaika: https://stackoverflow.com/questions/52387403/haskell-monadio-vs-io
ashkan_kiani: Was anyone here an intern at tsurucapital before? I'm curious what the likelihood of becoming a full time employee is after the internship.
ashkan_kiani: I got an offer from them
dmwit: That seems like a fantastic question to ask Tsuru Capital.
irc27313: liftIO will lift an IO action into an MonadIO instance, will this IO action will be executed?
dmwit: I guess Proxy could technically be an instance of MonadIO, with `liftIO _ = Proxy`. Which... obviously won't execute the provided action.
irc27313: whats the special about lift an IO action into an ReaderT ?
irc27313: ReaderT r IO a
dmwit: E_TOOVAGUE
ph88: is there a function for   return ()   or  pure ()   ?
dmwit: 1. No, because aren't (necessarily) functions. 2. Yes, `pure ()`.
dmwit: But see also `void`.
irc27313: what value can have ReaderT r IO a?
irc27313: ReaderT r IO is an instance of MonadIO? also Monad?
phaazon: I think I could try CA
dmwit: Yes, it has both of those instances.
irc27313: how to execute an IO action?
dmwit: Make it reachable from `main`.
irc27313: how to get a from IO a?
dmwit: Can't.
Uniaika: irc27313: from a type perspective you cannot
dmwit: But you can turn a function that would normally consume an `a` into a function that knows how to consume an `IO a`, which is almost as good.
Uniaika: from a value perspective, you can use the do-notation to retrieve the content of said `a` and play with it
dmwit: :t (=<<)
lambdabot: Monad m => (a -> m b) -> m a -> m b
hackage:  ACTION rainbox 0.22.0.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.22.0.0 (OmariNorman)
dmwit: % :t (=<<) @IO
yahb: dmwit: (a -> IO b) -> IO a -> IO b
irc27313: whats the effect of ReaderT r IO?
dmwit: So, for example, you can't get the `String` out of `getLine :: IO String` and pass it to `putStrLn :: String -> IO ()`. But you can convert `putStrLn` by `(=<<) putStrLn :: IO String -> IO ()`, and then `getLine` is a fine argument for it; `(=<<) putStrLn getLine :: IO ()`.
irc27313: if I want to use some value that inside an IO action, use do-notation or =<< means I have to put the function into that IO stack, it weird
dmwit: ReaderT r IO offers all the effects available to both Reader r and IO; that is: you can create a value of type r out of thin air and you can do IO.
dmwit: I agree that if you want to use some value that is inside an IO action, you must use do-notation or (=<<), and the result will still be in IO. I do not agree that this is weird.
tdammers: I think that before you attempt to understand MonadIO, you first need to understand IO
irc27313: yeah, I dont understand IO
tdammers: OK, so Haskell is a pure language, right? that means nothing in Haskell has any side effects - in other words, effects cannot occur as a result of evaluation
tdammers: that means we cannot trigger IO actions by evaluating a Haskell function
tdammers: and hence, IO doesn't do that either; it's not really special that way
tdammers: what IO *can* do is symbolically represent interactions with the outside world (a.k.a. effects)
tdammers: for example, `getLine` is a value (not a function!) that represents the effect of reading one line from stdin
tdammers: `putStrLn` *is* a function, but applying it does not cause any effects to happen; rather, it is a function that takes a string and gives a value that represents the effect of printing that string to stdout
tdammers: applying putStrLn to a string doesn't print anything, it just gives you a value of type IO ()
tdammers: and you cannot execute the effect from inside Haskell; only the RTS (runtime system) can do this
tdammers: and it will, if you bind a suitable IO action to the name "main" in the module "Main", and run the program
irc27313: t = getLine >>= putStrLn
main = t
:karatkievich.freenode.net 421 irc27313 main :Unknown command
tdammers: right, yes, >>=
irc27313: main = t
tdammers: obviously it's not very useful to have all these individual IO actions if we can't combine them into more useful programs, and that's what >>= does
tdammers: it happens to be a method of the Monad typeclass, so implementations also exist for a lot of other types, but in this context, it's probably best to only consider the version for IO
tdammers: :t (>>=)
lambdabot: Monad m => m a -> (a -> m b) -> m b
tdammers: :t (>>=)@IO
lambdabot: error:
lambdabot:     Pattern syntax in expression context: (>>=)@IO
:lambdabot!~lambdabot@haskell/bot/lambdabot PRIVMSG #haskell :    Did you mean to enable TypeApplications?
tdammers: aww
tdammers: (>>=) :: IO a -> (a -> IO b) -> IO b
tdammers: in this context
irc27313: we have fromJust or maybe or either to get the values from the context, but we cant get values from IO context?
tdammers: correct
tdammers: there is no way to "deconstruct" IO inside Haskell
irc27313: we only can pass values in IO actions?
tdammers: not quite
tdammers: IO a is an effectful computation that produces an "a"
tdammers: but the only thing we can do with it, other than passing it around and throwing it away, is to feed it to a combinator that accepts such values
irc27313: IO product an "a"
tdammers: yes, but the "produce" part happens outside of Haskell
irc27313: how you describe getLine >>= putStrLn?
tdammers: we can, for example, pass an IO a to the LHS of (>>=); this gives us the opportunity to consume that value in another function of our choice on the RHS, but due to the type of (>>=), that function must return another effectful computation
tdammers: getLine >>= putStrLn is a value that represents the effectful computation of reading one line from stdin and printing it to stdout
tdammers: colloquially, you will hear people say "getLine >>= putStrLn reads one line from stdin and prints it to stdout", but that's technically incorrect - it doesn't actually *do* that, it just *represents* it.
tdammers: > let blah = getLine >>= putStrLn in "hello"
lambdabot:  "hello"
tdammers: see? we're not putting it in a context where the RTS reaches it when executing the "main" action, so it doesn't get executed. it's just a value sitting somewhere, just like any other value
tdammers: > let blah = [getLine >>= putStrLn] in map (\x -> 1) blah -- we can even put IO actions in lists and all that
lambdabot:  [1]
tdammers: as far as Haskell itself is concerned, they're just values
lortabac: tdammers: what you are saying is true, but your results in lambdabot and the fact that you can put IO in lists are unrelated to your point
lortabac: both are due to laziness
merijn: What? No
tdammers: > let blah = getLine >>= putStrLn in seq blah "hello"
lambdabot:  "hello"
merijn: THe fact that you can put IO in lists would work just as well in a strict language
tdammers: > let blah = getLine >>= putStrLn in seq getLine $ seq putStrLn $ seq blah "hello" -- how hard do you want me to seq this?
lambdabot:  "hello"
merijn: tdammers: spoon hard
merijn: @hackage spoon
lambdabot: http://hackage.haskell.org/package/spoon
merijn: or deepseq or whatever :p
tdammers: yeah, but this should be deep enough to show that lazy evaluation has nothing to do with it
irc27313: ReaderT r IO a, if I put this action into main, it will ?
tdammers: you can't, because ReaderT r IO isn't the same type as IO, and main must be IO ()
tdammers: however, there is a useful function that can convert a ReaderT r m a value into an m a value (runReaderT)
irc27313: then how I can make that possible?
tdammers: :t runReaderT
lambdabot: ReaderT r m a -> r -> m a
tdammers: runReaderT takes your ReaderT r IO () action and gives you an IO () action; you do need to provide an r though
irc27313: why main must be IO () not IO a?
tdammers: the resulting IO () action, however, *can* be bound to main
lortabac: tdammers: oops you are right, I didn't sleep enough last night :)
tdammers: I'm not 100% sure it can't be IO a, but it would be pointless to use anything other than (), because the result can never be used
irc27313: IIRC POSIX can have return value 0-255 from program
tdammers: the RTS executes the action and throws the result away
merijn: tdammers: main has to unify with "IO a" per the report
tdammers: right... but that's not how we return exit codes from programs (though I don't know why not... might be to do with the fact that exit codes are a unix-specific thing)
merijn: GHC doesn't do anything with the return value, but that's not required
tdammers: merijn: ah, see, thought there was something
tdammers: right, you *could* build a Haskell compiler that does something with the return value, though it's kind of difficult to imagine what that would be
tdammers: you can
tdammers: t print it, because just "a" doesn't give you a Show instance
lortabac: maybe IO Int could be an exit code :)
merijn: tdammers: If you build a Haskell OS you could return results to the calling process!
tdammers: yeah, but that would require some un-haskelly dynamic dispatch logic
merijn: tdammers: Not everything has to be about this shitty unix nonsense! :p
tdammers: merijn: sure.
irc27313: :runReaderT
tdammers: merijn: just saying that returning an integer is not necessarily sensible for a program across execution environments / platforms
absence: if i have a HashSet of keys, can i use them to split a HashMap in two, one that contains the keys and one that doesn't?
tdammers: irc27313: you need to write it as :t runReaderT (":t" means "type of
hackage:  ACTION rainbow 0.34.0.0 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.34.0.0 (OmariNorman)
tdammers: ")
irc27313: whats the meaning to provide r in runReaderT ?
irc27313: ReaderT r IO (), because a is ()
irc27313: its like f _ = ()
kuribas: irc27313: reader is used for passing configuration
kuribas: irc27313: the r is a configuration type, for example which reads from a datafile, or from the command line.
irc27313: main = runReaderT (x :: ReaderT r IO ()) y
irc27313: y :: r
irc27313: what this y is used to?
irc27313: main = runReaderT (x >>= ...) y ?
kuribas: irc27313: it could be configuration you read from a file
irc27313: y is in the context of Reader T r?
irc27313: so it can pass to others
kuribas: irc27313: y :: r
kuribas: like main = do y <- readConfiguration; runReaderT myProgram y
kuribas: irc27313: supposing readConfiguration has type "IO r"
irc27313: how I can get y from ReaderT r IO context? pass x >>= \z -> ...      what z is?
irc27313: x :: ReaderT r IO ()
irc27313: x >>= \z -> ....     what z has?
irc27313: ()?
irc27313: becasue ReaderT r IO is the monad
kuribas: irc27313: you don't need to get y from ReaderT, because reader cannot change the value, unlike State
kuribas: irc27313: or do you ask you to get it in the monad?
kuribas: irc27313: you use ask
kuribas: :t ask
lambdabot: MonadReader r m => m r
irc27313: but this is a ReaderT
irc27313: how I get a Reader from it?
kuribas: irc27313: ReaderT is an instance of MonadReader
kuribas: ask is polymorphic
irc27313: ask (_::ReaderT r IO ()) will get?
irc27313: y::r?
kuribas: :t ask :: Monad m => ReaderT r m r
lambdabot: Monad m => ReaderT r m r
kuribas: irc27313: you need to be clearer in the question you ask
irc27313: ask is not a function?
kuribas: :t ask :: ReaderT r IO r
lambdabot: ReaderT r IO r
kuribas: irc27313: no, it's not
kuribas: it does wrap a function though
kuribas: :t ask :: Reader r r
lambdabot: Reader r r
kuribas: :t ask :: StateT s (ReaderT r IO) r
lambdabot: StateT s (ReaderT r IO) r
irc27313: then I dont understand
irc27313: ask is not a function, how it used to ReaserT
kuribas: irc27313: ask is a monadic action.
kuribas: in the reader monad
tdammers: OK, so here's the deal
kuribas: the same way putStrLn "hello" is a monadic action in the IO monad
kuribas: :t putStrLn "hello"
lambdabot: IO ()
tdammers: Reader r a is basically a synonym for r -> a
irc27313: main = runReaderT $ do x <- ask ...  y
tdammers: ReaderT r m a is a synonym for r -> m a (more or less)
irc27313: what this x has type?
tdammers: runReader(T) gets you from the former representation to the latter
kuribas: irc27313: r
tdammers: the trick is of course that Reader monads allow you to combine r -> a and a -> r -> b into r -> b
tdammers: and likewise, ReaderT allows you to combine r -> m a and a -> r -> m b into r -> m b
tdammers: what that means is that rather than passing an extra argument explicitly at every part of the call chain, you wrap things in Reader(T), and only supply the extra argument once
irc27313: its so trick
tdammers: essentially the Reader monad captures a very common coding pattern, namely the one where you have some sort of context or environment that you pass to all parts of an expression
tdammers: and now, if you look at ask:
tdammers: :t ask
lambdabot: MonadReader r m => m r
tdammers: and desugar the Reader notation away:
tdammers: ask :: r -> r
tdammers: oh boy
tdammers: so that means that if Reader r a is just r -> a, then ask is just r -> r
tdammers: and it follows that \r -> runReader r ask is the identity
tdammers: > runReader "hello" ask
lambdabot:  error:
lambdabot:       Couldn't match type [Char] with ReaderT (m0 r0) Identity a
:lambdabot!~lambdabot@haskell/bot/lambdabot PRIVMSG #haskell :       Expected type: Reader (m0 r0) a
tdammers: :t runReader
lambdabot: Reader r a -> r -> a
tdammers: > runReader ask "helo"
lambdabot:  "helo"
tdammers: (the other way around, actually)
tdammers: but of course the real use for it is when you use monadic combinators inside
tdammers: e.g.:
tdammers: > runReader (ask >>= \str -> return (str ++ str)) "hello"
lambdabot:  "hellohello"
tdammers: > runReader (ask >>= \a -> ask >>= \b -> return (a ++ b)) "hello"
lambdabot:  "hellohello"
tdammers: or, with do sugar:
tdammers: > runReader (do { a <- ask; b <- ask; return (a ++ b) }) "hello" -- literally the same thing
lambdabot:  "hellohello"
kuribas: > runReaderT (do y <- ask; liftIO (putStrLn y)) "hello"
lambdabot:  error:
lambdabot:       Ambiguous type variable m0 arising from a use of show_M559522842239...
:lambdabot!~lambdabot@haskell/bot/lambdabot PRIVMSG #haskell :       prevents the constraint (Show (m0 ())) from being solved.
kuribas: > runReaderT (do y <- ask :: ReaderT String IO String; liftIO (putStrLn y)) "hello"
lambdabot:  <IO ()>
kuribas: that would print "hello"
tdammers: > (runReaderT (do { y <- ask; liftIO (putStrLn y) }) "hello") :: IO ()
lambdabot:  <IO ()>
tdammers: oof

#################################
remove empty lines
M-x flush-lines RET ^$ RET

M-x replace-regexp RET ^hskl.* RET
remove all lines start with hskl

M-x replace-regexp RET ^John Wonder.*C-qC-j RET
replace two lines to one line
##################################

web server is not the productor of data, it's the reader of data
every visit will make it read once
make a cache of front-end or web server can speed it up

#####################################################

aptitude install libghc-persistent-postgresql-dev

POSTGRESQL NEEDS END WITH `;'
DON'T USE " ", use ' '

psql -d test_db -U test_user
SELECT * FROM person;

CREATE TABLE emp (
name text,
age integer,
designation text,
salary integer
);

INSERT INTO emp (name, age, designation, salary) VALUES ('Joe', 39, 'CEO', 200000);

SELECT * FROM emp;

UPDATE emp SET designation = 'CTO', salary = 300000;

 DELETE FROM emp WHERE salary > 100000;

ALTER TABLE : change the definition or structure of an existing table.

ALTER TABLE emp DROP COLUMN salary;

DROP TABLE emp;

\dt #check all the tables

#backup
pg_dump -U test_user test_db > Mybackup.pgsql

su - postgres
psql
DROP DATABASE test_db;

#after drop database, restore it need to create a new one

su - postgres
psql
CREATE DATABASE test_db;

#restore
psql -U test_user test_db < Mybackup.pgsql

 psql -d test_db -U test_user
 \dt

from https://www.w3resource.com/PostgreSQL/create-database.php

#######################################

aptitude install postgresql postgresql-contrib

/etc/init.d/postgresql start
'cause of fucking systemd won't work in chroot env
systemctl start postgresql

default user : postgres
passwd postgres


 vim /etc/postgresql/12/main/pg_hba.conf
 # "local" is for Unix domain socket connections only
` local all all peer' to `local all all md5'

 /etc/init.d/postgresql restart
 

su - postgres
psql
CREATE DATABASE test_db;   # create a database
CREATE USER test_user PASSWORD 'postgres'; # create a user
psql -d test_db -U test_user # login with that user

from https://www.howtoing.com/install-postgresql-database-in-debian-10
##################################################

seq :: a -> b -> b
a is strict evaluation, and b is lazy evaluation, return b

data P = P Int
P (1+2) :: P
P (1+2) `seq` () throw an exception
P 3 `seq` () it's fine
P 3 :: P

use `seq` to check if the value is evaluated or not

bang pattern
add !x !y = x +y
main = do
     let !five = add(1+1) (1+2)
         !seven = add (1+2) (1+3)

     putStrLn $ "five: " <> show five

this code now behave exactly like the
strict C doe, ghc force x y and five seven
evaluation, evaluate before getting to putStrLn

<Axman6> data Foo = Foo {fooInt :: !Int, fooChar :: Char } -- contains a
         strict Int and a lazy Char, so Foo undefined 'a' `seq` () will throw
         an exception, but Foo 1 undefined `seq` () won't
<jusss> Axman6: data P = P Int, here this Int is not a type?
<Axman6> yes it is
<Axman6> but !Int isn't a type, it's an annotation on the type Int
<EvanR> jusss: so !Int -> !Char is not valid anything
<EvanR> but data Foo = Foo !(Int -> Char) is a valid data type, though the !
        here is a bit silly                                             [13:49]
<EvanR> but it has nothing to do with the type, it's about the field
<EvanR> it should have been data Foo = Foo { !field1 :: Int, !field2 :: Char }
        or something                                                    [13:53]        

#####################################

Evaluation Strategy

Strict evaluation (Applicative order)
call-by-value : C, Scheme
call-by-reference : Python, Ruby
call-by-sharing

Non-strict evaluation (Normal order, lazy evaluation)
call-by-name : ALGOL 60
call-by-need : Haskell, R
call-by-future related to coroutine

beta-reduction, lambda calculus
thunk

###########################################

 aptitude install libghc-persistent-sqlite-dev


##################################################

#Reader #Writer #State

import Control.Monad.Writer
data Writer w a = Writer { runWriter :: (a, w) }
half :: Int -> Writer String Int
half x = do
     tell ("halved " <> (show x) <> ",")
     return (x `div` 2)  -- context is Writer ( ,String)

runWriter (half 8 >>= half)  == (2,"halved 8,halved 4,")

also >>= :: Writer w a -> (a -> Writer w b) -> Writer w b
so half :: a -> Writer w b
and half a :: Writer w b

Writer String is m, Int is a, its value form is Writer (Int, String),
its context is Writer ( ,String)
`tell' can change the String in ( ,String)
runWriter can get the (Int, String)

import Control.Monad.Reader
data Reader r a = Reader { runReader :: r -> a }
greeter :: Reader String String
greeter = do
        name <- ask
        return ("hello, " <> name <> ",")  -- context is Reader r in Reader r a, so `return' will get Reader name -> ("hello, ...), then runReader greeter get name -> ("hello"...) , give the value of name and get ("hello...)

`ask' get r from Reader r a

(runReader greeter) "Joe" == "hello, Joe,"

runReader (greeter >>= \x -> do c <- ask; return (c, x)) "Joe"   == ("Joe","hello, Joe,")
the context is "Joe", and x is the result, is a in Reader r a

it needs runReader to get the function from `Reader function', so we can apply something on the function, if in the do-notation or >>=, we can get the context Reader r, so after we apply something on the function, then get the result, we can use `return' to make a new Reader r a, and the result is a.

runReader (greeter >>= \x -> return $ (runReader greeter) x) "Jesse"
== "hello, hello, Jesse,,"

runReader (greeter >>= \x -> do c <- ask; return $ c <> x) "Jesse"
== "Jessehello, Jesse,"

import Control.Monad.State
data State s a = State { runState :: s -> (a, s) }
greeter2 :: State String String
greeter2 = do
        name <- get  -- get a from State s -> (a, s)
        put "tintin"  -- set the s
        return ("hello, " <> name <> ",")  -- context is State s-> ( ,s)

runState greeter2 $ "Joe"  == ("hello, Joe,","tintin")

`get' get the a in State s->(a,s)
`put' set the s in State s->(a,s)

m a, m is the context, in the value form, remove the a, the rest is the m, is the context
with Reader constructor, the context is Reader r, but if without Reader, just function,
then the paramerter of first function is the context.
return a in do-notation or >>=, it will get m a.

>>= :: State s a -> (a -> State s b) -> State s b
runState (greeter2 >>= \a -> return $reverse a) "Joe"  == (",eoJ ,olleh","tintin")

(greeter2 >>= \a -> return $reverse a) this is a new State Monad,
'cause we need to get the function inside of it to apply something on it
so runState (greeter2 ...) get the function s->(a,s) then apply "Joe" on it
get the (a,s)

this three monads have call form  like `runMonad monadic-action parameter'
runState (greeter2 >>= \a -> return $reverse a) "Joe"
runState greeter2 "Joe"
(runReader greeter) "Joe" == "hello, Joe,"
runReader (greeter >>= \x -> return $ (runReader greeter) x) "Jesse"
runWriter (half 8 >>= half)  == (2,"halved 8,halved 4,")
runWriter $ half 8

all the computation is in the monadic-action
reference http://adit.io/posts/2013-06-10-three-useful-monads.html#the-state-monad

#######################################################

all monads are about effects
Maybe Monad, the context is Just or Nothing, the form is Just a or Nothing
Maybe, Just in Just a
Reader Monad, the context is the e in e->a, Reader r in Reader r a
Writer Monad, the context is Writer ( ,x::Monoid) in Writer (a,x)
State Monad, the context m is State s -> ( ,s) in State s -> (a, s)

data Reader r a = Reader { runReader :: r -> a }
data State s a = State { runState :: s -> (a, s) }
data Writer w a = Writer { runWriter :: (a, w) }

effects:
Reader , a is read only, pass a read-only parameter
Writer, (a,s) s is log, log the message
State, a can be changed also s can be log, pass a read-write parameter also log the message

Reader id :: Reader a a
ask get r from Reader (r-> a) :: Reader r a,
runReader on f :: Reader r a, will get r->a
runReader f (x::r) :: a
also runWriter and runState

runReader (do x <- ask; return (x+x)) 42 will be 84

runState (x::State s a) :: s -> (a, s)
runState (x::State s a) (_::s) :: (a, s)

runWriter (x::Writer w a) :: (a, w)

there's no Reader, Writer and State type defined in Control.Monad.*
we use functions to generate they value has that type

we call it a `smart constructor'
<jle`> reader :: (r -> a) -> Reader r a
<jle`> there's also 'ask'
<jle`> asks :: (r -> a) -> Reader r a
<jle`> two ways to create a Reader from a function
<jle`> Writer and State as data constructors do not exist in transformers
<jle`> but we have:
<jle`> writer :: (a, w) -> Writer w a    -- why isn't this curried? we may
       never know
<jle`> state :: (s -> (a, s)) -> State s a
<int-e> This is isomorphic to the type we're discussing, but there is no
        actual `Reader` data constructor.
<int-e> But `reader` generalizes that data constructor, so no functionality is
        lost.
        
reader writer and state to constructor that value have that Reader Writer State type
`ask' for reader
`tell' for writer
and `modify' 'get' for state

<jle`> jusss: i was saying, we usually don't use reader/writer/state in
       practice
<jle`> we usually use 'ask' for reader                                  [15:07]
<jle`> 'tell' for Writer
<jle`> and 'modify' and 'get' for State
<jusss> and `put'?
<jle`> ask :: Reader r r
<jle`> tell :: w -> Writer w ()
<jle`> modify :: (s -> s) -> State s ()
<jle`> get :: State s s
<jle`> those are sort of the canonical "abstract interface" of reader, writer,
       and state                                                        [15:08]
<jle`> so you build complex reader/writer/state actions by sequencing calls to
       ask, tell, and modify
<dminuoso_> Similarly, how `putStrLn`, `getLine`, etc. form the "abstract
            interface" of IO.
<jle`> > execWriter $ do tell "hi"; tell "bye"                          [15:10]
<lambdabot>  "hibye"
<jle`> > execState (do modify (+1); modify (*10); modify negate) 3
<lambdabot>  -40
<jle`> > runReader (do x <- ask; y <- ask; pure (x+y)) 7                [15:11]
<lambdabot>  14
<jle`> so the person who gave us the IO type also gave us things to make
       'simple IO actions', like putStrLn, getLine.  we can use those simple
       Io actions to build more complex and interesting ones, by sequencing
       them and stuff like that                                         [15:12]
<jle`> the person who gave us the State s type also gives us things to make
       'simple State actions', like modify, put, get.  we use those simple
       State actions to build more complex and interesting State actions, by
       sequencing them with >>/do notation and stuff like that
<jle`> it's rare to actually use 'state', but we can define it in terms of
       modify and get: `state f = do s <- get; let (x, s') = f s; put s';
       return x`                                                        [15:13]
<jle`> likewise it's rare to actually use 'writer', but we can define it in
       terms of tell: `writer (x, w) = do tell w; return x`
<monochrom> You don't need an abstract constructor (or abstract type) if you
            have nothing to hide.                                       [15:21]
<int-e> pattern Reader :: (r -> a) -> Reader r a; pattern Reader f <-
        ((runIdentity .) . runReaderT -> f) where Reader f = reader f --
        somehow, pattern synonyms are not beautiful.                    [15:24]
        
#############################################

Maybe is a type, Maybe a is a type
Maybe is a type has kind *->*,  Maybe a is a type has kind *

type T = Maybe
type MyMonad = MaybeT IO
type MyMonadIO = MaybeT IO
##########################################

lsp-mode company-mode bot need extra language servers as backends
autocomplete mode doesn't

download sublimetext
https://www.sublimetext.com/3
install package control
https://packagecontrol.io/installation
install sublimehaskell, but sublimehaskell need ghc-mod or hsdev as backends
use cabal install hsdev

intellij idea, intellij-haskell only has stack,
haskforce has stack and cabal, but it nees stylish-haskell, hlint and ghc-mod

sublimetext need hsdev or ghc-mod as backends

#################################################

;;; unicode characters
;;;(set-default-font "Microsoft YaHei UI Bold-10")
;;;(set-fontset-font "fontset-default"  
;;;                  'gb18030' ("Microsoft YaHei UI Bold" . "unicode-bmp"))
(require 'unicode-fonts)
(unicode-fonts-setup)
;;;(set-default-font " Bold-10")
(set-default-font "Arial Bold-10")

########################################################

<jusss``> jle`: now I meet a typeclass, I ask three questions, laws, functions
          and used for                                                  [15:10]
<jusss``> or about
<jusss``> maybe I should append the kind
<jle`> the thing is that, what a typeclass is 'used for' is often not that
       useful                                                           [15:11]
<jle`> that a *type* is used for -- that's definitely very useful
<jle`> learn what Maybe is used for. what IO is used for
<jusss``> jle`: but that `used for' is we really use it to do
<jle`> right, but when do you actually 'use' a typeclass?
<jle`> usually you're using the types
<jle`> not the 'typeclass' as an abstraction                            [15:12]

<jle`> 90% of the time you use >>=, <$>, etc., you're using specific
       types. you're not using Monad the abstraction, Functor the abstraction,
       etc.
<jle`> so it doesn't matter what Monad is used for. it matters what the
       specific type you are using is used for
<jusss``> jle`: yeah, the typeclass's laws and implented functions, and the
          type instances of it, the type is used for, or about ?
<jle`> learning about laws and methods of a typeclass and what they 'mean' in
       the abstract sense is usually not very useful                    [15:13]
<jusss``> jle`: wait a sec, typeclass is not type, typeclass don't have kind?
<jle`> well, it can be in some situations. but it's never going to be the
       first thing you learn.
########################################

there're seven typeclasses,
Semigroup, Monoid, Functor, Applicative, Monad, MonadIO and MonadTrans.
type and typeclass both have kind, types are instances of typeclasses,
MonadTrans has kind (*->*) -> (*->*)
the others have kind * -> *
Semigroup Monoid instances are *
it means things of kind *
like Int, Bool, String, Double
but not Maybe, IO, Either, MaybeT
(Int -> Int) has kind *, it could be an instance of Semigroup and Monoid if
someone wrote an instance for it

`lift' lift m a into t m a
`liftIO' lift IO a into m a, m is a MonadIO instance
some Monads are MonadIO, some aren't,
MonadIO isn't related to MonadTrans,
`return' to lift a into m a,
`join' to lift m a from m (m a),
there's no general way to get a from m a,
see `maybe' `either'

###########################################################

<jle`> if seeing monad transformers is confusing, maybe look at a simpler
       MonadIO instance, like `newtype WithArgs a = WithArgs { runWithArgs ::
       String -> IO a }`                                                [14:23]
<jle`> er, `newtype WithArgs a = WithArgs { runWithArgs :: [String] -> IO a }`

<jle`> WithArgs a is [String] -> IO a, it's an IO a that has access to a
       [String], the command line arguments
<jle`> we can write an instance of Functor
<jle`> instance Functor WithArgs where fmap f (WithArgs x) = WithArgs (fmap f
       . x)
<jle`> we can write an instance of Applicative, which i'll only give 'pure'
       here:
<jle`> instance Applicative WithArgs where pure x = WithArgs $ \_ -> pure x
                                                                        [14:25]
<jle`> and we can write an instance of Monad (exercise left to reader)
<jle`> and we can write an instance of MonadIO:
<jle`> instance MonadIO WithArgs where liftIO x = WithArgs $ \_ -> x
<jle`> so that's an example of a Functor that is also an Applicative that is
       also a Monad that is also a MonadIO
<jusss``> jle`: MonadIO a is MT IO a, the value is like MT IO (M a) ?   MT
          mean monad transformer type constructor
<jle`> no, not necessarily                                              [14:26]
<jle`> look above where i gave an instance of MonadIO that doesn't involve any
       monad transformer applied to IO
<jle`> here the `WithArgs` type i defined above is an instance of (1) Functor,
       (2) Applicative, (3) Monad, (4) MonadIO                          [14:27]       
<jle`> but there are no monad transformers involved
<jle`> the purest form of a MonadIO

###########################################

we use `return' to lift a Maybe Int into IO (Maybe Int)
remember MonadTrans has the same type constructor and value constructor

newtype MaybeT IO a = MaybeT IO (Maybe a)
<jusss`> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

<jle`> another simple instance is MaybeT IO, liftIO x = MaybeT (Just <$> x)
<jle`> in that type, liftIO :: IO a -> MaybeT IO a

<jle`> lift :: MonadTrans t => m a -> t m a
<jle`> liftIO :: MonadIO m => IO a -> m a

<jusss``> jle`: MonadIO is a typeclass, and MaybeT IO is an instance of
          MonadIO, also MaybeT IO is an instance of Monad?              [14:19]

data T = V   maybe we should call this V as Value form,
data Maybe Int = Nothing | Just Int,   Just Int is not a value, Just 3 is a value
Int need to be defined, but Just Int is a form of Just 3

`lift' will lift an m a into a MonadTrans, which MonadTrans depends you give the type
`liftIO' will lift an IO a into a MonadIO
MonadTrans has kind (*->*) -> (*->*)
MonadIO has kind *->*
Int -> Int has kind *
Semigroup and Monoid's instance is *
Functor Applicative Monad and MonadIO has *->*
some Monads are MonadIO, some aren't, MonadIO is a sub class of Monad
there're seven typeclass Semigroup, Monoid, Functor, Applicative, Monad, MonadIO
and MonadTrans
type and typeclass both have kind
type are instances of typeclass
typeclass has laws and implementd functions, the type instances of typeclass are what used for, and about

MaybeT IO is an instance of Monad and  MonadIO,

<evocatus> jusss`: liftIO can take IO actions and turn them into actions in
           any monad `m`, so long as that monad `m` instances
           `MonadIO`... it's useful for when you're deep in a stack of monad
           transformers and want to perform IO actions within the stack
<Axman6> class Monad m => MonadIO m where liftIO :: IO a -> m a
<jle`> MonadIO makes no claim about how the type is structured          [12:24]
<jle`> just that it has to support IO a -> MyMonadIO a
<jle`> it's really as simple as just the typeclass here                 [12:26]
<jle`> it has a single method, liftIO :: MonadIO m => IO a -> m a
<jle`> i don't think MonadIO has anything to do with monad transformers in
       particular ... because no monad transformers are MonadIO instances
<jle`> MonadIO instances are monads
<jle`> not monad tnnasformers
<jle`> the simplest MonadIO instance is IO                              [12:28]
<jle`> instance MonadIO IO where
<f-a> the trick is mostly useful (or taught) as a way to fish IO from a stack
<jle`>   liftIO = id
<jle`> i think that's a narrow way of looking at it...a MonadIO instance
       doesn't even have to be a part of a 'stack'
<jle`> it's just something that "supports IO"
<Axman6> I think you'll find that MonadIO m => MonadIO (MaybeT m) is the
         instance
<Axman6> as long as MaybeT wraps something which can run IO actions, it can
         also run IO actions
<jle`> jusss`: well, is there a way to write an IO a -> MaybeT m a ?
<jle`> jusss`: if yes, then it's a MonadIO instance
<jle`> in this case, we can write one:
<jle`> liftIOMaybe :: MonadIO m => IO a -> MaybeT m a
<jle`> liftIOMaybe x = MaybeT (Just <$> liftIO x)
<jusss`> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
<jle`> it's possible, so it's an instance ... just as simple as that
<jle`> maybe looking more concretely, can you write IO a -> MaybeT IO a ?
<jusss`> jle`: f :: IO a -> MaybeT IO a;  f x = runMaybeT (liftIO x) ?  [13:38]
<Axman6> no, but it will let you rejoin all the returned sections with one of
         the combinators which adds a soft line
<Axman6> jusss`: does that type check?
<Axman6> that doesn't look like it matches the type you've given
<Axman6> jusss`: if you have an IO a, and you need an IO (Maybe a) how can you
         do that?
<jusss`> Axman6: get a from IO a, then  return Maybe , then return IO   [13:40]
<jusss`> Axman6: but this will switch contexts
<Axman6> that matches the type, but it's not as useful as returning the a that
         the IO action produced
<Axman6> jusss`: can you write f :: IO a -> IO (Maybe a) without using Nothing
<jusss`> Axman6: f = \x -> x >>= return $ return a                      [13:42]
<Axman6> not wuite
<jusss`> Axman6: I don't know the syntax, if I want declare the type in the
         value
<Axman6> quite*
<Axman6> jusss`: hint: use fmap
<Axman6> % :t MaybeT
<yahb> Axman6: m (Maybe a) -> MaybeT m a
<jusss`> Axman6: f x = fmap (\y-> Just y) x ?                           [13:46]
<jusss`> oh, f x = fmap Just x
<jusss`> eta-reduce
<Axman6> yep, good!
<jusss`> Just = \x -> Just x
<Axman6> jusss`: can you now write  g :: IO a -> MaybeT IO a? we've seen how
         to go from IO a to IO (Maybe a), and MaybeT is just a wrapper around
         things of the shape m (Maybe a)
<jusss`> f x = MaybeT $ fmap Just x                                     [13:50]
<Axman6> % :t let f x = MaybeT $ fmap Just x in f -- let's find out     [13:51]
<yahb> Axman6: Functor m => m a -> MaybeT m a
<Axman6> Looks good to me, though that's evenmore powerful :o
<Axman6> Nice work!
<Axman6> whatr you've actually defined is the function lift, from the
         MonadTrans class
<Axman6> :t lift
<lambdabot> (MonadTrans t, Monad m) => m a -> t m a
<Axman6> can you write h :: IO a -> ExceptT String IO a?                [13:55]
<Axman6> :t ExceptT
<lambdabot> m (Either e a) -> ExceptT e m a
<jusss`> lift x = Except $ fmap Right x?
<jusss`> ExceptT
<Axman6> % :t let lift x = ExceptT $ fmap Right x in lift
<yahb> Axman6: Functor m => m a -> ExceptT e m a
<Axman6> Looks good to me!
<Axman6> jusss`: well, for someing to be a monad transformer, it needs to
         provide the function lift which can turn some monad m into t m
<jusss`> Axman6: how I can tell lift will turn monads into which transformer?
<Axman6> it depends on the context                                      [14:02]
<Axman6> % :t lift (print ()) :: ExceptT Int IO ()
<yahb> Axman6: ExceptT Int IO ()
<jle`> jusss`: you use it whenever you want to turn an 'm a' into a 't m a'
<jle`> which can happen in many different situations                    [14:03]
<jle`> the types will guide you, when you need it
<jusss`> Axman6: jle` what's the relation, lift and liftIO?             [14:05]
<jusss`> lift is a function which lift its monadic value parameter into a
         monad transformer?                                             [14:06]
<Axman6> good queation - with what we've written so far, lift and liftIO have
         been the same. but what happens when we want ExceptT String (MaybeT
         IO) a?
<jle`> jusss`: the types tell you everything you need to know           [14:07]
<jle`> lift :: MonadTrans t => m a -> t m a
<jle`> liftIO :: MonadIO m => IO a -> m a
<jle`> they are similar in that they are both 'monad homomorphisms'
<jle`> or natural transformations
<jle`> they move you from one monad to another
<jle`> lift moves you from 'm' to 't m'
<jle`> liftIO moves you from 'IO' to 'm'                                [14:08]
<jle`> in a way they can be seen just as boilerplate, just moving an action
       from one monad to another
<jle`> liftIO :: IO a -> MaybeT IO a, you move from (IO) monad to (MaybeT IO)
       monad
<jle`> the use case?  when you have an IO a, but you want a MaybeT IO a
<jle`> or more generally, liftIO :: IO a -> MyMonad a                   [14:09]
<jle`> the use case? when you have an 'IO a', but you want 'MyMonad a'
<jle`> there isn't really anything deeper or more profound than that
<jle`> the reasion liftIO exists is so that you don't have to define a
       liftIOIntoMyMonad :: IO a -> MyMonad a, for every single monad
<jle`> then you'd have something like liftIOMaybeT :: IO a -> MaybeT IO a,
       liftIOStateT :: IO a -> StateT s IO a, liftIOExceptT :: IO a -> ExceptT
       e IO a
<jle`> you could just have one function referring to all of the with the same
       name
<jle`> like how by having Eq and (==), you wouldn't have to write eqInt,
       eqString, eqFloat, eqDouble, etc.
<jusss``> lift IO into MaybeT IO a, then lift the result into EexceptT?
<jle`> i'm not sure what you are asking                                 [14:11]
<jusss``> jle`: sorry, net split, I''m reading your words
* Axman6 hands the reins back to jle`
<jle`> MonadIO is a completely ad-hoc typeclass -- just like Eq, Ord, Show,
       Read, etc.; basically used for overloading names of useful functions,
       with some laws to make it a little more predictable
<jusss``> jle`: Axman6 sorry, this ExceptT String (MaybeT IO) a really got me
<jle`> without monad IO, we'd do just fine.  we'd have liftIOMaybeT :: IO a ->
       MaybeT IO a, liftIOStateT :: IO a -> StateT s IO a, etc.
<jle`> having MonadIO just lets us call all of those functions by the same
       name, liftIO. just like how having Eq lets us call our Int comparer,
       Double comparer, string comparer, etc. all with (==)             [14:13]
<jusss``> jle`: is MonadIO a monad?
<jle`> no, it is a typeclass, like Eq, Ord, Show, etc.
<jle`> but its instances are monads
<jusss``> MaybeT m is a monad?                                          [14:14]
<jusss``> when m is a monad,
<jle`> yes
<jle`> that's why it is called a "monad transformer"                    [14:15]
<jle`> give it a monad, and it returns a monad
<jle`> IO is a monad, so `MaybeT IO` is a monad
<jusss``> jle`: sorry, it's lots of messages I need to think a few moments
<jle`> give MaybeT a monad, and it returns a new monad.  if you have a monad
       M, then MaybeT M is a fresh new monad for you                    [14:16]
<jusss``> jle`: can you give me a simple instance of MonadIO 
<dibblego> jusss``: you can ask ghci for the instances, use :info       [14:17]
<jusss``> like newtype MaybeT m a = MaybeT m (Maybe a)
<jle`> one simple instance is IO
<jle`> instance MonadIO IO where liftIO = id
<jusss``> jle`: except IO
<jle`> another simple instance is MaybeT IO, liftIO x = MaybeT (Just <$> x)
<jle`> in that type, liftIO :: IO a -> MaybeT IO a
<jle`> yes all of those are true
<jle`> MonadIO is actually a subclass of Monad
<jle`> class Monad m => MonadIO m
<jle`> just like how Ord is a subclass of Eq                            [14:20]
<jle`> Fractional is a subclass of Num, etc.
<jle`> in haskell we have many Monads, and some of those Monads are MonadIO
<jle`> some Functors are Applicatives.  some Applicatives are Monads.  some
       Monads are MonadIO
<jle`> some shapes are quadrilaterals, some quadrilaterals are rectangles,
       some rectangles are squares, etc.                                [14:21]
<jle`> if seeing monad transformers is confusing, maybe look at a simpler
       MonadIO instance, like `newtype WithArgs a = WithArgs { runWithArgs ::
       String -> IO a }`                                                [14:23]
<jle`> er, `newtype WithArgs a = WithArgs { runWithArgs :: [String] -> IO a }`

<jle`> WithArgs a is [String] -> IO a, it's an IO a that has access to a
       [String], the command line arguments
<jle`> we can write an instance of Functor
<jle`> instance Functor WithArgs where fmap f (WithArgs x) = WithArgs (fmap f
       . x)
<jle`> we can write an instance of Applicative, which i'll only give 'pure'
       here:
<jle`> instance Applicative WithArgs where pure x = WithArgs $ \_ -> pure x
                                                                        [14:25]
<jle`> and we can write an instance of Monad (exercise left to reader)
<jle`> and we can write an instance of MonadIO:
<jle`> instance MonadIO WithArgs where liftIO x = WithArgs $ \_ -> x
<jle`> so that's an example of a Functor that is also an Applicative that is
       also a Monad that is also a MonadIO
<jusss``> jle`: MonadIO a is MT IO a, the value is like MT IO (M a) ?   MT
          mean monad transformer type constructor
<jle`> no, not necessarily                                              [14:26]
<jle`> look above where i gave an instance of MonadIO that doesn't involve any
       monad transformer applied to IO
<jle`> here the `WithArgs` type i defined above is an instance of (1) Functor,
       (2) Applicative, (3) Monad, (4) MonadIO                          [14:27]       
<jle`> but there are no monad transformers involved
<jle`> the purest form of a MonadIO
<jusss``> jle`: now, I see, there're four typeclass, Functor, Applicative,
          Monad and MonadIO, some monads are MonadIO, some aren't, MonadIO
          isn't related to Monad Transformer,  Monad Transformer is also a
          typeclass? what's the relation Monad and Monad Transformer?
<jle`> jusss``: MonadTransformer is also a typeclass, but it exists separately
       from the Functor > Applicative > Monad > MonadIO hierarchy       [14:37]
<jle`> it's a different "kind", too
<jle`> Functor, Applicative, Monad, MonadIO instances are all (Type -> Type)
<jle`> but MonadTrans instances are all (Type -> Type) -> (Type -> Type)
<jle`> they "take" a (Type -> Type) (your monad), and "return" a (Type ->
       Type) (your transformed monad)                                   [14:38]
<jle`> so MonadTrans is a higher-higher-kinded abstraction. it abstracts over
       all things that can transform monads
<jusss``> jle`: we use kind to describe type, we use typeclass to describe
          type, typeclass is related to kind?
<jle`> hm, i don't think there is really any formal link for it. kinds can be
       used to reason with types and how they fit together, but typeclasses
       express the 'capabilities' that certain types have in terms of
       value-level functions associated with them                       [14:41]
<jusss``> jle`: what you mean (Type -> Type)?                           [14:43]
<jle`> (* -> *)

<jusss``> Monad has the kind * -> *, and MonadTrans has the kind (*->*) ->
          (*->*) ?
<jle`> instances of Monad have kind * -> *, and instances of MonadTrans have
       kind (* -> *) -> (* -> *)
<jusss``> jle`: and instances of MonadIO have kind ?                    [14:45]
<jle`> Functor, Applicative, Monad, MonadIO instances are all * -> *
<jusss``> yeah
<jusss``> jle`: about the law, Monad has that three laws, and MonadIO ? 
                                                                        [14:46]
<jusss``> MonadIO is a sub class Monad, and some monads aren't MonadIO  [14:47]
<jusss``> MonadIO at least has three laws?
<jusss``> and the implement functions?
<jusss``> and laws and functions about MonadTrans?

<jle`>
       https://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-IO-Class.html
                                                                        [14:48]
<jusss``> jle`: Monads are about effects, and MonadIO and MonadTrans are about
          ?
<jle`> um...don't listen to the line that says "instances should satisfy ..",
       it's kind of iffy
<jle`> jusss``: MonadIO is being able to 'embed' IO actions into your monadic
       actions, IO a -> M a.                                            [14:49]
<jle`> there isn't any deeper meaning than that

<jusss``> jle`: monad actions are not function, what about Functor and
          Applicative?
<jle`> what about them?                                                 [14:50]
<jusss``> jle`: is there Functor action or Applicative action?

<jle`> sometimes people call values of 'f a', where f is a functor, a
       functorial action. same for applicative                          [14:51]
<jle`> but it's not really anything formal, it's just to aid discussion
<jle`> so an `IO Int` is an IO action. it's monadic, functorial, applicative,
       monadio-ic, etc.                                                 [14:52]
<jusss``> jle`: Functor and Applicative have laws?
<jle`> i know one way to find out :)
<jle`> hint: it utilizes a web browser                                  [14:53]

<jusss``> jle`: those concepts really make me confused ...              [15:01]
<jle`> that's ok :) familiarity and practice is what helps lower the confusion
       over time
<jusss``> it takes lots of time to build the intutive...
<jle`> all the time won't do anything unless you are writing programs using
       these abstractions                                               [15:02]
<jle`> so time can help, but practice is necessary
<jusss``> jle`: it's weird that it takes lots of time to understand concepts
          not to code
<jle`> you might be looking at it backwards
<jle`> writing the code is how you understand the concepts
<jle`> not the other way around
<jusss``> yeah
<jle`> so write the code, and the concepts will come to you after       [15:03]
<jle`> you won't even have to try  :)
<jusss``> jle`: but if I don't understand monad, how I can code about ti
<jle`> sounds like it would be hard, right?
<jle`> turns out, it isn't
<jle`> writing code using monads, day to day, requires understanding nothing
       about monads as an abstraction                                   [15:04]
<jle`> that's the beauty of it

<monochrom> It's true of everything.
<jle`> you can write code using the monad instance of Maybe, without ever
       understanding monads as an abstraction
<jusss``> jle`: but then I never would know about `return' is the unit,
<jle`> yes, so many things you will never know
<monochrom> No one says "I don't understand rings, so how can I do plus and
            times?"
<jle`> but so many things you will end up accomplishing                 [15:05]
<monochrom> In fact it's the other way round. You do plus and times for a long
            time, then you're ready to learn ring theory.

<monochrom> Similarly for Chess. Similarly for natural languages. I can go on
            and on.
<jle`> jusss``: imagine something building a useful haskell application,
       without ever knowing 'return is the unit'                        [15:06]
<jle`> the nerve of them!
<jle`> how dare they
<purelazy> You learn before you understand how muscles work
<jle`> how dare they ... not know this, and still make useful things, that
       don't require knowing it
<purelazy> You do walk before you understand how muscles work
<monochrom> When you were a child you didn't ask your parent to "explain
            English to me first" or whatever your mother tongue it was.
<purelazy> I think that is the point here
<jusss``> yes, you all are right                                        [15:07]
<jle`> it's like wondering how you can write a song without memorizing all the
       cadences, modes, extensions, etc. of music theory
<purelazy> If you can read and print using do, that is enough for the first
           year
<jle`> "you wrote a song? psh. did you even know about the locrian mode."
<purelazy> And you can concentrate on more important things             [15:08]
<jle`> knowing the 'essense of a monad' is maybe something fun to learn for no
       purpose at all, but using monads day to day requires none of that
<jusss``> jle`: now I meet a typeclass, I ask three questions, laws, functions
          and used for                                                  [15:10]
<jusss``> or about
<jusss``> maybe I should append the kind
<jle`> the thing is that, what a typeclass is 'used for' is often not that
       useful                                                           [15:11]
<jle`> that a *type* is used for -- that's definitely very useful
<jle`> learn what Maybe is used for. what IO is used for
<jusss``> jle`: but that `used for' is we really use it to do
<jle`> right, but when do you actually 'use' a typeclass?
<jle`> usually you're using the types
<jle`> not the 'typeclass' as an abstraction                            [15:12]
*** ht_ (~Thunderbi@2a02:a210:9501:ad80:2943:9ff1:1e07:65bc) has quit: Quit:
    ht_
<jle`> 90% of the time you use >>=, <$>, etc., you're using specific
       types. you're not using Monad the abstraction, Functor the abstraction,
       etc.
<jle`> so it doesn't matter what Monad is used for. it matters what the
       specific type you are using is used for
<jusss``> jle`: yeah, the typeclass's laws and implented functions, and the
          type instances of it, the type is used for, or about ?
<jle`> learning about laws and methods of a typeclass and what they 'mean' in
       the abstract sense is usually not very useful                    [15:13]
<jusss``> jle`: wait a sec, typeclass is not type, typeclass don't have kind?
<jle`> well, it can be in some situations. but it's never going to be the
       first thing you learn.

<jle`> typeclasses have a kind with -XConstraintKinds, they are k ->
       Constraint. but that's not too important here

<nshepperd> the term 'monad action' is kind of 

<jusss``> jle`: so now we have type and typeclass two stuff, and they both
          have kind, and types are instances of typeclass

<jusss``> Semigroup, Monoid, Functor, Applicative, Monad, MonadIO, MonadTrans,
          those seven all are typeclass, and MonadTrans has kind (*->*) ->
          (*->*), the others have kind (*->*), some instances of Monad are
          also instances of MonadIO too, but some aren't                [15:17]
<jle`> instances of MonadTrans ahve kind (*->*) -> (*->*), ec., yeah
<jle`> Semigroup, Monoid instances are *

<jusss``> jle`: what?
<jusss``> jle`: <jle`> Semigroup, Monoid instances are *
<jusss``> * is a type now?                                              [15:19]
<jusss``> or it means any type
<jle`> it means things of kind *                                        [15:20]
<jle`> like Int, Bool, String, Double
<jle`> but not Maybe, IO, Either, MaybeT
<jle`> :k Int
<lambdabot> *
<jusss``> :k (Int -> Int)
<lambdabot> *
<jusss``> jle`: so (Int -> Int) is an instance of Semigroup and Monoid?
<jle`> it could be if someone wrote an instance for it
<jle`> but in base, nobody has written an instance
<jle`> just like how there is no Show instance for it either
<jusss``> jle`: except those seven typeclass, is there any other special
          typeclass?                                                    [15:22]
<jle`> jusss``: none of those typeclasses are special
<jusss``> jle`: those seven may have connections
          
##############################################

we should use `return' to create a IO a type, not liftIO
like you do that in other OOP IO.return(whatever)

f = return (Just 3) :: IO (Maybe Int)

:t runMaybeT (liftIO (print True) :: MaybeT IO ())
runMaybeT (liftIO (print True) :: MaybeT IO ()) :: IO (Maybe ())

fmap (\() -> "3") (print 3)
3
"3"


#########################################

#four ways to express some same things

#1 (+1) ((+2) 3)
#2 (+1) $ (+2) 3
#3 ((+1) . (+2)) 3
#4 (+1) . (+2) $ 3

######################################

Data P = P a, is not ok, a is not defined in the scope
Data P a = P a , is ok, a is defined in the type side
Data P = P Int, is ok, Int is defined

static@(Static settings) <- static "static"
the whole result `static "static"' bind to static
then the result `Static x' match `Static settings'
bind x to settings, two bindings

/static StaticR Static getStatic
data Static = Static { getStatic :: value }

##################################################

Shakespearean templates
Hamlet for HTML
Julius for Javascript
Cassius and Lucius for CSS

As-patterns
bind a name to the whole value
let x@(y,z) = ("Hello", True) in (x,y,z)
bind the whole value ("Hello", True) to x
and (y,z) to match ("Hello", True)
so (x,y,z) is (("Hello", True), "Hello", True)

example xs@(y:ys) = (xs, y, ys)
exmaple [1,2,3] =
bind [1,2,3] to xs, and (y:ys) to match [1,2,3]
so
(xs,y,ys) is ([1,2,3], 1, [2,3])

everything@(h:t) = "Hello"
everything is "Hello", and (h:t) is "Hello"
so (everything, h, t) is ("Hello", "H", "ello")

everything@(Just x) = Just True
everything is Just True, Just x is Just True
so (everything, x) is (Just True, True)

do
static@(Static settings) <- static "static"
it means bind `static "static"' to static,
and `static "static"' has the value form `Static x',
bind x to settings, this is two bindings

data P = P a is not fine, a should show in the left befor,
like data P a = P a,
but data P = P Int is fine, 'cause Int is defined

in yesod
static :: FilePath -> IO Static
Static :: WaiAppStatic.Types.StaticSettings -> Static

data Static = Static WaiAppStatic.Types.StaticSettings


###########################################

#kleisli composition #monad transformer

>=> can't use to exchange the context,
 >=> is really not that special. It doesn't do anything that you cannot do with >>=.
 it's just a bit of convenience in certain situations.
 (f >=> g) x = f x >>= g
 That's the entire source code for it.
 loadUser :: Name -> IO User, loadProfile :: User -> IO Profile, you can do "loadUser >=> loadProfile :: Name -> IO Profile"
 compose
 But you could also do "\name -> do {user <- loadUser name; loadProfile user}"
 In general there is no concept for switching monads included in the typeclass. Every monad needs its own functions for "switching". Often you have something like "runPure :: m a -> a" or "runInIO :: m a -> IO a"

-- rememeber that, Functor need to implement fmap, Applicative need to implement
 fmap, apply, pure, Monad need to implement fmap, apply, return, bind, join
 -- typeclass is the class of type, every type instance need to implement that functions so
 that become the instance of typeclass, type has function
 -- semigroup need mappend, monoid need mempty and mappend
 -- mempty is the unit in monoid, return is the unit in monad, pure is the unit in applicative

-- join is m (m a) -> m a, not m a -> a,
so we have to  implement  m a -> a, For a particular m, you might be able to
But in general, a function of type m a -> a isn't going to be possible
yeah, like Maybe a->a, if Maybe a is Nothing
 but if we concret a then it's possible, Maybe String -> String
03:33:07 <jusss> then we can return a string if it's Nothing
03:33:45 <jusss> but that's not a good idea, not generics
03:34:58 <jusss> I saw that maybe and fromJust in Data.Maybe
03:35:22 <__monty__> It's not possible with IO a for example.
03:37:32 <jusss> :t either
03:37:33 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
03:39:00 <jusss> what about f :: (Maybe a-> b) -> (Maybe a -> b) -> b?
03:40:31 <Cale> Doesn't seem too plausible
03:40:51 <Cale> :t maybe
03:40:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:41:08 <Cale> If you're looking to something analogous to either
03:46:44 <Cale> Well, you could give Nothing to either one of those functions and get something of type b
03:46:59 <Cale> But that doesn't seem especially useful
03:47:53 <jusss> yeah, that's what I mean
03:49:14 <jusss> but it seems maybe already has that
03:49:22 <jusss> :t maybe
03:49:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
###########################################################

#ADT #data type #sum type #product type
#scotty #yesod #servant #wai #warp
<jusss> what's the different between scotty , yesod, servent?           [16:51]
<dminuoso> jusss: yesod is an opinionated feature-rich web framework with all
           batteries included. HTML templating, JavaScript, build pipeline,
           database models, everything. :)                              [16:53]
<dminuoso> jusss: servant is a family of libraries designed around type-driven
           HTTP APIs which is really great if you want to write both a server
           and some clients sharing the same API. Scotty is just a miniature
           web framework for simple web tasks.                          [16:54]
<maerwald> scotty is simple, servant is elegant, yesod is complex       [16:55]
<dminuoso> The differences are not in complexity, they are rather in the
           problem domain.
<maerwald> Of course there are differences in complexity. Some of those
           *might* be related to the problem domain, some might not     [16:57]
<jusss> dminuoso: and wai, warp?                                        [16:58]
<maerwald> Also note that most of complexity in software is not essential, but
           accidential complexity
<dminuoso> jusss: wai is a standard/specification how a web application should
           be exposed, such that you can separate the http server from the
           application running on it.                                   [16:59]
<dminuoso> jusss: warp is a http server capable of running wai applications.
<jusss> dminuoso: what's the diffrent between the term "type" and "data type"
        ?
<dminuoso> jusss: It probably depends on the context.
<dminuoso> jusss: "data type" is an expression I would try and avoid.
<jusss> dminuoso: I still have no idea about ADT and what it's used for
<dminuoso> jusss: An ADT is just the simple idea that you can create data
           types with a) multiple constructors and/or b) multiple fields in a
           given constructor. Nothing more.
<dminuoso> THat's it. :)
<dminuoso> jusss: Having "multiple constructors" is sometimes called "a sum
           type" and having "multiple fields in a constructor" is sometimes
           called a "product type". There's really nothing more to it. :)
                                                                        [17:16]
<merijn> Well, there's a lot more to it, but all that is mostly unnecessary
         for programming :p                                             [17:17]
<jusss> ok                                                              [17:18]
<dminuoso> jusss: In school you most likely learned elementary algebra in
           which you can add numbers... multiply numbers... so in the same
           sense the name "algebraic data types" is just derived from the fact
           that you can "add and multiply types together"               [17:19]
<dminuoso> jusss: (In truth there's more to it like merijn' hinted at, but
           this is sufficient for Haskell)                              [17:21]

<jusss> dminuoso: "add and multiply types together" is related to type family?
<dminuoso> jusss: No.
<dminuoso> jusss: `data F = F Bool Int` can be thought of as "F is Bool * Int"
           (multiple fields is called multiplication"
<dminuoso> jusss: Or `data G = R Int | L Bool` can be thought of as "G is Int
           + Bool"                                                      [17:22]
<jusss> dminuoso: and we can ignore those type consturctors?
<dminuoso> jusss: It's just a choice of words, really.
<jusss> dminuoso: ok                                                    [17:23]
<dminuoso> `data F = F Bool Int` is considered to be a product type. A product
           is what you get when you multiply things - and the things
           multiplied here are `Bool` and `Int`.
<dminuoso> Like I said
<dminuoso> 10:14:53        dminuoso | jusss: An ADT is just the simple idea
           that you can create data types with a) multiple constructors and/or
           b) multiple fields in a given constructor. Nothing more.
<dminuoso> If you have multiple constructors, you are "summing these things"
           and if you have multiple fields you are "multiplying these things"
<jusss> ok                                                              [17:24]
<ChaiTRex> jusss: If you look at it with Bool, product types multiply the
           number of possible values of each to get the number of values your
           type can hold. A Bool Bool Bool Bool can hold 2*2*2*2 different
           values. Similarly, sum types sum the number of values: A Bool | B
           Bool has 2+2 different values.
<dminuoso> `data F = G Int Char | H Bool` can be considered `(Int * Char) +
           Bool`
<phadej> anding and orring is more understandable then multiplying and adding
<jusss> dminuoso: what is this used for ?                               [17:25]
<jusss> type sum or multipy
<merijn> jusss: When you're just starting, nothing really
<jusss> on the value level?
<dminuoso> jusss: It's just a different name for what you know.
<merijn> jusss: It's like preschooler being able to do arithmetic without
         understanding groups and monoids
<dminuoso> jusss: You call it "this data type has two data constructors". I
           call it "its a sum type". You say "this data constructor has two
           fields". I say "its a product type"                          [17:26]
<dminuoso> Just different names for the same idea.
<merijn> jusss: The fact that basic arithmetic forms groups and monoids is
         interesting and you can invent some pretty cool things using that
         knowledge, but when all you wanna do is arithmetic the underlying
         theory is rather redundant
<dminuoso> jusss: So when someone says "oh this is a sum type" it just means
           "the type has two or more data constructors". Or when someone says
           "this is a product type" it just means "it has multiple fields"
<jusss> the type world is still misterioso to me, type inference, dependent
        type, polymorphic type, type in type, infinite type, recursive type,
        type application, type function, type family, type class, kind, sort,
        what else? :)                                                   [17:28]
<jusss> and that type system
<merijn> jusss: Dependent types are not really relevant when learning Haskell,
         they might become interesting once you're already comfortable with
         Haskell                                                        [17:29]
<jusss> I heard that scala has a different type system to haskell
<merijn> type families and type functions are the same thing and again, only
         really interesting when you're already comfortable with Haskell
<jusss> merijn: I heard rust will have that 
<dminuoso> jusss: Agreed, there's a lot of topics you encounter in Haskell -
           but thats not because Haskell is complicated, but rather because
           there's lots of advanced people doing interesting things with
           Haskell - and that's what you primarily read on blogs or this
           channel.
<dminuoso> jusss: Most of them are irrelevant to becoming a proficient Haskell
           programmer.
<dminuoso> Where's that "haskell pyramid" blog entry?                   [17:30]
<merijn> dminuoso: Just google haskell pyramid :p
<dminuoso> Oh
<dminuoso> jusss: https://patrickmn.com/software/the-haskell-pyramid/
<dminuoso> jusss: So ADT just means "You can have multiple fields and/or
           constructors for a data type". :)                            [17:31]
<jusss> dminuoso: ok, 
<mycroftiv> i think the slippery slope is real, but its a good thing. you
            start out just wanting to sort some strings into an array, and in
            about 5 easy connections you are lost in some arxiv paper looking
            at list sorting as a topological restructuring of some vector
            space                                                       [17:32]
<jusss> can I describe "data type" is a relation between type and value?
<mycroftiv> but hopefully its a fun and exciting discovery and chance to learn
            something new
<dminuoso> jusss: I'd say a data type is a type introduced using the keyword
           data.                                                        [17:33]
<jusss> dminuoso: why people use data to instead of value like value
        constructor, people will say data constructor                   [17:34]

<jusss> but value is a more easier to understand word
<merijn> Is it?
<merijn> Why?
<jusss> type and value, you never say data and type

<jusss> 3 is a value
<jusss> 3 is a value which has Int type                                 [17:36]
<tdammers> 3 is polymorphic, so it may not be the best example          [17:40]
<tdammers> but anyway, I think a better way of phrasing it is that 3 is a
           value that inhabits the Int type
<tdammers> you can think of types as sets of values; so it's not so much that
           the type is an inherent property of the value, but rather, that
           there is a "member-of" relationship between values and types
<f-a> I smile                                                           [17:43]
<f-a> I wonder if I inhabit the "old people" set or I am just old
####################################################################

aptitude install libghc-wai-middleware-static-dev libghc-scotty-dev

#web server

Main.hs
import Web.Scotty
import Network.Wai.Middleware.Static

main = scotty 80 $ do
  middleware $ staticPolicy (noDots >-> addBase "static") -- use ./static/ for files

  get "/" $ do
    -- html "Hello World!"
    -- text "20191101"
    file "./static/signature"  -- then you can change this file to update the page without restart web server

  get "/update" $ do
    file "./static/update"  -- visit yourDomain/update will point to ./static/update
  notFound $ do
    text "there is no such route"

aptitude install python python-requests

#check the signature
import requests
r=requests.get('yourDomain')
r.content

#download the file
import urllib2
updateFile = urllib2.urlopen('http://yourDomain/update')
with open("update", "wb") as handle:
  result = updateFile.read()
  handle.write(result)




########################################

type application in haskell, assert in python, contract in racket

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications #-}
import Data.Maybe
main = do
     l <- return $  (Just 2) >>= (\i -> Just (i+1))
     print l

#############################################

GET method- that would delete pages. When search engines started crawling these sites, they could wipe out all the content.

In many web frameworks, you write one handler function per resource. In Yesod, the default is to have a separate handler function for each request method.

 HTTP spec
 GET    Read-only requests. Assuming no other changes occur on the server, calling a GET request multiple times should result in the same response
 POST    A general mutating request. A POST request should never be submitted twice by the user. 
 PUT    Create a new resource on the server, or replace an existing one. 
 PATCH  Updates the resource partially on the server. When you want to update one or more field of the resource, this method should be preferred.
 DELETE   Just like it sounds: wipe out a resource on the server. Calling multiple times should be OK.

perhaps /person/michael.html, /person/michael.json,
in Yesod, all of these would be accessed from /person/michael.

HTTP Accept header: it gives a prioritized list of content types the client is expecting

 shamlet (a.k.a. simple Hamlet) produces an Html value, 

object generates a JSON value, which implies the mime type application/json. TypedContent is a data type provided by Yesod for some raw content with an attached mime type.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE TypeFamilies      #-}
import           Data.Text (Text)
import           Yesod

data App = App

mkYesod "App" [parseRoutes|
/ HomeR GET
|]

instance Yesod App

getHomeR :: Handler TypedContent
getHomeR = selectRep $ do
    provideRep $ return
        [shamlet|
            <p>Hello, my name is #{name} and I am #{age} years old.
        |]
    provideRep $ return $ object
        [ "name" .= name
        , "age" .= age
        ]
  where
    name = "Michael" :: Text
    age = 28 :: Int

main :: IO ()
main = warp 3000 App

curl http://localhost:3000 --header "accept: application/json"
will get {"name":"Michael","age":28}

curl http://localhost:3000 --header "accept: text/html
will get  <p>Hello, my name is Michael and I am 28 years old.</p>

curl http://localhost:3000
will get <p>Hello, my name is Michael and I am 28 years old.</p>

even you can visit http://localhost:3000/?_accept=application/json via your browser

and the address is http://localhost:3000 witout index.html
'cause there's no index.html in the yesod server

ghc index.hs will generate a binary file index, then run the index binary file will
run the web server

https://www.yesodweb.com/book/restful-content

-- so we can create {"version":20191031, "address":"/path/file"}



    Dispatch based on file name. This is how PHP and ASP work, for example.

    Have a centralized routing function that parses routes based on regular expressions. Django and Rails follow this approach.

Instead of using regular expressions, Yesod matches on pieces of a route.

such as /page/faq FaqR. In this case, the handler function must be named handleFaqR.
/person/#String PersonR GET POST DELETE. In this case, you would need to define three handler functions: getPersonR, postPersonR and deletePersonR.

The most commonly used subsite is the static subsite, which serves static files for your application. In order to serve static files from /static, you would need a resource line like:

/static StaticR Static getStatic

/etc/apt/sources.list
deb https://mirrors.tuna.tsinghua.edu.cn/debian sid main contrib non-free
deb http://mirrors.aliyun.com/debian sid main

aptitude install libghc-yesod-static-dev



############################################

<jle`> liftIO lifts *from* IO, not *to* IO
<jle`> jusss: in any case, you can't really say that the fact that 'liftIO'
       exists means that IOT exists; liftIO is actually backwards from the
       type you would need for IOT to exist                             [11:26]
<dmwit> IOT m a definitely can't be m (IO a), or else we would have e.g. \x f
        -> Just x >>= f :: IO a -> (a -> Maybe (IO b)) -> Maybe (IO b). This
        would be bad, because it would mean we could observe whether the
        function returned Just or Nothing without doing any IO.

liftIO will lifts the value of the IO into a monad, then lift the monad into IO,
so IO is still at the bottom of the stack

<Axman6> % :t runExceptT (liftIO (print True) :: ExceptT String IO ())
<yahb> Axman6: IO (Either String ())

import Control.Monad.Trans.Maybe (runMaybeT)
import Control.Monad.IO.Class (liftIO)

:t runMaybeT (liftIO (print True) :: MaybeT IO ())
runMaybeT (liftIO (print True) :: MaybeT IO ()) :: IO (Maybe ())

fmap (\() -> "3") (print 3)
3
"3"

#######################################################
<jusss> % :t fmap (\x -> ()) (pure @IO (Just ()))
<yahb> jusss: IO ()

:set -XTypeApplications
f = const @Int @String
f 3 "3" == 3

there is no IO transformer,
<Axman6> basically IO has to be the bottom of your stack
-- which means IO only can be the outsider, it can't be m (IO a), only be IO (m a)

IO is a type? IO a is a type?

IO is a type constructor, IO is a type function.

<jusss> dmwit: then why not IOT?                                        [10:05]
<Axman6> jusss: you're not supposed to (and don't need to) know how IO is
         defined. you are given hundreds of functions which work in IO, and
         know that it is a Functor, Applicative and Monad, which lets you
         combine these functions together into programs
<jusss> Axman6: ok, what about that IO lift function ? 
<dmwit> jusss: The question is a bit strange, I think. First you have to say
        what IOT would be if it existed. And "IOT is a transformer version of
        IO" isn't enough. You have to say what behavior it would have, what
        its (>>=) would do. Then I can answer why not that.
<jusss> I heard there's a function has to do with IO about other monads, I
        forget that function name                                       [10:09]
<jusss> liftIO
<dmwit> You heard correctly. There is, indeed, a function named liftIO.
                                                                        [10:10]
<Axman6> :t liftIO
<lambdabot> MonadIO m => IO a -> m a
<Axman6> liftIO lets you take something in the IO monad and embed it into
         another monad - one which will eventually (probably) be unwrapped
         into IO in your main function                                  [10:11]
<Axman6> % liftIO (print True) :: EitherT String IO Bool
<yahb> Axman6: ; <interactive>:44:24: error:; Not in scope: type constructor
       or class `EitherT'; Perhaps you meant `Either' (imported from Prelude)
<jusss> how I can lift the value from IO to Maybe?
<dmwit> You cannot.
<Axman6> % runExceptT (liftIO (print True) :: ExceptT String IO Bool)   [10:12]
<yahb> Axman6: ; <interactive>:45:13: error:; * Couldn't match type `()' with
       `Bool'; Expected type: ExceptT String IO Bool; Actual type: ExceptT
       String IO (); * In the first argument of `runExceptT', namely `(liftIO
       (print True) :: ExceptT String IO Bool)'; In the expression: runExceptT
       (liftIO (print True) :: ExceptT String IO Bool); In an equation for
       `it': it = runExceptT (liftIO (
<Axman6> % runExceptT (liftIO (print True) :: ExceptT String IO ())
<yahb> Axman6: True; Right ()
<Axman6> % :t runExceptT (liftIO (print True) :: ExceptT String IO ())
<yahb> Axman6: IO (Either String ())
<jusss> Axman6: I see, liftIO can lift the value into another monad, but the
        another monad still in IO ?                                     [10:13]
<jusss> lift other monad into the IO monad                              [10:14]
<dmwit> All the instances of MonadIO I know of are transformer stacks with IO
        at the bottom of the stack.
<nshepperd> the existence of a monad transformer is something which deserves
            more justification than its nonexistence

<jusss> dmwit: can I lift Mayber Monad's value into an Either Monad?
<dmwit> Sometimes.
<jusss> dmwit: example?                                                 [10:16]
<dmwit> Well. Let's be very careful.
<dmwit> Either is not a Monad.
<jusss> Either a
<dmwit> It has the wrong kind.
<dmwit> Yes. So now my answer is: sometimes.
<jusss> dmwit: Reader
<dmwit> Specifically: when a is inhabited.
<jusss> dmwit: I just want to know if it's not IO,  can we lift the value of a
        monad from the monad to another monad?
<dmwit> If `x :: a`, then `maybe (Left x) Right` lifts a `Maybe b` into
        `Either a b`.                                                   [10:17]
<dmwit> Sometimes.
<dmwit> :t \x -> maybe (Left x) Right                                   [10:18]

<lambdabot> a -> Maybe b -> Either a b

<jusss> :t maybe
<nshepperd> there's nothing special to Monads that enables lifting
<lambdabot> b -> (a -> b) -> Maybe a -> b

<dmwit> (Indeed, given that the answer to the more specific question of "can I
        lift Maybe to Either a" is "sometimes", the answer to "can I lift a
        value from one monad into another" *has to be* "sometimes". No other
        answer can be correct.)                                         [10:19]
<shachaf> It could also be "never, since the word lift is meaningless".
<nshepperd> generally, 'lifting' is just turning type a into type b. the
            answer to whether you can do that is 'it depends on a and b'
* dmwit slaps shachaf over the head with a copy of the Gricean axioms
<nshepperd> the MonadTrans typeclass provides one concept of 'lifting' that
            works for some types                                        [10:21]
<maerwald> would have been too easy to call it MonadLift                [10:24]
<dmwit> I don't think it's unreasonable for the class name and the method name
        to differ.
<dmwit> The class name describes the type. The method name describes the
        action.                                                         [10:25]
<maerwald> MonadBaseControl is even worse... it sounds like a joke, not a
           typeclass
<maerwald> can never get used to it :P
<maerwald> it all started with autobots...
<maerwald> and now we have funny names everywhere
<nshepperd> even haskell programmers need a base of control sometimes   [10:26]
<mniip> monadbasecontrol
<wejetheman> dmwit are you one of the guys who was explaining about the
             efficiency of my toBinary function the other night?
<mniip> ah er that was the joke
<EvanR> or was it the performance lads                                  [10:27]
<wejetheman> Im asking if he was one of said lads.                      [10:28]

<maerwald>
           https://hackage.haskell.org/package/wizard-0.1.1/docs/Wizard.html#v:leviosa
                                                                        [10:30]
<maerwald> better name than lift
<dmwit> wejetheman: I believe no. But I suspect I could answer a question if
        you had one.                                                    [10:31]

<koz_> 'The performance lads' LOL                                       [10:35]
<wejetheman> the meme would be better if i could remember who they were 
<dmwit> the slow is bad lads                                            [10:36]
<dsal> Base control to monad Tom

<jusss> Axman6: how i can create a value has IO (Maybe ()) ?
<Axman6> :t pure (Just ())
<dsal> > pure (Just ()) :: IO (Maybe ())
<jusss> % :t fmap (\x -> ()) (pure @IO (Just ()))
<yahb> jusss: IO ()
<Axman6> jusss: that's just one of an infinite number of ways to make a value
         of type IO (Maybe ()) though
<Axman6> :t readLn
<lambdabot> Read a => IO a
<Axman6> readLn will ask for a line from stdin and try to parse it as the type
         a which you've specified
<jusss> Axman6: 'cause there's IOT, so Maybe (IO ()) doesn't exist?     [11:43]

<Axman6> well, Maybe (IO ()) exists, it's just not really useful in the same
         way that other monad transformers are                          [11:44]
<jusss> ...

<Axman6> @unmtl ReaderT Config (ExceptT Error IO) ()
<lambdabot> Config -> ExceptT Error IO ()
<Axman6> @unmtl ReaderT Config (ErrorT Error IO) ()
<lambdabot> Config -> IO (Either Error ())
<Axman6> that's the type that  ReaderT Config (ErrorT Error IO) () is under
         the hood - it's functions which accept Config and execute some IO
         whose result might fail                                        [11:45]
<jle`> jusss: fmap (\_ -> ()) is pretty common, it's given a name, 'void'
                                                                        [11:47]
<jle`> :t void
<lambdabot> Functor f => f a -> f ()
<jle`> void = fmap (const ())                                           [11:48]
<jusss> Axman6: IO is a monad, IO a is a type, IO is a type?
<dmwit> > let f c '1' = reverse c; f c _ = c in map ('1':) . concat . iterate
        (("01">>=) . liftA2 (<$>) (:) . f) $ [""]
<lambdabot>
            ["1","10","11","100","101","111","110","1000","1001","1011","1010","1110","1...
<jle`> jusss: under the typical reckoning, yes
<Axman6> IO is a type constructor - it has kind * -> *; it needs another type
         to produce a type                                              [11:50]
<jusss> Axman6: so IO is not a type
<Axman6> just like Just isn't a value of type Maybe a, it'sd a function when
         when given an a returns something of tyoe May e a              [11:51]
<Axman6> Maybe a*
<jusss> jle`: the whole IO stuff is really weird to me
<Axman6> no
<jle`> but, Just is a value
<jusss> wait, jle` Just is a value?
<Axman6> yes, the analigy isn't very good
<jle`> yes, it is a value of type a -> Maybe a
<Axman6> analogy*
<jusss> Just is value constructor
<jusss> Just is a function
<jle`> Just, the "J-u-s-t" token thing you type into a text file, is the type
       constructor                                                      [11:52]
<Axman6> IO is a type construction
<jle`> it *denotes* a value
<Axman6> constructor*
<dmwit> IO is a type.
<dmwit> It is also a type constructor.
<dmwit> It is also a type of arrow kind, which is probably what Axman6 means
        when he says type constructor.
<jusss> aha, argue began
<jle`> typically you'd say IO is a type too.  It is a type that is denoted by
       the "I-O" symbols you type into a text editor
<dmwit> Not an important argument. Just a terminology argument.
<Axman6> we're not really arguing at all, I'm just not being as clear as I
         should be                                                      [11:53]

<dmwit> Just is a data constructor, not a type constructor. (Without
        extensions, this is true.)
<jle`> a lot of it is just the distinction between the letters you type into
       the text editor, vs. the things that they represent              [11:54]
<dmwit> Type constructors are the types that are not applications and not
        variables.
<dmwit> Maybe, IO, Int, Either, Bool are type constructors.
<dmwit> Either Int is not a type constructor, because it is an application; x
        is not a type constructor because it is a variable.             [11:55]
<Axman6> People oftern make a distinction between "values" and "functions" -
         in Haskell functions are also values, but only functions can be
         applied to other values. f with type a -> b is a value, but f a is
         also a value. In the same way, type constructors are also types, but
         only type constructors can be applied t other types - IO has _kind_ *
         -> *, which means it can be applied to something of kind * to produce
         something of kind *                                            [11:56]
<jusss> IO is a type function?                                          [11:57]
<dmwit> (Axman6 and I are using different definitions of the phrase "type
        constructor".)
* Axman6 should probably leave tthis to others who're better at explaining
  this

<dmwit> (For Axman6, "type constructor" means "type with arrow kind". For me
        it means what I said above.)

                                                                        [11:58]
<jle`> "types" are just the things you can play with at the type level to
       construct the things denoting what you want to mean
<jle`> so you can use IO, you can use Int, you can put them together to get IO
       Int, etc.
<jle`> each is useful in different situations
<jle`> they all have different roles, every type is useful
<jle`> otherwise we wouldn't care enough to talk about them :)

<jle`> IO is useful for some situations, Int is useful for some other
       situations, IO Int is useful for still even other situations
<dmwit> I think "IO is a type function" is basically right.
<jusss> dmwit: and IO is a type?
<jle`> indeed i don't think there is anything wrong with it
<dmwit> I like "IO is a type".                                          [12:00]
<jusss> is ther a 'but'?
<jusss> jle`: IO is a type?
<dmwit> Yes; some people use "type" to mean something different than me.
<jle`> yeah, it's a type. just not a "capital-T" Type                   [12:01]
<jusss> can we say Maybe is a type? Maybe is a type function, which kind is *
        -> *
<jusss> Maybe Int is a type
<dmwit> I like all of those sentences.
<jle`> yeah. Just is a value. Just is a value function, which has type a ->
       Maybe a
<jle`> `Just True` is a value                                           [12:02]
<jusss> :t print Just
<lambdabot> error:
<lambdabot>      No instance for (Typeable a0) arising from a use of print
<lambdabot>      In the expression: print Just

<jusss> % :t print Just

<yahb> jusss: ; <interactive>:1:1: error:; * No instance for (Show (a0 ->
       Maybe a0)) arising from a use of `print'; (maybe you haven't applied a
       function to enough arguments?); * In the expression: print Just

<jle`> not all values have a Show instance                              [12:03]
<jusss> % :t print (Just 3)
<yahb> jusss: IO ()

<Axman6> % print (Just True)                                            [12:05]
<yahb> Axman6: Just True

<koz_> Why did GHC decide on Type :: Type versus the 'Type tower' that Idris
       and Agda have?
<dsal> koz_: tower?

<Axman6> (what yahbis showing is what is printed to stdout, which the result
         of applying show to Just True and then writing that string to stdout)
<c_wraith> koz_: because it's simpler to implement with the semantics GHC
           already has
<koz_> dsal: In Idris, Type :: Type1, Type1 :: Type2, and so on.        [12:07]
<koz_> (I may not be getting the names right)
<dsal> I don't know idris.  I have a passing familiarity  with agda.
<koz_> dsal: I believe Agda also does this, with possibly different names.

<mycroftiv> i think its convienience vs consistency, haskell isnt committed to
            being logically consistent in the way a proof oriented language
            like agda is                                                [12:09]
<EvanR> a cumulative (or not) hierarchy of type universes
<koz_> Also, is it incorrect to understand Type1 as being 'Kind'?

<EvanR> what's Kind
<koz_> All kinds?
<EvanR> heh
<EvanR> BOX ?                                                           [12:10]
<koz_> EvanR: Wut.
<EvanR> the type of kinds

<koz_> Good to know. So is BOX the same as Type1, then, or is my understanding
       off?                                                             [12:11]

<EvanR> i don't understand the problems that Type :: Type potentially poses
<koz_> EvanR: It's inconsistent, but apparently this isn't an issue for GHC. I
       am unsure of why.                                                [12:14]
<mycroftiv> the barber paradox                                          [12:15]
<koz_> mycroftiv: Or, as I prefer to call it, Russel's Paradox.
<koz_> s/Russel/Russell/
<heatsink> It isn't an issue for GHC because GHC evaluates coercions strictly.
<jle`> koz_: values, types, kinds, sorts
<koz_> heatsink: Could you elaborate on that? Specifically, how evaluating
       coercions strictly helps dodge Russell's Paradox?                [12:16]
<mycroftiv> in another way it 'isnt an issue' because most languages
            deliberately allow you to express broken constructions. whether or
            not the ease of expression is worth losing safety is a big can of
            worms
<koz_> jle`: Are those all Type1?

<jle`> that's the 'hierarchy'
<heatsink> Paradoxes are effectively nonterminating loops that promise to
           provide evidence that x ~ y, but never deliver a result

<jle`> values have types, types have kinds, kinds have sorts
<jle`> above that i don't know if there are specific names
<koz_> jle`: Ah, I see.
<koz_> I think I saw a few people mention them, but the names got too
       ridiculous to remember. :P
<heatsink> So, a paradox will loop forever and not actually let you do
           something unsafe                                             [12:18]
<jle`> kind of like the displacement, velocity, acceleration, jerk ... then
       according to some, snap, crackle, pop...and above that no other names
       really
                                                                        [12:19]
<jle`> even though the tenth derivative of displacement exists as a concept,
       nobody has bothered to give it a name

<EvanR> koz_: the paradox is Girard's paradox and I haven't been able to grok
        it nearly as easily as Russell's                                [12:20]

* hackage emd 0.2.0.0 - Empirical Mode Decomposition and Hilbert-Huang
  Transform  https://hackage.haskell.org/package/emd-0.2.0.0 (jle)

<EvanR> or how to avoid it, i.e. what needs to be in what universe      [12:22]
<slack1256> EvanR: I used to think that restrict "inter-level comunication"
            was enough, so values can depend on other values and types on
            other types. The I discovered dependent typing and became confused
            again.                                                      [12:31]
<EvanR> in which family of types indexed by values is totally the point
                                                                        [12:32]
<slack1256> Yep                                                         [12:33]
<EvanR> the details get nontrivial fast ime                             [12:34]
                                                                        [12:47]
<koz_> Agreed.
<koz_> That be where the devil lives, yo.                               [12:48]
#########################################
import Data.Maybe

maybe defaultValue func x =
      case x of
           Nothing -> defaultValue
           Just a -> func a

fromJust (Just x) = x

import Control.Exception (throw)
https://wiki.haskell.org/Handling_errors_in_Haskell

##############################################

pip change sources
on linux  ~/.pip/pip.conf
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple

on windows, visit  %APPDATA% via file explorer
create pip/pip.ini
[global]
timeout = 6000
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
trusted-host = pypi.tuna.tsinghua.edu.cn

######################################

debootstrap --arch amd64 --foreign sid  ./sid/ http://mirrors.aliyun.com/debian
cd ./sid
chroot . /bin/bash
/debootstrap/debootstrap --second-stage
export PATH=$PATH:/bin:/usr/bin

exit the chroot env, then
cp mount.chroot.share.X.sh ./sid
cd sid; ./mount.chroot.share.X.sh
source source.me

amd64 is for 64 bit, i386 is for 32 bit

########################################

debootstrap --arch amd64 --foreign sid  ./sid/ http://mirrors.aliyun.com/debian
cd ./sid
chroot . /bin/bash
/debootstrap/debootstrap --second-stage
export PATH=$PATH:/bin:/usr/bin

exit the chroot env, then
cp mount.chroot.share.X.sh ./sid
cd sid; ./mount.chroot.share.X.sh
source source.me

amd64 is for 64 bit, i386 is for 32 bit

mount.chroot.share.X.sh
sudo mount -t proc proc ./proc
sudo mount -t sysfs sysfs ./sys
sudo mount --make-rslave  ./sys
sudo mount -t devtmpfs devtmpfs ./dev
sudo mount --make-rslave  ./dev
sudo mount -t tmpfs tmpfs ./dev/shm
sudo mount -t devpts devpts ./dev/pts
xauth extract - $DISPLAY | sudo tee ./root/.Xauthority
sudo mount -t tmpfs tmpfs ./tmp
sudo mount --make-rslave ./tmp
sudo chroot . /bin/bash

source.me
#!/bin/bash
export PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/home/john/.cabal/bin

##################################################

in ghci :set -XTypeApplications

Prelude> print @Int 3
3

We use type annotations to avoid ambiguity. Type applications can be used for the same purpose. For example

x :: Num a => a
x = 5

main :: IO ()
main = print x

This code has an ambiguity error. We know that a has a Num instance, and in order to print it we know it needs a Show instance. This could work if a was, for example, an Int, so to fix the error we can add a type annotation

main = print (x :: Int)

Another solution using type applications would look like this

main = print @Int x

To understand what this means we need to look at the type signature of print.

print :: Show a => a -> IO ()

The function takes one parameter of type a, but another way to look at it is that it actually takes two parameters. The first one is a type parameter, the second one is a value whose type is the first parameter.

The main difference between value parameters and the type parameters is that the latter ones are implicitly provided to functions when we call them. Who provides them? The type inference algorithm! What TypeApplications let us do is give those type parameters explicitly. This is especially useful when the type inference can't determine the correct type.

So to break down the above example

print :: Show a => a -> IO ()
print @Int :: Int -> IO ()
print @Int x :: IO ()

https://riptutorial.com/haskell/example/32285/avoiding-type-annotations
#####################################

#dependent type #polymorphic types  #type family #type application #type inference

<jusss> what is `dependent type' ?                                      [13:35]
<Axman6> a type which is determined by values at the value level.       [13:36]
related to type inference?
<koz_> It's related to type inference by being impossible for it. :P    [13:55]
<dminuoso> jusss: Polymorphic types are (value-levels) terms that can bind a
           type, dependent types are types that can bind a (value-level)
           term. :)                                                     [13:56]

<dminuoso> jusss: For example "Vec 10 Int" is the *type* of a vector
           containing 10 integers. :)
<jusss> dminuoso: ... but 10 is a value, and 10::Int, Int is a type not a
        value,                                                          [14:04]
<dminuoso> jusss: Yup!
<dminuoso> jusss: And dependent types is about mixing these levels
           intentoinally this way.
<jusss> dminuoso: so "Vec 10 Int" is a type or a value?
<MarcelineVQ> That's why it's called dependent type, a type depending on a
              value.
<dminuoso> jusss: Its a type!
<jusss> dminuoso: oh, I see
<jusss> MarcelineVQ: it should call dependent-on-value type             [14:05]
<dminuoso> jusss: People are lazy and like short terms. :)
<dminuoso> jusss: Which is why fancy mathy people call them Pi types.   [14:06]
<dminuoso> jusss: Do note, that in Haskell we mix type and value too.
<MarcelineVQ>  types if you're too fancy
<dminuoso> jusss: But for us its the other way around. In dependent types you
           can apply types to values, in GHC we can apply values to types.
<dminuoso> % :t id
<dminuoso> % :t id @Int
<yahb> dminuoso: a -> a
<yahb> dminuoso: Int -> Int
<dminuoso> This is called "polymorphic types"
<Axman6> %\Pi types% if you've extra fancy
<ammar2> now that's a pie I can get behind
<MarcelineVQ> dminuoso: did you accidently flip that?  @ is called a Type
              Application after all
<dminuoso> MarcelineVQ: Flip what exactly?
<MarcelineVQ> "In dependent types you can apply types to values, in GHC we can
              apply values to types."
<dminuoso> MarcelineVQ: The term "type applications" is mixed up.
<dminuoso> MarcelineVQ: Functions are applied to arguments.
<dminuoso> (Oh that pun in "the term ..." was not intentional)          [14:09]
<MarcelineVQ> When writing  @Int  you're calling Int a value?
<dminuoso> MarcelineVQ: Another way to put it "polymorphic types are terms
           binding types and dependent types are types binding terms"
<jusss> dminuoso: this @ symbol, I saw it once, and someone send me a link
        about it, I foreget it... it's a article about something 's created in
        2015           
<dminuoso> No? It's a type.
<MarcelineVQ> I don't understand what "in GHC we can apply values to types"
              means then followed by your id example                    [14:13]
<Axman6> id @Int is applying id ('s type) to @Int
<ammar2> jusss: it's called visible type application, basically when we have
         `id: a -> a` it really means that `id: for any type a, a -> a`, when
         we do `id @Int`, we fill that "any type" with `Int` explicitly to
         make `Int -> Int`                                              [14:14]
<Axman6> if :: forall a. a -> a is basically a fancy type level lambda: \\a
         --> (a -> a)
<dminuoso> jusss: In a perfect world we could imagine it wasn't there.
<dminuoso> jusss: So try and squint a bit and ignore the @ symbol. :)
<dminuoso> MarcelineVQ: `f 1` is f applied to 1. `f @Int` is f applied to Int.
<dminuoso> MarcelineVQ: Just like in the sense of System F....
<Axman6> (making up syntax for what type level lambdas could look like
<dminuoso> 07:15:01          Axman6 | if :: forall a. a -> a is basically a
           fancy type level lambda: \\a --> (a -> a)
<dminuoso> No!
<dminuoso> That's just false.
* Axman6 ducks
<dminuoso> Axman6: type families are type level lambda                  [14:16]
<dminuoso> Or non-nullary type constructors
<dminuoso> Consider:
<dminuoso>  /\t.\x^t. x : r. r
<jle`>  > type families are a type level lambda                         [14:17]
<dminuoso> The lambda abstraction you are thinking of really exists on the
           value world.
<jle`> [doubt]
<dminuoso> jle`: In what sense
<jle`> aren't lambdas anonymous?
<jle`> but all type families must have names
<dminuoso> jle`: Heh.
<Axman6> type families are type level functions, sure
<dminuoso> It's a fair point.
<dminuoso> Axman6: But really the point is, the binding happens in the *value*
           world.
<jle`> anonymity is the defining characteristic of lambda-ness
<MarcelineVQ> "<dminuoso> MarcelineVQ: `f 1` is f applied to 1. `f @Int` is f
              applied to Int." should probably be a line in the manual
<Axman6> you could argue that f 1 is f applied implicitly to Int and applied
         to the value 1                                                 [14:19]
<dminuoso> MarcelineVQ: The really weird thing is how ScopedTypeVariables
           visually binds from a type signature, as opposed to something like:
           f :: x. x -> x; f @t = id @t
<dminuoso> MarcelineVQ: ^- this would be more honest to how we have system fc
           in core.
           
####################

#fmap #foldl #filter

map, reduce and filter
fmap, foldl  and filter

map (+1) [1..5] == [2, 3, 4, 5, 6]

foldl (+) 10 [1..5] == 25

filter (>5) [1..10] == [6, 7, 8, 9, 10]

http://www.cse.unsw.edu.au/~en1000/haskell/hof.html
############################

#global variable #haskell

there's no global variable in haskell, all the variable is immutable in haskell,
so add a parameter and change the parameter in the recursive function to do that!
if several functions need to visit that parameter, then put them into one function
or connect them or chain them
that's why we have Reader, Writer and State monad
#################################

{-# LANGUAGE OverloadedStrings #-}
so you can make "String" has ByteString, String and Text type
#############################################################

module SplitList where
-- main = print $ splitList [1,2,3,2,4,5] [4,5] 
-- [1,2,3,2,4,5] [3,4] == []
-- [1,2,3,2,4,5] [1,2] == [[],[3,2,4,5]]
-- [1,2,3,2,4,5] [4,5] == [[1,2,3,2],[]]
-- also there's a split package on hackage, Data.List.Split.splitOn to do the same thing
splitList listA listB = f listA listB [] 0
      where
           lengthB = lengthList listB
           copyB = listB
           
           f (x:listA) [] before counter =
                     if (counter == lengthB) then (reverse $ removeN before lengthB):(x:listA):[]
                     else f listA copyB (x:before) 0

           f [] listB before counter =
                   if (null listB) && (counter == lengthB) then (reverse $removeN before lengthB):[]:[]
                   else []
                   
           f (x:listA) (y:listB) before counter =
                         if (x == y) then f listA listB (x:before) (counter+1)
                         else f listA copyB (x:before) 0
                     
removeN :: [a] -> Int -> [a]
removeN = \alist n ->
        if (n == 0) then
           alist
           else
           removeN (tail alist) (n - 1)

lengthList :: [a] -> Int
lengthList alist = f alist 0
           where
                f [] n = n
                f (x:xs) n = f xs (n+1)


  

##############################################################

module SplitAlistWithAlist where

-- (cons 1 2) == 1: [2]
-- (car '(1)) == head [1]
-- (cdr '(1)) == tail [1]

splitWithList :: (Eq a) => [a] -> [a] -> [a] -> Int -> [[a]]
splitWithList = \alist blist before n ->
              if (null alist) then
                  (if (null blist) then (reverse $ removeN before n): [alist] else [])
                  else if (null blist) then
                       (reverse $ removeN before n): [alist]
                       else if ((head alist) /= (head blist)) then
                            splitWithList (tail alist) blist ((head alist): before) n
                            else
                            splitWithList (tail alist) (tail blist) ((head alist): before) n

removeN :: [a] -> Int -> [a]
removeN = \alist n ->
        if (n == 0) then
           alist
           else
           removeN (tail alist) (n - 1)

splitListWithList alist blist =
                  splitWithList alist blist [] $ lengthList blist

-- lengthN :: (Eq a) => [a] -> Int -> Int
-- lengthN = 
--        \x n -> if (null x) then
--            n
--            else lengthN (tail x) (n+1)
-- 
-- lengthList alist = lengthN alist 0

lengthList :: [a] -> Int
lengthList alist = f alist 0
           where
                f [] n = n
                f (x:xs) n = f xs (n+1)


-- main = 
--       putStrLn $ show $ splitListWithList [1,2,3,4,5] [3]
-- import SplitAlistWithAlist
-- splitListWithList [1,2,3] [2]  will be  [[1],[3]]
-- splitListWithList [1,2,3] [5]  will be  []
-- splitListWithList [1,2,3] [3]  will be  [[1,2],[]]
-- splitListWithList [1,2,3] [1]  will be  [[],[2,3]]


---------------------------------------------------------------------------

let ... in and where

let ... in put the definition before the expression,
where put the definition after the expression.

x where x = y
let x = y in x

" Things in the where clause can refer only to the parameters of
   the function f (there are none) and things in outer scopes." from
    https://stackoverflow.com/questions/4362328/haskell-where-vs-let

x where x = y is wrong
but f x = y where y = x is right
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define split-with-N (lambda (alist a before)
                             (if (eq? alist '()) '()
                                 (if (eq? (car alist) a)
                                 (cons (reverse before) (cons (cdr alist) '()))
                                 (split-with-N (cdr alist) a (cons (car alist) before))))))
;;; (split-with-N (list 1 2 3) 2 '())

;;; http://matt.might.net/articles/cps-conversion/
(define (split-on a xs k)
  (cond ((null? xs) (k '() '()))
        ((eqv? a (car xs))
         (k '() (cdr xs)))
        (else
         (split-on a (cdr xs) (lambda (bs as)
                                (k (cons (car xs) bs) as))))))
;;; (split-on 3 (list 1 2 3 4 5) list)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define split-with-list
  (lambda (alist blist before n)
    (if (eq? alist '()) '()
        (if (eq? blist '()) (cons (reverse (remove-n before n)) (cons alist '()))
            (if (not (eq? (car alist) (car blist)))
                (split-with-list (cdr alist) blist (cons (car alist) before) n)
                (split-with-list (cdr alist) (cdr blist) (cons (car alist) before) n))))))

(define remove-n
  (lambda (alist n)
    (if (eq? n 0)
        alist
        (remove-n (cdr alist) (- n 1)))))

(define (split-list-with-list alist blist) (split-with-list alist blist '() (length blist)))

;;; > (split-list-with-list '(1 2 3 4 5 6) '(3 4))
;;; '((1 2) (5 6))
;;; > (split-list-with-list '(1 2 3 4 5 6) '(5 6))
;;; '()
;;; > (split-list-with-list '(1 2 3 4 5 6) '(4 5))
;;; '((1 2 3) (6))
;;; > (split-list-with-list '(1 2 3 4 5 6) '(9))
;;; '()
;;; > (split-list-with-list '(1 2 3 4 5 6) '(3))
;;; '((1 2) (4 5 6))

###########################################################

1. download plink from https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html
https://the.earth.li/~sgtatham/putty/0.73/w64/plink.exe
2. put plink.exe to your Path
3. (setq tramp-default-method "plink")
4. C-x C-f /plink:root@localhost:/root/path/file
5. about stunnel, plink use port 22, so make sure stunnel listen on localhost:22

############################################################

#cabal #merge #projects #link #install  #combine

they need to share the `dist' directory, 'cause cabal v2-install will write into that directory.
so ircbot should be into haskell-telegram-api directory

ircbot and haskell-telegram-api, two projects,
but rememer , haskell-telegram-api's name is
`telegram-api' , get the name from its .cabal file

cd into haskell-telegram-api, then

git clone that ircbot, then cd into it, get the package name from its .cabal,
cd back to haskell-telegram-api,
cabal v2-install `ircbot'

 vim .cabal, append `ircbot' into build-depends
, cabal v2-build, do care the version to see if the package is from local or hackage,
then cabal v2-repl, you can import both modules from the two projects
in the haskell-telegram-api directory.

otherwise it will pull from hackage

https://stackoverflow.com/questions/18085363/link-cabal-to-local-library

just get `ircbot' into `haskell-telegram-api' directory, then `cabal v2-install ircbot' in `haskell-telegram-api' directory, then write `ircbot' into telegram-api.cabal's build-depends,
`cabal v2-build' will be fine.

#############################################

Network.Socket isn't came with ghc
aptitude install libghc-network-dev

########################################

<jusss> main :: IO()
<jusss> main = do
<jusss>   Just 3 >>= \i -> Just i
<jusss> or we switch that context Maybe to IO ? turn Just 3 to IO 3
<__monty__> Why would bind suddenly get a different type?               [17:49]
<jusss> if we use return in `Just 3 >>= \i -> return i' what this i will bind
        with? IO or Maybe
<__monty__> Well it's a type error. >>= has type IO () -> (a -> IO ()) -> IO
            () in your context.                                         [17:51]
<__monty__> Just 3 doesn't have type IO ().
<jusss> oh
<jusss> but IO (Just 3) >>= \i -> return i ?                            [17:52]
<__monty__> IO's not a constructor.
<jusss> wait, I forget there's no IO transformer
<jusss> but there's IoT
<__monty__> You could do something like: return (Just 3 >>= return). That
            inner >>= and return would use the monad instance for Maybe.
                                                                        [17:54]
<jusss> ok                                                              [17:55]

##########################################################

#import #module #haskell #ghc #qualified

there's `reverse' in Prelude, Data.Text, and Data.List,
if we just want to use Data.Text.reverse

just do `import qualified Data.Text as T', and use T.reverse
if you want to import data Text from Data.Text
then `import Data.Text (Text)' if other module don't have data Text
or all the stuff within data Text
`import Data.Text (Text(..))

#1
`import Data.Text' that would import all the stuff from Data.Text,
but that would still be confilicted with others reverse when you have `import Data.List'
'cause import Data.List will also import reverse,
#2
import Data.Text (reverse)
import Data.List
that's still confilicted

#3
import Data.Text (reverse)
import Data.List hiding (reverse)
ok, this will be confilicted with Prelude,

#4
import qualified Data.Text as T
this will make T as Data.Text, and this won't import all the stuff of Data.Text
so T.reverse equal to Data.Text.reverse
this is ok

#5
import qualified Data.Text (reverse)
import Data.List
still confilict

#6
import Data.Text as T
this still will import all the stuff from Data.Text, that will clash with Prelude
you can use T.pack also pack, but ghc still don't know reverse come from Data.Text or Prelude


<jusss> jle`: I wonder why `import qulified Data.Text (reverse)' won't work,
        ghc steel don't know it's Data.Text.reverse not Prelude or Data.IO
<jusss> Data.List
<int-e> jusss: https://hackage.haskell.org/package/async is an extra package
<jle`> jusss: you'd have to use Data.Text.reverse in that case
<jusss> int-e: ok
<jle`> jusss: import qualified My.Module (blah), would import blah as
       My.Module.blah
<jusss> jle`: yes, that' what I did
<jle`> Prelude also exports 'reverse'                                   [13:36]
<int-e> "won't work" -- what did you expect it to do?
<jusss> jle`: what about `import Data.Text.reverse as reverse'?         [13:37]
<jle`> that's not valid syntax
<jusss> import reverse as Data.Text.reverse , is?
<jle`> what happens when you try? :)                                    [13:38]
<jusss> int-e: expect ghc will take reverse from Data.Text, not others
<int-e> jusss: import Data.Text (reverse)  does make `reverse` available as a
        plain name in principle. But you have to hide the one from Prelude
        somehow. For example, `import Prelude hiding (reverse)` would do the
        trick. I'd not recommend it though!
<jusss> int-e: yeah, and I have to hide that reverse in Data.List       [13:39]
<Axman6> import qualified Data.Text; ... Data.Text.reverse should work
<int-e> The thing is (and this has already been said), Data.Text is designed
        to be imported qualified, and the standard way to avoid typing
        "Data.Text." all over again is to rename the module to something
        shorter, as in import qualified Data.Text as T.
<Axman6> the usual way to do this is import qualified Data.Text as T and use
         T.reverse; this is the style this is used most commonly
<jusss> can I remove that `qualified' ?
<jle`> jusss: note that module imports don't 'affect' the other -- having one
       doesn't affect the other. so importing reverse from Data.Text doesn't
       affect how you would import reverse from Prelude as well
<jle`> i think it would be more confusing if it did
<jle`> jusss: what happens when you try?                                [13:40]
<int-e> If you remove the `qualified` you'll get extra unqualified imports
        that will clash with Prelude.
<int-e> Back to square one...
<jusss> import Data.Text as T,   T.reverse
<Axman6> if you do than then it imports everything in Data.Text
<Axman6> which means that if you use map, or null, or anything else from
         PRelude which is also in Data.Text you will keep getting these errors
                                                                        [13:41]
<jusss> ok
<jle`> jusss: if you did import Data.Text as T, then you can use both 'T.pack'
       and 'pack', without qualification
<Axman6> just do import qualified Data.Text as T
<jle`> jusss: but yeah, all lines in a module import list are 'additive'
                                                                        [13:42]
<Axman6> the full pattern people often use is import qualified Data.Text as T;
         import Data.Text (Text), so you don't need to write T.Text everywhere
<jle`> jusss: adding new lines to an import list only ever brings in new
       imported things
<jle`> jusss: it doesn't ever 'subtract' or negate other imports, if you add
       another import
<jle`> jusss: so if i write `import XXXXX` then later add `import YYYYY`, that
       second line will never 'remove' any imports that the import XXXXX
       brought in                                                       [13:43]
<jle`> it can only add to the items in scope
<jle`> not subtract
<int-e> The only exception is that if you import Prelude explicitly, it will
        not be imported implicitly.                                     [13:44]
<jusss> jle`: ok, I will use `import qualified Data.Text as T' then T.reverse
<jle`> jusss: so if you write import Data.List, then later write import
       Data.Text (reverse), it won't 'subtract' any imports from Data.List
<jle`> no imports from Data.List will be "removed" from the namespace
<jle`> no matter what you import later
<jle`> there is no import you can add later that would "delete" Data.List
       (reverse) from the namespace
<sicklorkin> jusss:
             https://stackoverflow.com/questions/3175583/proper-way-to-import-things-already-defined-in-the-prelude-in-haskell
<Axman6> jle`: this is starting to feel like it will end like
         https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/#answer-1732454
<sicklorkin> Axman6: that's a great answer                              [13:48]
<Axman6> it's one of the classics

####################################

<> is more general to the most type,
Data.Text don't have ++, but there's <>
(pack "a") <> (pack "b")
[1] <> [2]
"a" <> "b"


Data.List

union [1,2] [2,3]  == [1,2,3]
intersect [1,2] [2,3] == [2]
[1,2,3] \\ [1,2] == [3]
[2,3] \\ [1,2] == [3]
[2] \\ [] == [2]

############################################################

if there's data P defined in A.hs, we can through `import qualified A (P)' to import
to the current Main.hs, or `import qualified A (P, T(..))', this will import all data T

'cause there're lots same names of functions, we need to point which is what we want,
use `import qualified Data.Text.IO (getLine)' to declare that getLine is for Data.Text.IO,
not from Prelude or System.IO

if some types are instaces of typeclass Show, which means they implement
the function `show', but show is a function which has no effect, it won't put
something on screen, but we have print
<EvanR> print is a library routine that uses show                       [15:57]
<lambdabot> print x = putStrLn (show x)
<ammar2> :t show
<lambdabot> Show a => a -> String
<jusss> :t print                                                        [16:02]
<lambdabot> Show a => a -> IO ()


#################################################

#recordSyntax #record 

data P = P { i :: Int, ii :: String }
the form P i ii has the type P, not the form P {i ii}, but you can say P {i=3, ii="3"}
P 3 "3" :: P
i (P 3 "3") = 3
i is a field, also an accessor, i (P x y) = x

this i is no difference with others like runMkWhat where data MkWhat = MkWhat {runMkWhat :: What }
runMkWhat (MkWhat w) = w  -- which w :: What

newtype Foo a = Foo { runFoo :: a }
newtype Foo a = Foo a;
runFoo :: Foo a -> a
runFoo (Foo a) = a

also I think we can call this runFoo as a function, 'cause there's a (->) in its type
#####################################################

#emacs #focus #inputMethod

emacs focus issue with Chinese Input Method
when you select a section text in the browser with mouse, and don't release it,
then in emacs, you would find you can't input a whole character to get what you
want, 'cause the input method will only take one character then pop up the one
Chinese character which is not what you want, or just lost the focuse, so you can't
input any more,
this happend on archlinux/debian and windows 10, I think it's related to the focus

###################################################

git clone https://github.com/klappvisor/haskell-telegram-api.git
cd haskell-telegram-api
cabal build  -- if it's on archlinux, use cabal v2-build, 'cause cabal v3 won't installed on archlinux successful via `cabal install Cabal cabal-install'
cabal repl   -- append http-client-tls in the dpendent pacakges section

create a bot from BotFather
t.me/monoid_bot
token HTTP API: 9
https://api.telegram.org/bot9/POST

get your chatid 7 from telegram via add chatid_echo_bot

remember the token is "bot9" for haskell-telegram-api

the token is "9" for telegram-bot-simple

cd haskell-telegram-api
cd src
vim Main.hs
{-# LANGUAGE OverloadedStrings #-}

import           Network.HTTP.Client      (newManager)
import           Network.HTTP.Client.TLS  (tlsManagerSettings)
import           Web.Telegram.API.Bot

main :: IO ()
main = do
  manager <- newManager tlsManagerSettings
  let request = sendMessageRequest chatId message
  res <- sendMessage token request manager
  case res of
    Left e -> do
      putStrLn "Request failed"
      print e
    Right Response { result = m } -> do
      putStrLn "Request succeded"
      print $ message_id m
      print $ text m
  where token = Token "bot9"
        chatId = ChatId 7
        message = "hi"

ghc --make Main.hs
./Main.hs
#############################################################

https://mirrors.tuna.tsinghua.edu.cn/help/hackage/

debian sid
apt install cabal-install
cabal init
vim .cabal/config
repository mirrors.tuna.tsinghua.edu.cn
  url: http://mirrors.tuna.tsinghua.edu.cn/hackage

cabal update
cabal install Cabal cabal-install
aptitude install libghc-zlib-dev
aptitude purge cabal-install
export PATH=$PATH:/home/john/.cabal/bin

cabal install slack-api --installdir="/home/john/.cabal/packages"

mkdir MyRobot
cd MyRobot
cabal init
vim MyRobot.cabal
build-depends: base >=4.12 && <4.13, slack-api
hs-source-dirs: /home/john/MyRobot/src
mkdir src
touch src/Main.hs
cabal repl # now you can import Web.Slack
cabal build # build the code which is in src/Main.hs, then it will outputs in dist-newstyle/build

there's an example file for config
https://hackage.haskell.org/package/hw-kafka-client-3.0.0/hw-kafka-client.cabal

you even don't need to install slack-api, just config it in the MyRobot.cabal
and cabal will install it for your MyRobot project

you even don't need to run `cabal init' in the homedir
<sclv> you run it in a project dir to init a project
<sclv> and you can run update anywhere whenever
<sclv> and it just fetches the latest package list from hackage and caches it

`cabal build' will output an `mostly static' binary file by default.
if you want to fully static builds, you need to google it
<sclv> the fully static one links in at link time
<sclv> that's what static is!
<sclv> dynamic is when it uses the system lib :-)
<sclv> it links everything statically at link time into a single file   [11:57]
<sclv> but its only "mostly" static without work, because it dylinks standard
       things like glibc
<sclv> you can also `strip` to cut them down a bit
<sclv> i don't know how to do fully static builds. its hard
<sclv> you can google it
<jusss> ok
<sclv> you get "mostly static" by default
<fraktor> I'm working on two different machines that use Debian.  I should be
          able to build an artifact on one and move it to the other, right?
          Since they both have similar versions of glibc and so on.     [12:02]
<sclv> yes          

<jusss> pikajude: which tool you prefer? cabal or stack                 [12:11]
<sclv> you install ghc and cabal seperately
<sclv> you can manage installing both with the ghcup tool if you want   [12:12]
<jusss> sclv: but there're some issues on archlinux
<maerwald> jusss: like what
<jusss> sclv: the package ghc and cabal-install 
<sclv> yes. the issue is the archlinux maintainers are awful
<sclv> yes don't use their stuff
<sclv> the maintainers are obstinate and terrible                       [12:13]
<sclv> and refuse to listen to the entire haskell dev ecosystem screaming at
       them
<sclv> just use ghcup
<jusss> maerwald: use cabal to install pacakge there're lots of versions issue
        of package
<maerwald> ah, I thought there is an issue with ghcup on arch
<jusss> they just maintain dynamic libs
<jusss> and ghc mostly use static libs, which is the problem            [12:14]
<jusss> sclv: ghcup works well on archlinux?                            [12:15]
<jusss> now I have to chroot into a debian sid on archlinux for using cabal
<sclv> jusss: afaik ghcup should work. If it doesnt then  the maintainers
       would be interested to know                                      [12:25]
<sclv> it may need a little messing about to make sure you have tinfo compat
       etc                                                              [12:26]
<pikajude> stack also downloads and installs GHC
<pikajude> if you use it to build projects
#####################################################

haskell turn off line buffer
put this
`hSetBuffering stdout NoBuffering' into do-block

-- module ReverseInput where, comment this line will link to a binary file via `ghc --make ReverseInput.hs', uncomment this line will not compile to a binary file, it will be used as a module file

import Control.Monad
import Data.Char
import System.IO

main = do
     -- turn off line buffer
     hSetBuffering stdout NoBuffering
     putStr "Give me some input: "
     l <- getLine
     if null l
        then return ()
        else do
                -- putStrLn $ map toUpper l        
                putStrLn $ reverse l
                main

-- main = do
--      -- turn off line buffer
--      hSetBuffering stdout NoBuffering
--      putStr "Give me some input: "
--      l <- getLine
--      -- putStrLn $ map toUpper l        
--      putStrLn $ reverse l
--      when (not (null l)) main

##############################################################
#do-notation

'bout do-notation, we can put actions into it, but not only actions, like do True,
do-notation can combine those actions into one action,
and main is one IO action, main :: IO ()
monadic actions have effects
all the actions are monadic actions, all the monadic actions have effects
actions only can be executed if we combine them into one action and name it to `main'
main :: IO ()
main = do
     ...
ghc will run with `main' this one IO action
<jle`> jusss: `do x; y` is sugar for x >> y

#############################################################

<dminuoso> jusss: do-notation is just syntax sugar for Monad, and we tend to
           think of Monads as modelling effects, so values of some type `m a`
           for some choice of M can usually be thought of as actions.   [15:43]
<jle`> action is not a formal term, but in this context we refer to it as a
       value of type `m a` for some m and a
<jusss> jle`: aha, so it means, we can only put monadic actions into do-block?
<dminuoso> jusss: Sure. You could say that.
<jle`> jusss: in a single-line do block, not necessarily
<jle`> jusss: but as soon as you have more than one line, you need >> or >>=
<jle`> which requires a Monad instance, and to have type 'm a'          [15:44]
<jle`> that's because `do x` is desugared as `x`
<dminuoso> Well the way the question was phrased "we can only put monadic
           actions into do-block?" juss is right.
<jle`> but `do x; y` is desugared as `x >> y`
<dminuoso> You cannot put non-monad things into do-blocks (unless you enable
           ApplicativeDo).
<jle`> > do True
<lambdabot>  True
<dminuoso> Oh.
<dminuoso> TIL.
<dminuoso> I did not expect that. :-)
<jle`> do blocks can contain anything, but as soon as you string multiple
       lines together, you connect them with >> or >>=, so that's when the
       'monadic action requirement' starts happening                    [15:45]
<jle`> dminuoso: back in the day we used to use this trick to get rid of $'s
       or parentheses :)
<jle`> > 1 * do 3 + 4
<lambdabot>  7
<jle`> whoops, bad example
<jle`> > 2 * do 3 + 4                                                   [15:46]
<lambdabot>  14
<jusss> dminuoso: can we think putStrLn return an action, and that action will
        be executed? all the actions will be executed immediately when it
        shows up?
<jusss> % :t putStrLn
<yahb> jusss: String -> IO ()
<jle`> jusss: actions aren't really "executed" in Haskell evaluation of
       values, we just define them
<jle`> jusss: saying `main = putStrLn "hi"` means that we are defining 'main'
       as the IO action that puts "hi"
<jle`> we're *describing* an IO action
<jle`> then later when we compile the code, we are really compiling an IO
       action into bytestring, like an IO () -> Binary code             [15:47]
<jle`> *function
<jle`> GHC takes the IO action that describe and name 'main', and translates
       it into bytecode
<jle`> *the IO action that you describe, that is named 'main'           [15:48]
<jusss> jle`: oh, I forget that, actions only be executed when put them into
        `main'
<jle`> jusss: so note if you had a file like `main = putStrLn "hi";
       myOtherThing = putStrLn "bye"`, if you compile it, GHC will compile
       'putStrLn "hi"`, the IO action
<jle`> it has to pick one action to compile, so it uses the one you name
       'main', arbitrarily
<jle`> you really could imagine that it could turn main into your binary, or
       it could turn myOtherThing into your binary. it just chooses main
       because that's what we agree upon
<jusss> jle`: but if we put those actions into do-block, we pass main = do
        ... we can run more actions?
<jle`> jusss: not quite; main is always a single IO action
<jle`> but, we can use the IO API in ghc to create complex IO actions out of
       simpler ones
<jle`> for example, (>>) :: IO a -> IO b -> IO b                        [15:50]
<jle`> (>>) takes two IO actions and returns a new one
<jle`> so it would take `putStrLn "hi"` and `putStrLn "bye"`, and it would
       return `putStrLn "hi\nbye"`
<jle`> so main is a single IO action, but we can 'construct' IO actions by
       combining them using the functions ghc gives us                  [15:51]
<jusss> jle`: will `do' notation combine them to one?
<jle`> jusss: `do x; y` is sugar for x >> y
<jle`> yes, essentially. it combines them into one single IO action, which is
       all of its lines done sequentially
<jle`> so it's like myList = [1,2,3] ++ [4,5,6].  myList is a single list, but
       we can construct myList by appending together several simpler lists
<jusss> jle`: then what `sequence' is used for?                         [15:52]
<jle`> main is a single IO action, but we can construct that IO action by
       'appending' (or 'sequencing') together several simpler IO actions
<jle`> jusss: sequence [x,y,z] = x >> y >> z
<jle`> so it can be convenient if you have a list of IO actions, and you want
       to turn it into one big IO action
<koz_> So basically we get one gigantic IO action, which main will execute.
<jle`> sequence :: [IO ()] -> IO ()
<jusss> jle`: `sequence' can combine actions into one like `do' ?
<jle`> actually that's one of the benefits of IO-as-data, I think.  because
       you can think of many ways you could write [IO ()] -> IO ()      [15:53]
<jle`> you could create a new action that does all of the items in a sequence
<jle`> or you could create one that does them all in parallel
<jle`> jusss: yeah, in the end the main mechanism is (>>)
<jle`> do x; y; z  == x >> y >> z
<jle`> sequence_ [x,y,z]  == x >> y >> z
<jle`> both are basically wrapping around usage of >>
<jle`> but do blocks are a bit more powerful because you can do more than just
       >> with them                                                     [15:54]
<jusss> jle`: is that all the actions are monadic actions? which means all the
        actions contain monad?                                          [15:55]
<jle`> well it just means that they have an instance of Monad m         [15:56]
<jle`> because:
<jle`> :t (>>)
<lambdabot> Monad m => m a -> m b -> m b
<jle`> so you could technically write do True; False; True, but then that
       would desugar to True >> False >> True, and that's a type error
<jle`> so it's really just back to normal typechecking rules, nothing super
       special
<jusss> jle`: this >> is look like const
<jusss> :t const
<lambdabot> a -> b -> a
<jle`> indeed the type is similar
<jle`> but because we have some constraints, we get some more interesting
       functions
<jle`> > Just 3 *> Just 10
<lambdabot>  Just 10
<jle`> > Nothing *> Just 10
<lambdabot>  Nothing
<jle`> but yeah, (>>) can be defined as `liftA2 (flip const)`
<jle`> so that's the similarity you are seeing
<jle`> :t liftA2 const
<lambdabot> Applicative f => f c -> f b -> f c
<jle`> :t liftA2 (flip const)
<lambdabot> Applicative f => f b -> f c -> f c
<jusss> jle`: what its name of >> ?
<jle`> some people like to call it 'andThen' or 'then'                  [15:59]
<jle`> maybe you can say 'sequenced with'
#####################################################
#haskell-mode #indentation
ghc --make a.hs , lots of dependent files missing,
it needs the pacakge `ghc-static' in archlinux, 

about auto indentation

(electric-indent-mode 1)
(add-hook 'haskell-mode-hook
	  (lambda () (local-set-key (kbd "<f5>") 'my-haskell-compile)
      (haskell-indentation-mode -1)
      ;;; (haskell-indent-mode 1) just won't work, I don't know why
     ))
;;; http://haskell.github.io/haskell-mode/manual/latest/Indentation.html#Indentation
(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)

####################################################
higher-kinded types

<jusss> what is the higer-kind type?
<sarahzrf> jusss: a type with a function kind, usually                  [12:19]

:k Maybe
Maybe :: * -> *

<jusss> dmwit: Maybe is a type?
<jusss> or Maybe is a function?
<ghoulguy> Yes, both
<jusss> ghoulguy: Maybe is a higher-kinded type?                        [12:37]
<ghoulguy> jusss: Maybe is a type that has kind * -> *
<ghoulguy> Because it has an arrow kind it can be applied to other types,
           specificaly those types with kind *
<masaeedu[m]> ghoulguy: i don't get it. how is `Maybe` a function?
<ghoulguy> masaeedu[m]: Functions are things you apply, Maybe Int is Maybe
           applied to Int                                               [12:44]

<jusss````> ok,  3 and 5 are not same on value level, but 3 and 5 are same on
            type level
<jusss````> so Int and Int -> Int are not same on type level, but they're same
            on kind level?
<dminuoso> jusss````: Right.
<jusss````> dminuoso: -> in the kind level, does it still mean function? or
            what else?                                                  [16:23]
<jusss````> 'cause value and type levels both have function ->
<dminuoso> jusss````: and sort of yes, (->) in the kinds generates kinds for
           function types!
<jusss````> dminuoso: if type Int :: *, and Int -> Int :: *,  (->) Int Int ::
            *, (->) * * :: *, (->) :: * -> * -> *                    [16:26]
<jusss````> oh, it's (->) * * :: *,                                     [16:28]            
############################################################

#expressions #functions #actions #effects #side-effects #monadic actions

monadic actions have effects!

expressions which have function types can be evaluated to functions,
functions don't have effects.

actions can be executed, actions have effects, all the monadic actions have
their own effects.

"no side-effects in Haskell"

<ski> jusss : `[]' allows expresssing "possibly no result at all, and possibly
      more than one result"-effects
<ski> jusss : `return x' (equal to `pure x') always gives an action which
      actually performs no effects at all. or, if you prefer, only performs
      the "trivial effect", the "no-op effect"                          [10:43]
<jusss> ski: next time I meet a monad, I should ask what its effect is first
<jusss> % :t return
<yahb> jusss: Monad m => a -> m a
<jusss> ski: this m a is an action, right?
<ski> jusss : `IO' is (primarily) for doing Input/Output interaction, with the
      outside world (from the POV of the Haskell process). however, `IO' tends
      to be used as a sin-bin, so it also allows expressing local mutable
      state, and multiple threads of execution (whose synchronization is
      indeterministic)                                                  [10:45]
<ski> jusss : no, the *value* of type `m a' is an `m'-action. `m a' itself is
      the *type* of that action

<jusss> ski: next time I meet a monad, I should ask what its effect is first

<ski> jusss : `f x' is function application. `f' is a function expression (an
      expression evaluating to a function), `x' is another expression whose
      value will be passed to the function
<ski> also, the only way to cause `IO'-actions to execute, is by making them
      part of `main' (or entering them into the interactor)             [10:33]
<ski> the only way to cause I/O to happen, is by making the `IO'-action part
      of `main' (or by entering it into the interactor)      
####################################################

<jusss> dmwit: getLine is not a function, it's a IO action, right?
<jusss> % :t getLine
<yahb> jusss: IO String
<dmwit> jusss: Right.
<jusss> dmwit: can I think action are some operations which may have
        side-effect?
<dmwit> Sure.
* ski . o O ( s/side-effects/effects/ )                                 [10:01]
<jusss> ski: functions have effects too
<ski> you might think of an action as "list of instructions", or a "recipe"
<ski> jusss : not in this sense
<jusss> ski: wait a sec, what are monad actions? it means that may have side
        effects?
<jusss> or monadic actions?
<ski> remove "side"                                                     [10:03]
<jusss> those terms I saw them a lot, when I learned Monad, but I never
        understood them
<ski> they're not happening on the side. it's an explicit part of the value
      (the monadic action)
<jusss> ski: why ? you don't think funtions have effects? or what you call
        them?
<ski> it's not `openFile :: FilePath -> IOMode -> Handle', it's `openFile ::
      FilePath -> IOMode -> IO Handle'
<ski> the `IO' is an explicit part of the result. the I/O is not happening "on
      the side"
<ski> @type lookup
<lambdabot> Eq a => a -> [(a, b)] -> Maybe b
<jusss> ski: sorry, I don't get the term of "on the side", it's a metaphor ?
        or just literally?
<ski> same thing there, the `Maybe'-effects aren't happening on the side (no
      exceptions (possibly) implicitly being thrown). failure (`Nothing') is
      an explicit result                                                [10:05]
<jusss> ski: and what's happening on the side?                          [10:07]
<ski> when calling `FILE *fopen(const char *path, const char *mode);' in C,
      like `fopen("/path/to/file","r")', that is an expression of type `FILE
      *'. the I/O that is happening as a result of the call is not explicitly
      declared in the result type
<ski> in Haskell, nothing is happening on the side. no side-effects in Haskell
<jusss> ski: waht?
<jusss> ski: "no side-effects in Haskell" ? then how print somthing, visit
        files?
<ski> those are effects, not side-effects, in Haskell                   [10:09]
<ski> @type print
<lambdabot> Show a => a -> IO ()
<dmwit> I don't think I've ever heard this distinction made before, but I like
        it a lot.
<ski> the I/O is part of the result, is explicitly declared in the result type
<jusss> ski: then functions does have effects?
<ski> no
<jusss> ski: aha!                                                       [10:10]
<ski> calling `print' doesn't cause any I/O to happen
<ski> *executing* the resulting I/O-action, causes the I/O to happen
<ski> the only way to cause I/O to happen, is by making the `IO'-action part
      of `main' (or by entering it into the interactor)
<ski> just calling `print' will "compute what to do", but won't actually do it
<ski> evaluating expressions (which includes calling functions) can't cause
      I/O to happen. can't cause `IO'-actions to be executed            [10:12]
<jusss> ski: then what will cause IO actions to be executed?
<jusss> ski: put them to `main'?
<ski> (however, to execute an `IO'-action, one must determine what
      I/O-operations to perform. iow, one must first evaluate the action. in
      practice, these two "phases", execution and evaluation of an
      `IO'-action, are interleaved)
<ski> yes
<ski> also, note that it doesn't matter that "it all mutates memory locations,
      and probably does memory-mapped I/O, or else some I/O machine
      instructions"
<ski> (or that it executes C code, when GHC used to compile via C)      [10:14]
<ski> whether something has side-effects, or merely effects, is a matter of
      perspective, of which language one's looking from
<jusss> ski: if we put IO actions into functions, and put functions to `main',
        this IO actions will be executed?                               [10:15]
<jusss> % :t putStrLn
<yahb> jusss: String -> IO ()
<ski> it's about what reasoning laws one can apply, at the level of the
      language. how it is implemented is irrelevant
<jusss> like you see putStrLn is a function, which has an IO action as the
        result
<ski> if you write
<ski>   main = putStrLn =<< getline                                     [10:16]
<ski> then this will (evaluate and) execute `getLine', and the resulting
      monadic result (a `String', call it `s') will be passed to `putStrLn'
      (calling `putStrLn', like `putStrLn s', call the resulting action `p'),
      then that action `p' will be executed                             [10:17]
<ski> so, depending on the run-time result of executing `getLine', we'll
      perform/execute *different* actions (returned by `putStrLn') next
<jusss> ski: actions can be executed, and actions have effects, functions can
        be evaluated, and functions don't have effects, that's right?   [10:18]
<ski> dmwit : hm, i would have assumed you'd heard this story before, given
      that you've been here some time (can't recall how long ..)
<ski> functions are called
<ski> expressions are evaluated                                         [10:19]
<ski> an expression can be a function call/application
<jusss> ski: wow,
<ski> yes "functions don't have effects"
<ski> however, as a shorthand, we commonly say "invoke `openFile'", when we
      mean "call `openFile', and execute the resulting action"          [10:20]
<jusss> ski: then what's the different between functions and expressions, also
        function calls and function applications?
<ski> (and, sometimes people say "call `openFile'" when they mean this)
<ski> `2' is an expression. so is `x'
<ski> neither of those are function calls                               [10:21]
<ski> `let x = 2 in max x y' is not a function call
<dmwit> ski: evaluate/execute I've seen many times. side-effect/effect I've
        never seen.
<ski> dmwit : i drew out the lines of this story, years ago
<jusss> ski: then expressions can be executed, expressions don't have effects,
        expressions can be function calls,                              [10:24]
<jusss> ski: what's function application?
<jusss> this term I saw it a lot, but I don't get it
<ski> jusss : expressions are syntactic things (things in the program
      text). functions are really semantic things (things when the program is
      running). however one can talk about expressions which will evaluate to
      functions, and often also just call those "functions" as well

<ski> jusss : `f x' is function application. `f' is a function expression (an
      expression evaluating to a function), `x' is another expression whose
      value will be passed to the function

<ski> jusss : "function application" is more or less synonymous to "function
      call". by the former, we typically mean the thing in the program
      text. by the latter, we often also mean how it behaves, when the program
      is running                                                        [10:27]
<jusss> ski: but `f' and `f x' both are expressions?                    [10:28]
<ski> crestfallen : you can think of "executing a list action" as "selecting
      an element from the list", which is what `x <- xs' and `y <- ys' do
<ski> jusss : yes
<ski> jusss : `max x (min y z)' is also a function application. applying `max
      x' to `min y z'
<ski> (`f x' is applying `f' to `x')                                    [10:30]
<jusss> ski: function expressions and function calls are expressions,
        expressions can be evaluated to functions, and functions don't have
        effects, actions can be executed, actions have effects, this is right?
                                                                        [10:31]
<ski> "expressions can be evaluated to functions" -- in case they have
      function types, yes                                               [10:32]
<ski> by "function expressions" i basically means "expressions of function
      types"
<ski> jusss : yes
<ski> also, the only way to cause `IO'-actions to execute, is by making them
      part of `main' (or entering them into the interactor)             [10:33]
<ski> however, you can e.g. execute `Maybe'-actions, without needing to do
      anything like that                                                [10:34]
<jusss> ski: expressions like `2', function expressions like `f', function
        applications like `f 2', they all are expressions, but only function
        expressions and function applications can be evaluated to functions,
        this is ok?
<ski> you can write `let act = do k1 <- lookup k0 env0; v <- lookup k1 env1;
      guard (pred v); return (frob v) in case act of Nothing -> ...; Just w ->
      ..w..'
<ski> here, one could argue the `case act of ...' causes the execution of the
      `Maybe'-action `act'                                              [10:36]
<ski> jusss : "function applications can be evaluated to functions" sounds
      confused. a function application does not evaluate to a function, unless
      the function being applies is a function whose result will also be a
      function (e.g. if the function is defined in "curried style")     [10:37]
<ski> the function application `not False' will not evaluate to a function
      (however, in order to evaluate that application, we first need to
      evaluate the function expression `not', getting back the function value)
<ski> otoh, `delete "b"' is a function expression which will evaluate to a
      function                                                          [10:38]
<ski> @type delete
<lambdabot> Eq a => a -> [a] -> [a]
<jusss> ski: about the monad Maybe action, I still have a little confused
<jusss> ski: it's an action, so it has an effect                        [10:39]
<ski> > let f = delete "b" in map f [["a","b"],["b","cde"],["c","de","f"]]
<lambdabot>  [["a"],["cde"],["c","de","f"]]
<ski> jusss : yes. the effect in that case is "possible failure to compute a
      monadic result"                                                   [10:40]
<ski> jusss : very roughly (and vaguely) speaking, an "effect" is "any
      deviation from computing a single result, nothing else"
<ski> jusss : `Maybe' allows expressing "possibly no result at all"-effects
                                                                        [10:41]
<jusss> ski: which means all the monad actions have their own effects?
<ski> jusss : `Either e' also allows expressing failure like this, except that
      instead of just having a single ("anonymous") kind of failure, you have
      failures labelled with values of type `e' ("exceptions")          [10:42]
<ski> jusss : yes
<jusss> ski: and `IO'?
<ski> jusss : `[]' allows expresssing "possibly no result at all, and possibly
      more than one result"-effects
<ski> jusss : `return x' (equal to `pure x') always gives an action which
      actually performs no effects at all. or, if you prefer, only performs
      the "trivial effect", the "no-op effect"                          [10:43]
<jusss> ski: next time I meet a monad, I should ask what its effect is first
<jusss> % :t return
<yahb> jusss: Monad m => a -> m a
<jusss> ski: this m a is an action, right?
<ski> jusss : `IO' is (primarily) for doing Input/Output interaction, with the
      outside world (from the POV of the Haskell process). however, `IO' tends
      to be used as a sin-bin, so it also allows expressing local mutable
      state, and multiple threads of execution (whose synchronization is
      indeterministic)                                                  [10:45]
<ski> jusss : no, the *value* of type `m a' is an `m'-action. `m a' itself is
      the *type* of that action
<ski> (that may be what you meant. but you didn't say it)               [10:46]
<maerwald> ski: what do you mean with sin-bin?
* ski thinks it can help to be an extra bit pedantic, about terminology, when
  concepts are a bit unclear

<ski> maerwald : a potpourri of different effects, all mixed together in the
      same monad
<jusss> ski: m a is the type of m-action, right?
<maerwald> ski: well, that is exactly what it is for                    [10:48]

<maerwald> since there is no sensible way to separate that multitude of
           effects

<maerwald> most monad stacks have MonadIO somewhere inside, which blows up the
           entire purpose
<ski> well, depends                                                     [10:50]
<ski> some parts might be like `frob :: Monad m => ... -> T m X'
<ski> jusss : an `m'-action is a value of type `m a', for some type `a',
      yes. where `m' is a monad, or an idiom (or maybe sometimes only a
      functor, but i think it's more common to not say "action"
      then. sometimes "collection" feels like an appropriate word. can also
      often be used in the monad and idiom cases)                       [10:52]
<maerwald> until we have a *proper* effects system, I believe IO is the right
           choice for anything that has any intersection with real IO
<arahael> I thought we had one available? (But not in common use) - something
          similar to what's done in PureScript?                         [10:54]
<ski> i have used multi-level continuation stack, over `IO' (or `ST s', if
      preferred)
<heatsink> Disciple was an experimental haskell dialect with effects    [10:55]
<ski> (the depth of the stack being determined at run-time)
<arahael> Something like https://hackage.haskell.org/package/freer-effects
<maerwald> arahael: yeah, freer is nice, but also very leaky
<maerwald> but, we have 3+ implementations of it
<maerwald> and none of them are really used
<arahael> Leaky?  Blegh. :(
<maerwald> leaky in terms of API/Types                                  [10:56]
<maerwald> if you don't understand the implementation, you'll likely not
           understand the error messages
<maerwald> mtl isn't that bad when it comes to errors                   [10:57]
<maerwald> but then you can't even have two readers...
<ski> dmwit : comment/opinion on the side- / effect story ?
<jusss> ski: where is your story online?
<ski> on logs of this channel
<maerwald> In the end, I'm disappointed by all attempts. Either they are too
           complicated, leak implementation details or are too weak. So I
           embrace IO and write atomic functions.                       [10:59]
* ski might have gone through it at least a dozen times
<maerwald> ski: have you used freer/e-e in a project?
<ski> i haven't
<arahael> maerwald: Blegh. :(  I kind of like it with purescript, but I didn't
          stick with them for long.  What about manually implementing free
          monads? (Feels like too much work, though)
<maerwald> I've only messed with it, but since the ecosystem coverage is
           non-existent
<maerwald> how to even try properly                                     [11:00]
<ski> remind me, can it express composable continuation effects ?

<maerwald> dunno
* ski str many such attempts failing at that
<ski> sometimes i'd want an ordered logic of monad class (like
      `MonadReader',&c.) constraints. also named (so we could scrap the FDs
      ..)                                                               [11:01]
<MarcelineVQ> maerwald: any opinion on polysemy?
<maerwald> arahael: I've always dreamed about effects outside of the type
           system. Yes, I think effects are misplaced on type level (I don't
           care how it's *implemented*, that may very well abuse the type
           system)
<ski> well, ordered as default. but where some constraints are known to
      commute with each other
<maerwald> MarcelineVQ: haven't messed with it, is it worth it?         [11:02]
<arahael> maerwald: Interesting notion - why don't you think it should be in
          the type system?
<MarcelineVQ> No clue but I've not really used effect systems so I'm askin ye
              :>
<maerwald> arahael: The same way as exceptions shouldn't
<ski> maerwald : it would be interesting with an implementation based on
      composable continuations, along the lines of Andrzej Filinski's monadic
      reflection
<maerwald> arahael: yet, there is static knowledge about them (e.g. in java)
                                                                        [11:03]
<arahael> maerwald: I'm still making my mind up with exceptions.  I actually
          think they make perfect sense in Haskell - have them exposed by the
          monad (eg, as IO exceptions are), or have them handled explicitly -
          whatever is appropriate to the situation.
<ski> maerwald : in Clean, uniqueness is expressed in types. in Mercury,
      uniqueness is expressed in "insts" (instantiation states), and "modes"
      (which includes insts). perhaps one could have a story along similar
      lines, for effects                                                [11:04]
<ski> arahael : "handled explicitly" being ? like `Either e' ?          [11:05]
<maerwald> arahael: effects shouldn't enclose values, both are separate, that
           makes it also easier to refactor APIs without losing any guarantees
<ski> (insts and modes are separate from (but connected to) types)
<arahael> ski: Depends on what you think of as an exception.
<arahael> maerwald: So, in a similar way to say, ReactiveX's separation of
          values and errors?
<maerwald> arahael: the reason why enclose values in effects is because Monads
           make it so easy to express this relationship
<maerwald> I don't think anyone stopped there for a second and thought "wait,
           should we really do this?", because all alternatives need a new
           language
<ski> well, i think of `Either e' as expressing exceptions. also, i don't
      believe in "exceptions are for exceptional situations" (what even does
      "exceptional situations" mean ?) .. however, i was wondering what you
      had in mind
<maerwald> arahael: yeah, errors should never be values, in a way, you could
           argue                                                        [11:07]
<ski> (i have no qualms about using exceptions to express the "normal exit
      path")
##############################################################

:t putStrLn
putStrLn :: String -> IO ()
give function putStrLn a String, it will return a IO action which has type IO (),
(->) is the type of function, if there's no ->, then it's not a function
IO () is a IO action,
:t getLine
getLine :: IO String
so getLine is an IO action, which has type IO String, it's not a function

##########################################

newtype Fix f = MkFix (f (Fix f))
kotlin:
sealed class Fix<F>
data class MkFix<F: Fix<F>> (val x: F): Fix<F>()
class Foo: Fix<Foo>()

####################################
#mail
temporary email receiver
https://temp-mail.org/

#######################################

newtype Fix f = MkFix (f (Fix f))
MkFix (Just (MkFix (Just (MkFix Nothing)))) :: Fix Maybe
MkFix Nothing :: Fix Maybe
MkFix (Just (MkFix Nothing)) :: Fix Maybe
MkFix :: f (Fix f) -> Fix f
################################################

y = Y f = f (Y f)
f y = y
Y = \f.(\x.f(x x))(\x.f(x x))


#############################################

bmiTell'' :: Double->Double->String
bmiTell'' weight height
    | bmi <= 18.5 = "You are underweight!"
    | bmi <= 25.0 = "You are normal!"
    | bmi <= 30.0 = "You are fat!"
    | otherwise = "You are whale!"
    where bmi = weight / height ^ 2 

*Main> 4 * (let a = 9 in a + 1) + 2
4 * (a+1) +2
a=9

fix f = let x = f x in x
fix f = x
x = f x
fix = \f -> let x = f x in x
https://stackoverflow.com/questions/8308394/y-combinator-infinite-types-and-anonymous-recursion-in-haskell

import Data.Function
fix (1:)

fix f = f (fix f) = f (f (fix f))

let x = 1:x in x will produce a list x like [1,1,1,1...]
fix (\x -> 1:x) or simply fix (1:) which will find a fixed point of the (1:) function

fix f = f(...  f (f (f x)))
https://stackoverflow.com/questions/4787421/how-do-i-use-fix-and-how-does-it-work

fixed-point is used for recursion, in other languages, it can be used for some side-effect functions

y combinator is a higher-order function, function Y take a function f and return a function z, and that function z is the fixed-point of function f, so f(z) = z
Y f = z
f z = z
Y f = f (Y f)

Y is the Y combinator, and Y f is the fixed-point function of f

 fix  f  y = fix f f y == y

 fix  fix combinatorData.Function 
fix  f  Y 
https://blog.csdn.net/zwvista/article/details/81070680
##############################################

$signature = @"
[DllImport("user32.dll")]
public static extern bool SystemParametersInfo(int uAction, int uParam, ref 
int lpvParam, int flags );
"@

$systemParamInfo = Add-Type -memberDefinition  $signature -Name SloppyFocusMouse -passThru

[Int32]$newVal = 1
$systemParamInfo::SystemParametersInfo(0x1001, 0, [REF]$newVal, 2)

save this to FocuseFollowsMouse.ps1, and right-click run with Powershell
https://superuser.com/questions/954021/how-do-you-enable-focus-follows-mouse-in-windows-10

#####################################################

I think that Y combinator apply on value level, we get the same function `Y g = g(Y g)`
apply on type level, we get the same type `newtype Fix f = MkFix (f (Fix f))`
we can think that value constructor as a function
Maybe a = Just a | Nothing
Just = \x -> Just x
Just :: a -> Maybe a
Just is a function
Nothing :: Maybe a, Nothing is not a function, there's no -> there

<jusss> MarcelineVQ: so we can think everything within a -> can be functions?
<Axman6> well yes, that's what -> means                                 [09:57]
<MarcelineVQ> Directly, if your type (after constraints) starts with -> it's a
              function, because -> is the type of functions. Just :: a ->
              Maybe a is, Just :: (->) a (Maybe a), Just starts with ->

(->) is the type of function, which's type have (->) in it, which is a function

<MarcelineVQ> The reason I say that in that way is because you might see foo
              :: IO (a -> b), this is not a function despite having ->

data F = MkF (Int -> F)
MkF :: (Int -> F) -> F
<jusss> this value constructor MkF is a function just like Just

<jusss`> EvanR: Just 3, Nothing are monadic values also monadic actions, but
         Just is also a function, and Nothing is not a function, right?

IO () is a action, not a function

#action #function

all the recursive type, in the end we need a value to return0
1:47:31 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)"
01:48:09 <merijn> jusss``: So, say, "Fix Maybe" is "a MkFix constructor containing 'Maybe (Fix Maybe)" inside it
01:49:37 <merijn> Now, Fix with Maybe is usually not very interesting, because it's just going to be a bunch of "Just" until you eventually (maybe...) hit a Nothing
########################################

it seems Y combinator is only used to solve recursive issue,

<Axman6> any recursive function can be written using fix
<Axman6> so, if we only had fix, we could write any computable function, even
         if we weren't allowed to use recursion directly                [09:12]
<Axman6> well no, but it's not really any different than things lik const, (.)
         etc. existing. it exists because it does                       [09:13]
         
###########################################################

Y = \f.(\x.f(x x))(\x.f(x x))
Y g = (\x.g(x x))(\x.g(x x))
      =g((\x.g(x x))(\x. g(x x)))
      =g(Y g)

Y combinator, fixed-point, infinite type, recursive type

fib = Y fib' = fib' (Y fib') = fib' fib

01:47:31 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)"
01:48:09 <merijn> jusss``: So, say, "Fix Maybe" is "a MkFix constructor containing 'Maybe (Fix Maybe)" inside it
01:49:37 <merijn> Now, Fix with Maybe is usually not very interesting, because it's just going to be a bunch of "Just" until you eventually (maybe...) hit a Nothing
01:53:07 <jusss``> merijn: how we implement the MkFix function?
01:53:30 <jusss``> merijn: your examples is like binary tree

01:53:41 <merijn> jusss``: Suppose we define "data Foo b a = Foo b a | Nil" now if we look at "Fix (Foo a)" we get...[a]! "Fix (Foo a)". Let's see what's inside Fix. We see MkFix which has a "Foo a (Fix (Foo a))" so it has an element 'a' and another "Fix (Foo a)", alternatively inside our MkFix we find "Nil" and the list is finished
01:54:05 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)" <- this *is* the definition of MkFix


#################################################################
typescript
type Fun = (_: any) => Fun
const f : Fun = _ => {console.log(_); return f };

turn it to haskell
data Fun = any -> Fun
any->Fun is already a type, data Type = Value,
so it will think any->Fun as a value, that's not what we want,
we have to add a value constructor,
data Fun = MkFun (any -> Fun)

f::Fun
based on the type, f will be
f = MkFun (\i -> f)
runFun Fun :: any -> Fun
'cause there's no any in hasekll, let's replace it with Int
runFun Fun :: Int -> Fun
runFun f 1 :: Fun

runFun (runFun f 1) 2 :: Fun


 <dminuoso> % newtype F = MkF { unF :: Int -> F }
<dminuoso> % f :: F; f = MkF (\i -> f)
 <dminuoso> % :t unF (unF (unF f 1) 2) 3 
 <yahb> dminuoso: F
http://tunes.org/~nef/logs/haskell/19.10.01

data F where MkF :: Int -> F -> F   // data F = MkF (Int -> F)
unF :: F -> Int -> F
w :: Int -> F
unF (MkF w) = w

<EvanR> jusss: the type F seems to be an infinitary branching tree      [10:43]
<EvanR> (viewing Int as Integers)
<EvanR> and this tree has no data in it
<jusss> EvanR: so it's useless in the value level?
<jusss> EvanR: no value can have that type F?                           [10:48]
<EvanR> plenty of inhabitants of F
<EvanR> but i don't see how you can tell the difference between any of them
<EvanR> it just consumes Ints forever no matter what they are           [10:49]
<EvanR> it's a /dev/null for Int


<jusss`> dminuoso: I suddently understand your `newtyfpe F = MkF { unF :: Int
         -> F }`,  I talked infinite type with a typescript guy, and he give
         me a `type Fun = (_: any) => Fun` for that `const f : Fun = _
         =>{console.log(_); return f};` and then I tried to turn it to
         haskell, I wrote `data Fun = any -> Fun`, but `any -> Fun` is already
         a type, so we have to add a value constructor MkFun, which is `data
         Fun = MkFun (any -> Fun)`, and your `unF
<jusss`> F :: Int -> F`,  let's assume `f :: Int -> F` , so `unF (MkF f) = f`
<jusss`> dminuoso: and this `unF (MkF f) = f` is look like Y g = g (Y g) ,
         right?


<jusss``> dminuoso: a little misunderstood here, you use `f::F; f=MkF (\i ->
          f);` then `unF f 1 = f `                                      [16:21]
<jusss``> unF (unF f 1) 2 = f       which is related to Y g = g (Y g) = g (g
          (Y g)) ???                                                    [16:23]
<jusss``> function return itself, it's useful when it works on some
          side-effect operations,                                       [16:55]

unF (unF f 1) 2 :: F  it's not equal to f, so unF (unF f 1) 2 = f is wrong,

<jusss``> \s: 
          IO                                              [16:50]
<jusss``> \s: Promise
                                                                        [16:51]
<jusss``> 
<jusss``> \s: 
<jusss``> \s: OOP,FP                                        [16:52]

<jusss`> \s: tstype Fun = (_: any) => Fun, haskell any->Fun
         any->Fundata Type
         = Type MkFun, data Fun = MkFun (any ->
         Fun)
<jusss`> \s: 
<jusss`> ! tshaskellhaskell
                                                          [15:14]
<jusss`> \s: type Fun = (_: any) => Fun;  data Fun = MkFun ( _ ->
         Fun)  haskellany                                       [15:09]
<jusss`> \s: data Fun = MkFun (any -> Fun)                              [15:06]

type Fun = (_: any) => Fun;
const f : Fun = _ => { console.log(_); return f };

type Fun<T> = (_: T) => Fun<T>;
const f : Fun<number> = _ => { console.log(_); return f};
const g: Fun<string> = _ => {console.log(_); return g};

f(1)(2)(3)
g('a')('b')('c')

no function type signature, no recursive type,
how to do that in Kotlin with class implement for recursive type?

#whyWeHaveALotOfValueConstructorInHaskell
that's why we have a lot of value consturctors in haskell,
'cause data Type = Value, so that other type want to be the right of '=', it needs a
value constructor, otherwise it will think that type like Int as a value constructor Int,
a value Int not the type Int

https://stackoverflow.com/questions/18249583/infinite-type-error-when-returning-a-self-referential-function-in-haskell

To express something like this, you'd need a recursive type. Since Haskell doesn't support equirecursive types, you'll need to use newtype/data.

So you might define newtype Foo s = Foo { runFoo :: s -> (s, Foo s) }, for instance, and then write noOp :: Foo (A,B,C); noOp = Foo (\(a,b,c) -> ((a,b,c), noOp)).

This looks like a Mealy machine. The package machines exports a similar type: newtype Mealy i o = Mealy { runMealy :: i -> (o, Mealy i o) }

I gave an example there. It'll compile if you change (A,B,C) to some types you actually have. E.g. for Int state, you can write noOp :: Foo Int; noOp = Foo (\x -> (x, noOp)). Then noOp :: Foo Int. To get a function out of it, you can just use runFoo: runFoo noOp :: Int -> (Int, Foo Int)

####################################################################

00:57:30 <jusss`> dminuoso: I found an anwser is like your anwser a few days ago, about that recursive type, https://stackoverflow.com/questions/18249583/infinite-type-error-when-returning-a-self-referential-function-in-haskell       but I still don't know what this means...
00:57:52 <jusss`> about the anwser, I can't understand why create an new value constructor can solve that
00:59:28 <jusss`> how this trick can solve recursive type, can make function to return itself without product an infinite type
01:01:44 <merijn> jusss`: Infinite types are problematic because they bork the typechecker. Consider "x = [x]" what's the type of 'x'?
01:02:18 <merijn> jusss`: Obviously it's an infinitely nested [], but there's no way to work with infinite nestings in the compiler, you'd just loop forever

01:02:57 <merijn> jusss`: By going "newtype Foo = MkFoo [Foo]" you insert a sort of loopbreaker
01:03:05 <ski> (it's not that hard to adapt a type-checker to be able to work with such infinite types. however, enabling them would make a lot of common mistakes into strange inferred types, rather than type errors)
01:03:29 <merijn> "x = Foo [x]" What's the type of 'x'? "Foo", done. What's inside a "Foo"? A list, containing a Foo.
01:03:39 <ski> (if you want to play with such types, try `ocaml -rectypes')
01:03:43 <koz_> merijn: Is this similar to the Fix type recursion schemes use?

01:04:05 <merijn> jusss`: Note that now none of the questions ever have to deal with an uncomfortable answer that requires infinite unrolling to answer
01:04:17 <merijn> koz_: Fix is a newtype (instead of a type alias) to workaround this, yes
01:04:42 <merijn> koz_: Fix is one of the most common "infinitely nested" types
01:06:16 <merijn> jusss`: Wanting to nest an infinite/indefinite number of times isn't wrong, doing it "directly" just makes the type checker infinite loop while checking things (therefore making it impossible to handle them directly)
01:28:11 <jusss``> merijn: sorry about the bad network, I just saw your anwsers, what is the Foo of "x = Foo [x]"? a function? a value constructor?

01:29:12 <dminuoso> jusss``: Its both a function and a data constructor.
01:29:37 <jusss``> dminuoso: then how it's defined?
01:29:57 <dminuoso> jusss``: I think merijn made a typo and meant to write `x = MkFoo [x]`
01:30:18 <jusss``> is this related fix-point stuff?
01:30:26 <jusss``> y combinator?
01:30:46 <merijn> jusss``: x is a variable with type Foo and value "Foo [x]"
01:30:55 <merijn> eh, yes
01:31:06 <merijn> jusss``: Foo is is Fix specialised to Foo, yes
01:31:44 <jusss``> merijn: I just know the name and I never understand it 
01:33:13 <jusss``> merijn:  x = Foo [x]   but x is a variable, not a function name, how we canuse  x = Foo [x] to define function Foo?
01:34:25 <jusss``> Foo [x] = x?
01:45:55 <merijn> jusss``: Fix is "I have a Functor and I want to nest it an infinite number of times"
01:46:36 <merijn> jusss``: So Foo was nesting lists an infinite number times, but we could also, say, want to infintely nest Maybe, or "Either e", etc.
01:47:31 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)"
01:48:09 <merijn> jusss``: So, say, "Fix Maybe" is "a MkFix constructor containing 'Maybe (Fix Maybe)" inside it
01:49:37 <merijn> Now, Fix with Maybe is usually not very interesting, because it's just going to be a bunch of "Just" until you eventually (maybe...) hit a Nothing
01:53:07 <jusss``> merijn: how we implement the MkFix function?
01:53:30 <jusss``> merijn: your examples is like binary tree

01:53:41 <merijn> jusss``: Suppose we define "data Foo b a = Foo b a | Nil" now if we look at "Fix (Foo a)" we get...[a]! "Fix (Foo a)". Let's see what's inside Fix. We see MkFix which has a "Foo a (Fix (Foo a))" so it has an element 'a' and another "Fix (Foo a)", alternatively inside our MkFix we find "Nil" and the list is finished
01:54:05 <merijn> jusss``: "newtype Fix f = MkFix (f (Fix f)" <- this *is* the definition of MkFix
01:54:30 <jusss``> data Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)
01:55:36 <merijn> jusss``: You could also do trees using Fix, yes. "data TreeF a b = Leaf a | Node b b" then "Fix (TreeF a)" becomes equivalent to "Tree a"
01:55:37 <jusss``> merijn: the function form of MkFix?

01:55:54 <merijn> jusss``: MkFix is a constructor, just like Just or Nothing

01:56:42 <jusss``> merijn: this confused me, data constructor is function or not?
01:57:18 <merijn> jusss``: Yes, no, maybe. It depends on how you define "is" and function. They have a function type, yes
01:57:20 <jusss``> newtype or data are used to define types
01:57:43 <jusss``> merijn: f x = x, this is a function
01:57:59 <ski> `newtype' and `data' are used to define type constructors, and associated data constructors
01:58:12 <jusss``> merijn: f Int :: Int , this is a function type signature
01:58:40 <ski> some data constructors (like `Just',`MkFix') are functions. some are not (like `Nothing',`False',`True')
01:59:02 <dminuoso> jusss``: We've been interacting for a while now, and it is my honest opinion that what you are doing is ineffective.
01:59:20 <ski> `f Int :: Int' is not a function type signature
01:59:21 <jusss``> ski: and do those Just MkFix have a function form? or can those turn to lambda expressions?
01:59:47 <dminuoso> jusss``: You seem to digress in topics that are not relevant for writing effective Haskell code and, at the same time, far outside your reach. :)
01:59:49 <ski> `Just' is already a function. not sure what you mean by "function form"
02:00:02 <jusss``> dminuoso: I just feel it's so hard to return function itself within those static type-checked languages...
02:00:14 <ski> `Just' is equal to `\x -> Just x'. that's a lambda expression

02:00:50 <dminuoso> jusss``: I think the main problem is that you still conflate functions and actions - if you properly understood the difference, you wouldn't even be asking about "how can a function return itself".
02:01:02 <dminuoso> jusss``: (Im saying this, because I know why you are chasing this stopic)
02:01:20 <jusss``> dminuoso: sorry, I should stop
02:02:02 <dminuoso> jusss``: It's just my opinion. If you want to carry on, feel free to - but when after weeks you still have difficulties with this, I think you could spend your time more effectively and visit this topic later when you have basic type level competencies.

02:04:15 <dminuoso> jusss``: The original topic came up when you asked for the equivalent of `f(1)(2)(3)` where f would print a value, and then return itself. In Haskell you'd just write `f 1 >> f 2 >> f 3 ...` there's little point in f returning itself, since you already have access to f.
02:04:46 <dminuoso> Or, equivalently: traverse_ f [1,2,3,...]
02:05:37 <koz_> Yay traverse_. Probbo my favourite function.
02:05:44 <dminuoso> And even here, the notion of "a function returning something" and "f executing some actions" are orthogonal things. You are just chasing the function part, but we cant express printing something in a function.
02:05:57 <koz_> How would you even pronounce 'traverse_'? 'Traverse underscore'?

02:06:32 <merijn> dminuoso: Well, you can, it just doesn't mean what you'd naively expect it to mean from other languages :p
02:07:14 <dminuoso> merijn: The point Im getting at, is that a function itself doesn't do the printing.
02:07:21 <dminuoso> (Ignoring things like unsafePerformIO for sanity)
02:08:35 <dminuoso> So "a function that first prints something and then returns itself" would rather be expressed as some `f ~ Int -> IO f`

02:11:45 <ski> @let newtype Consumer m a = Consume {applyConsumer :: a -> m (Consumer m a)}

02:12:29 <ski> @let printConsumer :: Show a => Consumer IO a; printConsumer = Consume (\a -> do print a; return printConsumer)

02:14:22 <ski> @type printConsumer `applyConsumer` 0 >>= (`applyConsumer` 1) >>= (`applyConsumer` 2)
02:14:23 <lambdabot> (Show a, Num a) => IO (Consumer IO a)

02:14:53 <ski> (that's rather clunky, though)
02:17:04 <ski> @let printAccumulator :: (Show a,Num a) => Consumer IO a; printAccumulator = loop 0 where loop acc0 = Consume (\n -> do let {acc1 = acc0 + n}; print acc1; return (loop acc1))

02:23:38 <jusss```> dminuoso: actually I'm not chasing about the printing stuff, 

02:30:44 <dminuoso> ski: This smells like there's a monad transformer hidden.

02:33:56 <ski> well, this one is contravariant in `a'
02:35:16 <maerwald> you're smelling a contravariant transformer?

http://tunes.org/~nef/logs/haskell/19.10.08

fib = Y fib' = fib' (Y fib') = fib' fib

##################################################################

you can't return a function, 'cause Java doesn't really have first-class functions
<surial> jusss: in java, anytime you have a lambda or method ref, or example:
         (String a) -> a.length();   or perhaps String::length, the compiler
         will then infer from the context of where you use it, which so-called
         functional interface (an interface definition with precisely one
         method in it) you intended it to be, and the lambda then acts as if
         it is an instance of that interface. This is why [A] something like
         Object a = (String a) ->                                       [20:08]
<surial>  a.length(); does not compile (the compiler cannot tell what
         functional interface you're implementing), but ToIntFunction<String>
         f = (String a) -> a.length(); DOES. Also, [B] why you can write
         ToIntFunction<String> f = a -> a.length();  the compiler will infer
         a = String for you. Not even haskell can do that.
<surial> jusss: because it acts like an instance of the interface, to invoke a
         function, you can't do varName(). you have to do
         varName.funcName(). For example, the ToIntFunction interface is
         defined as: public interface ToIntFunction<T> { int apply(T in);
         }. So, ToIntFunction<String> f= String::length; and to invoke it:
         f.apply("Hello");... not f("Hello"). Yes, this is different from,
         say, javascript.                                               [20:09]

<jusss> how I can return the function itself in the function?           [09:52]
<jusss> like def f(x): print(x); return f
<jusss> then I can do f(1)(2)(3)
<Axman6> that sounds like an infinite type to me


return a function in a function is ok, but return itself in the function would produce
an infinite type

but java even can't return another function in a function,
haskell and kotlin (return ::f) can return aother funciton in a function, but it still can't return itself

is that all the type-checked languages can't return itself in a function?
scheme
(define f (lambda (x) (display x) f))
((f 3) 5)
js
f = x => {console.log(x); return f}
f(3)(5)
all the dynamic type languages can do that, but not java or haskell can,
'cause it would produce an infinite type in the those type-checked langauges?

but there's a trick in kotlin, we can change the result type manually
fun test(x:String):(String)->Any {
    println(x)
    return ::test
}
then we can do `test("1")("2")`
change its result type to (String)->(String)->Any, and we can call `test("1")("2")("3")`

fun test(x:String):(String)->(String)->Any{
    println(x)
    return ::test
}
test("1")("2")("3")

kotlin:
lateinit var f: (String) -> ((String) -> Any)
f = {
  print(it)
  f
 }

f("1")("2")("3")

object test {
       operator fun invoke(i: Int) = also
                { println(i) }
        }
fun main() {
    test(0)(1)(2)
}    
 
<jusss> but in a language like java, their class is their type, can we return
        the instance itself in the class?                               [10:44]
<jusss> that would produce an infinite type?
<EvanR> otoh in some interpretations an OOP class is "just a function" (that
        returns objects)                                                [10:47]
<monochrom> That means you go through a wrapper type in Java. And you can use
            a wrapper type in Haskell too.
<monochrom> Java: public class C { public C f() { return this; } }      [10:48]
<monochrom> Haskell: data/newtype C = MkC{f :: C}
<EvanR> MkC, McK, KmEtt, ...


#1 point out the type, avoid infinite type, point out how many times it will call, like kotlin examples above
#2 use class, return instance or class itself,

#################################################

#amb

https://wiki.haskell.org/Combinator
https://docs.huihoo.com/homepage/shredderyin/wiki/ContinuationPassingStyle.html
https://docs.huihoo.com/homepage/shredderyin/wiki/SchemeAmb.html
https://www.rosettacode.org/wiki/Amb#Haskell
https://cgi.soic.indiana.edu/~c311/lib/exe/fetch.php?media=cps-notes.scm

https://zhuanlan.zhihu.com/p/65449477

#CPS
https://2ality.com/2012/06/continuation-passing-style.html
https://blog.oyanglul.us/grokking-monad/part1

###########################################

amb function, y combinator, continuation passing style,
delimited continuation, lambda calculus, eta-conversion,
continuation monad, monad transformer,

############################################

#eta-conversion
f x = f x
f = \x -> f x      -- if x is not free in f, \x -> x y this y is free in this lambda

f s = g 3 s
f = \s -> g 3 s = g 3

f x = f x  -- move x to the right side
f = \x -> f x

f s = g 3 s  -- move s to the right side of f
f =\s -> g 3 s  -- move g 3 to the left side
\s -> g 3 s = g 3
f = g 3

eta-expand

<Solonarv>             map . map
<Solonarv> = \f     -> map (map f)               -- 1. definition of (.)
<Solonarv> = \f     -> map (\xs -> map f xs)     -- 2. eta expand the inner 'map' call
<Solonarv> = \f xss -> map (\xs -> map f xs) xss -- 3. eta expand outer 'map' call

\f -> map (\xs -> map f xs)
\f -> (\xss -> map (\xs -> map f xs) \xss)
\f xss -> map (\xs -> map f xs) xss

eta-conversion

f x = f x
f = \x -> f x

#####################################################

<[exa]> jusss: https://pastebin.com/pZM1tRt5  this is CPS with recursion

function factAcc(n,acc,k) {
   if n > 1
   then factAcc(n-1, acc*n, k)
   else k(acc)            // (\r -> main2(r,k))(acc)
}
 
function factorial(n,k) {
    factAcc(n,1,k);
}
 
function main(k) {
    n = read()
    factorial(n, main2(_,k));     // it's factorial(n, \result -> main2(result,k) ), eta-conversion
}
 
function main2(a, k) {
    print(a)
    k()
}

<[exa]> jusss: you're missing the lambda there
<[exa]> jusss: with _ I meant this: factorial(n, \result -> main2(result,k) )
<[exa]> jusss: you create a tiny function that just takes its argument and
        puts it to main2, and give it to factorial as a continuation    [18:09]
<[exa]> trick: main2() receives continuation from the original main(), so that
        they virtually behave as a single function
<jusss> [exa]: oh, it's a lambda
<jusss> [exa]: this lambda will eval to main2(result,k)                 [18:10]
<jusss> and main2(result,k) is the k
<jusss> and in the factAcc , main2(result,k)(acc), right?               [18:11]
<[exa]> (\r -> main2(r,k))(acc)  --more precise I believe
<[exa]> which evaluates to main2(acc,k)                                 [18:12]
<[exa]> so that the factAcc simply jumps to main2
<jusss> [exa]: is there a k I can use in this code?
<[exa]> how do you mean it                                              [18:24]
<jusss> [exa]: main(?) to run this up
<jusss> [exa]: we pass what to main()?
<[exa]> jusss: main needs a continuation. It can't return, what would it do
        with the result?                                                [18:29]
<[exa]> in case of main, the continuation may be something like system.exit(0)
<jusss> [exa]:  k() in main2, and   else k(acc) in factAcc, this k's parameter
        is not ...                                       
######################################################

Generics were introduced to the Java language to provide tighter type checks at compile time and to support generic programming.

 JVM 
Java

Replace all type parameters in generic types with their bounds or Object if the type parameters are unbounded. The produced bytecode, therefore, contains only ordinary classes, interfaces, and methods.
Insert type casts if necessary to preserve type safety.
Generate bridge methods to preserve polymorphism in extended generic types.

java uses type erasure to handle generics,
and haskell uses type variables, but they're very different
you can't really compare Java's generics with Haskell's polymorphism
###########################################################
#javascript
fact = (n, ret) =>{ if (n==0) ret(1); else fact(n-1,t => ret(n*t))}
fact(1000,console.log)

#python
fact = lambda n, ret: ret(1) if n==0 else fact(n-1, lambda t: ret(n * t))
fact(1000, lambda x: x)

#haskell
fact = \n -> \ret ->
   if n==0 then ret 1
   else fact (n-1) (\t -> ret $ n * t)

fact 1000 id


#lang racket
(define (fab-cps n k)
  (if (= 1 n)
      (k n)
      (fab-cps (- n 1)
               ( (v) (k (* n v))))))

(fab-cps 5 displayln)
##########################################################

function somefun(x,y) { return 2*x + y; }
 
function main() {
  a = 5+6;
  b = somefun(a,a);
 
  print (5+b);
  print ("haha here");
  print (b);
}

<[exa]> the aim is to rewrite the code so that it does the same thing, but you
        can never 'return' from any function

function somefun(x,y,k) {  k(2*x + y);}
 
function main() {
  a = 5+6;
  somefun(a,a,k);
  function k(b){
  print (5+b);
  print ("haha here");
  print (b);
  }
}
<[exa]> notice you can just take 'k' out of main and it will still work
<[exa]> after that, the code is basically in the same language as before, but
        uses no returns, and CPS is done, and that's it :]              [16:00]
<[exa]> jusss: Q: what is it good for? A1: You don't need the underlying
        system to remember "return addresses" itself, so e.g. tail recursion
        is much easier to implement                                     [16:01]
<jusss> [exa]: and A2?
<[exa]> jusss: A2: you've got 'goto' for free in a nicely looking functional
        language

<[exa]> let's try exceptions for example: Instead of calling 'somefun(x,y,k)',
        you would call 'somefun(x,y,k,e)' where 'e' is the landing point for
        whenever something goes wrong. No other language modifications needed.
<jusss> ok
<[exa]> jusss: in short, the whole point of CPS is 'tremendous jumping power
        with no underlying system required'                             [16:04]
<[exa]> s/no/minimal/
<[exa]> oh they call 'trampoline' a thing that repeatedly calls thunk
        evaluation                                                      [16:17]
<[exa]> yes, basically an engine for evaluating whatever gets returned again
        and again until there's an actual value
<jusss> [exa]: is this CPS?                                             [16:20]
<[exa]> no, but CPS makes this pretty simple -- after CPS there is no stack,
        so you don't need to keep any intermediate "state" of the functions
        being evaluated
<[exa]> but still you can perfectly "interrupt" them                    [16:21]
<tdammers> the basic idea is simple. instead of making a recursive call and
           returning its value, you return the equivalent continuation, and
           then you have a "trampoline" function at the top level that calls
           your function, and keeps calling the return value until it is not a
           continuation anymore
<jusss> [exa]: so how to do this if it uses CPS?
<merijn> jusss: You give f an extra argument which is the function that will
         use the result of f                                            [16:22]

<merijn> jusss: So instead of "result = f(0); print(result)" you'd simply do
         "f(0, print)"                                                  [16:26]
<merijn> jusss: Note that at not point do you actually need to "return" so the
         code can continue, because you're explicitly passing the "continue"
         as argument
<merijn> jusss: If you never have to return, then you don't have to remember
         where to return to, and if you don't have to remember where to return
         to, you don't need a function call stack
<merijn> (which, of course, means you can't overflow your function call stack
         either!)
<jusss> merijn: wow!
<merijn> jusss: Now imagine your entire program is just a giant expression
         (like Haskell programs effectively are) you can always just pass in a
         continuation that is "the rest of the program" which means you never
         have to "return" and, indeed, GHC compiles function calls to assembly
         jumps, rather than assembly calls
<merijn> jusss: Even compiler in imperative languages secretly do this
         internally
<merijn> jusss: A common compiler technique is to turn imperative code into
         "Static Single Assignment" form, where each variable is only ever
         assigned once (which makes code much easier to optimise/simplify),
         which has basically the same effect
<koz_> I think there was even a paper saying that SSA is CPS in disguise.
                                                                        [16:32]
<merijn> koz_: It's not even really in disguise
<merijn> CPS and SSA are quite obviously "the same thing from a slightly
         different viewpoint"
<merijn> jusss: The wikipedia page on SSA seems to have some ok examples (for
         as far as I can tell from quickly skimming)                    [16:34]

<jusss> merijn: ok
<jusss> merijn: I run your code https://paste.debian.net/1101388/  and
        "RuntimeError: maximum recursion depth exceeded"
<merijn> jusss: Right, because python use a callstack for call because it
         can't tell it's not needed there                               [16:59]
         
#trampoline
def f(n):
    if n> 10000:
        return 0
    else:
        return lambda: n+f(n+1)

def trampoline(f):
    while isFunction(f):
        f=f()
return f

#CPS
def id(x):
    return x

def f(n, continuation):
    if n > 10000:
        continuation(n)
    else:
        f(n+1, lambda x: continuation(n + x))

f(0, id)
##########################################################

#haskell #stack https://tech.fpcomplete.com/haskell/get-started/linux
wget -qO- https://get.haskellstack.org/ | sh
echo "export PATH=$PATH:/home/john/.local/bin" >> ~/.bashrc
source ./.bashrc

Copy the following content into a file called HelloWorld.hs
    #!/usr/bin/env stack
    -- stack --resolver lts-13.7 script
    main :: IO ()
    main = putStrLn "Hello World"
Open up a terminal and run stack HelloWorld.hs. then it will download the depend packages

v2ray --config tokyo2.json
proxychains stack new webConn yesodweb/sqlite && cd webConn

stack use AWS to store files, so it may sucks!
use cabal to install yesod
cabal update
cabal install yesod

and cabal sucks too!

on archlinux, hackage, stack, cabal, pacman

pacman -Ss haskell-yesod

###################################

<dminuoso> jusss: The Cont monad is one particular style of CPS. But any
           language that has first-class functions can implement
           continuations.
<dminuoso> jusss: In any language that has first class functions you are very
           likely to find libraries that offer a continuation based approach.
<ggole> Manually passing continuations is pretty common.
<ski> btw, first-class continuation( side-effect)s is something else
<ski> (as in Schemw, SML/NJ, and in some other languages / implementations)
                                                                        [14:31]
<ski> (er, s/Schemw/Scheme/)
<jusss> ski: do JS and Python have call/cc ?
<dminuoso> jusss: dont conflate call/cc with continuations.             [14:32]
<dminuoso> jusss: CPS is a general concept.
<ggole> Full first-class continuations in the guise of call/cc are probably a
        mistake though
<dminuoso> jusss: The general concept is about passing a "continuation", a
           sort of "here's how you can resume"
<dminuoso> jusss: If we squint a bit, functions like `withConnection ::
           (Connection -> IO a) -> IO a` accept a continuation.         [14:33]
<dminuoso> (It does slightly more than that though)
<masaeedu[m]> it's pretty easy to implement the continuation monad in JS

e.g:  "c >>= f = \k -> c (\a -> f a k)"

``` #continuation #Cont
const pure = x => cb => cb(x)
const bind = amb => ma => cb => ma(a => amb(a)(cb))
const lift2 = f => ma => mb => bind(a => bind(b => pure(f(a)(b)))(mb))(ma)

const delay = d => v => cb => setTimeout(() => cb(v), d)

const hello = delay(1000)("hello")
const world = delay(1000)("world")
const format = x => y => `${x}, ${y}!`
const main = lift2(format)(hello)(world)

main(result => { console.log(result) })
// after a couple seconds, logs "hello, world!"
```

<masaeedu[m]> that's it. if you curry most node js and browser apis and
              whatnot a tiny bit they all turn into continuations that you can
              sequence using those operations
<masaeedu[m]> and traverse/monad transform etc.                         [14:36]
<dminuoso> jusss: In general CPS is about returning some kind of
           object/value/thing that requires the consumer to specify how to
           resume, rather than the result itself.
<dminuoso> % :t ($ "foobar")
<yahb> dminuoso: ([Char] -> b) -> b
<dminuoso> This could be thought of as a continuation.
<dminuoso> It's some value, but you don't see it as String/[Char], instead you
           are being asked to specify some function how to resume this
           computation.
<dminuoso> It's a programming style, sort of.                           [14:39]
<ski> jusss : `call/cc' (in the form it's present in Scheme, and SML/NJ), is a
      means to express continuation side-effects
<dminuoso> jusss: They allow you to alter control flow in your program
           differently.                                                 [14:41]
<ski> (`callCC' in `Control.Monad.Cont' is not)
<jusss> dminuoso: instead of if-else?
<dminuoso> jusss: It's much more wide ranging than that.
<dminuoso> jusss: The entire program structure becomes different.
<ski> (however, several people think that composable / delimited / sub- /
      partial continuations, say using `shift' & `reset' (there are some
      alternatives), are better, than using ordinary (undelimited)
      continuations (as with `call-with-current-continuation'))         [14:43]
<jusss> dminuoso: it sounds wonderful! do people use it usually?
<dminuoso> jusss: Yes, sometimes.
<dminuoso> jusss: There's essentially two main reasons: CPS gives you much
           higher control about how to do control flow/exception handling, and
           with CPS you can do things like suspend computations.
* ski . o O ( "Web Programming" by Eli Barzilay at
  <http://tmp.barzilay.org/cont.txt> )                                  [14:46]
<ski> jusss ^
<mniip> here's a library that uses CPS to safely handle allocation of foreign
        types
        http://hackage.haskell.org/package/marshal-contt-0.2.0.0/docs/Foreign-Marshal-ContT.html
<dminuoso> But we dont need CPS to implement either, they might just be a
           useful technique for some problem domains. :)
###########################################################

<jusss> like python has tornado, flask, django, and java has spring stuff,
        what haskell has?
<jusss> Taneb: haskell can work with postgresql?
<Taneb> Yesod, servant, happstack, snap, scotty, warp
<Taneb> jusss: yes                                                      [17:55]
<jgt> jusss: https://lmgtfy.com/?q=haskell+web+framework
<Taneb> jusss: http://hackage.haskell.org/package/postgresql-simple is a
        commonly used library for working with postgresql in Haskell

############################################

CPS, concurrency, Y-combinator, anonymous function recursion,
Cont Monad
inversion of control, dependency injection
effect
side effect

###########################################
docker
docker need root privilege, so
sudo usermod -aG docker john
sudo systemctl start docker
docker image ls #check local images
docker image rm imageName #remove local images
the official repo is Docker Hub
docker image pull library/hello-world #pull an image from the repo
the default is library, so it can be missing here, just pull hello-world is fine
docker container run hello-world #run this image
docker container kill containID #kill it
docker container ls #show the running images
docker container rm containerID #remove the image

search on hub.docker.com, even mysql
docker image pull mysql  or docker pull mysql
usage https://hub.docker.com/_/mysql

docker image pull fauria/vsftpd

[john@CASE ~]$ sudo mkdir /opt/vsftpd
[john@CASE ~]$ sudo chown john:docker /opt/vsftpd/
[john@CASE ~]$ ls /opt/vsftpd/

docker run -d  -v /opt/vsftpd/  -e FTP_USER=test -e FTP_PASS=test  -e PASV_ADDRESS_ENABLE=no --name ftpd fauria/vsftpd 



#####################################################

MaybeT is also a value constructor
MaybeT m is the monad, and return = lift . return , so do in MaybeT m will get the monadic value (Maybe a) from m (Maybe a)

newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
runMaybeT will get m (Maybe a), then do will get Maybe a

instance (Monad m) => Monad (MaybeT m) where
  return = lift . return             -- the context is MaybeT m (Maybe )
  x >>= f = MaybeT $ do    -- add the context MaybeT, 
        v <- runMaybeT x     -- get Maybe a
        case v of
             Nothing -> return Nothing  -- return MaybeT m Nothing
             Just y -> runMaybeT (f y)    -- Maybe a

<dmwit> There is no reason to think that "return calls MaybeT" means "(>>=)
        calls MaybeT". There is no reason to think that "return calls MaybeT"
        means "(>>=) does not call MaybeT".                             [09:38]
<iqubic> return and (>>=) are two separate functions.
<jusss> dmwit: if there's no return, and that MaybeT should be given by f in x
        >>= f                                                           [09:44]
<jusss> dmwit: do we put Just in the x >>= f = Just $ ... when Maybe is the
        monad?
<dmwit> Okay, this question is much better.                             [09:45]
<dmwit> The trick is that we want to use the (>>=) of the transformed monad.
<dmwit> To do that, we must unwrap the MaybeT wrapper that f provides.
<dmwit> But then, to be type-correct, we must rewrap eventually.        

#####################################################

inputString :: MaybeT IO String
inputString = lift getLine      -- so this will lift Maybe into IO String to IO (Maybe String)

t = return 3 :: Maybe Int   -- t will be Just 3, 'cause the context Maybe is claimed in the type

main :: IO ()
main =  do                -- do will get the context IO from the type
     x <- IO a
     return x

use M-x shell RET runghc x.hs   for interactive input haskell code

#########################################

<jle`> liftIO lifts *from* IO, not *to* IO
<jle`> jusss: in any case, you can't really say that the fact that 'liftIO'
       exists means that IOT exists; liftIO is actually backwards from the
       type you would need for IOT to exist                             [11:26]
<dmwit> IOT m a definitely can't be m (IO a), or else we would have e.g. \x f
        -> Just x >>= f :: IO a -> (a -> Maybe (IO b)) -> Maybe (IO b). This
        would be bad, because it would mean we could observe whether the
        function returned Just or Nothing without doing any IO.


##################################################

ffmpeg concat videos

vi mylist.txt
file fileName1.mp4
file fileName2.mp4

ffmpeg -f concat -i mylist.txt -c copy output.mp4

ffmpeg rescaling videos
 If you need to simply resize your video to a specific size (e.g 320x240), you can use the scale filter in its most basic form:
ffmpeg -i input.avi -vf scale=320:240 output.avi
Same works for images too:
ffmpeg -i input.jpg -vf scale=320:240 output_320x240.png
https://trac.ffmpeg.org/wiki/Scaling

x265 hecv encoding
ffmpeg -i input -c:v libx265 -crf 28 -c:a aac -b:a 128k output.mp4

concat videos side by side, make sure they have same resolution first, otherwise rescale them
ffmpeg -i left.mp4 -i right.mp4 -filter_complex "hstack" -c:v libx264 -crf 18 output.mp4

clip videos
ffmpeg -i input -ss start-time -t dust-time -acodec copy -vcodec copy output

filter audio
ffmpeg -i input -vcodec copy -an output

concat videos side by side, and delay one?

#######################################
module ReaderTest where
data Environment = Env
  { firstName :: String
  , lastName :: String
  } deriving (Show)

t2 :: Environment -> String
--t2 x = "Hello " ++ (firstName x) ++ (lastName x)
--t2 x = ( firstName >>= \x -> lastName >>= \y -> return $ x ++ y ) x
-- the interesting thing here is that \x -> lastName is a binary function, we put a prefix \x -> to an unary, then it's binary now
t2  = do
  x <- firstName
  y <- lastName
  return $ "Hello " ++ x ++ y

main = putStrLn (t2 $ Env "John " "Doe")
################################################

haskell-mode on emacs, also python-mode
;;; show line number
(dolist (hook '(python-mode-hook
                javascript-mode-hook
                html-mode-hook
                css-mode-hook
                js-mode
				mhtml-mode
                haskell-mode-hook
		c-mode-common-hook))
(add-hook hook (lambda () (display-line-numbers-mode t))))

;;; python-mode will not eval python buffer if there is threading code
(defun my-python-compile ()
  (interactive)
  (setq tmp-file (concat (buffer-file-name) ".tmp"))
  (write-region (point-min) (point-max) tmp-file)
  (compile (concat "python " tmp-file)))

(add-hook 'python-mode-hook
	  (lambda () (local-set-key (kbd "<f5>") 'my-python-compile)))

;;; haskell-mode, runghc will only read .hs file, so suffix with .tmp.hs
(defun my-haskell-compile ()
  (interactive)
  (setq tmp-file (concat (buffer-file-name) ".tmp.hs"))
  (write-region (point-min) (point-max) tmp-file)
  (compile (concat "runghc " tmp-file)))

(add-hook 'haskell-mode-hook
	  (lambda () (local-set-key (kbd "<f5>") 'my-haskell-compile)))

(setq compilation-save-buffers-predicate '(lambda () nil))
(setq compilation-always-kill t)

##########################################################
Test.hs

module X where
{-# LANGUAGE FlexibleContexts #-}

import Control.Monad.Reader

data Tree a = Leaf a | Node (Tree a) (Tree a) deriving (Show)
mapTree :: (a->b) -> Tree a -> Tree b
mapTree f (Leaf x) = Leaf (f x)
mapTree f (Node xl xr) = Node (mapTree f xl) (mapTree f xr)

data Environment = Env
  { firstName :: String
  , lastName :: String
  } deriving (Show)

helloworld :: Reader Environment String
helloworld = do
  f <- asks firstName
  l <- asks lastName
  return ("Hello " ++ f ++ l)

runHelloworld :: String
runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
                         
main = putStrLn runHelloworld

#########################################################

#Reader #Monad

<jusss> return x = \_ -> x is return = \x -> \_ -> x
const = return in Reader, const is the unit in the monoid >>=

(+1) >>= return   this will return an unary function, so if you give it a input, it outputs a result, return takes two input, the first one is (+1)'s result, the second one is (+1)'s input, and it will return (+1)'s result

f x = f x, based on eta-conversion
f = \x -> (f x)
f y = (\x -> f x) y

f >>= return   =    f >>= \x -> return x     =   f

<jusss> ( (+1) >>= return ) 2   -- this one, the (+1)'result is 3, we pass 3
        to return as its firt input, and the context is 2, we pass 2 as
        return's second input, right?                                   [09:44]

<jle`> jusss: one way to find out --- you can just expand all of the
       definitions                                                      [09:45]
<jle`> of (>>=) and return
<jle`> ( (+1) >>= (\r _ -> r) ) 2
<jusss> jle`: that would be (+1) >>= return = \x -> return ((+1) x) x   [09:46]
<jle`> yeah, which is \x -> const (x + 1) x, which is \x -> (x + 1)

<jusss> jle`: I want the intuition...                                   [09:49]
<jusss> my intuition is ok? 
<jle`> if you think of it as monadic actions, the "result" of (+1) is 3, and
       the "result" of `return 3` is then therefore 3 as well
<EvanR> lambdas are the intuition, >>= return are notation
<jle`> if you want to think of reader actions as monadic actions with results,
       the "result" of the (+1) action there is 3 yes, when you apply the
       whole thing to 2
<jle`> consider another example using do notation, if you are trying to get
       away from the literal function applications:                     [09:52]
<jle`> one = do x <- sin; y <- cos; return (x^2 + y^2)
<jle`> if you do `one 0.2`, for instance, the "result" of the `sin` action is
       0.199, the "result" of the `cos` action is 0.980
<jle`> and the final result is then 0.199^2 + 0.980^2                   [09:54]
<jle`> @let one = do x <- sin; y <- cos; return (x^2 + y^2)
<lambdabot>  Defined.
<jle`> > one 0.2
<lambdabot>  1.0
<jusss> and return 0.199^2+0.980^2 0.2
<jle`> the final result is 0.199^2 + 0.980^2, which is approcimately 1.0
<jle`> > 0.199^2 + 0.980^2
<lambdabot>  1.000001
<jle`> the result of `return blah` is `blah`                            [09:55]
<jle`> this is the abstract intepretation in terms of monadic actions and
       results.  written in do notation it hides what is going on underneath
       to emphasize the "action/result" interpretation, but you can recover
       what is going on by doing the desugaring                         [09:57]
<jle`> writing 'sin'/'cos' inline like that, though, is pretty bad for
       readability.  so sometimes we use something like 'ask' to help remind
       us that we are thinking in terms of monadic actions              [09:58]
<jle`> in this case ask = id
<jusss> jle`: the term "action", what is it?
<jle`> it's somewhat meaningless, but it's a way to interpret lines of a do
       block
<jle`> where you imagine each line is sequencing some series of monadic
       actions (values of type `M a`)                                   [09:59]
<jle`> and each line has a result, and the result of the final line is the
       result of the entire do block
<jle`> *result of the final action
<jle`> more generally it is an abstract word to help us interpret values of
       type `M a` for some monad M...also known as monadic values or motes
       etc.                                                             [10:00]
<jle`> but choosing the word 'action' emphasizes the fact that we're
       sequencing a bunch of them, potentially using the results they produce
                                                                        [10:01]
<jle`> choosing to use the word 'action' in a particular
       explanation/interpretation, i mean
<jle`> for example in do x <- getLine; putStrLn ("hello " ++ x), we have two
       actions sequenced one after the other on each line of the do block, and
       the result of the first action is called x (and is the reuslt of
       getLine)                                                         [10:02]
<jle`> in do x <- [1,2,3]; y <- [4,5,6]; return (x + y), we have three actions
       sequenced, where the result of the first action is bound to x, and the
       result of the second action is bound to y
<jle`> and the result of the third action is (x + y)
<jle`> it's just one way of interpreting the things you are sequencing in a do
       block, or >>'s/>>='s                                             [10:03]
<jusss> ok


#############################################

(isEven >>= \i ->
       if i then double
       else half) y

isEven = \x -> 
	if (x mod 2) == 0 then True
	else False
halt = \x -> (x div 2)
double = \x -> x*2
algo y = if (isEven y) then (double y)
	else (halt y)

<dminuoso> jusss: With the monad instance you'd write: do { i <- isEven; if i
           then double else half } y                                    [14:24]
<dminuoso> Or, using >>= explicitly: (isEven >>= \i -> if i then double else
           half) y
<dminuoso> It's still the same code, except the monad instance makes argument
           passing implicit.                                            [14:25]


###########################################################

<jusss> like in Maybe, there're Just and Nothing in the context, so what's in
        the context of functions?
<pacak> It passes around  value you pass in.                            [10:37]
<jusss> pacak: so if e->a and e-> is the monad, then a is the result of the
        function, right?                                                [10:38]
<pacak>
        http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-828
<jusss> pacak: and the context is the function (->) and input e
<jusss> 
<pacak> I guess so                                                      [10:39]
<jusss> :t (.)                                                          [10:40]
<lambdabot> (b -> c) -> (a -> b) -> a -> c
<jusss> if a-> is the context, input a and function (->) is the context, the
        result b is the a in f a, right? so (.) will apply a function (b->c)
        on another function (a->b) and get a new function (a->c) , which has
        the same context (a->) but changed the result                   [10:44]
<jusss> ?
<pacak> (a->) stays the same, value changes.                            [10:45]
<jusss> pacak: but hey, when it's in >>= , it seems diffrent
<jusss> :t (>>=)                                                        [10:46]
<lambdabot> Monad m => m a -> (a -> m b) -> m b
<pacak> (a ->) sits inside m
<jusss> >>= :: (e->a) -> (a->(e->b)) -> (e->b)

>>= apply a->mb on m a and get m b
e-> is what in the context, the input e and the function (->)
so (.) apply b->c on a->b , changed the result b to c and attatch the context a->
we get a->c,   f . g x = f (g x)
>>= apply a->e->b on e->a and get e->b
so a->e->b is a binary function and e->a is an unary function
let's assume x :: e and f :: e->a, g :: a->e->b, so g (f x) x :: b
a->e->b work on a then get b, attatch the context e->,  so e->b
but a->e->b need e->a's result a and e->a's input

the input and the result both are not coming yet in the context

instance Monad ((->) r) where
    f >>= k = \ r -> k (f r) r

instance Functor ((,) a) where
    fmap f (x,y) = (x, f y)

instance  Functor Maybe  where
    fmap _ Nothing       = Nothing
    fmap f (Just a)      = Just (f a)


newtype State s a = State { runState :: s -> (a,s) }  
(>>=) :: State s a -> (a -> State s b) -> State s b  

    instance Monad (State s) where  
        return x = State $ \s -> (x,s)  
        (State h) >>= f = State $ \s -> let (a, newState) = h s  
                                            (State g) = f a  
                                        in  g newState

data Reader r a = Reader {  runReader :: r -> a }
date Reader r a = Reader r->a
runReader Reader r a :: r->a
#######################################################

newtype Writer w a = Writer { runWriter :: (a, w) }
it means
data Writer w a = Writer (a, w)
runWriter :: Writer w a -> (a, w)

(a,w) is a type,
if x :: a and l :: w, then (x,l) :: (a,w)
() is the type of the value ()
() :: ()
the unit type, or the empty tuple type, and the value the empty tuple
<ski> in the MLs, you have `(2,"true",false) : int * string * bool' and `() : unit'
<Ariakenom> ski: is the ML type x * y * z special syntax or some inductive
            tuple?                                                      [15:29]
<Athas> Ariakenom: it's just (x,y,z).                                   [15:30]
<Athas> ML has odd syntax, including postfix application of type constructors.
<EvanR> i know x * y * z is effectively (x,y,z), but that doesn't tell me
        whether (x * y) * z means the same thing or different thing as x * (y
        * z)
<Ariakenom> Athas: so (x * y) * z  /=  x * (y * z)  /=  x * y * z ?
<Athas> Right.                                                          [15:32]
<Ariakenom> (I meant to say they're all different)
<EvanR> wacky
<Athas> It's still magical syntax, even though it looks like repeated
        application of an infix operator.
<Athas> Haskell did this one better.
<Athas> (As with most things syntax.)
* EvanR doesn't mention record field syntax
<Athas> Everybody lost that battle, except OCaml.

########################################################################

22:52:30 <jusss> what is Functor composition?
23:01:35 <jusss> ski: f . g is function composition?
23:03:26 <ski> if `f' is a function from `T' to `U', and `g' a function from `U' to `V', (`T',`U',`V' being types / (structural) sets), then `g . f' is a function from `T' to `V', the composition of `g' after `f'. defined by `(g . f) x = g (f x)', for all inhabitants/values `x' in `T'
23:05:37 <ski> if `F' is a functor from `C' to `D', and `G' a functor from `D' to `E', (`C',`D',`E' being categories), then `G . F' is a functor from `C' to `E', the composition of `G' after `F'. defined on all objects `A' of `C' by `(G . F) A = G (F A)' (result is an object in `E'); and defined, for all objects `A',`B' of `C', on all morphisms `f' (in `C') from `A' to `B', by `(G . F) f = G (F f)' (result is a morphism (in `E') from `G (F A)' to `G (F B)')
23:08:07 <ski> in Haskell, an instance `f' of the type class `Functor' (iow an `f' where `Functor f' holds) must be a type `f' of king `* -> *', so the from and to categories (say `C' and `D' above) would both be the same category, corresponding to `*', sometimes written `Hask'. so `f' is a functor from `Hask' to `Hask' (both `C' and `D' being `Hask'), iow an *endo*functor (on `Hask')
23:11:04 <ski> one could also talk about functors between other categories in Haskell, but they wouldn't be instance of the type class `Functor' (which is only for endofunctors on `Hask')
23:11:04 <ski> e.g. if one defines `newtype StreamVia f a = SV (f (a,StreamVia f a))', then `StreamVia' is a functor to `Hask', from : the category of all functors from `Hask' to `Hask'. iow from the category of endofunctors on `Hask'
23:11:12 <ski> er, actually, sorry, the "to" is also that functo category here, not `Hask'
23:11:50 <ski> let's say `newtype IntegerStreamVia f = ISV (f (Integer,IntegerStreamVia f))' instead, to remedy that
23:12:46 <ski> in terms of Haskell kinds, we then have `IntegerStreamVia :: (* -> *) -> *' (`StreamVia :: (* -> *) -> (* -> *)' for the other one) -- but that doesn't say anything about `Functor'
23:14:14 <ski> one could imagine writing something like `IntegerStreamVia :: {f :: * -> * | Functor f} -> *', or `IntegerStreamVia : Hask^Hask >---> Hask' (in more "mathematical" notation)
23:15:36 <ski> for simpler cases, like `Maybe',`Either e' (for some `e :: *'), we get `Maybe :: * -> *',`Either e :: * -> *' (or `Maybe : Hask >---> Hask',`Either e : Hask >---> Hask')
23:16:27 <ski> we can compose `Maybe' and `Either e', in either way (let's take `Maybe' after), so `Maybe . Either e :: * -> *' (or `Maybe . Either e : Hask -> Hask')
23:17:03 * ski looks at jusss, idly wonders whether they're bewildered yet
23:20:02 <dminuoso> You probably intimidated them. ;)
23:22:30 <ski> anyway, `Either e' is a functor from `Hask' to `Hask', because it will accept one concrete type (like `Integer'), before producing a concrete type (then `Either e Integer') (assuming `e' is a concrete type, a type of kind `*', the type would be an object in the category `Hask' of all concrete types)
23:22:30 <ski> anyway, `Either e' is a functor from `Hask' to `Hask', because it will accept one concrete type (like `Integer'), before producing a concrete type (then `Either e Integer') (assuming `e' is a concrete type, a type of kind `*', the type would be an object in the category `Hask' of all concrete types)
23:25:24 <ski> what then is `Either' ? it will accept a concrete type `e' (an object in `*' / `Hask'), and produce a type `Either e' (a functor from `*' / `Hask' to itself). iow produce an object in the category of endofunctors on `*' / `Hask', written `{f :: * -> * | Functor f}' / `Hask^Hask' above
23:26:41 <ski> iow, `Either :: * -> {f :: * -> * | Functor f}' is a functor from `*' to `{f :: * -> * | Functor f}'. in other notation, `Either : Hask >---> Hask^Hask'
23:27:50 <ski> combining that with `IntegerStreamVia :: {f :: * -> * | Functor f} -> *' / `IntegerStreamVia : Hask^Hask >---> Hask'. composing that functor `IntegerStreamVia' after `Either', we get `IntegerStreamVia . Either :: * -> *' / `IntegerStreamVia . Either : Hask >---> Hask'
23:28:51 <ski> (and i'll stop here. the point/goal was to show a slightly more complicated composition than say `Maybe . Maybe' or `Maybe . Either e', where the categories involved were not all `*' / `Hask')

########################################################################

#compose monad and monad transformer

compose two functors and get a functor,
compose two applicatives get an applicative
but compose two monads may not get a monad, by Compose, or :.: Maybe :.: IO
that's why monad transformer come,
monad transformer is a type function, it takes a monad and return a monad, MaybeT IO
>=> is composition of functions "into" monads

Compose Monad is from Data.Functor.Compose.Compose
<tsahyt> :t Data.Functor.Compose.Compose
<lambdabot> forall k1 k (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) ->
            Data.Functor.Compose.Compose f g a

monad is a type-function of kind *->*
but you can compose type-functions with :.:, and it's a type level
:k (:.:)
<yahb> dminuoso: (:.:) :: (k2 -> *) -> (k1 -> k2) -> k1 -> *
<dminuoso> jusss: So if `(f . g) x = f (g x)`, can you solve `(Maybe :.: IO)
           Bool = ...`  ? :)                                            [15:35]
<jusss> dminuoso: Maybe (IO Bool) ?                                     [15:38]
<dminuoso> jusss: Indeed. Now they are not fully equal, but isomorphic.

Maybe :.: IO is the composition of Maybe after IO
:.: is an infix of Data.Functor.Compose

<dminuoso> jusss: A monad transformer is a type function that, itself, accepts
           a monad and gives you a new monad back
<dminuoso> jusss: So it sort of transforms a monad into a new monad.

import Control.Monad.Trans.Maybe
monad transformer MaybeT :: (*->*)->*->*
it takes a monad which kind is *->* and return a monad which kind is *->*

MaybeT IO gives you a new monad
MaybeT (Either a) gives you a monad

(Maybe :.: IO) Bool is a monad composition,
(MaybeT IO) Bool, MaybeT is the monad transformer, MaybeT IO is a new monad

<dminuoso> jusss: If F is a functor, and G is a functor, then (F :.: G) is
           also a functor. but when both F and G are monad, then `F :.: G` is
           not necessarily a monad. So you cant combine them into new monads
           arbitrarily.                                                 [15:49]
<dminuoso> jusss: Which is a shame, because it means we cant just arbitrarily
           compose the effects we want. So if we want the effect of both F and
           G we need something else, we can't just compose them together.
<jusss> dminuoso: that's why monad transformer come?
<dminuoso> jusss: Indeed.
<dminuoso> jusss: So instead of composing (Maybe :.: IO) and hoping for a
           monad, we create a type function that takes an arbitrary monad, say
           IO, and "gives it the exception-effect of Maybe" and returns the
           new monad.                                                   [15:52]
<dminuoso> jusss: So MaybeT transforms an arbitrary monad by giving it
           "exception effects"
<dminuoso> jusss: The cool trick is, MaybeT works on *any* monad. :)    [15:53]
<dminuoso> jusss: MaybeT is not a monad, so it cant be applied to itself.

MaybeT is a type function, we can compose two type functions with :.:

<dminuoso> jusss: The type system works differently, :.: is not exactly
           "evaluated to some definition"                               [15:58]
<dminuoso> jusss: So :.: sort of acts like composition, but it creates a new
           type in the process.
<jusss> dminuoso: then what it's used to? Maybe :.: IO
<dminuoso> jusss: Its when we want to capture the composition as a separate
           entity.
<dminuoso> jusss: So (:.:) is a type constructor at the end, so its not just a
           type function.           
<dminuoso> jusss: `(Maybe :.: IO) Bool` is not equal to `Maybe (IO Bool)`,
           it's rather comparable to it. The first gives you a brand new type
           in comparison.                                               [16:06]
<dminuoso> jusss: The usefulness stems from being able to write instances like
           `instance (Functor f, Functor g) => Functor (f :.: g)` which only
           works if :.: computes a new type
<dminuoso> jusss: The thing is, while you have things like "type functions"
           and sort of "evaluation at the type level", its a different
           language. The type system in itself can be thought of a separate
           programming language that isnt concerned with "database calls" or
           "drawing images"           

#######################################################
compose monads is like combine two set to new one,
and there're value constructor in that set or called context,
so we can have two effect constructors in the new one and have two effects
MaybeT IO we can have Maybe's exception effects by its Nothing in the context


think context as a set, Maybe has a context, there're two values in the context, Just and Nothing
Either has Left and Right in the context
3 is a normal value, Just 3 is a fancy value, is a data type
Just a >>= you can "return" Just a or Nothing
Nothing >>= you can only "return" Nothing
Left a >>= you can "return" Left a
Right a >>= you can "return" Left a or Right a
the unit in >>= is "return", and return can pick value constructor from the context and combine one

>>= will split the data type and get its mornal value, and then it picks one value constructor from
its context and combine it to a data type then return it

return is the unit, the identity law in >>=, so
m >>= return = m
id is the unit in the monoid (.), so
f . id = f

semigroup: mappend is for the associativity law, two combine to one, and (a<>b)<>c = a<>(b<>c)
monoid: the associativity law , identity law,  x+0=x, f . id = f,  0 and id is the unit, + and . is the monoid
the associativity law (f . g) . h = f . (g . h),   m>>=f>>=g  =  m >>= \x -> f x >>= g


(>>=) :: Either e a -> (a -> Either e b) -> Either e b
(>>) :: Either e a -> Either e b -> Either e b
return :: a -> Either e a
fail :: String -> Either e a 

instance Monad (Either e) where
    Left  l >>= _ = Left l
    Right r >>= k = k r

either :: (a -> c) -> (b -> c) -> Either a b -> c
use either can get the normal value in Left a or Right a
either id id (Left 3) = 3
either id id (Right 2) = 2

either f _ (Left x)     =  f x
either _ g (Right y)    =  g y

-- | Promote a function to a monad.
liftM   :: (Monad m) => (a1 -> r) -> m a1 -> m r
liftM f m1              = do { x1 <- m1; return (f x1) }

Prelude> import Control.Monad
Prelude Control.Monad> :t liftM
liftM :: Monad m => (a1 -> r) -> m a1 -> m r
Prelude Control.Monad> liftM (+1) (Just 2)
Just 3
Prelude Control.Monad> Just (+1) <*> (Just 2)
Just 3

liftM :: (a->b) -> f a -> f b
<*> ::  f (a -> b) -> f a -> f b
pure :: a -> f a

aha, liftM is fmap, ap is <*>
ap :: Monad m => m (a -> b) -> m a -> m b
and ap is the Monad version of <*>

<tsahyt> all monads are applicatives, all applicatives are functors.
<tsahyt> but not the other way round. there are functors that aren't
         applicatives, and there are applicatives that aren't monads.
<tsahyt> the Const functor apparently
<tsahyt> jusss: monad transformers are actually something you can use to "get
         around" the problem of composing monads.                       [15:26]
<tsahyt> that's why they exist. otherwise we'd probably just use Compose*
<tsahyt> jusss: and >=> is composition of functions "into" monads (or Kleisli
         arrows, if you wanna be technical), not of the monads themselves

<jusss> tsahyt: to make a type as an instance of typeclass Monad, it has to
        implement how many functions at least?
<tsahyt> jusss: return and (>>=). but return is also in Applicative (called
         pure), so it's really just (>>=).                              [15:21]
<jusss> like >>= and return is nessecary
<tsahyt> ah and indeed the docs now name (>>=) as the minimal complete
         definition
<tsahyt> so it's only >>= now, because Applicative is a superclass of monad
                                                                        [15:22]
<jusss> tsahyt: does that mean it has to be an instance of Functor and
        Applicative first?
<tsahyt> yes
<jusss> so there're four functions to make a type become an instance of monad,
        fmap, <*>, pure and >>= ?                                       [15:24]
<tsahyt> jusss: but perhaps most importantly, stuff you get out of
         Compose. you can compose functors together with it, and the
         composition of two applicatives are also always an applicative. but
         the composition of two monads may not be a monad.        

http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html
find Monad (Either e) click the # Source will get its function definition
click the '+' before it will get its type signature 'bout >>=
or http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html

######################################################################

t = [(+)] <*> [1,2]
t is [(+1), (+2)] :: Num a => [a->a] , so you need a way to get (+1) out of [(+1)] to do something
t >>= \x -> return (x 1)    = [2,3]
t <*> [1,2]                          =[2,3,3,4]

Prelude| t2 = do
Prelude| n <- [(+1),(+2)]
Prelude| m <- [1]
Prelude| return (n m)
Prelude| :}
Prelude> t2
[2,3]

Just because something is made an instance of the Monad type class doesn't mean that it's a monad, it just means that it was made an instance of a type class. For a type to truly be a monad, the monad laws must hold for that type.

left identity:
return x >>= f       =      f x
right identity:
m >>= return        =      m
associativity:
m >>= f >>= g     =      m >>= (\x -> f x >>= g)

Reader is not the other monads
when m ~ e->
>=> f g x y = g (f x y) y
f >=> g = \x -> \y -> g (f x y) y

but m ~ []
>=> :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
>=> :: (a->[b]) -> (b->[c]) -> (a->[c])
f ::(a->[a])
f x = [x]
g :: b->[b]
g x = [x+1]
>=> f g 3 = [4]

if m~e-> you give it three parameters it supposes to return a function, four to return value
but m~[] you give it three parameters, it returns a list
check the type, it's not necessary to be four, a -> e-> b, can be f g :: a->e->b
the polymorphic, you give functions to >=>, and it returns functions
you give lists to >=> and it returns lists

<jusss> dmwit: did f <=< (g <=< h)  =   (f<=<g) <=< h?
<dmwit> That equation is fine.
but  m >>= f >>= g is not equal to m >>= (f >>= g)
m >>= f >>= g  =   m >>= (\x -> f x >>= g)

<jusss> m x >>= \x -> m y >>= \y -> x+y
<jusss> equal m x >>= \x -> ( m y >>= \y -> x + y) ?


(m >>= f) >>= g      =        m >>= (f >>= g)                                   incorrect!
m >>= f >>= g         =        m >>= (\x -> f x >>= g)                      correct!
f >>= g                      =       \x -> (f x) >>= g                                 incorrect
f <=< (g <=< h)        =       (f<=<g) <=< h                                    correct!
(f . g) . h                     =        f . (g . h)                                               correct!
f >=> g                      =       \x -> (f x) >>= g                                   correct!
m >>= f >>= g         =       m >>= (f >=> g)                                   correct!
f >>= g                       =    \x -> f (g x)                                            correct!

the associative law
(f . g) . h = f . (g .h)
(f >=> g) >=> h = f >=> (g >=> h)
m >>= f >>= g = m>>= (\x -> f x >>= g)



semigroup has associative law (a<>b)<>c = a<>(b<>c)
monoid has associative law and identity law
the right identity law
a `op` unit = a  
the left identity law
unit `op` a = a


<jusss> dminuoso: instances of monads can turn to instances of monoid and
        semigroup?
<dminuoso> jusss: Yes, for example through the EndoKleisli construction I have
           just shown you.                                              [18:06]

return is the unit,
<jusss> dminuoso: the unit, if return is the unit, then f >>= return = f?
<dminuoso> jusss: Yes!

<jusss> (>>=) :: Either e a -> (a -> Either e b) -> Either e b 
<jusss> return :: a -> Either e a

<dminuoso> jusss: So here's the lie: the additional requirement for Semigroup
           and Monoid is something called "closure". The operation in question
           must take two things of exact same type and return something of the
           exact same type back.

<dminuoso> % :t (>=>)
<yahb> dminuoso: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
<dminuoso> As you can see this doesnt fit the bill, becaue the types vary.
<dminuoso> We could however make it a monoid if we somewhat constrict it.
<dminuoso> If we say "what if a ~ b ~ c", then we'd have `(a -> m a) -> (a ->
           m a) -> (a -> m a)` and we could certainly make a Semigroup and
           Monoid instance for that.                                    [17:58]
<jusss> dminuoso: wow
<dminuoso> jusss: Its the same thing with (.) by the way. And there is a
           newtype wrapper that does exactly that, its called Endo.

<jusss> :t (>>=)
<lambdabot> Monad m => m a -> (a -> m b) -> m b
<jusss> m a ->(a -> m a) -> m a?
<dminuoso> jusss: Doesnt fit the "both input types and the output types must
           be the same" rule                                            [18:00]
<jusss> dminuoso: no
<dminuoso> jusss: But we could use it as the underlying implementation
           regardless
<dminuoso> jusss: So this is what the Monoid would look like:           [18:01]
<dminuoso> % newtype EndoKleisli m a = EndoKleisli { appEndoKleisli :: a -> m
           a }
<yahb> dminuoso: 
<dminuoso> % instance Monad m => Semigroup (EndoKleisli m a) where EndoKleisli
           kl <> EndoKleisli kr = EndoKleisli kl >=> kr
<dminuoso> % instance Monad m => Semigroup (EndoKleisli m a) where EndoKleisli
           kl <> EndoKleisli kr = EndoKleisli (kl >=> kr)
<dminuoso> % instance Monad m => Monoid (EndoKleisli m a) where mempty =
           EndoKleisli return                                           [18:02]
<dminuoso> jusss: So (>=>) is actually something more general than a Monoid
           because the types sort of vary, and we don't call this "A
           semigroup" or "A monoid" but "A category". :)                [18:04]
<dminuoso> But this is quickly getting into mathematical topics
<jusss> dminuoso: instances of monads can turn to instances of monoid and
        semigroup?
<dminuoso> jusss: Yes, for example through the EndoKleisli construction I have
           just shown you.                                              [18:06]
<jusss> dminuoso: I think I can't follow this right now...
<dminuoso> jusss: Then dont. Note that none of this is relevant to practical
           Haskell programming, you can become a proficient programmer without
           understanding any of this.
<dminuoso> I just sort of digressed.           

##################################################################

action computation context with monad

Maybe is the Monad, Just is the context

3 is normal value, Just 3 is added context Just to 3 and get a data type Just 3, this is called pure
return :: a-> m a, if there's no >>= to get the m, return will be pointless,
you can't return 3 to get Just 3 or Left 3, 'cause there's no m
you can only get m when return is used in >>=,
and it's like >>= split m to an namespace and bound m

Just 3 >>= f  , >>= will split Just and store Just as m,
so return will get Just when it finds m in the current temporary namespace
it's like (let ((m Just)) ...)

(>>=) = (lambda (m a f)
                (return m f a))

pure or return is used for \x -> ... , when f is \x -> ...
otherwise we use pattern matching to do that, no need for pure or return

<*> (Just f) (Just x) = Just (f x) = \x -> return (f x)
fmap f (Just x) = Just (f x) = \x -> return (f x)
>>= (Just x) (f =(\x -> return (doSomeThing x))) = f x




<jusss> :t fmap (-) [3,4]                                               [16:03]
<lambdabot> Num a => [a -> a]
<jusss> :t (-)
<lambdabot> Num a => a -> a -> a
<jusss> :t fmap
<lambdabot> Functor f => (a -> b) -> f a -> f b
<jusss> why we can put (-) into fmap?                                   [16:04]
<merijn> jusss: Well, why not?
<jusss> merijn: 'cause it's (a->b)
<merijn> jusss: 'b' is allowed to be 'a -> a'
<merijn> jusss: Remember that "a -> b -> c" is equivalent to  "a -> (b -> c)"
<jusss> merijn: so it's fmap :: (a->(a->a)) -> f a -> f (a->a) ?
<merijn> jusss: Yes
<jusss> and fmap (-) [3,4] == [(-)3 , (-) 4] ?
<merijn> Yes                                                  
<merijn> jusss: Because the Applicative for list does cross-product     [16:11]
<merijn> It applies every function from the first list to every value from the
         second
<merijn> jusss: There are, in fact, two lawful Applicatives for lists. Cross
         product (the default one) and "zip"
<jusss> merijn: then it should be [2,1,0,3,2,1]
<merijn> > (-) <$> ZipList [3,4] <*> ZipList [1,2,3]
<lambdabot>  ZipList {getZipList = [2,2]}
<jusss> yeah, map (-) 3 on the second list get [2,1,0]
#############################################

f :: a->b; f=undefined
fish::Monad m => (a->m b)->(b->m b) ->(a->m b); fish=undefined
:t (fish (return . f) return)

##########################################################

CUDA GPU Accelerated h264/h265/HEVC Video Encoding with ffmpeg

download ffmpeg with enable_nvenc and enable_nvdec version
https://ffmpeg.zeranoe.com/builds/win64/static/ffmpeg-20190708-f83b46e-win64-static.zip

>ffmpeg.exe -hwaccel cuvid -i Desktop\IMG_0667.MOV -c:v h264_nvenc -pix_fmt yuv420p -preset slow -rc vbr_hq -b:v 8M -maxrate:v 10M -c:a aac -b:a 224k outmovie.mp4

https://ntown.at/de/knowledgebase/cuda-gpu-accelerated-h264-h265-hevc-video-encoding-with-ffmpeg/

Encoding high quality h264 video with CPU only:
ffmpeg.exe -i inmovie.mov -c:v libx264 -pix_fmt yuv420p -preset slow -tune film -crf 19 -c:a aac -b:a 224k outmovie.mp4

Encoding high quality h264 video via GPU:
ffmpeg.exe -hwaccel cuvid -i inmovie.mov -c:v h264_nvenc -pix_fmt yuv420p -preset slow -rc vbr_hq -b:v 8M -maxrate:v 10M -c:a aac -b:a 224k outmovie.mp4

Encoding high quality h265/HEVC 10-bit video via GPU:
ffmpeg.exe -hwaccel cuvid -i inmovie.mov -pix_fmt p010le -c:v hevc_nvenc -preset slow -rc vbr_hq -b:v 6M -maxrate:v 10M -c:a aac -b:a 240k outmovie.mp4

but this ffmepg require a higher version nvida driver than 418.31

#####################################################

there's no a general way to get its function definition through its type

add :: Int -> Int
assume x :: Int
at least we get one fit function add x = x, but there's also add x = x+1 fit it up

one type may have multiple function definitions

>>= :: m a -> (a -> m b) -> m b
when m is e-> and x :: m, f :: m a, g :: a -> m b
we can get >>= f g x == b == g ( f x ) x

but when m is Maybe
>>= :: Maybe a -> (a -> Maybe b) -> Maybe b

we can not get its function definition through its type signature

not all the function can get its function definition through its type signature

there's a syntax sugar, which is
>>= f g x = g (f x) x , this can be turn to >>= f g = \x -> g (f x) x
<dmwit> jusss: `>>= f g x = ...` is defined to mean `>>= f g = \x -> ...`
        (and, therefore, to mean `>>= = \f -> \g -> \x -> ...`)

<jusss> dmwit: does this transformer or syntax sugar has a name?
<dmwit> Not one I know.
<jusss> ok then                                                         [11:47]

Reader and not Reader
it seems only monad is e-> we can do type inference to get the function's definition
otherwise we may not, that's why Reader is special
'cause when m is e-> and m b is e->b, we can make x as e then give it a x to get b
f :: e-> b
x :: e
f x :: b

#1 from its type get its function definition

>>= :: m a -> (a -> m b) -> m b
when m is e->
>>= :: (e->a) ->(a -> (e->b)) -> (e->b)
f :: e->a
g :: (a -> (e -> b))
x :: e

>>= f g x == b == g (f x) x 

and the sugar syntax  >>= f g = \x -> g (f x) x

<bifunctorial> every type is inhabited in haskell though

#2 get its type through other types

fmap . fmap :: ?
(a -> b) -> f1 (f2 a) -> f1 (f2 b)

#3 get new function from other  functions

fmap :: (a->b) -> f a -> f b
<*> :: f (a->b) -> f a -> f b
pure :: a -> f a

i :: f a
j :: a ->b

fmap j i = f b
<*> (f j) i = f b
now we need get the f j

pure j = f j

fmap j i == f b == <*> (pure j) i
j <$> i = (pure j) <*> i


(.) :: (b->c) -> (a -> b) -> (a->c)
let's assume c = m b              #mark two
(.) :: (b-> m b) -> (a->b) -> (a-> m b)
return :: a -> m a                     #mark one
return :: b -> m b
f :: a->b
(.) return f :: a-> m b

>>= g (return . f) = fmap f g
f <$> x = x >>= (return . f)

for all c, you can use any b to instead of c  #mark three

>=> :: (a-> m b) -> (b-> m c) -> a -> m c
>>= :: m b -> (b -> m c) -> m c

f :: a-> m b
g :: b -> m c
x :: a

>=> f g x :: m c :: >>= (f x) g
after the sugar syntax
>=> f g = \x -> >>= (f x) g
infix
f >=> g = \x -> (f x) >>= g

<dminuoso> jusss: So things get easier if we adopt the explicit forall
           notation.                                                    [16:53]
<dminuoso> (>>=) :: forall m a b. Monad m => m a -> (a -> m b) -> m b   [16:54]
<dminuoso> The "forall m a b" merely means "for every choice of m, a, b ... ",
           which indicates that the occurance of "m", "a", and "b" in the
           right side is actually introduced through "forall"


get function definition from its type signature when m is e->

m~e->
fmap :: (a->b)->(b->c)->(a->c)
f :: a->b
g :: b->c
x :: a
fmap f g x :: c = g (f x)     sugar syntax fmap f g = \x -> g (f x)
<*> :: (a->b->c)->(a->b)->(a->c)
<*> f g x :: c = f x (g x)
>>= :: (e->a)->(a->(e->b))->(e->b)
>>= f g x :: b = g (f x) x
>=> :: (a->e->b)->(b->e->c)->a->e->c
>=> f g x y :: c = g (f x y) y

j <$> i = (pure j) <*> i
f <$> x = x >>= (return . f)
f >=> g = \x -> (f x) >>= g

f <$> g = \x -> g (f x)
f <*> g = \x -> f x (g x)
f >>= g = \x -> g (f x) x
f >=> g = \x -> \y -> g (f x y) y

#type inference

1. there're how many type variables in the type signature, then you need the exactly variables in the function defintion, (or by -> ?)
2. only when m is e->, get a function definition based on its type signature
3. inference functions to function, no need variables if it's no need to resolve

#################################################################

so any types which kind is *->* and implement those functions make them as instances of Monad, so they become Monad, right?

can we get bind through >=> and unit ?

Monad:  1. types's kind is *->*   2. implement bind apply fmap functions 

01:34:06 <dminuoso> jusss: In principle we could give you two functions "pack :: a -> IO a" and "then :: IO a -> (a -> IO b) -> IO b"
01:34:17 <dminuoso> jusss: The point of Monad is just this observation
01:34:46 <dminuoso> You also have two functions packState :: a -> State s a; nextState :: State s a -> (a -> State s b) -> State s b
01:35:17 <dminuoso> jusss: Monad is just the observatoin that all these function look the same way. So instead of making up a new function name every time, they just share the same function name.
01:35:23 <dminuoso> That pretty much all there is to Monad.
01:35:55 <merijn> jusss: Monad instances don't add anything to a type, the same functionality would exist without Monad. The monad instances just allow us to conveniently reuse operators (and syntactic sugar) and write code that is generic across multiple instances of Monad

02:02:57 <dminuoso> jusss: So if we again think of (>>=) as a family of functions indexed by a type m, then the index type is of kind (* -> *)
02:03:12 <jusss> dminuoso: ok
02:03:39 <dminuoso> jusss: Now, we still cant pick an arbitrary type of kind * -> * either.
02:04:01 <jusss> dminuoso: until?
02:04:24 <dminuoso> jusss: The limitation is, whatever type you pick, let's call it t0, there must be an instance Monad t0
02:04:28 <dminuoso> Nothing more.


#Monad Types

before being monads, State and Reader are just types, just like Maybe and Either,
they don't have to be monads, until they have an instance of Monad through implement
bind apply map join and return functions

01:27:12 <jusss> State and Reader are types right
01:27:17 <dminuoso> jusss: Yes.
01:28:26 <jusss> dminuoso: before it's a monad, it just is a type? until we implement that bind apply  fmap mempty functions
01:28:47 <merijn> jusss: "being a monad" is a property of some types
01:28:47 <dminuoso> jusss: "It being a monad" just means there exists an instance Monad for that type. :)

01:29:12 <dminuoso> jusss: Perhaps its cleaner to think "IO is not a monad. IO just have an instance Monad"
01:29:34 <merijn> jusss: "foo :: m Int" <- here 'm' is a type that has kind "* -> *"
01:29:35 <dminuoso> (It's technically not correct, but perhaps this mindmodel is more helpful for you)
01:30:08 <dminuoso> jusss: The usefulness from this phrasing is to stop thinking about 'what is it about IO that it makes a "monad" and what does "being a monad mean"'
01:30:16 <merijn> jusss: "bar :: Monad m => m Int" <- here 'm' is a type that has kind "* -> *" *and* that type has to have a Monad instance (alternatively "that type has to be a monad")
01:30:25 <dminuoso> jusss: And it introduces the idea that "Monad" is just an interface (like say in Java), consisting of just two functions.
01:30:28 <EvanR> sometimes you can implement a typeclass properly in more than 1 way
01:30:38 <dminuoso> jusss: And IO conforms to that interface.
01:31:21 <merijn> jusss: I always like to explain constraints like "foo :: Monad m => m Int" as: IFF 'm' has an instance of Monad THEN 'foo :: m Int' ELSE type error"
01:31:22 --- quit: ___laika (Ping timeout: 244 seconds)
01:31:38 <dminuoso> jusss: So a typeclass in general can be thought of an interface, and writing an instance of an type for that typeclass can be thought of "writing an implementation for that interface" :)
01:32:41 --- join: doublex (~doublex@c-73-117-89-215.hsd1.oh.comcast.net) joined #haskell
01:33:01 <jusss> merijn: dminuoso I just wonder if we forget that monad things, can we use State or other monad types like regular types?
01:33:09 <dminuoso> jusss: Yes absolutely!
01:33:13 <dminuoso> jusss: State is just a type!
01:33:19 <dminuoso> jusss: You can use it without the monad interface just fine.
01:33:38 <jusss> dminuoso: and IO?
01:33:47 <merijn> jusss: IO (and Reader and everything) else would work just as well without a Monad instance
01:34:06 <dminuoso> jusss: In principle we could give you two functions "pack :: a -> IO a" and "then :: IO a -> (a -> IO b) -> IO b"
01:34:15 <merijn> jusss: What you lose is the ability to have a single set of operators used for each and the ability to write code that is generic across different monad instances
01:34:17 <dminuoso> jusss: The point of Monad is just this observation
01:34:27 * hackage boots 0.0.100 - IoC Monad in Haskell  https://hackage.haskell.org/package/boots-0.0.100 (leptonyu)
01:34:46 <dminuoso> You also have two functions packState :: a -> State s a; nextState :: State s a -> (a -> State s b) -> State s b
01:34:49 <merijn> jusss: Consider Maybe. If Monad disappeared we could still write "foo :: Maybe a -> (a -> Maybe b) -> Maybe b"
01:35:17 <dminuoso> jusss: Monad is just the observatoin that all these function look the same way. So instead of making up a new function name every time, they just share the same function name.
01:35:23 <dminuoso> That pretty much all there is to Monad.
01:35:24 --- quit: gienah_ (Ping timeout: 245 seconds)
01:35:28 --- join: fosterite (~fosterite@2601:445:447f:dd14:441a:5e8a:d6c2:4223) joined #haskell
01:35:44 <dminuoso> From a consumer perspective, you take (>>=) and set m to say "State Int"
01:35:50 --- quit: jose_zap (Quit: My MacBook has gone to sleep. ZZZzzz)
01:35:55 <merijn> jusss: Monad instances don't add anything to a type, the same functionality would exist without Monad. The monad instances just allow us to conveniently reuse operators (and syntactic sugar) and write code that is generic across multiple instances of Monad
01:35:56 <dminuoso> then (>>=) :: State Int a -> (a -> State Int b) -> State Int b
01:36:18 <jusss> ok

#anonymous type

01:37:43 <jusss> 'cause we have anonymous function like lambda, so I wonder is there anonymous type?
01:38:17 <dminuoso> jusss: I suppose every type not bound to a type alias is anonymous in a sense.
01:38:22 <dminuoso> jusss: or a type family
01:38:36 <merijn> jusss: You could have "type lambdas", yes. But we don't in Haskell because they make type checking undecidable
01:38:40 <dminuoso> jusss: If you just write Either Int Bool in the type system its anonymous because its not bound to any particular type.
01:38:56 <merijn> jusss: i.e. there would be no way to guarantee that typechecking doesn't infinite loop, additionally it breaks type inference
01:39:04 <dminuoso> merijn: We actually covered various forms of type functions yesterday. I think they rather care about the "anonymous" part. :)
01:39:19 <merijn> jusss: But there are type systems and languages where you can have anonymous type lambdas
01:39:37 <[exa]> jusss: you can get a similar feeling from types like (forall a. ... a ...) that are implicitly put into almost all types you see
01:40:01 --- quit: fosterite (Ping timeout: 264 seconds)
01:40:12 <dminuoso> jusss: There exist a way to build anonymous functions even in the Haskell type system if you enable about 6 type extensions. At least conceptually
01:40:15 --- join: jakobhillerstrom (~jakobhill@h-74-117.A137.corp.bahnhof.se) joined #haskell
01:41:42 <dminuoso> [exa]: That's wildly different though.
01:41:56 --- quit: gienah (Ping timeout: 246 seconds)
01:42:03 <dminuoso> [exa]: The reason is that forall quantification in haskell gives you terms that can bind types.
01:42:33 --- quit: ktonga (Ping timeout: 248 seconds)
01:42:53 --- quit: keepLearning512 (Remote host closed the connection)
01:42:55 <dminuoso> (where terms refers to value-level constructs)
01:43:28 --- quit: jedws_ (Quit: My MacBook has gone to sleep. ZZZzzz)
01:43:39 <[exa]> dminuoso: I know, didn't want to imply it's the same technically
01:44:01 --- join: agander_ (agander@gateway/vpn/protonvpn/agander) joined #haskell
01:45:35 <[exa]> but it's generally interesting to compare the computational vs. symbolic value of (\a->f a) and (forall a.F a)

01:46:25 <dminuoso> jusss: My preferred way to think about Monad these days, is to just look at (>>=) and see it as a family of functions. You can pick one of those functions by setting m to some appropriate type (so you could say that it's indexed by the type m, sort of like a map from m to a function type)
01:47:23 --- quit: yahb (Ping timeout: 244 seconds)
01:47:25 --- quit: petersen (Quit: petersen)
01:47:29 --- quit: MoarSpaceFi (Ping timeout: 245 seconds)
01:47:36 <dminuoso> jusss: So the function (>>=) at m ~ IO gives you then :: IO a -> (a -> IO b) -> IO b, (>>=) at m ~ State Int gives you nextState :: State Int a -> (a -> State Int b) -> State Int b, and so forth. Do you notice how the word Monad has disappeared?
01:48:30 --- join: gienah (~mwright@gentoo/developer/gienah) joined #haskell
01:48:51 --- join: bolichep (~bolichep@2802:8000:2707:5100:f8f1:13e5:d45b:872) joined #haskell
01:48:53 <dminuoso> jusss: The question is merely "but what do those functions do" - and Id say it doesnt matter. If you just know that the function IO a -> (a -> IO b) -> IO b is the one you want, then you can "grab and use it" so to speak. Ignore all the other functions, they are irrelevant to you.
01:49:00 <dminuoso> jusss: Does that make any sense?
01:49:42 <jusss> dminuoso: remove that m part?
01:50:06 <Cale> That's just a way of thinking about type classes in general though. It's important to know the meaning of the things that you're using...
01:50:10 <jusss> dminuoso: or why m is *->*
01:50:21 --- join: ilikeheaps (~sushi@176.120.120.135.telemedia.pl) joined #haskell
01:50:31 <Cale> But yeah, it's only important to know what the specific instance you're using does
01:50:37 <dminuoso> jusss: Look at the type signature of then/nextState, or the maybe function merijn mentioned above.
01:50:57 <dminuoso> jusss: Do you notice that if you set m ~ IO, then you end up with something like "IO a" 
01:51:35 <jusss> dminuoso: what it means m ~ IO?
01:51:44 <jusss> this symbol ~?
01:51:48 <dminuoso> jusss: ~ is to denote equality on the type level.
01:52:00 <dminuoso> % :t (>>=)
01:52:10 --- join: jose_zap (~jose_zap@176-20-96-236-dynamic.dk.customer.tdc.net) joined #haskell
01:52:15 <dminuoso> :t (>>=)
01:52:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:52:22 <jusss> ok

01:53:27 <dminuoso> jusss: You could read this as: "Pick m, a and b to be any type you want and Ill give you a function"
01:53:28 * hackage salak-toml 0.3.3.2, salak-yaml 0.3.3.2 (leptonyu): https://qbin.io/utah-debut-24u7
01:53:57 --- join: gienah (~mwright@gentoo/developer/gienah) joined #haskell
01:53:57 <dminuoso> jusss: Now as a disclaimer, you cant pick something completely arbitrary for m. You can only pick m out of a certain set.
01:54:05 --- join: keepLearning512 (~keepLearn@49.204.75.26) joined #haskell
01:54:17 <dminuoso> jusss: Lets ignore the a and b variables, and just focus on the type variable m.
01:54:38 <jusss> dminuoso: yeah
01:54:39 <dminuoso> jusss: Let's try and set m ~ Either
01:54:39 --- quit: dansho (Quit: Leaving)
01:55:05 <dminuoso> jusss: What's the type of the function you get back?
01:55:19 <jusss> dminuoso: Either a b?
01:55:24 <dminuoso> :t (>>=)
01:55:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:55:33 <dminuoso> jusss: Just replace m with "Either" in that type signature.
01:56:22 <jusss> Either a 'a -> ( 'a -> (Either a b)) -> Either a b
01:56:32 <dminuoso> jusss: Wait. That's sneaky of you.
01:56:40 <dminuoso> jusss: We said "Either", not "Either a"
01:56:46 <jusss> haha
01:57:03 <jusss> Either a -> (a -> Either b) -> Either b
01:57:19 <dminuoso> jusss: So here comes the issue. This is a function demanding a value of type Either a
01:57:21 <dminuoso> :k Either
01:57:23 <lambdabot> * -> * -> *
01:57:41 <dminuoso> jusss: Using the knowledge you obtained yesterday, can there be a value of Either a for some choice of a?
01:58:07 <jusss> :k (Either a)
01:58:10 <lambdabot> error: Not in scope: type variable a
01:58:14 --- quit: hexfive (Ping timeout: 244 seconds)
01:58:22 <dminuoso> jusss: Pick some concrete type for a, say Int or whatever you like.
01:58:26 <jusss> :k Either Int
01:58:29 <lambdabot> * -> *
01:58:31 --- quit: treehaqr (Ping timeout: 258 seconds)
01:58:43 --- join: dfeuer (~dfeuer@wikimedia/Dfeuer) joined #haskell
01:58:51 --- join: dmitri (~dima14@ppp-124-122-27-35.revip2.asianet.co.th) joined #haskell
01:58:53 <jusss> no value has Either Int
01:59:12 <dminuoso> jusss: Is Either Int inhabitatable at all? Could we make up values of that type?
01:59:14 <jusss> 'cause values have types which's kind is *
01:59:29 <dminuoso> jusss: Right! And can types with a kind different from * have values at all?
01:59:50 <jusss> no
01:59:59 <dminuoso> jusss: Alright! So clearly setting m to a type of kind * -> * -> * is not valid. Do you agree?
02:00:05 --- join: oish (~charlie@host81-130-206-144.in-addr.btopenworld.com) joined #haskell
02:00:13 --- quit: mniip (Quit: This page is intentionally left blank.)
02:00:18 <jusss> yes
02:00:23 --- quit: wjp1 ()
02:00:30 --- join: ___laika (~laika@99-0-83-18.lightspeed.sntcca.sbcglobal.net) joined #haskell

02:00:32 <dminuoso> jusss: Try something else. Do you think we could set m ~ Bool perhaps?
02:00:47 --- join: yahb (~yahb@178.219.46.58) joined #haskell
02:00:47 --- quit: yahb (Changing host)
02:00:47 --- join: yahb (~yahb@haskell/bot/yahb) joined #haskell
02:00:49 --- nick: agander_ -> agander
02:01:01 <jusss> dminuoso: m is *->* and Bool is *, so no
02:01:18 <dminuoso> jusss: But why is m required to have a kind of * -> *, really?
02:01:29 --- join: mniip (mniip@freenode/staff/mniip) joined #haskell
02:01:54 <jusss> dminuoso: that means why monad have to be *->*?
02:02:00 <dminuoso> jusss: It's because the function (>>=) would make any sense, otherwise. (>>=) takes that m, applies one type to it, and then demands that this type be inhabitatable (since eventually a function is produced, that demands value of m applied to that type, and it produces values of m applied to another type)
02:02:07 --- quit: gienah (Remote host closed the connection)
02:02:17 --- join: gienah (~mwright@gentoo/developer/gienah) joined #haskell
02:02:28 * hackage boots-app 0.1.0.5 - Startup factories using IoC monad  https://hackage.haskell.org/package/boots-app-0.1.0.5 (leptonyu)
02:02:35 --- join: smakarov (~user@217.12.249.74) joined #haskell
02:02:57 <dminuoso> jusss: So if we again think of (>>=) as a family of functions indexed by a type m, then the index type is of kind (* -> *)
02:03:12 <jusss> dminuoso: ok
02:03:39 <dminuoso> jusss: Now, we still cant pick an arbitrary type of kind * -> * either.
02:03:56 --- quit: keep_learning (Ping timeout: 268 seconds)
02:04:01 <jusss> dminuoso: until?
02:04:24 <dminuoso> jusss: The limitation is, whatever type you pick, let's call it t0, there must be an instance Monad t0
02:04:28 <dminuoso> Nothing more.

02:04:55 <dminuoso> How do we know which ones have that instance? We can look at the haddoc documentation of Monad to get sizable list of instances.
02:05:18 <dminuoso> jusss: https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Monad scroll down to the section that says "instances"
02:05:38 <dminuoso> jusss: [] is a valid choice for m. Maybe is a valid choice for m, IO is a valid choice for m. Each "choice" gives you a different function (>>=)
02:05:57 <jusss> yeah
02:06:26 --- quit: gienah (Ping timeout: 246 seconds)
02:08:37 --- quit: o1lo01ol1o (Remote host closed the connection)
02:09:17 --- join: asymptotically (~quassel@gateway/tor-sasl/asymptotically) joined #haskell
02:09:22 <dminuoso> jusss: So Monad can be viewed as "the collection of all those types that have an instance/the collection of all those types that are valid to pick for "m" in (>>=)"
02:09:45 <dminuoso> jusss: There's even a language to ask whether a type is a member of that collection, its constraints. 
02:09:52 <dminuoso> % data SomeType a = SomeType
02:09:53 <yahb> dminuoso: 
02:10:16 --- quit: gentauro (Quit: leaving)
02:10:26 --- join: Sgeo_ (~Sgeo@ool-18b98455.dyn.optonline.net) joined #haskell
02:11:26 <dminuoso> jusss: So a constraint "Monad m" can be also be thought of as "m must be a member of Monad"/"Whatever the choice of m, there must be an instance Monad m"
02:11:27 --- join: mastarija_ (~mastarija@cm-2171.cable.globalnet.hr) joined #haskell
02:11:59 <dminuoso> jusss: You see, the notion of "IO is a Monad" is slippery and not useful. Perhaps its better to say "IO conforms to the interface of Monad" or "IO has an instance Monad"
02:12:08 <dminuoso> jusss: The same applies to State, Reader, etc..
02:12:32 --- join: gienah (~mwright@gentoo/developer/gienah) joined #haskell
02:12:48 --- join: mastarija__ (~mastarija@cm-2171.cable.globalnet.hr) joined #haskell
02:13:28 --- quit: Sgeo__ (Ping timeout: 258 seconds)
02:14:06 --- quit: sw1nn (Quit: WeeChat 2.5)
02:14:10 --- join: treehaqr (~treehaqr@unaffiliated/treehaqr) joined #haskell
02:15:05 --- join: fosterite (~fosterite@2601:445:447f:dd14:441a:5e8a:d6c2:4223) joined #haskell
02:15:37 --- quit: mastarija (Ping timeout: 248 seconds)
02:15:57 --- join: xff0x (~fox@210.57.57.162) joined #haskell
02:16:32 --- quit: mastarija_ (Ping timeout: 272 seconds)
02:17:20 <jusss> dminuoso: ok

#Types have values, Types have functions

02:32:02 <jusss> dminuoso: we can say values have types, or types have values, can we say types have functions?
02:32:11 <jusss> 'cause functions are values
02:32:53 --- join: DavidEichmann (~david@213.31.79.26) joined #haskell
02:32:59 <dminuoso> jusss: Depending on the context that could be a valid thing to say, though Im not convinced that this is a particularly useful thing to say.
02:33:02 --- quit: v01d4lph4 (Remote host closed the connection)
02:33:50 --- join: v01d4lph4 (~v01d4lph4@125.16.234.60) joined #haskell
02:34:56 <dminuoso> jusss: I'd probably prefer to use the word "inhabitant/inhabited" rather than "have"
02:35:19 <dminuoso> jusss: e.g. "Int -> Double is inhabited by functions/values"

http://tunes.org/~nef/logs/haskell/


################################################################

#Monad Transformer

monad transformer, used to compose monads
mtl library provides typeclasses for monads
the effects from two or more monads
<Axman6> IT's the difference between foo :: ReaderT Config IO a and foo ::
         (MonadReader Config m, MonadIO m) => m a

<jle`> so one way you can look at using MaybeT is, ">>= for IO doesn't do what
       I want.  it doesn't short circuit when I hit a Nothing.  but if i wrap
       it in this newtype wrapper, >>= will do what i want it to do"
<jle`> >>= for MaybeT IO, that is
<jle`> Control.Monad.Trans.Maybe                                        [15:13]
<dminuoso> jusss: MaybeT is, at the end, just a newtype.

<jle`> so for example i have `do action1; action2`.  and both of them are `IO
       (Maybe Int)`
<jle`> normally for IO, >> will do one, then the other
<jle`> it won't care if action1 returns Just or Nothing
<jle`> but we want a different >>; we want one that will stop as soon as it
       sees a Nothing
<jle`> so you can do MaybeT action1; MaybeT action2, and now this will not
       perform action2 if action1 returns Nothing

<jle`> so if i apply MaybeT to IO, then `MaybeT IO` is just a slightly
       different version of IO with a slightly different Monad instance
<jle`> like a Monad -> Monad type-level function, in a way
<dminuoso> jusss: The usual monad transformers take a base monad, a precursor
           monad and then imbue the base monad with the effect of the
           precursor monad, somehow.
<dminuoso> jle`: In case of "MaybeT IO" the base monad is IO, and it gets
           imbued with the effect from Maybe, somehow.           

<dminuoso> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) } -- with
           the implicit understanding that "m" usually has an instance Monad.

###############################################################
#Either Catch Exceptions

<jusss> jle`: actually I have never understand why you people call Either can
        catch the exceptions,
<jusss> like python or java they do have try ... except statement for catching
        exceptions
<jle`> ah, "exceptions" here is something slightly different
<lavalike> because when things don't go Right that's what you're Left with
<jle`> what you are talking about in python or java is exceptions as a
       language feature
<jle`> and a feature of the runtime
<dminuoso> jusss: By exception we mean the generalized notion of "here we set
           an error state and shortcircuit any further computation until some
           "catching" mechanism.
<jle`> when people talk about Either, we're more talking about the abstract
       "idea" of an error
<jle`> and not an actual built-in language feature                      [15:18]
<jle`> the idea of "something going wrong", as a first-class value
<jle`> we're implementing a sort of error system "inside" the language, using
       normal values
<jle`> instead of relying on built-in features of the language/runtime
<jusss> ok, it seems to me like it can be Left a or Right b, because they both
        have Either a b,                                                [15:19]
<jle`> right. now, the behavior of >> is to stop as soon as it sees a Left
<jle`> > Right 1 >> Right 2 >> Right 3
<jusss> and it seems there's no type inheritance in haskell, but in kotlin or
        java, it seems there're type inheritance
<jle`> > Right 1 >> Right 2 >> Right 3 >> Left True >> Right 4
<dminuoso> jusss: Right, we dont have the usual concept of inheritance at all.
<jle`> so if there is any Left, >> will pattern match it and return the Left
<jle`> this is 'short-circuiting', like with Maybe. but you also return the
       'reason' why it short circuits: the value inside the Left
<jle`> so we don't really say "Either can catch the exceptions".  instead, we
       say that Either can be used to model exception-handling in a
       first-class value sort of way
<jle`> we can use Either e and its monad instance to simulate some sort of
       exception system
<jle`> but this doesn't mean "Either can catch runtime exceptions"
<jusss> fine, but that's really weird, 'cause exception in haskell doesn't
        mean what it means in other languages
<jle`> fwiw, Haskell actually *does* have a runtime exception system, within
       IO and its runtime
<jle`> and haskell has actual runtime exceptions and a try/catch system like
       python/java
<jle`> that system is unrelated to Either
<jle`> MaybeT m is a way of enhancing an 'm' with short-circuiting >>=  [15:26]
<jle`> the emphasis is on what the 'm' already does, and what it adds to the
       'm'
<jle`> and this is a specific statement that isn't ambiguous

<jle`> whereas "combining IO and Maybe" is sort of ambiguous and doesn't
       really mean anything specific
<jusss> MaybeT is a monad?                                              [15:27]
<jle`> MaybeT is not a monad, but `MaybeT m` is a monad
<jle`> it takes a monad (m) and returns a new monad (MaybeT m)
<jusss> wait a sec, but m in `MaybeT m` is already a monad              [15:29]
<jle`> right
<jle`> just like 1 is already a number
<jle`> 'negate 1' is also a number
<jusss> jle`: let's assume that m is Either a, so MaybeT Either a is a monad?
<jle`> MaybeT (Either a) is a monad, yes
<jle`> `MaybeT (Either a)` is a monad, so it's kind * -> *
<comerijn> jusss: It's already a type, it just not a type with kind * (all
           values have types with kind *)
<jusss> so we give a 'a' to Maybe and we get Maybe a, right/
<jle`> yup

not all the types have values, types's kind is * have values, otherwise not

###################################################
#Type Function

<dminuoso> jusss: A motivating example to see how things like (->) and Either
           themselves are types, is understanding that on the value level not
           only 1 and "foobar" are values, but functions like \x -> x +
           10 themselves are values too.                               [15:50]
<dminuoso> jusss: So on that basis you can also understand (->) and Either as
           type functions, but that does not preclude them from being types.
<dminuoso> Similarly how "value functions" are functions too.
<dminuoso> Err how "value functions" are values too. :)                 [15:52]

<dminuoso> Either is all three: a) a type, b) a type function (that is a
           function acting on types), and c) a type constructor

<dminuoso> Right is also all three: a) a value, b) a (value-level) function,
           and c) a data constructor

<jusss> they're type/value constructor, I can understand, because they need a
        type or value to consturct an new one
<dminuoso> jusss: Formally speaking, a type is just something that exists on
           the type level.
<dminuoso> jusss: Just like a value is something that exists on the value
           level.
<dminuoso> jusss: The kind system is to the type system as the type system is
           to the value world. Just like the type system classifies values and
           creates limitations about what you can and cant do in the value
           world, the kind system classifies types and it creates limitations
           about what you cant and can do in the type world.            [16:43]
<dminuoso> jusss: And just like you can do computation in the value world,
           computation in the type world is possible too.


<jusss> dminuoso: Either is a type? Either a b is a type                [15:55]
<jusss> and also Right b is a value, Right is a value?
<dminuoso> Yes.
<dminuoso> jusss: The key part is what jle` said:                       [15:56]
<dminuoso> 09:42:43        jle` | some confusion comes from baggage coming
           from other languages, though.  in other languages, the only context
           in which you hear about types is by how they classify values
<dminuoso> 09:42:54        jle` | so you start to believe that the only use of
           types is for classifying values

<jle`> jusss: 'Right' is a value, right?
<jle`> do you agree that 'Right' is worth calling a value, as an expression?
<jusss> jle`: base your story, it is
<jle`> it's something you can pass to 'id'
<jle`> or any other higher-order function

<dminuoso> jusss: Forget the notion that a "type is something that has
           values", its a dangerous assumption that holds true for only the
           simplest type systems. Lets just define the type system as a
           separate detached universe in which objects are allowed to exist.
<jusss> I can pass Right String to function id, but I don't think I can pass
        Right to id
<dminuoso> jusss: Elements inside that universe are called types.
<jle`> jusss: try :)
<jle`> :t id Right
<lambdabot> b -> Either a b
<jle`> ta dah ~
<jusss> jle`: no, that's currying
<jle`> > let f = id Right in f 10
<dminuoso> jusss: No its not.
<lambdabot>  Right 10
<dminuoso> jusss: Its proper function application.
<jle`> jusss: what is being curried here?
<jle`> `id x = x`, and you evaluate that by substituting `id x` with `x`.
       that's what's going on here: how do you evaluate `id Right`?     [16:00]
<jusss> wait, I will try it
<jle`> `const x y = x`
<jle`> so `const Left Just = Left`.
<jusss> ok, f = id Right, it's fine
<jle`> simple. that's because we don't treat Left any different...it's just
       like any other value we could pass to 'const'
<jusss> Right is a value,
<dminuoso> jusss: The specialty of Right is just that it's also a data
           constructor. The relevance of that is merely that you can do
           pattern matching with it.                            
<jusss> so can we say monad is a type now?
<jusss> Maybe is a type?
<jle`> well, a monad like Maybe is a type
<jusss> ok then, you guys blow up my mind, I remember some people told me that
        Maybe is not a type, Maybe a is a type
<dminuoso> jusss: monad itself is a typeclass now!                      [16:03]
<merijn> jusss: There's a lot of people using very sloppy terminology,
         unfortunately
<jusss> dminuoso: I mean type, not typeclass stuff
<jle`> honestly i don't think it's a universal consensus and you'll get
       different people saying different things on whether or not type-level
       terms can be called types                                        [16:04]
<jle`> in the end the terminology is a tool to aid in understanding
<jusss> dminuoso: merijn jle` does this type Maybe has a value?
<dminuoso> jusss: Nope!
<jle`> nope, Maybe has no values of that type
<jusss> or monad can have value?
<MarcelineVQ> Maybe being a type isn't too contentious. The more common
              confusion is when someone says Either is a type constructor but
              Either e isn't
<jle`> or more importantly, "X is a type" doesn't mean that there are values
       of type X
<dminuoso> jusss: Now the interesting part is, you can use the kind system to
           classify types according to whether they can have inhabitants at
           all.
<dminuoso> jusss: Some types can have values, others cant.              [16:05]
<dminuoso> jusss: We use the kind system to, amongst other things, classify
           types to say whether/when a type can have inhabitants at all.,
<jusss> dminuoso: how to use this kind system
<dminuoso> jusss: In Haskell its tied into the type system automatically, just
           like the type system is tied into the value world.
<jle`> jusss: one basic way to utilize it is that only types of kind * can be
       inhabited
<dminuoso> So the kind of Either is "* -> * -> *"
<dminuoso> Since, like jle` just said, only types of kind * can be
           inhabitated, Either cannot because it does not have kind *.
<jle`> so you can answer your question: "does Maybe have any values of this
       type", by looking at the kind of Maybe
<jusss> so if a type's kind is *, it can have values, otherwise it can't?
<dminuoso> jusss: Precisely.                                            [16:13]
<jusss> wait a sec, [] is *->*
<dminuoso> jusss: [] is just a bit weird because it has special cased syntax.
                                                                        [16:15]
<dminuoso> jusss: You could imagine [Int] as just List Int
<jusss> [Int] is *
<tdammers> it sometimes help to think of [] (the type) as an alias for List,
           and [a] as an alias for List a
<jusss> but it seems ghci doesn't auto import the type List             [16:16]
<dminuoso> jusss: For what its worth, you could also write: ([]) Int
<jusss> :k List got error
<merijn> dminuoso: UnliftedRep doesn't exist in Haskell
<jusss> :k List
<dminuoso> jusss: It doesnt actually exist.
<dminuoso> jusss: Im just saying imagine that type constructor existed.
<jusss> dminuoso: ...
<dminuoso> jusss: My point is, [a] is just special because it has special
           application syntax.                                          [16:17]
<dminuoso> But you could also apply [] to another type via juxtaposition
<merijn> > [1..5] :: [] Int -- doesn't even need parenthesis
<dminuoso> % :k [] Int
<lambdabot>  [1,2,3,4,5]
<yahb> dminuoso: [] Int :: *
<dminuoso> jusss: ^- see? You can write "[] Int" just fine. :p
<dminuoso> jusss: It's just that [Int] means "[] Int" really
<jusss> dminuoso: why not List, people prefer names I think,not symbols
<dminuoso> jusss: Good question, it was a design decision.
<dminuoso> jusss: It could have been List just as well, really. But [] won.
<dminuoso> jusss: Next up, the kind system tells you how application can work
                                                                        [16:19]
<dminuoso> jusss: For example
<dminuoso> % :k []
<yahb> dminuoso: [] :: * -> *
<dminuoso> jusss: Do you think [Maybe] is a valid type? Make an arugment for
           your position.
<dminuoso> jusss: :t operates on value level constructs. So you give :t a
           value-level expression, and it tells you its type.           [16:20]
<dminuoso> jusss: similarly how :k takes a type-level expression, and it tells
           you its kind.
<jusss> :t [Nothing]
<lambdabot> [Maybe a]
<dminuoso> jusss: My point is, the kind system tells you that [] takes a type
           of kind * and it returns a type of kind *
<dminuoso> jusss: So [] applied to Maybe will not kind check, since [] expects
           a type of kind *, but Maybe :: * -> *
<dminuoso> jusss: The kind system is to the type system as the type system is
           to the value world. Just like the type system classifies values and
           creates limitations about what you can and cant do in the value
           world, the kind system classifies types and it creates limitations
           about what you cant and can do in the type world.            [16:43]
<dminuoso> jusss: And just like you can do computation in the value world,
           computation in the type world is possible too.


#RankN
<jusss> dminuoso: and what about Rank-N and higher logic stuff          [16:51]
<jusss> higher-order logic                                              [16:52]
<jusss> it's related to kind?
<dminuoso> jusss: Nope
<merijn> jusss: RankN isn't really
<dminuoso> jusss: Its basically about extending where you can put universal
           quantification in.
<merijn> jusss: This is the simplest example of exactly what problem RankN
         types solve: https://gist.github.com/merijn/77e3fa9757658e59b01d
{-# LANGUAGE RankNTypes #-}
module RankN where

data Foo = Foo Int | Bar Double

mangle :: (forall a . Num a => a -> a) -> Foo -> Foo
mangle f (Foo i) = Foo (f i)
mangle f (Bar d) = Bar (f d)
<dminuoso> jusss: In very short terms, RankNTypes is, amongst other things,
           what allows you to specify "my argument itself must be a
           polymorphic function"
<dminuoso> So with rank 1, you can only produce polymorphic things, but you
           cant demand that your consumer must pass you a polymorphic thing.
<jusss> ok, and higher-order logic?
<dminuoso> Well that's a logic topic, isn't it? :)                      [16:56]
<jusss> type for value, kind for type, so what for kind?
<jusss> kind for kind?
<dminuoso> jusss: the next layer is called "sort" in haskell, but its blant
           and boring.
<dminuoso> Its boring because there exists only a single sort called "BOX"
<dminuoso> So there's no useful classification anymore.
<jusss> dminuoso: what type system haskell use?
<dminuoso> jusss: Some other languages have infinite towers.
<jusss> about those type systems, there're differences among them?
<dminuoso> jusss: So in Agda for example you have Set : Set1, Set1 : Set2,
           Set2 : Set3 and so forth
<dminuoso> Ad infinitum.
<dminuoso> jusss: In Haskell however we are making a move to change our type
           and kind system to do something completely different

<dminuoso> Called TypeInType where we crush the tower of "types, kinds and the
           rest" into just the "type world"

<dminuoso> Such that: Type :: Type
<dminuoso> So values have types, and types have a types.
<Ariakenom> 1 :: Int, Int :: Type, Type :: Type. (Type is same as *)    [17:03]
<merijn> Also, TypeInType is an abomination
<merijn> I'll take stratified universes over it any day
<dminuoso> jusss: Regarding your question "what kind of type system does
           Haskell have" - I dont think it has a particular name other than
           "the type system of Haskell/GHC". Some features are inherited, such
           as inference coming from Hindley Milner.
<jusss> wow, types have types?
<dminuoso> jusss: Well yeah. Anyway, you probably best forget it again - it's
           just what the future holds for us. Until then, types have *kinds*
                                                                        [17:07]
<dminuoso> And after kinds there's nothing really.
<merijn> Sorts!

<dminuoso> jusss: At the end the kind system is very simple, consisting of,
           essentially, just two primitives. * and (->). A confusing part here
           is that (->) is a construct that exists in all three worlds. It
           exists, syntactically at least, in the value world, it exists as a
           type, and it exists as a kind.
<dminuoso> Unlike types which can be much richer since you can have type
           families and type constructors
<jusss> dminuoso: and what that (->) is named? and it's related to Kleisli
        arrow?                                                          [17:15]
<dminuoso> jusss: I'd say "function" 
<dminuoso> So the kind (* -> *) is the kind of all type functions taking a
           type of kind * and returning a type of kind *                [17:16]
<dminuoso> Maybe is one inhabitant of that kind.
<dminuoso> Either Int is another inhabitant of that kind.
<dminuoso> Const () is yet another.
<dminuoso> (All three are type functions)
<dminuoso> Equivalently, the type "Int -> Char" is inhabitated by all the
           functions taking an Int and returning a Char.                [17:17
<jusss> dminuoso: and *->*->* is a type function which take two types of kind
        * and return one type of kind *?                                [17:19]

<dminuoso> jusss:  *->*->* is a *kind*
<Ariakenom> % :k Void#                                                  [17:20]
<yahb> Ariakenom: Void# :: TYPE ('TupleRep '[])
<dminuoso> jusss: This might sound like pedantry, but being careful about the
           terminology can save you from confusion. And not exactly actually
<dminuoso> jusss:  * -> * -> * is the kind of all types, who take something of
           kind * and return a type of kind * -> *
<dminuoso> Just like in the value level, all type functions take just a single
           argument.                                                    [17:21]
<dminuoso> Ariakenom: Shush!
<jusss> dminuoso: aha, but in the value level, we can say take two parameter
        and return one value
<dminuoso> jusss: But its not really two parameters on the value level either.
<dminuoso> f :: Int -> Double -> Char formally takes only a single argument.
                                                                        [17:22]
<jusss> dminuoso: it depends what it function definition, not types 
<Ariakenom> dminuoso: it's C's void. Haskell's ()
<dminuoso> f 1 10.0 is not "f applied to two arguments", its rather "f
           applied to 1, producting a new function, which in turn is applied
           to 10.0"
<dminuoso> jusss: All functions in Haskell take a single argument.      [17:23]
<jusss> dminuoso: that's currying
<dminuoso> jusss: Currying exists in your head.
<dminuoso> jusss: But sure, if that helps.
<jusss> dminuoso: yeah, all functions are unary functions in haskell
<dminuoso> jusss: Right. Same thing on the type level. :)
<merijn> jusss: "\x y -> x + y" is just syntactic sugar for "\x -> (\y -> x +
         y)"
<jusss> ok                                                              [17:24]
<dminuoso> jusss: Of course sometimes we employ different mind models.
<dminuoso> jusss: Once you have completely accepted that functions can take
           only single arguments, we sometimes pretend that "f :: Int -> Float
           -> Char" takes two arguments, understanding that its a function
           that returns a function.                                     [17:25]
<dminuoso> jusss: The same holds true on the type level.
<jusss> so there're three levels, kind, type and value, right?
<dminuoso> So we could view Either as a type function taking two arguments, or
           think of it as a type function that returns a type function.
<dminuoso> jusss: Right.
<jusss> and (->) you called function is in all of them                  [17:26]
<jusss> about Either a b = Left a | Right b, how I can think it as a type
        function?
<dminuoso> jusss: So the "Either" part is a type function.
<dminuoso> jusss: It acts a sum/plus if you want. So Either "adds" two types
           together.
<jusss> and it takes a type a then?
<dminuoso> jusss: Sure, so using our previous knowledge, we could say Either
           takes two types and it "computes/constructs" a new type.     [17:28]
<jusss> Either adds a and b return Either a b?
<jusss> it's interesting about those three levels, to think data Either a b =
        Left a | Right b again, this `data` connect that type level and value
        level                                                           [17:29]
<jusss> use '=' is really interesting part, types are equals to values
<lortabac> jusss: in data declarations '=' does not mean equality       [17:32]
<jusss> dminuoso: so is there another keyword that connect kind level with
        type level?
<dminuoso> jusss: Its the same as type and value level, ::
<lortabac> it's just a way to introduce the definition of a data type
<jusss> lortabac: maybe we should use another symbol                    [17:33]
<dminuoso> jusss: You can use GADTSyntax if you prefer.
<dminuoso> data Either a b where Left :: a -> Either a b; Right :: b -> Either
           a b
<jusss> dminuoso: the simple ADT is good for me :)
<jusss> I really don't like record syntax...
<dminuoso> jusss: Thats not record syntax. Its GADTSyntax.
<jusss> dminuoso: I know...                                             [17:35]
<jusss> I mean that {...}
<dminuoso> jusss: You get used to it.
<jusss> dminuoso: yeah
<dminuoso> jusss: Anyhow. The relevant part is not the sum part, that's merely
           how the new type acts. It's that Either takes two types and it
           returns another type.                                        [17:36]
<jusss> dminuoso: what it returns?
<jusss> Either a b?
<dminuoso> jusss: A new type that doesnt have a name of its own.
<dminuoso> jusss: We just identify it by the same name how it was constructed.
                                                                        [17:37]
<dminuoso> jusss: This is what we mean by "Either is a type constructor"
<jusss> dminuoso: so what we think about like Int?
<dminuoso> jusss: What do you mean?                                     [17:38]
<jusss> Int is a type function?
<merijn> % :k Int
<yahb> merijn: Int :: *
<dminuoso> jusss: No.
<dminuoso> jusss: ^- what merijn just did :)
<jusss> Either is a type function which take two parameters
<jusss> :k Either
<merijn> % :k Either
<yahb> merijn: Either :: * -> * -> *
<lambdabot> * -> * -> *
<dminuoso> jusss: Note, because I think this is a good fit now, there are
           other type functions.                                        [17:39]
<jusss> dminuoso: like what?
<dminuoso> jusss: type families for example are type functions that return
           known types!
<dminuoso> (Rather than constructing new ones, like type constructors)
<jusss> what are type families?
<dminuoso> You could have a type function First which takes two type arguments
           and always returns the first type.                           [17:40]
<dminuoso> jusss: just type functions, where you can say F Int = Double; F
           Char = String
<dminuoso> Such that when you use F Int somewhere in the type system, it
           evaluates to Double.
<jusss> wow, we can use patter matching in type level?
<dminuoso> Yes! :)
<jusss> how we can do that?                                             [17:41]
<dminuoso> % type family F p
<yahb> dminuoso: 
<dminuoso> % type instance F Int = Double
<yahb> dminuoso: 
<dminuoso> % type instance F Char = String
<yahb> dminuoso: 
<dminuoso> % x :: F Char; x = "foobar"                                  [17:42]
<yahb> dminuoso: 
<dminuoso> jusss: There's also a different pattern matching on types, which is
           implemented by typeclasses.                                  [17:43]
<jusss> dminuoso: ok, 
<dminuoso> jusss: Note that F is vastly different from a type
           constructor. That is, "F Int" is not a new type of its own. Rather,
           F is applied to Int, computing the type "Double" in its place.
                                                                        [17:44]
<dminuoso> jusss: But both type families and type constructors functions are
           type functions that take some types and return types.        [17:45]
<maralorn> So, why doesnt run TypeInType in all the Russels Paradoxon
           problems?
<merijn> maralorn: It does
<merijn> TypeInType isn't consistent
<dminuoso> maralorn: It does, but the reasoning is that the type system is
           crapped anyway :)
<dminuoso> merijn: So adding TypeInType doesnt lead to additional
           inconsistency.
<dminuoso> Err maralorn ^-
<dminuoso> maralorn: https://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf
           explains why                                                 [17:46]
<maralorn> dminuoso: Thx
<mniip> that's hardly an explanation
<jusss> since we have value function and type function, so we have kind
        function too?
<merijn> jusss: Conceptually you could, but they're not expressible in
         Haskell+extensions
<merijn> jusss: There are languages with type systems where such things exist
<dminuoso> jusss: Note that TypeInType allows you express that idea.    [17:48]
<jusss> merijn: dminuoso ok
<jusss> those three worlds, kind type and value, change my mind
<dminuoso> jusss: Once you get into this business, there's lots of
           trivialities to discover. Like there is a type with no inhabitants,
           called Void. So just like "a + 0 = a" you get "Either a Void ~
           a". You can start to think of ADTs are just adding and multiplying
           types together. :)
<dramforever> > sortOn Down [1..5]
<lambdabot>  [5,4,3,2,1]
<dminuoso> jusss: (,) takes the role of multipyling two types, with () as its
           unit. 
<kuribas> dminuoso: except that every type in haskell is inhabited with bottom
<dminuoso> kuribas: I honestly wonder what the point of raising that point is,
           repeatedly. :p
<jusss> dminuoso: we can do function on type level that is really change my
        mind about type stuff
<jusss> dminuoso: is there only two functions on type level? add and multipy?
<dminuoso> jusss: Well you can make your own type constructors which use them
           inside.
<kuribas> dminuoso: because it makes the Void type useless in haskell
<jusss> dminuoso: for example?
<MarcelineVQ> can't be that useless, it's occupying space in base       [17:56]
<dminuoso> jusss: Using a pseudo language you could make "T a b = (a * b) + b"
           - in actual Haskell that would look: newtype T a b = L a b | R b
<dminuoso> Err, data type of course!                                    [17:57]
<jusss> dminuoso: yeah, but that's still just multipy and add, any others?

<kuribas> MarcelineVQ: for completeness probably
<dminuoso> jusss: You can use type families too!
<dramforever> jusss: you can also throw recursive data types in the mix
<jusss> dramforever: wow, you mean do recursive in the type function?   [17:58]
<jusss> that sounds what should I say
<dramforever> Uhh not really
<dminuoso> jusss: So for example you could make some T a b = (Better a b) +
           b, which would be encoded by : data T a b = L (Better a b) | R b
<dminuoso> Where Better is some suitable type function (could be a type family
           or a type constructor)                                       [17:59]
<dramforever> But consider data List a = Nil | Cons a (List a)
<dminuoso> jusss: You can achieve full computational power in the type system,
           so you can do complicated type computations.
<dramforever> List *is* of kind * -> *
<dramforever> I don't know if you consider that a 'type function'
<dramforever> (The built-in List is called [] in Haskell)               [18:00]
<dminuoso> dramforever: We've been operating under the assumption that any
           type of kind g -> k for some choices of g and k are type
           functions.
<dramforever> Then it is                                                [18:01]
<jusss> about type families, this is an exist term?
<dminuoso> jusss: I just made one earlier, did I not? :)                [18:02]
<jusss> dminuoso: I'm not familiar with it yet :(

<dminuoso> jusss: A type family is just a "mapping from types to types"
           basically. This should be familiar, remember how (value) functions
           are just mappings from values to values?

<jusss> dminuoso: yeah
<dminuoso> % type family F x where F Int = Char; f x = Int              [18:04]
<yahb> dminuoso: ; <interactive>:359:37: error: Malformed head of type or
       class declaration: f x

<dminuoso> % type family F x where F Int = Char; F x = Int
<yahb> dminuoso: 
<MarcelineVQ> kuribas: That's not especially compelling, there's plenty of
              things missing from base, should be put them in there? :>
              https://www.fpcomplete.com/blog/2017/07/to-void-or-to-void is a
              reason Void is pretty neat, there's probably more compact
              examples out there though
<dminuoso> jusss: ^- this is a simple type family mapping Int to Char, and
           every other type to Int.

<jusss> dminuoso: ok                                                    [18:05]

<dminuoso> jusss: Which type does F String evaluate to?

<jusss> Int
<dminuoso> jusss: And F Int ?
<jusss> dminuoso: Char

<dminuoso> jusss: There you go. That's a type family in a nutshell.
<jusss> dminuoso: ok
<dminuoso> jusss: There's of course further type computation you can do by
           means of type application.                                   [18:10]
<jusss> dminuoso: like?                                                 [18:11]
<dminuoso> jusss: Phantom types is a very simple example of how one can
           leverage the type system to produce guarantees.
<dminuoso> jusss:
           https://gist.github.com/dminuoso/bb97536e4c38ce7e0040b1b04f69e522
                                                                        [18:14]
data ValidationError = BadSyntax
                     | TooLong
                     | HasSqlInjection

data Validated = IsValidated
               | NotValidated

data Input (k :: Validated) = Input Text

getFromUser :: IO (Input NotValidated)
getFromUser = ...

saveIntoDatabase :: Input IsValidated -> IO ()
saveIntoDatabase = ...

validateInput :: Input NotValidated -> Either ValidationError (Input IsValidated)
validateInput = ...

<dminuoso> jusss: Guaranteeing that no unsanitized input ever goes into the
           database.
<dminuoso> jusss: Anyway. There's many other ways to express ideas in the type
           system. 
<jusss> dminuoso: yeah
<dminuoso> jusss: Notice how the parameter to Input is completely disregarded?
           It doesn't correspond to any values.
<maralorn> What does it mean for a kind to be inhabitate?
<dminuoso> maralorn: It would mean that it can have types belonging to it.
                                                                        [18:17]

<dminuoso> maralorn: There is no kind that is not inhabitated by a type.

<dminuoso> iow every kind is inhabitated by some type
<dminuoso> *inhabited.                                                  [18:18]

<dminuoso> (* -> *) e.g. is inhabited by Maybe, Const (), Either Int etc...

########################################################

:t for values
:k for types
<jusss> so if a type's kind is *, it can have values, otherwise it can't?
<dminuoso> jusss: Precisely.                                            [16:13]

:k Maybe Int, it's *, 
monads are types too, but they're *->*, so monads can not have values
or no value can have monad types

there's no List type in haskell, only []
<jusss> dminuoso: why not List, people prefer names I think,not symbols
<dminuoso> jusss: Good question, it was a design decision.
<dminuoso> jusss: It could have been List just as well, really. But [] won.

<jusss> wait a sec, [] is *->*
<dminuoso> jusss: [] is just a bit weird because it has special cased syntax.
                                                                        [16:15]
<dminuoso> jusss: You could imagine [Int] as just List Int
<jusss> [Int] is *

<jusss> Right is a value,
f = id Right   
f 3 will get Right 3
and it's not curried

type for value, kind for type, and sort for kind

type function , type family and typeclass
type family F x where F Int = Char; F x = Int


<dminuoso> jusss: In Haskell however we are making a move to change our type
           and kind system to do something completely different
<dminuoso> Called TypeInType where we crush the tower of "types, kinds and the
           rest" into just the "type world"
<dminuoso> Such that: Type :: Type

<dminuoso> So values have types, and types have a types.
<Ariakenom> 1 :: Int, Int :: Type, Type :: Type. (Type is same as *)    [17:03]

<jusss> wow, types have types?
<dminuoso> jusss: Well yeah. Anyway, you probably best forget it again - it's
           just what the future holds for us. Until then, types have *kinds*

not all the types can have values, only types which kind is * can have values,
and monad types's kind is *->*

<dminuoso> jusss: A type is something that exists on the type level.

<jle`> well, a monad like Maybe is a type
Maybe's kind is *->* ,so Maybe doesn't have a value

<dminuoso> Either is all three: a) a type, b) a type function (that is a
           function acting on types), and c) a type constructor
<dminuoso> Right is also all three: a) a value, b) a (value-level) function,
           and c) a data constructor

<dminuoso> jusss: We say that types of kind * are inhabitatable, which means
           that they *could* be inhabitated. (We dont know for sure, but the
           kind system at least allows for it)                          [16:10]
<dminuoso> So a type of kind * is, by the rules of the kind system, allowed to
           have values - but its allowed to have none. Contrarily a type of
           kind (* -> *) is not allowed to have any values.             [16:12]
<dminuoso> jusss: If a type is inhabitated, there exist values of that type.
<jle`> "can have a type"
<merijn> jusss: "type Foo is inhabited" = "there is at least one value with
         type Foo"                                                      [16:09]
<merijn> jusss: And reversed: "type Foo is uninhabited" = "there are no values
         with type Foo"



############################################

#newtype #type
1. newtype is faster than type
2. the value constructor introduced by newtype is strict
   and the value constructor introduced by data is lazy
3. you can only have one value constructor and that value constructor can only have one field

data CoolBool = CoolBool { getCoolBool :: Bool }
it means
data CoolBool = CoolBool Bool   // the first CoolBool is type constructor, and the last is value constructor
getCoolBool :: CoolBool -> Bool

helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"

newtype CoolBool = CoolBool { getCoolBool :: Bool }   
#########################################

Monad Transformer
Kleisli Arrow
CPS

##############################################
#kotlin #httpurlconnection #use httpconn.setRequestProperty for header
#data use urlencoded or json depend on header  #RESTful #post 
httpurlconnection
val reader: BufferedReader = BufferedReader(InputStreamReader(httpconn.inputStream, "UTF8"))
var output = reader.readLine()
        var result = ""
        while (output != null){
            result += output
            output = reader.readLine()  // readLine need "\r\n" as end of a line!
        }

val outputStream: DataOutputStream = DataOutputStream(httpconn.outputStream)
        outputStream.write(
            getBody(filePath)
                .toByteArray(charset=Charsets.UTF_8))
        outputStream.flush()
#######################################

json to map, kotlin
json is just a string,
val aJson = "{ret:x, msg:x}"
data class Msg(val ret:String, val msg:String)
val gson=Gson()
val result = gson.fromJson(aJson, Msg::class.java)
println(result.ret)

or just take what you need
data class Msg(val ret:String)
val gson=Gson()
val result = gson.fromJson(aJson, Msg::class.java)
println(result.ret)

map to json
val sendDataStr  = gson.toJson(whatever)

###############################################

<ski> and `(<=<)' composes functions whose results are monadic actions
<jusss> eiGHttt: fish operator, <=<
<jusss> eiGHttt: https://zhuanlan.zhihu.com/p/65449477                  [13:28]
<jusss> eiGHttt: composemonad, monadic actions
                                                                    [13:31]
<eiGHttt> 'monad                                            [13:33]
<eiGHttt> composemonad
###########################################

free mail receiver
http://www.utilities-online.info/email/

##############################################

#lambda in #kotlin

val exitDialog:(ALDialog,String,String) -> Unit = {
    a,b,c ->
        a.deactivateTopic(b)
        a.unloadTopic(b)
        a.unsubscribe(c)
}

https://www.baeldung.com/kotlin-lambda-expressions
##############################

`static' keyword in java is like class variables in python,
all the objects share the same variables at any time
it's called companion object in kotlin

java's singleton is implement by `object' keyword in kotlin

##########################################
#SAM #kotlin #interface
1. kotlin implement java interface
 Java 8, interfaces with exactly one function (known as "functional interfaces")
 can be replaced by lambdas. 
an instance of an anonymous class can be replaced by lambda

with a single method defined, making it a Single Abstract Method interface, which can be converted to a lambda

Kotlin has SAM ("single abstract method") only for Java interfaces.

EventCallback { it: Float ->
  if (it > 0) println("ouch!") else println("1")
}

or

EventCallback<Float> { if (it > 0) println("ouch!") else println("1") }

instead of

        object : EventCallback<Float> {
            override fun onEvent(arg0: Float): Unit = if (arg0 > 0) println("ouch!")
             else println("1")
             
and

new EventCallback<Float>() {
                    @Override
                    public void onEvent(Float arg0)
                            throws InterruptedException, CallError {
                        // 1 means the sensor has been pressed
                        if (arg0 > 0) {
                            tts.say("ouch!");
                        }
                    }
                }

2. f(a,b) to f(a)(b)
Whenever you have a function of the form `func(..., f: (...) -> T)`
(so `f` is a function type and is the last argument in `func`'s parameter list),
you can move `f` outside the parentheses and include it as a block
within curly braces after the close paren.

3. override method when instantiate a class

new EventCallback<Float>() {
                    @Override
                    public void onEvent(Float arg0)
                            throws InterruptedException, CallError {
                        // 1 means the sensor has been pressed
                        if (arg0 > 0) {
                        exitDialog(dialog,topic,"myModule");
                        }
                        else {tts.say("ouch!");}
                    }
}

object : EventCallback<Float> {
          override fun onEvent(arg0: Float): Unit =
          if (arg0 > 0) exitDialog(dialog,topic,"myModule")
          else
                tts.say("ouch!")
}
############################################

// Subscribe to FrontTactilTouched event,
        // create an EventCallback expecting a Float.
        frontTactilSubscriptionId = memory.subscribeToEvent(
                "FrontTactilTouched", new EventCallback<Float>() {
                    @Override
                    public void onEvent(Float arg0)
                            throws InterruptedException, CallError {
                        // 1 means the sensor has been pressed
                        if (arg0 > 0) {
                            tts.say("ouch!");
                        }
                    }
                });
<jusss> jsjava


#java #constructor

instantiate an class inside itself
it's look like make `self' of python in java

public class ReactToEvents {

    public static void main(String[] args) throws Exception {
                ReactToEvents reactor = new ReactToEvents();
                reactor.run(application.session());
                //what if we do reactor.attribute = "value"
                //but main() won't execute when class instantiate
                // what if we put this reactor into a constructor function and return it
                //constructor function will run this object when class instantiate
                // gg,
                //https://www.w3schools.com/java/java_constructors.asp
    }

     public void run(Session session) throws Exception {
     }
}
<jusss> class constructor  the constructor(object), class
        constructor
<jusss> the constructor                               [11:10]
<jusss> main()


##################################

abstract, sealed and data class in kotlin

in java, List is an interface, and ArrayList is an implement of List
inheritance a class use `extend' keyword
use `implement' to implement interfaces,
you can implement some interfaces in one class,
class xxx () implemnt xxx implemnt xxx { }

abstract class is like interface, but you only inheritance one abstract class from a class
class xxx () extend a-abstract-class

data class is a class that only stored data, nothing more, no methods
sealed class is can not be inheritance in java, only via reflection to visit
className.class.attributes

sealed class can be inheritance in kotlin, can not be instantiated,
use sealedClass.attributes to visit

sealed class can not be instantiated
data class must have at least one parameter as constructor

type inheritance!

open class G
class G2():G()
fun S(s: G){}
fun z() { val e = G2();  S(e)}

if A as parameter type in a function, then the instance of class B which inherit A,
can be applied by this function

##################################

#Either
f :: Either Int String -> Either Int String
fl :: Either a b -> a
fr :: Either a b -> b

f (Left x) = Left (x+1)
f (Right y) = Right (reverse y)

fl (Left x) = x
fr (Right y) = y

#################################################

java has @nullable annotation to declare a pointer cannot be null
<jusss> does haskell have Object type and null value ?
<jackdk> no                                                             [11:39]
<koz_> That's an oddly-specific question, jusss.
<koz_> What do you wanna do?
<jusss> koz_: I'm learning java and kotlin just now,                    [11:40]
<jusss> so I wonder                                                     [11:41]
<jusss> undefined in haskell is a value or a type? and what is bottom type?
<heatsink> jusss: In Java, there was no way to declare that a pointer cannot
           be null, and mistakes cause NullPointerExceptions.  Java introduced
           @nullable annotations to help deal with the problem, saying at
           least sometimes that a pointer can't be null
<Cale> jusss: undefined is a value, but it's a value which is
       indistinguishable from your program going into an infinite loop
<heatsink> jusss: Haskell comes from the opposite direction.  "Pointers" are
           always pointing to valid data.  If you want an maybe-present,
           maybe-absent value, like a pointer that can be null, you would use
           the Maybe data type.
<Cale> So, you don't "test for undefined" the way you might "test for null"
<M31violet13[m]> That's what the Maybe monad is for, no?                [11:45]
<glguy> The Maybe type at least                                         [11:46]
<Cale> Yeah, as heatsink mentioned.
<Cale> You might not bother using the Monad instance, just the type and
       pattern matching can be good enough a lot of the time.
<jusss> what we call Maybe a?  Maybe Int is a type, Maybe a is a type?
<M31violet13[m]> That is a type.                                        [11:48]
<jusss> ok
<EvanR> undefined is theoretically indisinguishable but...              [11:50]
<EvanR> you can do evil things like catch undefined exception
<jusss> haskell has Exception stuff?                                    [11:56]
<EvanR> yes                                                             [11:57]
<jusss> I thought Haskell is like C, just have a static type system without OO
<EvanR> theres few ways haskell is like C                               [11:58]
<glguy> EvanR: It's not relevant to this discussion, but catching undefined
        evaluation exceptions are much less precise than matching on null
<glguy> you can't tell where the undefined came from
<jusss> now I learn four kinds of languages, 1. dynamic type with OO like
        Python and Javascript,  2. static type without OO like C and Haskell,
        3. static type with OO like Java and Kotlin, 4. dynamic type without
        OO, scheme...
<EvanR> yeah but haskell feels much different from python, javascript, C,
        Java, and scheme                                                [12:02]
<EvanR> so that 2-bit criteria seems like its missing something
<jusss> that 3. static type with OO was really make me confused a few days
        ago, 'cause they have type and class!
<jusss> and they even have type inheritance!
<jusss> they can use class as type, or say type as class?               [12:05]
<heatsink> jusss: Besides those 4 kinds of languages, some programming
           languages are designed to help programmers prove that their code
           works correctly.  For example, some languages let you wrote proofs
           and code together; invalid proofs and invalid code alike are
           detected by the compiler.                                    [12:08]
<heatsink> jusss: Haskell isn't really in that category of languages
           supporting formal proofs, but it's influenced by that domain
<jusss> heatsink: you mean like @ annotation in java?
<heatsink> jusss: Some Java tools use annotations to prove specific kinds of
           correctness, such as null-safety.  It's similar.
<heatsink> jusss: The difference is, each tool proves just one thing.  If you
           want to prove that your program doesn't access arrays out of
           bounds, your @nonnull annotations won't help at all.
<___laika> i think the idea is to be more explicit about what functions have
           access to which capabilities
<heatsink> jusss: Proof-oriented languages try, more or less, to let you prove
           anything that's proveable
<jusss> heatsink: decorator in python is a proof?                       [12:19]
<heatsink> jusss: No
<___laika> and then not tying it to IO allows users to be more flexible about
           monad stack and such, i guess                                [12:21]
<___laika> jusss: python decorators are just syntax sugar to make it easier to
           wrap top normal definitions                                  [12:22]
<jusss> heatsink: ___laika ok                                           [12:23]
<___laika> if you annotate a function foo with @bar
<___laika> thats the same as saying foo = bar(foo)
<___laika> err
<___laika> foo = bar(original definition of foo)                        [12:24]
<___laika> it rebinds it to the same name
<jusss> ___laika: I wonder if decorator in python is like compose in haskell?
<jusss> function compose, of course
<___laika> not exactly i dont think                                     [12:26]
<jusss> ok
<___laika> a decorator basically extends an existing function with some given
           functionality                                                [12:27]
<___laika> in haskell it would look more like
<___laika> decorator = <some definition>
<___laika> f = <other>
<___laika> f' = decorator f
<___laika> function composition in python can be accomplished via a couple
           mechanisms
           https://mathieularose.com/function-composition-in-python/    [12:28]
<jackdk> in a similar vein, you can think of fmap, liftA(n), foldMap, >>=,
         traverse etc as "function transformers"                        [12:43]

#####################################

#Types have Functions  or Functions appy on Types?
#abstract&concrete

Prelude> :{
Prelude| f::Either a b -> a
Prelude| f (Left x) = x
Prelude| :}
Prelude> f (Left 3)
3

Prelude> :{
Prelude| g :: Either a b -> Either a b
Prelude| g (Left x) = Left (x+1)
Prelude|
Prelude>      is not ok, 'cause x+1 need x is Int, 'cause Types have Functions
but here x is just a, not Int

if you want use x+1 and reverse a string, then make Either a b concrete!
'cause concrete Int has +1 and String has reverse function

Prelude> :{
Prelude| g::Either Int String -> Either Int String
Prelude| g (Left x) = Left (x+1)
Prelude| g (Right y) = Right (reverse y)
Prelude| :}
Prelude> g (Left 2)
Left 3
Prelude> f (g (Left 2))
3

Prelude> :{
Prelude| t :: Either Int b -> Int
Prelude| t (Left x) = x+1
Prelude| :}
Prelude> t (Left 2)
3

########################################
#instance #variable #kotlin
another way is define function B inside function A,
then you can call B inside A

instance variable self.var in python is look like
class T2 {
      var time:Time
      init{
        time = Time()
      }
      fun test(){
          time = Whatever
      }
}
'cause to instantiate a class to an object, it must be in a method of class
but you can declare it outside a method and inside a class, and
init it in the init block,
or
class T2(var time:Time){
      init{
        time = Time()
      }
 }
 don't do variable instantiate in init block
 init { var time = Time() } you won't visit time in other place

this keyword

this in kotlin is not like self in python
 class T:
...     def __init__(self):
...             self.t = self()
...
>>> s=T() will be an error AttributeError: T instance has no __call__ method

>>> class T:
...     def __init__(self):
...             pass
...     @classmethod
...     def finit(cls):
...             self.t = cls()
...
>>> s=T()
>>> s.t
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: T instance has no attribute 't'

 Every secondary constructor must invoke another (primary or secondary)
 constructor by using the this keyword as if it were a function (so that every instance
 construction eventually calls the primary constructor).

class Person(val name: String, var age: Int) {
    constructor(name: String) : this(name, 0)
    constructor(yearOfBirth: Int, name: String)
        : this(name, 2018 - yearOfBirth)
}

val a = Person("Jaime", 35)
val b = Person("Jack") // age = 0
val c = Person(1995, "Lynne") // age = 23

I feel `this' keyword in kotlin is look like `this' in javascript,
`this' is the stuff where it's in a scope when it runs

so init { this.age = 22; var time = Time() } are stupid

#infix expression

infix fun marry(spouse: Person) {
    println("$name and ${spouse.name} are getting married!")
}
val lisa = Person("Lisa")
val anne = Person("Anne")
lisa marry anne // Prints "Lisa and Anne are getting married!"

https://kotlinlang.org/docs/tutorials/kotlin-for-py/classes.html

###########################################

val f2 = mutableMapOf<String,String>()
f2["1"] = "2"
println(f2["2"])
will print null
#############################################

#kotlin #map #dict

why to instantiate a class, it must be in a method of a class? not in a class directly?
class Intro{
    fun MyInit():Map<String,String>{
       // why instantiate an class must be put into a method?
       val duce = mutableMapOf<String, String>()
       duce["key"] = "value"
       return duce
   }
    val duce = MyInit()
}

###########################################

#kotlin global variable, instance variable

class Test {
     fun f(): Int{
         var t = 1
         return t
         }
    t = f()
    fun g(){
        // then you can use t here
        }
 }
###############################

#socket

about two socket exceptions
1. shutdown without exit signal, catch Exception to handle
2. shutdown with exit signal, read() will return -1

##########################################

#kotlin #String #ByteArray

String to ByteArray,   "a".toByteArray(Charsets.UTF_8)
ByteArray to String,  String(aByteArray, Charsets.UTF_8)

.toString is showing as string, you even can ByteArray.toString show the bytes as string
but .toString can not return a string, so use String(aByteArray, Charsets.UTF_8) to convert
a ByteArray to String

type(3) in python, is like 3.getClass()
isinstance in python is like is in kotlin

String.substring(0,2)
ByteArray.sliceArray(0..2)  or (0 until sizeVar)

IntRange is look like 0..1  or 0..size

python has socket.recv() and send(),
but java and kotlin don't have that , they have write() and read()
and read() may read one byte once or one byte array once
there's no a sign of end, you need to design it by yourself, like
you can use "\r\n" as end sign, then you write ("abcd\r\n") and
when put read in a loop, when read "\r\n" then break the loop,
also you need to use the byte array's size to get the valid byte array
to turn it to a string

val size = client.inputStream.read(aob);
val recvMsg:String =
        String(aob.sliceArray(0 until size), Charsets.UTF_8)
###################################################

<Bombe> An arrays toString() does not return a representation of the content
        of the array.                                                   [14:18]
<Bombe> And InputStream.read(byte[]) is not guaranteed to fill the array or
        generally return more than one byte. If you are expecting multiple
        bytes you need to make sure you read them all before proceeding.
<Bombe> You can wrap it in a BufferedReader which offers readLine(), sure.
<jusss> does kotlin have list/set/dict comprehesion, decorator, generator,
        those features those modern languages have?                     [16:15]
<jusss> I saw that kotlin has coroutine, and java doesn't               [16:16]
<jusss> and kotlin's coroutine is related with Promise/Future ?
<yawkat> yes, kotlin has some of those features.                        [16:17]
<yawkat> no, coroutines are not related to promises or futures, though they
         can be used to implement them.
<jusss> and I also saw kotlin has a static type system, and does it have
        typeclass ?                                                     [16:18]
<yawkat> no.                                                            [16:19]
<jusss> and I saw kotlin say coroutine libraries are stable now, and when it
        will make it as buit-in or called std lib?
<yawkat> im not sure if they ever will be in the stdlib - the stdlib is meant
         to be light.
<jusss> if kotlin's coroutine doesn't to do with Promise/Future, then what's
        the meaning of exist?                                           [16:20]
<jusss> it can not be flattern, can not be cancel, can not be append
<yawkat> coroutines are a nicer way to implement state machines. what you do
         with them is up to you.
<jusss> even javascript the front language has Promise now, I don't understand
        a language like java/kotlin why still not have it               [16:21]
<Bombe> Because the language designers didnt put it in.               [16:22]
<jusss> it's too difficult to implement to kotlin? 
<yawkat> jusss: that is an entirely different statement.
<Bombe> And especially JavaScript shouldnt be taken as an example for
        anything.                                                       [16:23]
<jusss> all those features other modern langues have, and kotlin is design as
        a moder language?
<jusss> I heard your sugestion,and put "1" as a sing of end, but why the
        "c.length" is 1017, even I just send a 4 character string       [16:28]
<Bombe> jusss, that doesnt contain anything of what we talked about.
<yawkat> jusss: because your array is that big.
<yawkat> youre converting the entire array to a string.
<jusss>   val size = client.inputStream.read(aob)                       [19:19]
<jusss>  val recvMsg:String = String(aob, Charsets.UTF_8)
<jusss> how I can do ByteArray slice on aob?
<jusss> aob[0:size] on kotlin?
<jusss> I saw that slice method, but I don't understand why it
        aob.slice(0..size) is wrong?
<yawkat> use sliceArray                                                 [19:23]
<yawkat> also, 0 until size, because .. is inclusive
<yawkat> also, read may terminate before the input has been fully read, so
         calling it outside a loop is almost always wrong               [19:24]
<yawkat> also, just use an inputstreamreader instead of decoding it yourself.
<jusss> yawkat: fun ByteArray.sliceArray(indices: IntRange): ByteArray,  I
        don't know what IntRange looks like?                            [19:29]
<yawkat> 0..4 is an intrange.                                           [19:30]
<jusss> 0 until size?
############################################

#kotlin #socket #server
import java.net.ServerSocket
fun main(){
    val server = ServerSocket(50017)
    val client = server.accept()
    val msg = "hello"
    var aob = ByteArray(1024)

    client.outputStream.write(msg.toByteArray(Charsets.UTF_8))
    client.outputStream.flush()
    //client.inputStream.read(aob)
    val size = client.inputStream.read(aob)
    //println(aob.toString(Charsets.UTF_8))
    println(String(aob.sliceArray(0 until size), Charsets.UTF_8))

}

#kotlin #socket #client
import java.net.Socket
class Client(addr:String, port:Int){
    val sock = Socket(addr, port)
    fun sendToRobot(msg:String): Boolean {
        sock.outputStream.write(msg.toByteArray(Charsets.UTF_8))
        sock.outputStream.flush()
        return true
    }
    fun recvFromRobot():String{
        var aob = ByteArray(1024)
        val size = sock.inputStream.read(aob)
        //println(aob.toString(Charsets.UTF_8))
        return String(aob.sliceArray(0 until size), Charsets.UTF_8)
    }
    fun close(){
        sock.close()
    }
}

fun main(){
    val a = Client("127.0.0.1",50017)
    //val a = Client("192.168.31.207",50007)
    a.sendToRobot("3\n")
    a.sendToRobot("7")
    println(a.recvFromRobot())
}
// sock.use {} is like with statement in python, auto close file io or socket io

#############################################

compile java code on windows 10 and run it on gentto
http://doc.aldebaran.com/2-1/dev/java/index_java.html
1. download jdk
download jdk7 for windows from oracle.com
download jre7 or jdk7 for linux from oracle.com

2. download dependecy library
download java-naoqi-sdk-2.1.4.13-win32-vs2010.jar for windows from aldebaran.com
download java-naoqi-sdk-2.1.4.13-atom.jar not *-linux.jar for linux from aldebaran.com

3. coding on windows 10
open intellij idea and create a project based on jdk7 then import that download jar file,
after coding, then
>"c:\Program Files (x86)\Java\jdk1.7.0_60\bin\javac.exe" -cp D:\java-naoqi-sdk-2.1.4.13-win32-vs2010.jar src\HelloWorld.java
it will output a HelloWorld.class, copy this HelloWorld.class to gentoo

4. run *.class on gentoo
export JAVA_HOME=/home/nao/java/jdk1.7.0_60
export PATH=$PATH:/home/nao/java/jdk1.7.0_60/bin
 java -cp .:java-naoqi-sdk-2.1.4.13-atom.jar HelloWorld

remember! the -cp must contain '.' when you run `java -cp `
'cause '.' is where HelloWorld.class is
the default -cp contain '.', but if you tell it -cp x.jar, then it doesn't include '.',
you need to point it in -cp like '-cp .:x.jar'

5. compile kotlin code to jar on windows 10 and run it on gentoo
create a kotlin/JVM project based on jdk7 and use intellij idea artifacets build to jar
pass that jar to gentoo,
java -cp .:java-naoqi-sdk-2.1.4.13-atom.jar:KotlinOnNaoqi.jar HelloWorldKt

6. use jdk8 test that java-naoqi-sdk-2.1.4.13-win32-vs2010.jar which is compiled by jdk7
download jdk8 for windows and linux
>"c:\Program Files (x86)\Java\jdk1.8.0_212\bin\javac.exe" -cp D:\java-naoqi-sdk-2.1.4.13-win32-vs2010.jar src\HelloWorld.java
copy that src\HelloWorld.class to gentoo
 ~/java8 $ ./jdk1.8.0_212/bin/java -cp ~/java-naoqi-sdk-2.1.4.13-atom.jar:. HelloWorld
 and it just works!

7. use kotlin based on jdk8 compile on windows run on gentoo
compile with intellij idea artifacts build to jar on windows 10,
./jdk1.8.0_212/bin/java -cp ~/java-naoqi-sdk-2.1.4.13-atom.jar:Java8Naoqi.jar HelloWorld

or java on jdk8
"c:\Program Files (x86)\Java\jdk1.8.0_212\bin\javac.exe" -cp D:\java-naoqi-sdk-2.1.4.13-win32-vs2010.jar src\Hello.java
./jdk1.8.0_212/bin/java -cp ~/java-naoqi-sdk-2.1.4.13-atom.jar:. Hello

String seems different betweeen java and kotlin
##################################################

compile kotlin with arrow code to a jar, and import that jar in java, and it works!
pack jar use kotlin's artifacts build

###############################################

#java #classpath #main class

java -classpath xxx    main-class

1. create a class
java with gradle, del2\src\main\java\Main.java,  there's a public static Main{ psvm {}} in it
there's no package, so the main class is "Main", if this Main.java is in package "com.sun",
then its main class is "com.sun.Main", and the path of Main.java is the classpath, if it's package,
then the path of package is the classpath, `cd del2` then `java -cp src\main\java`,
`cd del2\src\main\java` then `java -cp .`

2. build.gradle 
jar {
    manifest {
        attributes 'Main-Class': 'Main'       //this make it as a runnable jar
    }
    // from(zipTree("path-of-dependency-jar"))
    //https://stackoverflow.com/questions/21721119/creating-runnable-jar-with-gradle
    //https://medium.com/@preslavrachev/kotlin-basics-create-executable-kotlin-jars-using-gradle-d17e9a8384b9
}
this will find Main.java in source root folder "src\main\java" then pack Main.java alone into a jar without the path,
'cause main class is Main, there's no prefix package

3. cd into del2, run `gradle build`, it will output  del\build\libs\del.jar

4. cd del\build\libs\ , run `java -cp del2-1.0-SNAPSHOT.jar Main`, that main method in Main.java will run

5. or compile Main.java to Main.class via `cd del2\src\main\java`, `javac -cp . Main.java`, then run `java -cp . Main`
if there's "import org.junit.Test;" in Main.java
then put junit-4.12.jar in current directory, run `javac -cp junit-4.12.jar Main.java`, you can put several jars here split with ';' on  windwos, ':' on unix
and `java -cp . Main` to run this code
you can not run `java -cp . Main` without compile Main.java to Main.class

6. about jar files, it just a simple zip file which contains some *.class files
and a *.class is just a binary code file, you can create jar files with
`jar cvf del2.jar      *.class`
`java -cp del2.jar      Main`  but this is not a runnable jar, you can not run it with `java -jar del2.jar`, or change manifest file in jar file
but you can create a runnable jar with gradle, but it needs edit build.gradle, append jar{ manifest {... }}

now there're four ways to create jars, 1. use intellij idea-artifact build, 2. `gradle build`, 3. maven, 4. `jar cvf x.jar x.class`
https://github.com/junit-team/junit4/wiki/Getting-started
https://enigmastation.com/2014/07/11/repost-rocket-java-that-stupid-classpath-thing-you-should-understand/
https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/classpath.html
https://docs.oracle.com/javase/tutorial/rmi/compiling.html

################################################

the classpath points to paths of packages

Cool.class in the package utility.myapp.
If the path to that directory is /java/MyClasses/utility/myapp,
% java  -classpath /java/MyClasses       utility.myapp.Cool

But when classes are stored in an archive file (a .zip or .jar file)
the class path entry is the path to and including the .zip or .jar file.
% java  -classpath /java/MyClasses/myclasses.jar      utility.myapp.Cool

To find class files in the directory /java/MyClasses as well as classes
in /java/OtherClasses, you would set the class path to:
% java  -classpath /java/MyClasses:/java/OtherClasses       ...
Note that the two paths are separated by a colon.

-cp is short for -classpath
on unix is colon ':', but on windows is ';'

java -cp foo.jar:bar      foo.bar.Baz
the classpath is foo.jar in the current directory, or bar folder in the current directory
Java will then look inside foo.jar, looking for a file entry of /foo/bar/Baz.class
If foo.jar contains /foo/bar/Baz.class, Java uses it and stops looking further in the classpath.
If foo.jar does not contain /foo/bar/Baz.class,
then Java will look in the bar directory for ./foo/bar/Baz.class



##########################################################
#gradle build jar

javac is used to compile package to jar or java file to class file 
java is used to run jars or class

1. build.gradle
jar {
    manifest {
        attributes 'Main-Class': 'Main'
    }
}
put your main class in build.gradle, if src\main\java\Main.java without package,
then the main class is Main

2. public class Main {} in Main.java should have one public static void main(String[] args) {} as entry point, and import others pacakges in this Main.java

3. cd into the root of this project, run `gradle build` will output a jar in "build\libs\"

4. java -jar a.jar to run it

https://stackoverflow.com/questions/21721119/creating-runnable-jar-with-gradle
##############################################

1. build.gradle
    implementation 'junit:junit:4.12'
2. Settings - Build - Gradle - Runner - Platform Test Runner

there're two junit, junit 4 and junit 5

Settings - Build - Gradle - Runner - Gradle Test Runner

###############################################

one file only has one public class, it can have several other class,
every class only has one main() method, as the entry point,
and the file name must be the same with the public class name
put cursor on the code block you may want to run, then right click,
choose run the function

main() should be  public static void main(String[] args) {}
main() is the entry point, so main() doesn't need @Test

##############################################

JAVA_HOME in windows 10, download java sdk 12 from oracle, 
and install it,
JAVA_HOME is point to "C:\Program Files\Java\jdk-12.0.1"
and append "%JAVA_HOME%\bin" to PATH

download gradle from gradle.org, and unzip it to C:\Gradle\
put this "C:\Gradle\gradle-5.5\bin" into PATH via search "Advance xxx"
cd into the root of project, then do `gradle build`  will generate "build\libs\xxx.jar"
you should change build.gradle for main class, like MainKt, then in main.kt to import
other files it wants to use, then `gradle build`

######################################
class name in java should be the same with file name
Main.java
public class Main

java's class instance must be in a method of a class!
you can instance a class in a class directly, do it in a method of a class!

kotlin, src/k2p.kt   there's a class Robot in it, and no main function,
and its main class is K2pKt
if it's main.kt, its main class should be MainKt

src if it's not blue, 'cause it's not source root, right click change it to source root

src/ right click create package, com.sun.k2p
right click create a new file Robot.kt on that package,
pacakge com.sun.k2p will auto show in that new file
main class will be com.sun.k2p.RobotKt
so in kotlin, main class is "pacakge-name.file-name"

export to jar
Project Structure - Artifacts - '+' - JAR - from modules with dependices
main class is com.sun.k2p.RobotKt
Build Artifacts - build 

import jar
create lib folder in project, and copy jar to that folder,
Project Structure - Modules - Dependencies - + - JARs or directories choose that jar in lib

#1
java need junit to run a part of code,
download jnit.jar and import it in project, then put it on above on the method like

import com.sun.k2p.Robot;
import com.sun.k2p.RobotKt;
public class Test {
    @org.junit.Test
    public void main(){
        Robot n = new Robot("127.0.0.1", 50017);
        n.sendToRobot("hello");
    }
}

right click Run Test will run this function

#2 use gradle
build.gradle
 compile 'junit:junit:4.11'
 do the same

#3 use maven  pom.xml
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.11</version>
    </dependency>
    </dependencies>
    do the same

#############################################

use in kotlin is like with statement in python, auto close file io or socket io
socket.use{
        it.inputStream.read(read_buffer)
}
//without socket.close() in it

#####################################################

#socket #python #server

socket server, 1 to 1 , multiple connection times
import socket
def net_init():
        conn, addr = sock.accept()
        #conn.settimeout(10)
        while True:
            try:
                t=conn.recv(1024)
                if not t:
                    break
            except:
                break
            print(t)
        conn.close()
        net_init()

if __name__ == '__main__':
        sock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0',50017))
        sock.listen(50)
        net_init()

#########################################

json can handle list too, not just dict

c=json.dumps(list)
alist = json.loads(c)
and json is a str

but an object can not be jsonlized!

#######################################

java anonymous thread

new Thread()
{
    public void run() {
        System.out.println("blah");
    }
}.start();

#####################################################3

import jar in java project, jetbrain intellij idea, gradle with java
vim build.gradle
dependencies {
     implementation files('d:\\k2pjar-1.0-SNAPSHOT.jar')
}

in android studio
you can use the same way with upside, or 
File - Project Structure -Dependencies - <All Modules> -All Dependencies - click '+' -
input your jar's path

on linux you can use one command "grade clean build"

export jar, kotlin with gradle in intellij idea
click right sidebar Gradle - Tasks - build - double click build, it will generate jar in the project directory C:\Users\admin\IdeaProjects\k2pjar\build\libs
or File - Project Structure - Artifacts - '+' -  jar - empty -ok - then
Build - Build Artifacts - choose your jar name - build (but it seems alwasy faild to me)

#######################################
<jusss> how to use kotlin code in java project?
<roboirc> jusss: you can create separate kotlin file and use the kotlin code
          in it
<roboirc> jusss: depends what your kotlin code is in? class or ?
<jusss> roboirc: class or what?                                         [16:53]
<roboirc> but problem is only have custom file commons-codec-1.12.jar in libs,
          not common-codec-1.10.jar
<roboirc> jusss: what is your kotlin code?
<jusss> roboirc: it's look like this https://paste.ubuntu.com/p/TTPmGxzP4r/
<jusss> roboirc: now it's just a simple socket code
<roboirc> jusss:
          https://kotlinlang.org/docs/tutorials/mixing-java-kotlin-intellij.html
                                                                        [16:56]
<jusss> roboirc: I want run this a.sendToRobot() when a picture is clicked on
        android
<jusss> and that android project is written by java
<roboirc> your using android studio right, jusss?
<jusss> roboirc: right                                                  [16:58]
<jusss> roboirc: but the config I always don't understand
<roboirc> jusss: check out the site I showed you?
<jusss> roboirc: yeah
<roboirc> jusss: since your code is a class, just create a new kotlin class
          and paste it there and start using it                         [17:06]
<jusss> roboirc: but I want the java code to call this kotlin method    [17:10]
<jusss> roboirc: I can import this kotlin file in java ?
<roboirc> yes                                                           [17:11]
<roboirc> just drag and drop it into your project
<roboirc> should be fine
<jusss> how to wrap kotlin code to a jar file and use that jar in java?
<Tazmain> I believe you just compile to a jar and import it             [16:57]
<dreamreal> jusss: mvn package, or gradle jar... it's just a regular jar, and
            java can use the kotlin code pretty much out of the box in a lot
            of cases                                                    [17:07]
<dreamreal> there are a few things to consider, because kotlin has a lot of
            features java does not (package level functions, default arguments
            for methods, stuff like that) that might necessitate using
            specific annotations and class names for use in java, but it's
            usually pretty sane                                         [17:09]
<jusss> dreamreal: the question is I don't how to use gradle to make a jar,
<dreamreal> if only I had said a simple command to use! That might have helped
            you a lot. Such a command would look like "gradle jar", you know?
<jusss> I don't know the envrionement variable on windows, 
<dreamreal> WHAT environment variable?                                  [17:29]
<jusss> there's no /usr/lib or /usr/bin/ on windows
<dreamreal> It's a SIMPLE COMMAND!
<dreamreal> "grqdle jar"
<jusss> and where I can run the simple command?
<dreamreal> cmd.exe?
#################################################################

return/break/continue to the caller of the lambda

fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda, i.e. the forEach loop
        print(it)
    }
    print(" done with explicit label")
}
1245 ,  return to the caller of the lambda, i.e. the forEach loop

we can also return using an implicit label, like return@forEach
https://www.baeldung.com/kotlin-return-break-continue

Without a label, continue will proceed to the next iteration of the enclosing loop
when we use continue with a label marking a loop, it will proceed to the next iteration of that loop

Without a label, break terminates the nearest enclosing loop. 
we can use break with a label, which terminates the loop marked with that label

Any expressions in Kotlin can be marked with a label.
For example, abc@,
loop@ for (i in 1..10) {
    // some code 
}

@Test
fun givenLoop_whenBreakWithLabel_thenComplete() {
    var value = ""
    outer_loop@ for (i in 'a'..'d') {
        for (j in 1..3) {
            value += "" + i + j
            if (i == 'b' && j == 1)
                break@outer_loop
        }
    }
    assertEquals("a1a2a3b1", value)
}


###########################################3
this is receiver,

class A { // implicit label @A
    inner class B { // implicit label @B
        fun Int.foo() { // implicit label @foo
            val a = this@A // A's this
            val b = this@B // B's this

            val c = this // foo()'s receiver, an Int
            val c1 = this@foo // foo()'s receiver, an Int

            val funLit = lambda@ fun String.() {
                val d = this // funLit's receiver
            }


            val funLit2 = { s: String ->
                // foo()'s receiver, since enclosing lambda expression
                // doesn't have any receiver
                val d1 = this
            }
        }
    }
}

https://kotlinlang.org/docs/reference/this-expressions.html#qualified
https://kotlinlang.org/docs/reference/keyword-reference.html
https://kotlinlang.org/docs/reference/basic-syntax.html
# kotlin this at notation
###########################################################

https://kotlinlang.org/docs/reference/extensions.html
extension functions
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // 'this' corresponds to the list
    this[index1] = this[index2]
    this[index2] = tmp
}
The this keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any MutableList<Int>:

val l = mutableListOf(1, 2, 3)

l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'

Of course, this function makes sense for any MutableList<T>, and we can make it generic:

fun <T> MutableList<T>.swap(index1: Int, index2: Int) {

    val tmp = this[index1] // 'this' corresponds to the list

    this[index1] = this[index2]

    this[index2] = tmp

}

#############################################

#catagory theory
# seven sketches mit
https://ipv4.google.com/search?source=hp&ei=Ke39XMK4B822mAWa5Iv4Ag&q=seven+sketches+mit+&oq=seven+sketches+mit+&gs_l=psy-ab.12...576.5630..6252...0.0..0.772.5710.2-15j1j1j1j1......0....1..gws-wiz.....0..0i131j0j0i10j0i22i30j0i22i10i30j33i22i29i30j33i160.vN6W_ZEhvZM

<$> and >>= different, >>= can return Nothing, but <$> can't if (f a) is not Nothing
https://stackoverflow.com/questions/35387237/difference-in-capability-between-fmap-and-bind
#combine two decorators
https://stackoverflow.com/questions/5409450/can-i-combine-two-decorators-into-a-single-one-in-python

#java #http request #post #get #RESTFul API
https://www.cnblogs.com/newflydd/p/4891809.html
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
 
public class SendPostDemo {
 
    public static void main(String[] args) throws Exception{
        String urlPath = new String("http://localhost:8080/Test1/HelloWorld");  
        //String urlPath = new String("http://localhost:8080/Test1/HelloWorld?name=".getBytes("UTF-8"));
         
         
        String param="name="+URLEncoder.encode("","UTF-8");
         
        //
        URL url=new URL(urlPath);
        HttpURLConnection httpConn=(HttpURLConnection)url.openConnection();
         
        //
        httpConn.setDoOutput(true);     //
        httpConn.setDoInput(true);      //
        httpConn.setUseCaches(false);   //
        httpConn.setRequestMethod("POST");      //POST
         
        //
        httpConn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        httpConn.setRequestProperty("Connection", "Keep-Alive");// 
        httpConn.setRequestProperty("Charset", "UTF-8");
         
        //,connecthttpConn.getOutputStream()connect
        httpConn.connect();
             
        //URL
        DataOutputStream dos=new DataOutputStream(httpConn.getOutputStream());
        dos.writeBytes(param);
        dos.flush();
        dos.close();
         
        //
        int resultCode=httpConn.getResponseCode();
        if(HttpURLConnection.HTTP_OK==resultCode){
            StringBuffer sb=new StringBuffer();
            String readLine=new String();
            BufferedReader responseReader=new BufferedReader(new InputStreamReader(httpConn.getInputStream(),"UTF-8"));
            while((readLine=responseReader.readLine())!=null){
                sb.append(readLine).append("\n");
            }
            responseReader.close();
            System.out.println(sb.toString());
        }  
    }
}

###################################################

android cast screen to TV or PC (dell laptop inspiron 5480), miracast
https://www.jianshu.com/p/bc8a7ecfd083
https://www.asus.com.cn/support/faq/1031773
1. Window + P 
2. 

on you android phone (asus zenfone 5)
1. connect the same wifi with PC or TV
2. PlayTo connect to TV or PC
3. allow the connection on PC or TV
##########################################################

#postgresql

pip install psycopg2

5432 is the default port to postgresql
pgAdmin is the manage tool for postgresql
add the path of psql.exe into you $PATH environment on win10

use pgAdmin to create a new database

notice, add new server is not the same with creating new database

there's a default database called postgres, and user is postgres, 
click 'Servers' - 'PostgreSQL' - 'Databases' right click create 'Database'
right click on that new databases create cast

import psycopg2
conn = psycopg2.connect(database="j4", user="postgres", password="p", host="127.0.0.1", port="5432")
print ("Opened database successfully")
cur = conn.cursor()
cur.execute('''CREATE TABLE COMPANY2
       (ID INT PRIMARY KEY     NOT NULL,
       NAME           TEXT    NOT NULL,
       AGE            INT     NOT NULL,
       ADDRESS        CHAR(50),
       SALARY         REAL);''')
print ("Table created successfully")

conn.commit()
conn.close()
################################################################

https://kotlinlang.org/docs/reference/extensions.html

#kotlin #arrow
follow the arrow website
"Could not find io.arrow-kt:arrow-effects-kotlinx-coroutines-data:0.9.1-SNAPSHOT."
put
 maven { url 'https://mvnrepository.com/artifact/io.arrow-kt'}
 into repositories {} in build.gradle

#########################################################
#REST #RESTFul #restful

https://requests.readthedocs.io/en/master/api/
params  (optional) Dictionary, list of tuples or bytes to send in the query string for the Request.
data  (optional) Dictionary, list of tuples, bytes, or file-like object to send in the body of the Request.
json  (optional) A JSON serializable Python object to send in the body of the Request.
headers  (optional) Dictionary of HTTP Headers to send with the Request.

in python requests, `data' will upload a dict as
"emp2Name=Jesse&emp2Op=insert&emp2Table=emp2&emp2Age=49"
`json' will upload a dict as
"{\"emp2Name\": \"Jesse\", \"emp2Op\": \"insert\", \"emp2Table\": \"emp2\", \"emp2Age\": 49}"

#############################################################

about REST Ful API,

url, headers, params, data, json, auth, cookies, timeout, allowRedirects, stream, files

    //1. every value in key-value should do URLEncoder.encode in java, but python has urllib.urlencode(dict) for a dict
    //2. pass a key-value string like a=b&c=d, not a json {a=b;c=d}, declare this in header by "Content-Type", "application/x-www-form-urlencoded"
    //3. params is in body in post, in header in get
    //4. headers is look like accept: application/json content-type: application/json
    //5. params is in body, so they're same, when headers application/x-www-form-urlencoded, params and body like parameter=value&also=another
    //6. multipart/form-data is for files, application/json is for json like "{a=b;c=d}"
    //7. check post or get first, check json or urlencoded second,
    //8. if it's urlencoded, value should be urlencoded, if it's json, the dict or map should be to json
    //9. headers maybe a json, and body maybe bytes from file

# restful passing file
self.headers = {'Ocp-Apim-Subscription-Key': '','Content-type': 'audio/ogg; codec=audio/pcm; samplerate=16000','Accept': 'application/json'}
response = self.http_client.fetch('https://westus.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=zh-CN',method='POST',headers=self.headers,body=open(self.filename,'rb').read())

# passing json
post_data={"reqType":0,"perception":{"inputText":{"text":p},"inputImage":{"url": "imageUrl"},"selfInfo":{"location":{"city":"","province":"","street":""}}},"userInfo":{"apiKey":"","userId": ""}}
                data_send = json.dumps(post_data).encode("utf-8")
                response = self.http_client.fetch('http://openapi.tuling123.com/openapi/api/v2',method='POST',body=data_send)

# passing urlencoded
paramsDict = {'app_id':'2111117142',
              'question':questionBytes,
              'time_stamp':time_stamp,
              'nonce_str':nonce_str,
              'session':'10000'
             }
body = urllib.urlencode(paramsDict)
response = http_client.fetch(url, method='POST', body=body,  validate_cert = False)

//10. body are bytes, the different is that read bytes from file, or turn json to bytes or turn urlencoded to bytes


##################################################

kotlin and java have two dependcy trees, maven and gradle, pom.xml and build.gradle
khttp in build.gradle
add JitPack repository to build file
repositories{
        maven { url 'https://jitpack.io' }
}
add the dependency
dependencies {
             implementation 'com.github.jkcclemens:khttp:0.1.0'
}
then import khttp.post in you code.kt

fun sendw(question: String):String{
    val res = khttp.post(
        url = "https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat",
        data = get_params(question)
    )
    return res.text
}

https://www.baeldung.com/kotlin-khttp

khttp is better than httpurlconnection okhttp retr*** spring boot

create maven and choose kotlin archtype then next will generate pom.xml and kotlin file
create gradle and chosse kotlin, will do build.gradle and kotlin
###################################################

they like this
    finalObject = Object.changeAttrB(x).changeAttrA(x)
    finalObject.run()
    and that changeAttrB and changeAttrA will return Object itself with x

class Test:
    def __init__(self):
          self.attb = 'whatever'
          self.atta = 'aha'
    @classmethod
    def changeAttrB(cls,x):
        tt=cls()
        tt.attb=x
        return tt
    @property
    def run(self):
        print(self.atta)
        print(self.attb)

t=Test.changeAttrB(3)
t.run

#python #class

######################################

kotlin class and inheritance

1. if the class has no body, curly braces can be omitted.
class Empty

2. primary constructor and secondary constructor
class Person constructor(firstName: String) { ... }

for declaring properties and initializing them from the primary constructor,
class Person(val firstName: String, val lastName: String, var age: Int) { ... }
or  Initialization code can be placed in initializer blocks, which are prefixed with the init keyword.

If the constructor has annotations or visibility modifiers, the constructor keyword is required, and the modifiers go before it:
class Customer public @Inject constructor(name: String) { ... }

the secondary constructor
class Person {
    constructor(parent: Person) {
        parent.children.add(this)
    }
}

If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor,
class Person(val name: String) {
    constructor(name: String, parent: Person) : this(name) {
        parent.children.add(this)
    }
}

open class Base(p: Int)           // 

class Derived(p: Int) : Base(p)

why Derived have p?

secondary constrctor is like __init__ , and this constructor will run, super() will jump to Base class's secondary constructor and run

http://www.runoob.com/kotlin/kotlin-extend.html


#############################################################

type variables for parameter polymorphism, different types with same behavior, the behavior don't depend on the type
typeclass for behavior polymorphism, different types with different behaviors, the behavior depend on the type


polymorphic in python haskell and kotlin

def f(x):
    if isinstance(x, int):
        return x+1
     if isinstance(x, str):
        return x[::-1]

in haskell, we have pattern matching to do that

f :: Either Int String -> Either Int String

f (Left x) = Left (x+1)

f (Right x) = Right (reverse x)

in kotlin, use overload method, functions have same names but different parameters

fun getValue(id: Int): Any { ... } 

fun process(value: Int) { ... } 
fun process(value: String) { ... }
val value = getValue(valueId)
 when (value) { 
is Int -> process(value)
is String -> process(value)
else -> ... }

https://stackoverflow.com/questions/56680581/how-to-create-a-type-that-may-contain-int-or-string?noredirect=1#comment99929450_56680581


<__monty__> jusss: Most common way to have function implementation depend on
            the type of the value they're applied to is through
            typeclasses. `class X a where f :: a -> a; instance X Int where f
            = (+1); instance X String where f = reverse` then you can do both
            `f 4` and `f "abc"`.                                        [16:25]




#################################################

how to create a type that contain Int or String?
use Either Int String,  so Left 3 has Either Int String, Right "3" has Either Int String
we can pass it, and it may contain Int or String

<jusss>  data T = Either Int String;   f :: T -> T;   f x = x;   f (Left 3)
        got an error , why?                                             [13:36]
<jle`> defines a new data type T        
<jle`> with a single data constructor, 'Either'
<jusss> jle`: oh, my fault, I should use Either on the right side
<jusss> without a value constructor
<jle`> fwiw this is a pretty confusing data type constructor, because 'Either'
       is commonly used as a type name from Prelude
<jusss> jle`: I should just use f :: Either Int String -> Either Int String
<jle`> if that's what you want :)                                       [13:39]
<jle`> that'd be a very different type, yeah
<jle`> but the only person who really knows what you want is you, yourself. so
       search inside your heart :)
<jusss> jle`: I want the either type, 'cause I'm not sure which type the
        paramter is
<jusss>  ff :: (Either Int String) -> (Either Int String);  ff x = x;   ff
        (Left 3);  ff (Right "3")

and we still can get 3 from (Left 3) by
f (Left x) = x

it's about polymorphic, for example,
f(x) if x is String, then make reverse x and return it,
if x is Int, then plus one and return it


f :: Either Int String -> Either Int String
f (Left x) = Left (x+1)
f (Right x) = Right (reverse x)

g :: Either a a -> a
g (Left x) = x
g (Right x) = x

the right way:

<__monty__> jusss: Most common way to have function implementation depend on
            the type of the value they're applied to is through
            typeclasses. `class X a where f :: a -> a; instance X Int where f
            = (+1); instance X String where f = reverse` then you can do both
            `f 4` and `f "abc"`.                                        [16:25]



<jusss> how to know a value's type?                                     [15:37]
<jusss> like python, we can use isinstance(x, int) to know if x has int type
                                                                        [15:38]
<jusss> if x has  Either Int String, so how we know x is Left a or Right b ?
                                                                        [15:39]
<winny> Interactively you can use :t , but since haskell is statically typed,
        you know types at compile time
<winny> https://wiki.haskell.org/Algebraic_data_type                    [15:40]

<ski> jusss : "how we know x is Left a or Right b ?" -- pattern-matching. but
      that is not knowing type
<jusss> winny: I want to write a function, and its parameter has Either Int
        String,  if it's Left a then return Left (a+1), if it's Right b then
        return Right b
<ski>   foo :: Either Int String -> ...
<ski>   foo (Left  n) = ..n..                                           [15:41]
<ski>   foo (Right s) = ..s..
<ski> that's pattern-matching
<jusss> ski: aha, I see
<ski> you're checking which "shape" the input has. that is not checking its
      type                                                              [15:42]
<jusss> we don't need to check the type of parameter, 'cause we have pattern
        matching!

<jusss> ski: another silly question, how we can reverse a string?
<jusss> "ab" to "ba"
<ski> > reverse "ab"                                                    [15:43]
<lambdabot>  "ba"
<jusss> ...
<ski> or are you asking about how that is implemented ?
<jusss> no

<ski> `String's are lists of `Char'acters, in Haskell. this is sometimes not
      so good for performance, but it means that general list operations will
      also work on strings

<ski> > ['a','b']                                                       [15:45]

<lambdabot>  "ab"
<winny> :t "abc"
<lambdabot> [Char]

<erikd> __monty__: fixed it. "instance (KnownNat i, KnownNat o, KnownNat (i +
        o), (i <= (i + o)) ~ 'True"                                     [15:49]

<__monty__> I didn't know addition and constraints on values was allowed, TIL.
                                                                        [15:50]
<fuzzy_id> i'm trying to run a haskell exec on aws lambda and use HTTP to
           fetch the next invocation id.
<fuzzy_id> in the logs i see 'c_poll: permission denied (Operation not
           permitted)' and later 'ioManagerDie: write: Bad file descriptor'
<jusss> ski: about polymorphic, we can return any type in dynamic languages
        like python or javascript, and can we return any type in static
        languages?
<fuzzy_id> any ideas what this is and how to work around this?          [15:51]
<fuzzy_id> (i mean the HTTP library)
                                                                        [15:52]
<erikd> fuzzy_id: c_poll is not the HTTP library, its the haskell runtime
        system

<fuzzy_id> yeah                                                         [15:53]
<__monty__> jusss: You can return any type you want from a function of
            course. But you can't have that type depend on the values of the
            parameters. Oftentimes Either is enough though, like your Either
            Int String example.
<ski> jusss : the question doesn't make sense to me                     [15:54]

<ski> jusss : you can write e.g. `id :: a -> a; id x = x'. then `id' can
      return a value of any type you like (provided you call it with a value
      of that type) ..
<ski> .. but i suspect that's not what you meant

<ski> (instead of `id', you could take `(!!) :: [a] -> Int -> a', or other
      functions, if you want something less trivial)
<erikd> or "read :: Read s => String -> a"                              [15:57]
* ski nods

<erikd> (even though i screwed up the type var names)
<ski> (also, nitpick. you don't return types from function. you return value,
      which belong to types)
<ski> @type read
<lambdabot> Read a => String -> a
<jusss> f = lambda x: x+1 if isinstance(x, int) else ( x[::-1]  if
        isinstance(x, str))
<jusss> f(3) get 4, and f("ab") get "ba", polymorphic
<ski> and `f("abc")' ?                                                  [16:03]
<jusss> "cba"
<ski> you can do that, if you *really* want to
<ski> but why would you want to ?

<merijn> The solution to wanting that is to stop wanting bad things
<jusss> we already have f :: Either Int String -> Either Int String ; f (Left
        x) = Left (x+1) ; f (Right x) = Right (reverse x)               [16:04]

<jusss> how to implement a function that take x from Left x or Right x?
                                                                        [16:05]

<jusss> 'cause x in Left x is Int, and in Right x is Str, so that one function
        may return two type

<Rembane> jusss: There's either from Data.Either IIRC.
<Rembane> :t either
<lambdabot> (a -> c) -> (b -> c) -> Either a b -> c

<ski> > nonsense 3                                                      [16:07]
<lambdabot>  4
<ski> > nonsense "abc"
<lambdabot>  "cba"
<ski> jusss : happy ?
<jusss> ski: yeah                                                       [16:08]

<ski> @type either id id

<lambdabot> Either c c -> c
<jusss> @type nonsense
<lambdabot> Typeable a => a -> a
<jusss> I don't understand how your nonsense did that                   [16:13]
<merijn> Via Typeable, which is basically a short way of saying "I absolutely
         hate knowing what my code does before I run it", so at least it's a
         good match if you like Python                                  [16:14]
                                                                        [16:20]
<jusss>  f::Either a a -> a ; f (Left x) = x ; f (Right x) = x  

<ski> that's the same as `either id id', yes                            [16:21]

<__monty__> jusss: Most common way to have function implementation depend on
            the type of the value they're applied to is through
            typeclasses. `class X a where f :: a -> a; instance X Int where f
            = (+1); instance X String where f = reverse` then you can do both
            `f 4` and `f "abc"`.                                        [16:25]

<__monty__> Hmm, that's not quite true, I guess the most common way is
            parametric polymorphism. But that doesn't get you what you want.
<jusss> and polymorphic result                                          [16:27]

<lortabac> jusss: it depends on what you mean by "polymorphic result". When
           you have a signature 'a -> a', the return type must be the same as
           the argument type                                            [16:32]
<lortabac> jusss: if you want the return type to depend on the argument type,
           you need more advanced stuff like associated types or functional
           dependencies
<__monty__> jusss: Read does this kind of. It's just that it infers the type
            *first* and then picks the right implementation of `read :: String
            -> InferredType`, rather than looking at the *value* and
            determining what that type should be.                       [16:34]
<jusss> ok                                                              [16:36]

<__monty__> jusss: Do note that even though this all may sound constricting to
            a pythonista there's generally good reasons for the limitations.
                                                                        [16:42]
                                                                        [16:44]
<ski> jusss : `id' is polymorphic, its result is not
<jusss> __monty__: ski I love type variables, I love polymorphic, but I'm
        still not good at it                                            [16:46]
<__monty__> ski: Though its result *could* be, right?                   [16:47]
<tdammers> it is a limitation, but the trick is that by constraining what we
           allow ourselves (and the compiler) to do, we free ourselves from
           having to take a million things into account that we would never
           want to occur in the first plcae
<jusss> did type limite your image?                                     [16:48]
<jusss> or may?
<ski> __monty__ : with `ImpredicativeTypes', sure
<merijn> Friends don't let friends use -XImpredicativeTypes             [16:50]
<ski> constraining the implementor can mean giving more power to the user, and
      vice versa
<__monty__> ski: Hmm, I was talking about `id id` not familiar with
            impredicative types.
<ski> __monty__ : that's another thing
<merijn> That extension should really be deprecated and/or produce a HUGE ass
         warning
<ski> __monty__ : in that case, conceptually, the result returned by the `id'
      call is still not polymorphic
<__monty__> But it would be if ImpredicativeTypes was enabled?
<ski> both `id's are specialized to be monomorphic (as always with polymorphic
      values, except when there's higher-rank stuff going on). the first one
      having type `(_a -> _a) -> _a -> _a', the second having type `_a -> _a',
      so that the result has type `_a -> _a' .. then, depending on the context
      in which you use this result, either `_a' will be instantiated to some
      specifi type, like `Integer', or it would be generalized upon, so that
      e.g. the result gets assigned                                     [16:54]

<ski> (hrm, possible cut off near ".., or it would be generalized upon, so
      that e.g. the result gets assigned type `forall a. a -> a'")
<ski> __monty__ : it could be, at least                                 [16:55]

<__monty__> Hmm, does this mean `polyId = id id` would retain the
            polymorphism?
<__monty__> And would it still be lost if we'd dare use polyId?
ERC> 


#############################################

c.kt
package c // used for imported in other files
class C<T>(v:T) {
    val vv = v
}
fun  add(x:C<Int>, y:C<Int>):Int{
    return x.vv + y.vv
}
fun <T> another(x: C<T>):T{
   return x.vv
}
fun main() {
    val w = C<Int>(3)
    val y = C<Int>(7)
    println(add(w,y))
    println(another(C<String>("aha")))
}

###################################################

fun <T,U> fun_name(x: T, y: U, z: A<T>, a: <T,U>) {...}

<T,U> before the function's name is called type parameters,
https://stackoverflow.com/questions/54880432/generic-type-t-parameter-before-the-function-name

1. it is used to indicate that generics are used and not some type T or U are referenced.

2. if you use <T> in a class, Whenever you create an instance of this class, you must specify an actual type in place of T

type constraints class TreeNode<T : Vehicle>
if there're several type constraints, then use `where`
class TreeNode<T> where T : Vehicle, T : HasWheels

https://kotlinlang.org/docs/tutorials/kotlin-for-py/generics.html


##################################################

f :: a->a->a
f x y = x + y
will be an error, 'cause (+) function's parameter are Int,
(+)'s type signature has type constraint, so we can not use type variables in (+)
(+) :: Num a => a -> a -> a

1. you need check the function's type signature before call it !
2. type variables have the ability to do polymorphism
3. typeclasses describe shared behavior that multiple types can have

about type variables and typeclass

type variables have the ability to do polymorphism
id :: a -> a
id :: (e->a) -> (e->a)
id :: (e->a) -> e -> a

then why we need typeclass?
<oats> typeclasses describe shared behavior that multiple types can have

<jusss> type variables have the ability to do polymorphism, then why we need
        typeclass?                                                      [09:42]
<Welkin> parametic vs adhoc polymorphism                                [09:43]
<Welkin> totally different
<Welkin> also nothing at all like oop polymorphism
<Axman6> type classes let you know what you can do with those type
         variables. what's the difference between foo :: a -> String and bar
         :: Show a => a -> String?
<Welkin> type classes are for function overloading
<Welkin> describing interfaces
<Axman6> in the first one, I know _nothing about a, so I can guarantee there
         is nothing in that String that came ferom a. in the second, I know
         that there is a way to turn an a into a String, so there;s ia good
         chance that there is information from a in the returned string
<oats> Axman6: so could it be said that the first example is a "useless"
       function?                                                        [09:48]
<oats> since there's nothing of a that produces String, there's no mapping, no
       transformation happing
<oats> I'm guessing it'd have to be a constant function                 [09:49]
<Axman6> )yep
<jusss> or let's talk about the monad typeclass
<jusss> it seems to me like typeclass force the instance to implement its
        method                                                          [09:51]
<jusss> >>= :: m a -> (a -> m b) -> m b
<jusss> in Maybe, >>= :: Maybe a -> (a -> Maybe b) -> Maybe b           [09:52]
<oats> I think maybe "force" isn't the most accurate way to think of it here
                                                                        [09:53]
<jusss> oats: and what's the more specific word to express?             [09:54]
<oats> you're guaranteeing to the compiler that values provided to the
       function fit in a "constraint"
<oats> if you don't provide a typeclass constraint, as with your (>>=) Maybe
       example there, you won't be able to compute any function of `a` that
       has a more "restricted" constraint                               [09:56]
<oats> and the compiler will enforce that
<oats> for example, if you tried to do `show a` as a part of that (>>=)
       implementation for some reason, the compiler will remind you that you
       haven't guarunteed that your `a` can be turned into a String (via the
       Show typeclass)
<oats> please let me know if that was unclear, I'm still new to haskell and
       trying to reason through some of this stuff too :)               [09:59]
<oats> does that answer your question?
<jusss> I don't know, I'm still fuzzy
<Welkin> hi fuzzy
<jusss> think about why we need a typeclass or interface in other languages
<Welkin> having a standard API is very useful                           [10:01]
<Welkin> you don't need to know anything about how it's implemented for
         different data types
<Welkin> you can fmap over a list, a tree, a graph
<Welkin> your custom data structure too
<jusss> all I see is that typeclass can make its instances to implement its
        function                                                        [10:02]
<oats> typeclasses describe shared behavior that multiple types can have
<oats> continuing the `Show` example, there's lots of things that can be
       turned into strings                                              [10:03]
<oats> Bools, Integers, lots of stuff
<oats> so when we implement `Show Foobar` for some imaginary type `Foobar`,
       we're telling the compiler, This is a thing that can be turned into a
       string, with this neat function I have, `show`!                [10:05]
<jusss> oats: "<oats> typeclasses describe shared behavior that multiple types
        can have" this is good
<oats> jusss: I hope that was helpful :)                                [10:07]
<oats> and so when we declare a function `bar :: Show a => a -> BarBaz`, we're
       telling the compiler that the type variable has a constraint on it,
       `Show a`, and so the compiler will hold us to our promise that whatever
       value we give to `bar` will be a thing that can be turned into a string
<jusss> oats: and do wee need to use typeclass frequently?
<jusss> create we own typeclass I mean
<oats> typeclasses cut down on function clutter :)
<oats> are you familiar with a language like C that doesn't have typeclasses
       or interfaces?
<jusss> oats: I don't know if python counts
<jusss> python have abstract method
<oats> I am unfortunately unfamiliar with python                        [10:10]
<jusss> or javascript, scheme?
<oats> I think this stuff mostly only applies to statically-type languages
<jusss> scheme doesn't have typeclass also declared type, I think
<jusss> also OO
<oats> but, since there's no way to describe shared behavior among types in C,
       we have to create a separate function with a different name for every
       type we want to be able to string-ify
<oats> for example, intToString(), boolToString(),...                   [10:11]
<jusss> what about the simple function id
<jusss> idInt :: Int -> Int
<oats> jusss: what about it?
<jusss> idStr :: String -> String
<oats> ah
<jusss> that's what you want to talk?
<jusss> and now we have id :: a -> a                                    [10:12]
<oats> yes, that is how you'd have to do it in C
<oats> (we will pretend pointers don't exist :))
<oats> pointers makes things super fuzzy!
<oats> jusss: do you understand why the `id` function works in haskell?
<jusss> but the point here is that id :: a->a is just type variables or call
        generics in other languages                                     [10:13]
<jusss> oats: actually no, or I can ask you do you know why the `id` function
        shouldn't work in haskell?
<nitrix> Ironically, if you were to use pointers and cast them to `void *` to
         implement a `void *(void *, void *)` function, you'd be
         re-implementing what Haskell does by boxing types and its parametric
         polymorphism + newtype.
<Welkin> id :: forall a. a -> a
<oats> ah, yes, the hidden forall!                                      [10:14]
<jusss> actually, I did notice that keyword forall, but I haven't see a
        article tell me what it is
<Welkin> there is an implicit forall in every type that contains all type
         variables                                                      [10:15]
<nitrix> Universal quantification. `a` being a type variable, it has to come
         from somewhere. Something introduces `a`.
<nitrix> This becomes more important when you start nesting polymorphic type
         signatures, they have their own scopes (:                      [10:16]
<nitrix> e.g. `forall a. a -> (forall b. b -> b) -> a`
<Welkin> that's existential quantification then, right?                 [10:20]
<Welkin> for the b -> b
<nitrix> Yeah. Going towards Rank-2 and such.       

#############################################

interface Collection<E>  {
  void addAll(Collection<E> items);
}

void copyAll(Collection<Object> to, Collection<String> from) {
  to.addAll(from);
 }

'cause of the definition of interface about addAll,
so when 'to' has Collection<Object> type, addAll's parameter has Collection<Object> type
but we pass the parameter 'from' which has Collection<String> type, not Collection<Object>,   there will be an error, 'cause Collection<String> is not a subclass of Collection<Object> even String is a subclass of Object

interface Collection<E>  {
  void addAll(Collection<? extends E> items);
}
this can make the type of addAll's parameter, Collection<String> can be here,
this ? means String, <String extends Object>
addAll's parameter type can be Collection<String> or Collection<Int> whatever
'cause if the object is Collection<Object> and String and Int both are subclass of Object

the opposite is Collection<? super E>, which means ? is a superclass of E, Object is String's superclass

interface Collection<E>  {
  void addAll(Collection<? super E> items);
}

void copyAll(Collection<String> to, Collection<Object> from) {
  to.addAll(from);
 }

<? extends E>  which means ? is a subclass of E,   <out E>


<? super E> which means ? is a superclass of E,  <in E>


think about, value null has any type, and any value has Object/Any type

out and in or <? extends E> and <? super E> are for type inheritance

 we need to use the out keyword on the generic type.
 It means that we can assign this reference to any of its supertypes.

We can use the in keyword on the generic type if we want to assign
it to the reference of its subtype

########################################################

Kotlin has two types of references, Nullable and Non-Nullable Reference Types
var a: String = "value"

If we want to create a nullable reference, we need to
create append the question mark(?) to the type definition:
var b: String? = "value"
After that, we can assign null to it:
b = null

data class Person(val country: Country?)
 data class Country(val code: String?)
 Note that the country and code fields are of nullable reference type.
To access those fields in a fluent way, we can use the safe call syntax:
val p: Person? = Person(Country("ENG"))
 val res = p?.country?.code
 assertEquals(res, "ENG")
 Should the variable p hold a null, the safe calls syntax will return a null result:
val p: Person? = Person(Country(null))
val res = p?.country?.code
assertNull(res)

The let() method, To execute an action only when a reference holds a non-nullable value, we can use a let operator.
val firstName = "Tom"
val secondName = "Michael"
val names: List<String?> = listOf(firstName, null, secondName)
Next, we can execute an action on every non-nullable element of the names list by using a let function:
	
var res = listOf<String?>()
for (item in names) {
    item?.let { res = res.plus(it) }
}
 
assertEquals(2, res.size)
assertTrue { res.contains(firstName) }
assertTrue { res.contains(secondName) }

If we want to apply some additional operation, for example logging on every non-nullable value we can use an also() method and chain it with a let()

Kotlin has a run() method to execute some operation on a nullable reference. It is very similar to let() but inside of a function body, the run() method operates on this reference instead of a function parameter

Sometimes, when we have a reference, we want to return some default value from the operation if the reference holds a null. To achieve that, we can use an elvis (?:) operator.

The double exclamation mark operator (!!) takes a value from a nullable reference and throws a NullPointerException if it holds null.

? means it could be null, ?. means non-null check, ?: return something if there's a null
!! if a reference hold a null then throws a NullPointerExeception

The List class in Kotlin has a utility method filterNotNull() that returns only non-nullable values from a list that holds nullable references

https://www.baeldung.com/kotlin-null-safety

p?.country?.code only when p and country both are not null, code will execute, otherwise return a null result,  like Maybe

null can has any type in java, so kotlin has null and non-null type,  null type use ?, and the
others would be non-null 
Int? == Int or null   like Maybe a = Just a | Nothing
but Int only can be Int, null can not has Int type in kotlin, but null can has Int type in java

java is not a pure OO language, 'cause of its primitive data type's values and functions are not objects,
any value has Object type in java,
any non-null value has Any
and null and non-null have Any? type
Nothing type only has one value, null

class SmartList<T>: ArrayList<T> () {
      fun find(t: T): T? {
          val index = super.indexOf(t)
          return if (index >= 0) super.get(index) else null
          }
 }

fun main(args: Array<String>) {
    val smartList = SmartList<String>()
    smartList.add("one")
    println(smartList.find("one"))
    println(smartList.find("two").isNullOrEmpty())
    }

type constraint, <T: Fruit> T can only be Fruit or its sub-class type
open class Fruit(val weight: Double)
class Apple(weight: Double): Fruit(weight)
class Banana(weight: Double): Fruit(weight)

class FruitPlate<T: Fruit>(val t: T)

haskell doesn't have type inheritance, like type in OO
###############################################33

what's the difference between class and type?
Roman Elizarov [JB]  [1 hour ago]
https://stackoverflow.com/questions/468145/what-is-the-difference-between-type-and-class
can we use a class as a type?
Roman Elizarov [JB]  [9 minutes ago]
Yes.
Roman Elizarov [JB]  [8 minutes ago]
(unless class is generic, in which case youll need to instantiate it with specific type arguments to get a type) (edited)

and can we think instances of classes as values of types?
Roman Elizarov [JB]  [5 minutes ago]
They are


################################################

class without declared type                type without class
(python,js,scheme)                            (c,haskell)

                                class with type
                                (java, kotlin, c++)

there're two ways to operate something in classes,
1. inheritance, A inherit from B, then A can operate something in B
2. passing, pass B to A, then A can operate something in B

3. the class is the type, the type is the class, the instance is the value, the value is the instance
4. C use typedef to define a new type to an existing value like list constructor , construct primitive data type to new type, or use enum or tagged union for something like `data Whatever = YouWant` in haskell
5. https://stackoverflow.com/questions/468145/what-is-the-difference-between-type-and-class
6. function and class both can have type variable, but instances must have the specific type,  value and instance have the specific type, class and type or function have type variable

<jusss> LdBeth: java/kotlinclasstype
        classtype                                               [09:42]
<jusss> class C<T>  type ,  Ctype constructor, <T>type variable
<jusss> C<T>instance  value ?                               [09:43]
<LdBeth>  type  class  class  type 
<LdBeth>  C++                                                       [09:44]
<jusss> LdBeth: python/js/schemetype,
        haskelloo based on class
<jusss> LdBeth: c++
<jusss> ctpyeclass
<LdBeth>  C++ 
<jusss> C++                                                   [09:45]
<LdBeth> 
<jusss> LdBeth: C++classtype?                                     [09:46]
<LdBeth> jusss:  class        
<jusss> LdBeth: class
<LdBeth> jusss:  C                                                [09:50]
<jusss> LdBeth: Ctype?                                    [09:51]
<jusss> LiuYan: class
<Flandre`>                                                      [09:52]
<LdBeth> 
<LdBeth> C 
<jusss> 
<onlylove> typedef
<jusss> chaskellhaskell
        type
<jusss> typedef is a keyword used in C language to assign alternative names to
        existing datatypes.                                             [09:54]
<jusss> existing
<LdBeth>  Haskell                                     [09:55]
<LdBeth>  primitive type                                  [09:56]
<jusss> haskell data Whatever = YouWant 
<jusss> LdBeth: c
<jusss> LdBeth: pythonprimitive type
<LdBeth> jusss:  enum
<LdBeth>  tagged union                                              [09:57]
<jusss> LdBeth: haskelldata x = yenum ?
<LdBeth> jusss: http://www.pythonvisually.com/ebook/primitive-data-types.html
<anotitlebot> Primitive data types  Python book 1.0 documentation
<LdBeth> 
<LdBeth> jusss:  tagged union 
<jusss> LdBeth: Intpythonclass, 1Intinstance, 1(+)
<LdBeth>  primitive type                                [09:59]
<LdBeth>  primitive type 
<jusss> LdBeth: typevalues?                       [10:12]
<LdBeth> jusss: programming  type  set, mathematical 
<jusss> LdBeth: programmingtype
<LdBeth> mode
###################################################

if function's type is a generic, put it before the function

fun <T> boxIn(value: T) = Box(value)

mix the type and class,

class Box<T>(t : T) {
    var value = t
}

think this Box as type constructor, and <T> is type variable, so
Box<T> is like Maybe a
and also the type is the class, and the class is the type in kotlin
generic in kotlin is like type variable in haskell
everything is so clear now!

###################


do-notation,  or kleisli compose on promise

do
a <- m a
b <- m b
return a +b

a = async ...
b = async ...
a whatever b

###############################################

`this@MainActivity`

Thread(Runnable { }).start()

sealed class Maybe<out T> {
       object `Nothing#` : Maybe<Nothing>() {
              override fun toString(): String = "Nothing#"
        }
        data class Just<out T>(val value: T)
}

lambda in kotlin, {it -> it}

f ({ x -> x })
f {x -> x}

object.method { it.whatever }  it means object

use {} to contain lambda,
{ x:Int, y:Int -> x+y}

https://kotlinlang.org/docs/reference/lambdas.html

############################################

update UI in coroutine

GlobalScope.launch{ ... withContext(Dispatchers.Main){ update-UI-here
        }}

fun updateUI(view: View){
        GlobalScope.launch {
            val showTextView = findViewById<TextView>(R.id.text1)
            val sock = Socket("192.168.31.204", 50007)
            sock.use {
                it.outputStream.write(
                    "aha, it's from kotlin".toByteArray(
                        Charsets.UTF_8
                    )
                )
                it.outputStream.flush()
                var aob = ByteArray(1024)
                it.inputStream.read(aob)
                withContext(Dispatchers.Main){
                    showTextView.text=aob.toString(Charsets.UTF_8)
                }
            }
        }
    }

Dispatchers.Main is for UI, Dispatchers.IO is for IO, there're also Default and Unconfined
https://stackoverflow.com/questions/54671817/update-ui-async-call-with-coroutines

#############################################
1. don't stuck the main thread, don't run socket in main thread
2. update UI in non-main thread use runOnUiThread

<serafeim> jusss:  the thing is that you can't do network operations on your
           main thread                                                  [15:04]
<serafeim> jusss:  because this will make your app unresponsive
<serafeim> so you must do that in a different thread. asynctask can help you
           with this.
<serafeim> or you can just create a plain old java thread and do that
           operation. that would make synchronizing more difficult though
                                                                        [15:05]
<jusss> serafeim: ok, I will try async                                  [15:08]
<serafeim> jusss: cool                                                  [15:09]

<serafeim> jusss:  you can't change things in the main thread from other
           threads. the usual way to resolve that is to use runOnUiThread
<serafeim> something like this:
           https://stackoverflow.com/questions/11140285/how-do-we-use-runonuithread-in-android
<serafeim> i.e from your secondary thread you pass some code to be run on the
           main thread so that it will update your UI components        [15:38]
<serafeim> this is basic Android 100 :)
<serafeim> but i can understand it is overwhelming for a new user

<serafeim> jusss: i don't think i told you to use any function          [15:51]
<serafeim> i told you to use runOnUiThread
<jusss> sorry
<serafeim> the function runs on the same thread
<serafeim> follow the instructions i have you in the SO answer

https://www.tutorialkart.com/kotlin-android/android-runonuithread-example-kotlin/

enable coroutine in kotlin android

put the next lines to build.gradle and click the import button on the right top
implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.1'
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.0.1"

then import kotlinx.coroutines.launch in MainActivity.kt
GlobalScope.launch { ... }
##################################################################

function compose

f . g = f (g x)
f >>= g = g (f x) x
f >=> g = g (f x y) y

what's the next ?

################################################
look this and image Promise in JS
                   g (                  f                ( x                      y   ))          y 
new Promise( new Promise.resolve(action-x).action-y).action-z
run x, y, z by order

unit = (x,y) => new Promise.resolve(x).then(y)
unix ( unix(x,y), z)

############################################
compose, unary, argument can't pass to another f . g
reader, unary and binary, one argument pass  f >>= g
kleisli compose, binary and binary, pass one argument, you decide use result and
argument or not, you construct  them, you construct a binary with an unary!!!
all that is just function compose!!!

<jusss> jle`: I suddently get something from compose, reader monad and kleisli
        compose, they're all function compose!
<jusss> compose is one unary and one unary
<jusss> reader is one unary and another is binary
<jusss> kleisli compose is two binary compose
<jusss> f . g = \x -> f (g x) ;   f >> g = g (f x) x   ;   f >=> g = \x -> \y
        -> g (f y x) y                                                  [09:25]

<jusss> the results,  f (g x), g (f x) x, and g (f y x) y
<jusss> are what we want to construct                                   [09:26]

<jusss> to the form
<jusss> so what about one unary with one three-parameter function?
<jusss> if we want passing two paramters to a bunch of functions, we need to
        construct those function with three parameters?
<Axman6> > (f >> g) x :: Expr
<lambdabot>  error:
<lambdabot>       Ambiguous type variable a0 arising from a use of f
<lambdabot>        prevents the constraint (FromExpr a0) from being
            solved.
<Axman6> > ((f::Expr -> Expr) >> (g::Expr -> Expr)) x :: Expr           [09:32]
<lambdabot>  g x
<jusss> Axman6: is this f >=> g     =     \x -> (\y -> g (f y x) y)   right?

<Axman6> > ((f::Expr -> Expr -> Expr) >=> (g::Expr -> Expr -> Expr)) x y ::
         Expr
<lambdabot>  g (f x y) y
<Axman6> Looks good to me, well done :)                                 [09:34]
<jusss> (1,1) -> 0 share,  (1,2) -> 1,  (2,2) -> 1,     in compose, unary and
        unary share 0 parameter, unary and binary share 1, binary and binary
        share 1, so I wonder (1,3) -> ? and if it exist?                [09:40]

<Axman6> what's the type

<Axman6> always start with the types
<Welkin> what's *your* type?
<Axman6> ;)
<jusss> f>>=g = g (f x) x, this binary function g, we can construct an unary
        function to a binary and we can decide don't to use this result (f x),
        so we can use x in f and g                                      [09:44]
<jusss> g _ x

<jusss> Axman6: Welkin is there somebody has already did this?
<jusss> I think there must be somebody have already do compose in
        three-parameter functions                                       [09:46]
<Axman6> What;s the type. 
<Axman6> if you can think of the type, you can use hoogle to see if someone
         has                                                            [09:47]

###################################################################

all that is just about function compose!

functor compose :: (a->b) -> (e->a) -> (e->b)

reader monad >>= :: (e->a) -> (a->e->b) -> (e->b)

kleisli compose <=< :: (b -> m c) -> (a -> m b) -> (a -> m c)
<edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a -> e -> c        [12:19]

f . g = \x -> f (g x)  -- f and g both are unary functions

f >>= g = \x -> g (f x) x    -- f is unary and g is binary,   focus on the result! what it constructs!

f >=> g = \x -> (f x >>= g)    -- f and g both are binary functions
          

z >>= g = \x -> g (z x) x
let z = f y
f y >>= g = \x -> g (f y x) x

f >=> g     =     \x -> (\y -> g (f y x) y)

f (g x)
g (f x) x    this is one parameter x passing in two functions
g (f y x) y

###########################################
(>>) :: m a -> m b -> m b
k >> f = k >>= \_ -> f
(>>) is like (>>=), in that it sequences two actions, except that it ignores the result from the first one.

####################################
<edwardk> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
<edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a -> e -> c        [12:19]
<jusss> f >=> g = \x -> (f x >>= g)                                     [12:02]
#####################################################
>>= :: (e->a) -> (a-> (e->b)) -> (e->b)
(a->(e->b)) == (a->e->b)
so this can be an unary function that take a and return a function e->b
also this can be a binary function that take two parameters a and e then return b

t = (+1) >>= (+)
t 3 will get 7

##################################################

<jusss> wait a sec, this is really change my mind,   'cause think (a->(e->b))
        as a binary function

<jusss> Axman6: wait a sec, in "<jle`> ((f >=> g) 3) 10  ==> g 10 (f 10 3)"
        yes, we pass 10 to f and g both, but why g still need f's result ?

<jle`> the only time Reader ever is relevant is in teaching examples

<jle`> jusss: f >=> g is function composition, so you're eventually passing
       the result of f to the result of g

<jle`> look at the type of join -- join :: (e -> e -> a) -> e -> a
<jusss> jle`: that would be join f x = f x x
<jle`> so join f x = f x x is sugar for join f = \x -> f x x

<jusss> I'm attracted by this special thing                             [13:14]

<jle`> yes, it is okay to be attracted to it
<jle`> but just be aware that it is not useful
<Axman6> c_wraith: slightly mindblown. I had noticed that but never put into
         words
<jle`> this is the nature of life, in a way
<jusss> fine

<jusss> I hope one day I can find the useful way for it                 [13:15]
<jle`> yes, you are attracted to it. that's a good thing, and a lot of us here
       share your fascination
<jle`> but, we also know that it is a more or less useless thing
<Axman6> spark plugs are pretty cool though

<jle`> jusss: so yes, functional programming is useful. functions are
       useful. but this is not. and that's ok                           [13:16]
<c_wraith> jusss: it comes up sometimes.  Sometimes you have a function with
           the right shape and realize that you can use Reader to pass extra
           arguments.

<jusss> special but useless...

<Axman6> jusss: Reader by itself isn't very useful, but ReaderT gets used all
         the time in applications which need to pass configuration around to
         many different components
<jle`> just because functional programming is useful doesn't mean that every
       single minute function that exists ever, will be useful
<c_wraith> jusss: and that is fun!

<jle`> functional programming is about finding the useful functions, and using
       those :)
<jle`> it isn't about making all functions useful                       [13:17]
<Axman6> @remember jle`: functional programming is about finding the useful
         functions, and using those.  it isn't about making all functions
         useful.
<lambdabot> Good to know.

#################################################
<jusss> what this Kleisli compose is used for?

<juliusdeane> Like the (>=>) type of composition?
<jusss> juliusdeane: yeah
<jusss> juliusdeane: what it's used for

<juliusdeane> It's like (.) but for monadic actions                     [11:59]

<juliusdeane> As an example, you could do mapM uncons >=> mapM (return . fst)
              $ ["excuse", "this", "absurd", "example"]                 [12:00]
<juliusdeane> And you'd get Just "etae"

<jusss> f >=> g = \x -> (f x >>= g)                                     [12:02]
<jusss> z >>= g = \x -> z (g x) x

<jusss> f >=> g = \x -> (f x) (g x) x

<jusss> ?
<juliusdeane> The first definition you had for (>=>) looks good, that's
              actually how it's defined in Control.Monad I'm pretty sure
                                                                        [12:06]
<jusss> the second is not
<juliusdeane> Yeah
<juliusdeane> Same for (>>=)
<jle`> i use it sometimes when i have two (a -> Maybe b)'s i want to compose
<jusss> 'cause z >>= g , z::e->a  and g::a->(e->b)                      [12:07]
<jle`> to "double-filter", so to speak

<jusss> those stuff beyond my comprehension, I have seen those Reader and
        Kleisli compose article enough, and I still don't understand it
                                                                        [12:08]
<edwardk> jusss: i use it when i start refactoring code a lot

<juliusdeane> It's good for making stuff point-free, kind of like
              Control.Arrow
<jle`> jusss: what stuff exactly?
<edwardk> foo x = do x <- y; z                         then becomes foo x = y
          >>= z          then becomes foo = y >=> z

<edwardk> er
<jle`> jusss: specific usages of >=> like we are talking about, or its
       behavior with the (e ->) monad?
<edwardk> foo x = do w <- y; z
<jusss> jle`: I can't understand (e->) monad
<jusss> jle`: also >=>
<jle`> you don't understand how to use it, or how to implement it?
<edwardk> in general (>=>) is a tool for avoiding one use names
<jusss> I don't know what they're used for, what situation they would be help?
<juliusdeane> Like if you have lots of configuration data that you send
              through functions                                         [12:10]
<jle`> honestly nobody really uses (e ->)'s Monad or Functor instance
<jusss> jle`: I know how to implement it, I don't understand why it's look
        like that and what is it used for
<jle`> except in rare situations, and it's usually always more readable to
       pass values normally
<edwardk> jle`: i use the monad a lot actually
<jle`> jusss: well, one answer to "why it looks like that" is...that's the
       only way that will typecheck :)
<edwardk> :t join (,)
<lambdabot> b -> (b, b)
<juliusdeane> (e->) still works like a data constructor, it just looks wacky
                                                                        [12:11]
<jle`> is join (,) really more readable than \x -> (x,x) ?
<edwardk> atomicModifyIORef foo $ join (,) . what i want to do to the foo
<edwardk> jle' now i don't have to name the temporary variables on either side
<edwardk> because that is a lot shorter than
<jusss> juliusdeane: jle` but (e->) is not like Maybe or List,
<jle`> you're shifting the cost from write-time to read-time
<jle`> jusss: that is also true
<edwardk> atomicModifyIORef $ \x -> let y = something complicated x in (y,y)
<jusss> Maybe or List are simple to image, like a wrapper or container
        whatever
<jusss> but functions're not                                            [12:12]
<juliusdeane> Think of (->) as an infix constructor
<jle`> it's difficult to imagine functions?

<jusss> jle`: no, it's difficult to put function in those pattern like bind
<edwardk> i mostly use it for the atomicModifyIORef case
<jusss> fmap is ok, but bind or >=>                                     [12:13]

<jusss> put function in bind, like the monad you all called Reader Monad,
        that's not easy to understand, I don't understand what it's used for,
        what situation it would be help with which form, 
<juliusdeane> jusss it's easier to use (->) like a prefix constructor and then
              give it a normal name like `Arrow` in your head           [12:14]
<edwardk> the functor for ((->) e) matters for a bunch of things like the
          existence of setters in lens, it pretty much is the reason why
          linear can exist, because every monad i offer in there is isomorphic
          to reader for some basis.
<juliusdeane> So a -> b becomes Arrow a b
<jusss> juliusdeane: I wonder why (e->) is monad, and what `return` would like 
<jle`> jusss: edwardk's suggestion with something like join (,) was that you
       just use it as a useful utility function, without worrying about the
       fact that it is a monad
<jle`> for example, `join (,)` is the same as \x -> (x,x)
<jle`> and it's useful to have \x -> (x, x)                             [12:15]
<juliusdeane> jusss There's lots of blog posts all about the (->) monad
<edwardk> jusss: join for (->) e isn't that bad. try to write it.
<edwardk> (e -> e -> a) -> e -> a
<jle`> jusss: it's just useful exactly because of what it does
<jle`> there is no 'deeper' reason
<jusss> I don't know how to construct this monadic function
<jle`> i think you might be trying to find a deeper reason than there actually
       is
<edwardk> you are given a function that needs 2 e's give you an a    and an e,
          you have no way to combine or manipulate the e so you have to pass
          it through unmolested
<jle`> don't construct it as a 'monadic function'
<jle`> just write a function (e -> e -> a) -> e -> a
<jle`> in the end, (e -> e -> a) -> e -> a is a useful function to have
<jusss> f >=> g     = \x -> f x >>= g    so this monadic function f, how to
        construct one?                                                  [12:16]
<edwardk> @djinn (e -> e -> a) -> e -> a
<lambdabot> f a b = a b b
<jusss> f take a normal value and return a function
<jle`> jusss: for (>=>) and (e ->), the type is (a -> e -> b)
<jle`> jusss: that's just any two-argument function
<jusss> when monad is [], we know `return` would like [a]
<jle`> there are several in base that you can use
<jle`> one famous one is (+)
<jle`> another famous one is (,)
<jle`> in general you can write one as \x y -> ..., using lambda syntax, too
                                                                        [12:17]
<jusss> and monad is Promise, `return` like _ => new Promise.resolve(_)
<edwardk> > join (+) 2
<lambdabot>  4
<edwardk> > join (*) 5
<lambdabot>  25
<edwardk> > join (-) 4 -- =)
<lambdabot>  0
<jle`> jusss: for (f >=> g) for the (e ->) monad instance, f is just any
       function (a -> e -> b).  there are bunches of these :)
<jle`> jusss: are you familiar with how to define functions?
<jle`> myFunc x y = x * y + 2, for example                              [12:18]
<edwardk> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
<jusss> jle`: wait a sec, you mean binary functions are monadic function?
<edwardk> when m = (e ->)
<edwardk> we get

<jle`> jusss: look at the type of a -> (e -> b)
<jle`> jusss: that's just the type of a binary function
<edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a -> e -> c        [12:19]
<jle`> the (a -> m b), where m ~ (e ->), is just a -> e -> b

<jusss> jle`: but I think it's a unary function
<jusss> jle`: it take a value and return a function value
<jle`> that's what a binary function is in haskell
<jle`> all binary functions in haskell are like that :)
<jle`> look at the type of (+):
<jle`> (+) :: Int -> (Int -> Int)
<edwardk> in english 'if you know how to turn an a into a b with the help of
          an e, and know how to turn b into c with the help of an e, you can
          turn a into c with the help of an e.
<Axman6> All functions take one argument
<Axman6> never forget

<jle`> jusss: a -> (e -> b) is equivalent to a -> e -> b
<jle`> just because that's how -> associates
<jusss> edwardk: so "<edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a ->
        e -> c" means >=> take two binary functions and return one binary
        functions ?                                                     [12:21]

<jle`> you can think about it as taking two binary functions and returning a
       binary function
<jle`> (a -> e -> b) -> (b -> e -> c) -> (a -> e -> c)
<jusss> and this >>= :: (e->a) -> (a -> (e->b)) -> (e->b)  it means >>= take a
        unary function and a binary function then return a unary function?
                                                                        [12:22]
<jle`> jusss: do you see how (a -> m b) turns into (a -> e -> b) when we set m
       ~ (e ->) ?
<jusss> jle`: I see
<edwardk> jusss: effectively, yes.
<jusss> jle`: 'cause m is (e->)
<jle`> yeah. follow the types :)
<jle`> earlier you asked how to construct the 'f'.  to do it, just look at the
       type, (a -> e -> b), and look back in your memory if you ever learned a
       way to construct an (a -> e -> b)                                [12:23]
<jle`> :t ((+) >>=)
<lambdabot> Num a => ((a -> a) -> a -> b) -> a -> b

<jle`> oops
<jusss> wait a sec, this is really change my mind,   'cause think (a->(e->b))
        as a binary function
<jle`> :t ((+) >=>)
<lambdabot> Num b => (b -> b -> c) -> b -> b -> c
<jle`> jusss: right, there are many ways to think of an a -> (e -> b)

<Axman6> jle`: strictly, in Haskell there is no such thing as a binary
         function. _all functions take one argument_ __always__         [12:25]
<Axman6> UH, jusss
<Axman6> I will assume jle` already knows this
<jle`> i don't mind hearing it again :)

<Axman6> ____always____
                                                                        [12:26]
<jusss> so (+) is the (a->e->b)
<jle`> in fact, a -> e -> b might even be a "trinary function", if b is a
       function type
<Axman6> (+) is a -> (a -> a)

<jle`> > ((+) >=> (+)) 3
<lambdabot>  <Integer -> Integer>
<jle`> > (((+) >=> (+)) 3) 10
<lambdabot>  23
<jle`> that was less helpful than i had imagined                        [12:27]
<jusss> jle`: wait a sec, how this >=> works in this example?
<jusss> this is really change my mind about the pattern of monad, think
        (a->e->b) as a binary function                                  [12:28]
<jle`> it's basically "plus ten" twice

<jle`> so 10 becomes the first argument to (+), it becomes:
<jle`> (10 +) ((10 +) 3)                                                [12:29]

<jle`> if we use useful names like f and g, we'd get

<jle`> ((f >=> g) 3) 10  ==> g 10 (f 10 3)

<Axman6> imagine 10 is some configuration both f and g need to access. now ou
         have a way to pass that config to both of them without having to do
         it explicitly                                                  [12:31]
<jle`> and also remember that nobody really ever uses (>=>) for functions

<jle`> so if this is puzzling you...know it would puzzle most haskellers as
       well :P
<Axman6> but they do for Reader, which is just a newtype over functions which
         all need the same config                                       [12:32]
<Axman6> @src Reader
<lambdabot> type Reader r = ReaderT r Identity
<lambdabot> --OR
<lambdabot> data Reader r a = Reader { runReader :: r -> a }
<jle`> i have never in my life seen anyone use Reader
<jle`> but a lot of people do use ReaderT :)
<jusss> Axman6: wait a sec, in "<jle`> ((f >=> g) 3) 10  ==> g 10 (f 10 3)"
        yes, we pass 10 to f and g both, but why g still need f's result ?

<jle`> the only time Reader ever is relevant is in teaching examples
<Axman6> There's a spiderman pointer at spiderman meme to be had here...
<jackdk> reader is good practice when teaching someone by helping him or her
         write out the instances. Though it's probably better to use (->) r
         for that
<jle`> jusss: that's just what >=> does
<jackdk> as in good-as-practice, not "good practice"
<jle`> that's like saying "why does (+) add two numbers together?"
<Axman6> :t (>=>)
<lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c

<jusss> is there another example for Reader Monad?
<jle`> jusss: f >=> g is function composition, so you're eventually passing
       the result of f to the result of g
<jusss> pass value to two functions?
<jle`> try implementing join
<Axman6> :t join                                                        [12:36]
<lambdabot> Monad m => m (m a) -> m a
<jusss> join (Just (Just x)) = Just x
<jle`> right, but join for (-> e)
<Axman6> :t join @((->) r)
<jle`> joinFunc :: (e -> e -> a) -> (e -> a)
<lambdabot> error: parse error on input ->
<MarcelineVQ> % :t join @((->) _) -- Axman6
<yahb> MarcelineVQ: (w -> w -> a) -> w -> a

<Axman6> <3
<MarcelineVQ> @((->) _) isn't the most clear thing to a learner tho
<lambdabot> Unknown command, try @list
<MarcelineVQ> @botsnack
<lambdabot> :)
<jusss> this one I can't, 'cause we only can get the output by apply it on f
                                                                        [12:38]
<jusss> join:: m(m a) -> ma

<jusss> if f:: m(m a),  we must f(x) get m a
<jusss> make something apply on f                                       [12:39]

<jusss> jle`: how you implement this ? when (e->) is m in join          [12:40]
<MarcelineVQ> jusss: jle is asking you to write joinFunc :: (e -> e -> a) ->
              (e -> a)
<jle`> jusss: plug in (e ->) for m, the same way you just did before    [12:41]
<jle`> join :: m (m a) -> m a

<jle`> join :: (e ->) ((e ->) a) -> (e ->) a
<jle`> join :: (e -> (e -> a)) -> (e -> a)

<jusss> I know it's look like join take a binary function and return a unary
        function, but hey, this is a function , not like List or Maybe that
        container is not changed , 
<Axman6> join e2e2a = ...
<jusss> [a] and Just a, that [] and Just are not changed, but not same for
        functions                                                       [12:43]

<jle`> try writing it out
<jle`> join f = ....
<Axman6> jusss: if you have a function which takes two arguments, both of the
         same type, and you have one of those things, can you fet that
         function to return its result?

<jle`> note the type is join :: (e -> e -> a) -> e -> a
<jle`> so you can start out:
<jle`> `join f x = ....`

<Axman6> if I have f :: Int -> Int -> String, and I have x = 4 :: Int, can you
         give me a String?

<jle`> you want an 'a' as the result, right?  and you have an 'e' and an 'e ->
       e -> a'

<jusss> f:: e->e->a,   and f e:: e->a  so join f ... wait a sec , let me think
<jusss> I'm not sure the paremeter of join now                          [12:46]
<jusss> f x or  f x y or f x y z
<jle`> `join f x = ???`
<jle`> right, giving x to f gives you an e -> a
<jle`> and you want an 'a' as a final result
<Axman6> jle`: you are join, I have given you f :: Int -> Int -> String, and x
         = 7, please give me a String
<jusss> but that x is e->a
<jusss> no                                                              [12:47]
<jle`> jusss: no, that x is e :)
<Axman6> no, that x is e
<jusss> and f x is e->a
<Axman6> @quote stereo
<lambdabot> monochrom says: Welcome to #haskell, where @remember's are in
            majestic stereo!
<jle`> look at the type of join -- join :: (e -> e -> a) -> e -> a
<jle`> right, `f x :: e -> a`
<jle`> but you want an 'a' in the end
<jusss> join f = f x
<jle`> so, riddle me this:
<jle`> if you have an 'e -> a'
<jle`> and you have an 'e'
<jle`> how do you get an 'a' ?
<Axman6> join f e = ...                                                 [12:48]
<jusss> but x is not in the left =
<jusss> wait a sec,  what yours f::?
<jle`> yes it is. witness:
<Axman6> look at the type: join :: (e -> e -> a) -> e -> a

<jle`>   `join f x = ....`
<jle`> the x here is on the left hand side of the =, as opposed to the right
       hand side
<jusss> jle`: what's your f 's type?
<jle`> (e -> e -> a)
<Axman6> join f returns a function of type e -> a
<jle`> jusss: i also wrote this a few times, but:
<jle`> the type of join is (e -> e -> a) -> e -> a                      [12:49]
<jle`> so the first argument is (e -> e -> a), and the second argument is e
<jusss> jle`: but if f:: e->e->a and x:e  so join f = f x,
<jusss> and x can not be right if it's not in the left
<jusss> so this is confilicted
<jle`> right, good thing it's on the left                               [12:50]
<jle`> join f x = ...
<jle`> see, it is on the left :)
<jusss> jle`: that would be join f x = f x x
<Axman6> join f = \x -> ...
<jle`> hooray :D
<Axman6> ues!
<Axman6> yes*
<jusss> based on point-free or whatever-expanse or expand?              [12:51]
<jusss> I don't know the name, put the same symbol both on the side of =
<Axman6> so... the pointfree implementation of join f x = f x x is... join
                                                                        [12:52]
<jusss> so I'm think wrong
<jusss> a x = \x -> a

<jusss> I know what you means
<jusss> join f = \x -> f x                                              [12:54]
<jusss> we give f a x to get f's result 
<jusss> but still I don't know why this lambda can do this, 'cause x is not
        showing in the left of = and we can use it on the right part of =
                                                                        [12:55]
<jle`> join f = (\x -> f x x)

<jle`> you can think of (\x -> f x x) as its own expression

<jle`> it's a self-contained lambda expression

<jusss> jle`: wait a sec, join f= \x -> f x x is right? not \x -> f x?

<jle`> right, because giving x to f is (e -> a)
<jle`> so you need to give x again to the (e -> a) to get the 'a'

<jusss> jle`: join f x = f x x, is right?                               [12:58]

<jle`> yes
<jle`> remember that myFunc x = ... is just sguar for myFunc = \x -> ...

<jle`> so join f x = f x x is sugar for join f = \x -> f x x
<jusss> jle`: but apply one parameter on same function twice is really weird,
        not just join, bind and >=> too                                 [12:59]
<jusss> they all apply twice
<jle`> is that something you think is weird?
<jle`> you might be bringing in some preconceived notions of weirdness to the
       table :)                                                         [13:00]
<jusss> in other languages, we may do f(g(x)) , 
<jusss> but not f(g(x), x)
<jle`> have you ever went out on the street and ask people for the easiest
       'arithmetic question' they know?
<jle`> usually they will give you 1 + 1
<jle`> or 2 + 2
<jle`> applying the same value to a function twice is pretty normal :)  [13:01]
<jle`> jusss: you do f(g(x), x), sometimes. not all the time
<jle`> you aren't going to be doing f(g(x), x) for every function
<jle`> but sometimes, you do do it
<jusss> jle`: I don't remember I did this in other function programming, like
        js or python or scheme
<jusss> what the situation I would do that?                             [13:02]
<jle`> that's because you haven't needed it, right?
<jusss> yeah, I haven't needed it and I haven't seen it yet
<jle`> so, you rarely need it here, too
<jle`> just because it *exists* doesn't mean that it's *useful*

<jle`> you seem to think that because (>=>) *exists* for functions, it means
       that it's *useful*
<jle`> but, it doesn't

<jle`> maybe your problem is that you are looking at (>=>) and asking "why is
       this function useful for (e ->)? i have enver used it before"    [13:03]
<jusss> I thought that >=> and Reader Monad are useful, 'cause they're
        functions
<jle`> functions are useful
<jusss> and functions are everywhere 
<jle`> but not every function combinator is useful
<jusss> they must be made for something
<jle`> nobody made (>=>) for Reader
<jusss> something I haven't met
<jle`> they made it for Maybe, [], etc.
<jle`> we get (>=>) for Reader as a mistake, an accident
<jle`> it was never meant to be used for Reader. it was meant to be used for
       other monads                                                     [13:04]

<jusss> jle`: I mean bind pattern for Reader, and >=> for monadic values
<jusss> jle`: for example, Maybe can use for nullable detect, and Either can
        do some part of if-else(not all)                                [13:05]
<jle`> i even mentioned earlier that pretty much nobody ever uses Reader
<jle`> just because it *exists* doesn't mean that it's *useful* :)      [13:06]

<jusss> so I thought that Reader should be used for something too, and I don't
        know that what is that yet
<jle`> you're out of luck, i'm afraid
<jusss> I hope I can understand them                                    [13:07]
<jle`> it looks like you do understand them already :) 
<jle`> but you might be stuck on finding a useful situation to use them

<jusss> that's right
<jle`> that part, i can tell you now, you won't really find
<jle`> just because the monad instance exists doesn't mean that it's useful

<jle`> also note that you might be giving 'Monad' a little bit more importance
       than it's due
<jle`> monad is only one small aspect of a type's interface
<jle`> usually it's maybe like 5% of what makes that type useful
<jusss> but all the articles said how them're important , how they changed
        something like corotine
<jle`> i made that number up, but it's probably lower :)
<jle`> maybe those articles were trying to sell you something. save your
       credit card number :)                                            [13:09]

<jusss> people are selling Functional Programming at every languages now
                                                                        [13:10]
<jle`> functional programming is useful
<jle`> "the Monad instance for (->)" is much much much much less useful
<jusss> jle`: about free monad, they said it can seal the side effect   [13:11]
<jle`> that's a property about the free monad
<jle`> that doesn't have to do with the specific Monad instance for Reader
<Axman6> monads are important because they are very simple, extremely general
         and very widely applicable to many problems.
<jusss> but Reader is a special case for me
<Axman6> they're important because people use them all the time in all
         languages but don't know it
<Axman6> it's no more special than State                                [13:12]
<jle`> jusss: yes, Reader is an uninteresting special case

<jle`> jusss: here's an analogy: let's say somebody just invented the first
       ever car.  it's a great invention that can take you from city to city,
       for a very low cost

<jle`> you buy a car, and you look at it and say you want to learn how to
       drive it
<jle`> you look at a screw on the dashboard
<jle`> "this screw cannot take me anywhere. but i will spend ten years
       studying it"                                                     [13:13]

<c_wraith> the only thing that makes reader special is that its Monad
           interface doesn't actually give more power than its Applicative
           interface.
<jle`> you are only looking at a very small part of functional
       programming. and furthermore, it is a specific part that is not useful
       at all

<jle`> so, what if someone comes up to you and says, "this screw on my
       dashboard is not very useful.  but, i have heard that cars are useful.
       what is the deal?"
<jusss> I'm attracted by this special thing                             [13:14]

<jle`> yes, it is okay to be attracted to it
<jle`> but just be aware that it is not useful
<Axman6> c_wraith: slightly mindblown. I had noticed that but never put into
         words
<jle`> this is the nature of life, in a way
<jusss> fine

<jusss> I hope one day I can find the useful way for it                 [13:15]
<jle`> yes, you are attracted to it. that's a good thing, and a lot of us here
       share your fascination
<jle`> but, we also know that it is a more or less useless thing
<Axman6> spark plugs are pretty cool though

<jle`> jusss: so yes, functional programming is useful. functions are
       useful. but this is not. and that's ok                           [13:16]
<c_wraith> jusss: it comes up sometimes.  Sometimes you have a function with
           the right shape and realize that you can use Reader to pass extra
           arguments.
<jusss> special but useless...
<Axman6> jusss: Reader by itself isn't very useful, but ReaderT gets used all
         the time in applications which need to pass configuration around to
         many different components
<jle`> just because functional programming is useful doesn't mean that every
       single minute function that exists ever, will be useful
<c_wraith> jusss: and that is fun!

<jle`> functional programming is about finding the useful functions, and using
       those :)
<jle`> it isn't about making all functions useful                       [13:17]
<Axman6> @remember jle`: functional programming is about finding the useful
         functions, and using those.  it isn't about making all functions
         useful.
<lambdabot> Good to know.
<dibblego> but Reader is useful
<jle`> the problem was more that they believed that every single possible
       monad combinator in Control.Monad, as applied to Reader, must be
       generally useful
<jle`> or else it wouldn't have been included in Control.Monad          [14:03]
<jle`> generally useful as in, (>=>) for Reader would be something that is
       useful enough to use all the time

<Axman6> jusss: if you're still around, you might find dibblego's somewhat
         enlightening. It helped me a lot to stop thinking about what classes
         mean and focus on what the types mean:
         https://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
                                                                        [14:08]
<Axman6> uh, dibblego's 20 intermediate haskell exercises*
<Axman6> is that really 11 year old D: jesus
#####################################################

composeM, Kleisli compose,
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
(.)   ::            (b ->   c) -> (a ->   b) -> (a ->   c)

https://elvishjerricco.github.io/2016/10/12/kleisli-functors.html

compose two Promise Monad in js

<jusss> f >=> g     = \x -> f x >>= g                                   [10:22]
<jusss> (<=<) = flip (>=>)                                              [10:23]

https://downloads.haskell.org/~ghc/8.6.1/docs/html/libraries/base-4.12.0.0/src/Control-Monad.html#%3C%3D%3C

<jusss> lambdahaskell f >=> g = \x -> (f x >>= g)
                                                                        [10:28]
<jusss> kalxd[m]:  f x >>=g, 
        (f x)monadic value                                [10:30]
<jusss> fg (f x)
<kalxd[m]> fa -> m b                            [10:33]

##################################################

if you put xmlns:and="http://schemas.android.com/apk/res/android" you would be able to use and: instead android:

You are talking about custom namespace.In android we can create custom views in additional to already available views.

Once you define the custom attributes, you can use them in layout XML files just like built-in attributes. The only difference is that your custom attributes belong to a different namespace. Instead of belonging to the http://schemas.android.com/apk/res/android namespace, they belong to http://schemas.android.com/apk/res/[your package name]

https://stackoverflow.com/questions/28045648/android-layout-when-to-use-app-vs-android

################################################

#kotlin socket for client

import java.net.Socket
import java.net.ServerSocket

fun main(args: Array<String>) {
    val sock = Socket("127.0.0.1", 50007)
    sock.use {
        it.outputStream.write("aha, it's from kotlin".toByteArray(
            Charsets.UTF_8
        ))
        it.outputStream.flush()
        var aob = ByteArray(1024)
        it.inputStream.read(aob)
        println(aob.toString(Charsets.UTF_8))
    }
}

#reference #socket #kotlin #java
https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html
https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html
https://rosettacode.org/wiki/Sockets
http://net-informations.com/java/net/socket.htm
https://gist.github.com/banasiak/7069bb7da0cd2dd322c2d554677ac37a
https://gist.github.com/Silverbaq/a14fe6b3ec57703e8cc1a63b59605876
################################################

package whatever.classname1
package whatever.classname2
just used for import those class in other files

server.use{ it.whatever }  like f( function(x){...}) in js,
'cause this function(x) {...} will operate on something in f
and x mean that something, it's equal f(g) and g will operate
something which in f

java socket code to kotlin, only send is ok, recv isn't
http://net-informations.com/java/net/socket.htm
<MoonTide> jusss:  readUTF              [17:21]
<MoonTide> jusss:  readUTF  java 
           
           

#########################################

irc, twitter, telegram, mail list, usenet, slack, stackoverflow and github

   kleisli category, category theory,
Haskell Curry, Alonzo Church

<LdBeth>  category  seven sketches
<LdBeth> MIT 
<LdBeth> 
<jusss> LdBeth: codewars leetcode
                                                                        [13:50]
<LdBeth>                                    [13:51]
<jusss> codewarsgg
<jusss> LdBeth: 
                                              [13:52]
<eiGHttt> head . filter (== 1) . group . sort
<LdBeth> Time O(n) space O(n)

<jusss> (Just f) . (Just g) == Just(f.g) ?
<jle`> jusss: you might be thinking of liftA2 (.), not (.)              [12:08]
<iqubic> :t (liftA2 (.))
<lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
<jle`> jusss: liftA2 here lifts an (a -> b -> c) over a (Maybe a) and  (Maybe
       b) to produce a (Maybe c)
<jle`> it's like the binary version of fmap
<jusss> jle`: composeM :: (a->m b) -> (x-> m a) -> (x -> m b)           [13:19]
<jusss> f composeM g = \x -> (g x) >>= f                                [13:20]
<slack1256> @type (<=<)                                                 [13:22]
<lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
<slack1256> composeM seems to be the kleisky(sic) arrow
<jusss> slack1256: and what this <=< pronouce ?
<slack1256> I've seen it called the "fish" operator                     [13:24]
<slack1256> but you can also say it is the composition operator on the kleisky
            category                                                    [13:25]
<jle`> jusss: does this answer the question you asked earlier, 'what is
       composeM look like?'
<jusss> slack1256: kleisli ?
<jusss> jle`: sort of                                                   [13:26]
<jusss> jle`: actually I'd like to see the function definition, not type
        signature                                                       [13:27]
<jle`> isn't that what you just gave?                                   [13:28]
<jle`> 22:20:15 | f `composeM` g = \x -> (g x) >>= f                    [13:29]
<jle`> or are you looking for something more, maybe
<slack1256> jusss:
            https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/src/GHC-Base.html#%3D%3C%3C 
                                                                        [13:30]
<slack1256> the code for (<=<)
<jusss> jle`: yeah, more about f and g's definitions                    [13:31]
<jle`> they are parameters to a function
<jle`> for example, `myFunction x y = x + y`
<jle`> myFunction takes two inputs, x and y, and returns a value
<jle`> so for `composeM f g = ...`, it takes two inputs, f and g        [13:32]
<jle`> and rethrns \x -> g x >>= f
<jle`> x `myFunc` y = ..., is a way of defining a function using infix
       notation                                                         [13:35]
<jle`> it's equivalent to myFunc x y = ....


################################################

do-notation

Just 3 >>= \x -> Just "!" >>= \y -> Just (show x ++ y)
Just 3 >>= (\x -> (Just "!" >>= (\y -> Just (show x ++ y))))

from Maybe import *
foo= Just("3").bind(lambda x:
               (Just("!").bind(lambda y:
                               Just(x+y))))
print(foo.join())

foo = do
    x <- Just 3
    y <- Just "!"
    return $ show x ++ y

foo= Just("3").bind(lambda x:
               (Nothing.bind(lambda y:
                               Just(x+y))))
print(foo.join())

why not use
let x= Just("3").join()
     y = Just("!".join()
     foo=unit(x+y, Just)
'cause y may be Nothing, and "3" + Nothing will get an error

so we still stay on bind

foo = do
    (x, Just("3"))
    (y, Just("!"))
    (x+y, Just)

<jusss> I wonder if decorator can get (b)..(z) in f(a)(b)(c)...(z) ?

transform this 

foo= Just("3").bind(lambda x:
               (Just("!").bind(lambda y:
                               Just(x+y))))
to this form

foo = do
    (x, Just("3"))
    (y, Just("!"))
    (x+y, Just)       # if mx is Just("3") so we can use (mx.unit(x+y)) to replace this line

so what this do should like ?
this do should take two paramter and return a function, that function still take the same
and return a function, until the last one , return a monadic value,
I don't know if decorator can capture this (b) in f(a)(b)

>>= can filter Nothing

add mx my =
    case mx of
        Nothing -> Nothing
        Just x  -> case my of
                       Nothing -> Nothing
                       Just y  -> Just (x + y)

add mx my =
    mx >>= (\x ->
        my >>= (\y ->
            return (x + y)))

add mx my = do
    x <- mx
    y <- my
    return (x + y)

addM = lambda mx,my:
     mx.bind(lambda x:
                    my.bind(lambda y:
                                   unit(x+y)))

'cause of mx and my have the same monad, so we use mx.unit to construct monadic value
addM = lambda mx,my:
     mx.bind(lambda x:
                    my.bind(lambda y:
                                  mx.unit(x+y)))
                                   
and composeM?

#####################################################

#website
#metaclass
https://www.pythoncentral.io/how-metaclasses-work-technically-in-python-2-and-3/
#pymonad #python #monad
https://github.com/fnl/pymonad/blob/master/pymonad/Either.py
https://pypi.org/project/PyMonad/
#monoid
https://medium.com/@sjsyrek/five-minutes-to-monoid-fe6f364d0bba
#maybe #monad
https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/
#either #monad
https://blog.logrocket.com/elegant-error-handling-with-the-javascript-either-monad-76c7ae4924a1/
#cps #monad
https://stackoverflow.com/questions/4525919/continuation-passing-style-vs-monads


#keyword #thought #idea
purify function, share state, state monad, pure function
lisp haskell lambda calculus AST CPS category theory ADT Monad
semigroup, monoid, free monad, reader monad, writer monad
frontend React TypeScript redux, RESTFul API, Vue, knex, mobx, 
Java vert.x
python django
ruby rails
elixir phoenix



#abstractmethod #abstractattribute
zope.interface
@abstractmethod
@property

#persistent #python #data #const #pyrsistent
https://github.com/zopefoundation/persistent
https://pyrsistent.readthedocs.io/en/latest/intro.html

#reader monad
https://passy.svbtle.com/dont-fear-the-reader
https://wiki.haskell.org/All_About_Monads#The_Reader_monad

#face_recognition #website
https://github.com/ageitgey/face_recognition/blob/master/examples/facerec_from_webcam_faster.py
https://github.com/ageitgey/face_recognition/blob/master/README_Simplified_Chinese.md
https://github.com/habrman/FaceRecognition
https://www.pyimagesearch.com/2018/06/18/face-recognition-with-opencv-python-and-deep-learning/
https://github.com/Microsoft/Cognitive-Face-Python
https://realpython.com/face-recognition-with-python/
https://realpython.com/face-detection-in-python-using-a-webcam/

#higher-order logic 
https://en.wikipedia.org/wiki/Higher-order_logic
https://en.wikipedia.org/wiki/First-order_logic

#javascript #monad
https://medium.com/@tzehsiang/javascript-functor-applicative-monads-in-pictures-b567c6415221
https://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/

#history of #functional programming #lisp #haskell
https://zhuanlan.zhihu.com/p/24648375

#Elm #css #three-ways #css-file #in-js #elm-css #elm-elements
https://proandroiddev.com/taming-state-in-android-with-elm-architecture-and-kotlin-part-1-566caae0f706
https://segmentfault.com/a/1190000004886629
https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md
https://elmprogramming.com/model-view-update-part-2.html
https://qiita.com/jinjor/items/245959d2da710eda18fa
http://heimdal.hatenablog.com/entry/elm-0.19-sandbox#main%E6%A7%8B%E6%88%90
https://medium.com/@_safhac_/elm-for-beginners-overview-of-programs-architecture-c8209a09ac18
https://medium.com/javascript-inside/introduction-into-elm-67a422911ae5
https://blog.realkinetic.com/elm-changed-my-mind-about-unpopular-languages-190a23f4a834


#fibonacci #haskell
https://wiki.haskell.org/The_Fibonacci_sequence

#python #argparse #ast
https://docs.python.org/2/howto/argparse.html
https://docs.python.org/3/library/ast.html

#quick sort
http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html

#python #Tkinter #tk
https://stackoverflow.com/questions/40323850/second-frame-with-fill-both-and-expand-true-not-expanding-fully

#python #tornado #counter #crontab
http://xiaorui.cc/2016/01/20/%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90tornado-periodiccallback-crontab%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e5%ae%9e%e7%8e%b0/

#sql
https://www.postgresql.org/
https://simpleisbetterthancomplex.com/series/2017/09/04/a-complete-beginners-guide-to-django-part-1.html

#fetch #mozilla #js
https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch

#zhihu #monad
https://zhuanlan.zhihu.com/p/21624824
https://zhuanlan.zhihu.com/p/58514370
https://blog.oyanglul.us/grokking-monad/part2
http://blog.forec.cn/2017/03/02/translation-adit-tum/

#elm #bootstrap #css
https://medium.com/javascript-inside/introduction-into-elm-pt-3-272c2e9b9d0
https://medium.com/javascript-inside/introduction-into-elm-67a422911ae5
https://cnodejs.org/topic/575c354ce5fa62531af6e1c2
https://hackernoon.com/how-elm-ports-work-with-a-picture-just-one-25144ba43cdd
https://elm-lang.org/docs/syntax
http://elm-bootstrap.info/getting-started
https://becoming-functional.com/test-driving-the-elm-style-elements-library-7e7771c4159a


#haskell #clay
http://hackage.haskell.org/package/clay-0.13.1/docs/Clay-Background.html


################################################################

class Right(Either):
      def __init__(self,value):
          self.v1=1
          self.value = value

      def chain(self,fe):
          

class Left(Either):
      def __init__(self,value):
          self.v0=0
          self.value=value


(Right
        right1,left1
                right2,left2
       right3,left3
                Left).chain(right1, left1).chain(right2, lfet2)

how right3,lfet3?

unless use
(Right
        right1,left1
                right2,left2
        right3,lfet3
                right4,left4

                Left).chain1(right1,left1).chain2(righ2,left2).chain1.(right3,left3).chain2(right4,left4)
                or a chain-pair to if-else
                (Right,Left).chain-right(righ1,left1).chain-left(right3,left3).

so this is impossible, use Either Monad to do if-else stuff
https://dev.to/rametta/basic-monads-in-javascript-3el3
https://github.com/rametta/pratica#resultchain
Either will only eval one branch, another branch won't

or

var o = ... // could be undefined or null
Either.fromNullable(o)
  .fold(invalidO.fold(invalid1.fold(invald2,good2) ,good1), goodO)
  .fold(invalid3, good3)
https://glebbahmutov.com/blog/if-else-vs-either-monad-vs-frp/

Either Monad in Haskell, the Left part shouldn't be evaluated and make a chain on it,
'cause it means the end, but in if-else, there could be another if-else in the upper else block

https://www.toptal.com/javascript/option-maybe-either-future-monads-js
#website

" we want to define a happy path and a sad path for our code. On the happy path, we just keep happily running our code until an error happens or we finish. If we end up on the sad path though, we dont bother with trying to run the code any more."
eval only on one path,
https://jrsinclair.com/articles/2019/elegant-error-handling-with-the-js-either-monad/
still don't handle if-else in else block, 'cause else means end in here

all those three only work on,  or we can say Either Monad can used for this pattern
if :
   if:
        if:
        else:
    else:
else:

not work on, Either won't be used for this pattern
if:
        if:
        else:
                if:
                else:
                
else:
        if:
        else:

but what if

if 3>1:
else:
        if 2>1:
        else:

is equal to

if 3>1:
else:
if 2>1:
else:

??? only equal with the same condition, but not equal with different conditions



###############################################

jdk https://jdk.java.net/12/
https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html?ssSourceSiteId=otnes
download android studio from android.com
https://qisdk.softbankrobotics.com/sdk/doc/pepper-sdk/ch1_gettingstarted/installation.html#installation

https://mazhuang.org/2015/05/06/android-studio/

" Android Studio 3.0.1  3.1 Check for Updates...  Cause: jcenter.bintray.com:443 failed to respond Settings  HTTP Proxy  no proxy Connection refused: connect  ~/.gradle/gradle.properties Android Studio"

Java 8 Optional class same as Maybe in Haskell

######################################################

Prelude> :{
Prelude| div x y =
Prelude|     case y of
Prelude|         0 -> Left "Zero"
Prelude|         _ -> Right $ x/y                                                --or use Right (x/y)
Prelude| :}

Prelude> div 3 2
Right 1.5
Prelude> div 3 0
Left "Zero"
Prelude> :t div
div :: (Eq b, Fractional b) => b -> b -> Either [Char] b

it seems to me just like return any two type results in one function with Either type,
'cause static languages's result type is specific, so there Either comes
just like Either a as Maybe, and Left a as Nothing, Right b as Just a
Left x >>= f = Left x
Right x >>= f = Right (f x)

it's two branches, one is right and another is left,

if :
  if :
    if :
    else:
  else:
 else:
 
one pair if-else is left-right

f1 = if: return right()  else: return left()
f2 =
f3 =

f0().chain(f1).chain(f2).chain(f3)

class Right(Either):
      def chain(self, branch):
          return branch()

class Left(Either):
      def chain(self, branch):
          return branch()

################################################

none, maybe monad
if-else, either monad

<ski> if `y' has type `b', then `Right y' has type `Either a b'         [17:15]
<ski> if `x' has type `a', then `Left x' has type `Either a b'
<Rembane> jusss`: That is indeed correct, you cannot do anything with the Left
          in the Monad instance.
<dminuoso> jusss`: So `Either Text Int` can be thought of a computation to
           produce an `Int` that could however fail with a Text error.
<Rembane> jusss`: Left a >>= f -- f doesn't do anything.
<ski>   Left  e >>= _ = Left e
<dminuoso> jusss`: `Either e` is conceptually the same as Maybe.
<dminuoso> jusss`: The only difference is that `Nothing` cannot encode any
           information into failure. You don't get to write `Nothing "parse
           failed, no number found"\`
<dminuoso> But with `Either e` you do. If you for example have `Either String
           Int`, you can write `Left "parse failed, no number found"` which
           might be equivalent to some `throw "parse failed, no number found"`
           in some languages.

module EitherEx where
 
import Data.Map as M
 
ageList :: M.Map String Int
ageList = M.fromList [("Paul", 21), ("Mary", 17), ("Don", 40)]
 
getAge :: String -> Either String Int
getAge name =
  case M.lookup name ageList of
    Nothing -> Left $ "Could not find any age for " ++ name
    Just x -> Right x
 
ageSum :: Either String Int
ageSum = do
  paulAge <- getAge "Paul"
  bobAge <- getAge "Bob"
  maryAge <- getAge "Mary"
  donAge <- getAge "Don"
  return $ paulAge + bobAge + maryAge + donAge


###############################################

#MRO #python #class #super
class A
class B(A)
class D(A)
class C (D,B) find in D first, then B in py3k, A in py2k

py2k,  
class B(A):
      def __init__(self):
          B.__init__(self)
py3k,
class B(A):
      def __init__(self):
          super()__init__()

########################################

@f == fmap f

############################################

for easy to use higher-order function, js got arrow function, python got decorator

f = lambda x: lambda y: x+y
f = x=> y=> x+y

def addX(f):
    return lambda x: lambda y: f(x)+y
        
@addX
def f (x):
    return x

#############################

#metaclass
https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python
#javascript #Maybe
https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/

#########################################

<jusss> LdBeth: eiGHttt id lawidentivity law
        monadlaw                          [11:08]
<jusss> LdBeth:  eiGHttt https://paste.ubuntu.com/p/ZZHFq2BpYD/

https://wiki.haskell.org/Monad_laws
###################################

<jusss> eiGHttt LdBeth Int  Semigroup instance?             [10:37]
<jusss> mempty = 0
<jusss> mappend x 0 = x
<jusss> mappend 0 x = x
<eiGHttt> (1, *)(0, +) 2 <> 3 = ?                       [10:38]
<jusss> 1 + 0 = 0,  1* 2 =2
<jusss> eiGHttt 
<LdBeth> jusss:
<jusss> eiGHttt  String  List                   [10:40]
<eiGHttt> :i Monoid

#######################################

#abstract attribute

class Monoid(Semigroup, metaclass=ABCMeta):
    mappend = Semigroup.mappend
    @property
    @abstractmethod
    def mempty(self):
        raise NotImplementedError

class Just(Monoid, Maybe):
    def __init__(self, value):
        self.value = value
    @property
    def mempty(self):
        return Nothing

Just("a").mempty

the trick part is that @abstractmethod only check function's name, not variables
so we use @property turn to call the function like a variable,
now we can use this instance.variable form

##################################

from abc import ABCMeta, abstractmethod
class Foo(metaclass=ABCMeta):
	@abstractmethod
	def fun(self):
		raise NotImplementedError

you must set metaclass=ABCMeta for @abstractmethod

class Coo(metaclass=ABCMeta):
	@property
	@abstractmethod
	def fun(self):
		pass

class Yoo(Coo):
	fun=1

	
>>> i=Yoo()

#######################################################

oh, I see, object to python, value to haskell, quote to lisp
Nothing = _Nothing()
Just 3
'Nothing
they all are values, eval values and get themself
function is a value too
function is a value that we can get other values from this values
just pass the values, that can prevent call-by-value, 'cause eval value and get itself

and we can use function to store value to prevent call-by-value
f = lambda: the-value-you-want
then you can pass f to anywhere, and eval f will get f, until you want to get the value,
then f()

##############################################

<jusss> ok, Maybe a is *,  Maybe a is a monoid
<jusss> Maybe is *->* ,   Maybe is a monad
that's why you need to implement Just class in python as Monoid instance
'cause Maybe class is Monad instance
<Solonarv> there is no Semigroup Int instance
#####################################

<Cale> For Monoid, you define mempty and mappend                        [15:30]
<Cale> A simple monoid instance is the one for lists:
<jusss> Cale: yeah, and how those two functions work?
<Cale> instance Monoid [a] where
<Cale>   mempty = []
<Cale>   mappend = (++)
<Cale> instance Num t => Monoid (Sum t) where -- the Sum type here is a
       newtype wrapper                                                  [15:31]
<Cale>   mempty = Sum 0
<jusss> Cale: yeah, [] is instance of List Monad, but Maybe Monad hasn't
        instance right?
<Cale>   mappend (Sum x) (Sum y) = Sum (x + y)
<Cale> The Monad is irrelevant here
<Cale> We didn't use return or (>>=) or anything based on Monad
<Cale> We only used [] and (++)                                         [15:32]
<Cale> instance Semigroup a => Monoid (Maybe a) where                   [15:36]
<Cale>   mempty = Nothing
<Cale>   mappend Nothing y = y
<Cale>   mappend x Nothing = x
<Cale>   mappend (Just x) (Just y) = Just (x <> y)

<bahamas> jusss: mempty is the identity element                         [15:45]
<bahamas> jusss: like 0 is for addition and 1 for multiplication

<Axman6> it's just a value
<Axman6> @src Monoid
<lambdabot> class Monoid a where
<lambdabot>     mempty  :: a
<lambdabot>     mappend :: a -> a -> a
<lambdabot>     mconcat :: [a] -> a

#####################################################
Semigroup, <>,
<> :: s -> s -> s
x <> y,  if x and y are string then ++,  are list then ++,
for int, raise CompileError or NotImplementError, 'cause Int is not instance of Semigroup
<> definition, the last one line is raise CompileError
others like pattern matching type, like String or Int do ++

Just ("a" <> "b") == Just "ab"
and Just (x <> y) is a value,  just like Just 3, but I think it's a un-complete computation
so there's Just a <> Just b = Just (a<>b)

#############################################################
<jusss> monoid's mempty and mappend have to do with monad's identity law and
        associativity law?
<Cale> uhhh... in the case of the Writer monad that's true
<jusss> Cale: if I want turn a type T to Monad, can I just make T be the
        instance of Functor, Applicative and Monad?  does T need to be
        instance of Monoid?
<Cale> It wouldn't even make sense for T to be an instance of Monoid in that
       case                                                             [15:15]
<Cale> It's not the right kind
<Cale> :k Monoid
<lambdabot> * -> Constraint
<jusss> Cale: but Monad is a Monoid
<Cale> :k Monad
<lambdabot> (* -> *) -> Constraint
<Cale> hm?
<jusss> not right?                                                      [15:16]
<Cale> Monoid is for monoid objects in the category of sets (or Haskell types)
<jusss> that famous joke!
<Cale> Monads are monoid objects in the category of endofunctors on some
       category
<Cale> (in this case, the endofunctors on the category of Haskell types)
<Cale> I can sketch the connection a little if you want
<jusss> please
<Cale> So recall that a monoid is a set M with some unit element e in M,
       which, since we have our category theory hats on, we can regard as a
       function 1 -> M, where 1 is some one element set                 [15:18]
<Cale> and a multiplication M x M -> M
<jusss> Cale: wait a sec, is Maybe a Monoid instance?
<Cale> where x is Cartesian product
<Cale> not directly                                                     [15:19]
<Cale> jusss: However, there is an instance Semigroup a => Monoid (Maybe a)
<Cale> So while there's no instance Monoid Maybe (nor does that kind-check)
                                                                        [15:20]
<Cale> there is an instance Monoid (Maybe a), whenever there's an instance
       Semigroup a
<jusss> Cale: actually I wonder what's the shape of monoid in haskell, like 1
        + 0,  1 * 3,  id . f
<jusss> what's the monid?
<jusss> [] is monad in something, e-> is mond in something, what's the monoid
        like?
<Cale> Monads and monoids are only very abstractly similar              [15:23]
<Cale> There won't be a monoid corresponding to any given monad
<Cale> Well, I could come up with several, but there isn't a canonical choice
       of one :)
<Cale> (Monoids are very easy to come up with)                          [15:24]
<jusss> come up with what form or shape?
<Cale> For example, if M is a monad, we could turn M () into a monoid, where
       mappend is (>>) and mempty is return ()                          [15:25]
<Cale> Also, for any type t, we could turn functions a -> M a into a monoid,
       where mappend is (<=<) and mempty is return                      [15:26]
<Cale> er, for any type a
<Cale> (I was going to use t, and then I didn't ;)
<jusss> still don't get it                                              [15:27]
<Cale> Also, for any monad M, we can define an instance Monoid a => Monoid (M
       a) where mempty = return mempty; mappend = liftM2 mappend
<Cale> There are a lot of monoids
<Cale> jusss: I might not be understanding what you're trying to get    [15:28]
<jusss> Cale: what it's like? now I can get Functor, Applicative and Monad,
        like we can implement fmap, apply and bind also return to turn the
        type be an instance of those three typeclass, but Monoid is like that? 
<jusss> sorry, my English is not good
<Cale> For Monoid, you define mempty and mappend                        [15:30]
<Cale> A simple monoid instance is the one for lists:
<jusss> Cale: yeah, and how those two functions work?
<Cale> instance Monoid [a] where
<Cale>   mempty = []
<Cale>   mappend = (++)
<Cale> instance Num t => Monoid (Sum t) where -- the Sum type here is a
       newtype wrapper                                                  [15:31]
<Cale>   mempty = Sum 0
<jusss> Cale: yeah, [] is instance of List Monad, but Maybe Monad hasn't
        instance right?
<Cale>   mappend (Sum x) (Sum y) = Sum (x + y)
<Cale> The Monad is irrelevant here
<Cale> We didn't use return or (>>=) or anything based on Monad
<Cale> We only used [] and (++)                                         [15:32]
<jusss> Cale: what about Maybe
<Cale> and it's a monoid because for any list xs, we have [] ++ xs = xs and xs
       ++ [] = xs, and for any lists xs, ys, zs, we have xs ++ (ys ++ zs) =
       (xs ++ ys) ++ zs
<bahamas> jusss: Monad and Monoid are `type classes`. `List` and `Maybe a` are
          `types`, in case the distinction is not clear                 [15:33]
<Cale> jusss: I never got through explaining the connection between Monoid and
       Monad, it's *very* abstract
<Cale> Do you happen to know what a natural transformation is?
<jusss> Cale: bahamas if we turn Maybe as an instance of Monoid, how we
        impelemnt the mempty and mappend?
<jusss> Cale: I don't know about natural transformation yet, I heard that name
        before :)
<Cale> jusss: We can use a Semigroup instance for a to obtain an instance of
       Monoid for Maybe a
<Cale> instance Semigroup a => Monoid (Maybe a) where                   [15:36]
<Cale>   mempty = Nothing
<Cale>   mappend Nothing y = y
<Cale>   mappend x Nothing = x
<Cale>   mappend (Just x) (Just y) = Just (x <> y)       
<Cale> Where now <> is the Semigroup operation                          [15:37]
<Cale> This is a way of adding an identity element to any semigroup
<bahamas> jusss: are you trying to understand how monoids work or something
          else?
<Cale> jusss: So, natural transformations are the arrows in the category that
       monads are monoid-objects in. For now, you can think of a natural
       transformation f -> g as being a polymorphic function of type  forall
       a. f a -> g a
<jusss> bahamas: I'm trying to know how to turn a type as an instance of
        monoid
<Cale> jusss: A monad consists of some endofunctor M: C -> C, and then a
       couple of natural transformations: return: 1 -> M, and join: M . M ->
       M. Here, 1 is the identity functor, and the '.' is composition of
       functors                                                         [15:40]
<Cale> But since in one case, we were dealing with pairs of elements of a set,
       and combining them, and now we're taking things of type M (M a), and
       producing things of type M a
<Cale> well, it's not *quite* the same thing as soon as you look at the
       details
<bahamas> jusss: you need to implement the two methods required by Monoid:
          mempty and mappend. that means that your type needs to have a
          meaningful mempty value. like 0 is in the case of addition, [] for
          the list type, Nothing for the Maybe a type                   [15:42]
<Cale> It's like, if you can blur your eyes enough, these become exactly the
       same thing, and they even have the same laws.
<Cale> But as soon as you unblur them, they're completely different concepts.
<jusss> bahamas: Cale and those mempty and mappend are linked with identity
        law and associativity law ?                                     [15:43]
<Cale> jusss: mempty <-> return                                         [15:44]
<Cale> mappend <-> join
<Cale> The identity law and associativity law can be made to look the same for
       monads and monoids, if you write them in a particular funny way
<bahamas> jusss: mempty is the identity element                         [15:45]
<bahamas> jusss: like 0 is for addition and 1 for multiplication
<Cale> If we go back to our picture of monoids where we had some function e: 1
       -> M picking out the identity element
<Cale> and m: M x M -> M
<Cale> the multiplication
<Cale> then we could write the unit laws in a particular way... I fear the
       notation won't make any sense, because I haven't introduced much of it
<Cale> actually, I'd also have to introduce the left and right unitors and the
       associator...                                                    [15:47]
<Cale> hah
<Cale> https://en.wikipedia.org/wiki/Monoid_(category_theory) -- maybe just
       look here for a moment
<Cale> In one case, we can replace the tensor product symbols (x) with
       Cartesian product
<Cale> and interpret I as some one-element set
<Cale> and then alpha is a function which reassociates tuples alpha ((x,y),z)
       = (x,(y,z))
<jusss> Cale: wait a sec, "mempty = Nothing"  this mempty is a function
        without arguments?
<jusss> every function is an unary function                             [15:49]
<Cale> jusss: It's not even a function as it's expressed in Haskell. In the
       stuff I'm talking about, we're taking it to be a function from a
       one-element set, but usually it makes more sense just to think of it as
       an element of the monoid.
<Axman6> it's just a value
<Axman6> @src Monoid
<lambdabot> class Monoid a where
<lambdabot>     mempty  :: a
<lambdabot>     mappend :: a -> a -> a
<lambdabot>     mconcat :: [a] -> a
<Cale> jusss: anyway, I think it's probably best to ignore the connection
       between Monad and Monoid, since it's really abstract, and even once you
       understand it, it won't do much for you unless you're interested in
       many other areas of mathematics -- in which case, it leads to asking
       about what the monoid objects of other categories might look like.
                                                                        [15:51]
<jusss> Cale: ok
<Cale> For programming in Haskell, the connection isn't useful in any way
<Cale> (at least, in any way that we've managed)                        [15:52]
<jusss> Cale: so It doesn't need to be a monoid befor a monad, right?
<Cale> yeah, these concepts don't even really discuss the same *kind* of
       things
<Cale> jusss: A monoid has to be a type of kind *                       [15:53]
<Cale> A monad has to be a type of kind * -> *
<jusss> Cale: forgive me, I forget how the (m a) is with * -> *         [15:54]
<jusss> I remember that Either a is a mond, not Either
<Cale> jusss: that's right
<jusss> Maybe is a mond , Maybe a isn't                                 [15:55]
<Cale> jusss: yep
<jusss> and with the kind type *-> *  ,  I forget the connection
<Cale> :k Maybe
<lambdabot> * -> *
<Cale> :k Maybe Int
<lambdabot> *
<Cale> :k Either
<lambdabot> * -> * -> *
<Cale> :k Either String
<lambdabot> * -> *
<Cale> :k Either String Int                                             [15:56]
<lambdabot> *
<Cale> Monads M are always things of kind * -> *
<Cale> so that the types
<Cale> return :: a -> M a
<Cale> and
<jusss> ok, Maybe a is *,  Maybe a is a monoid
<Cale> (>>=) :: M a -> (a -> M b) -> M b
<Cale> will make sense
<jusss> Maybe is *->* ,   Maybe is a monad
<Cale> jusss: Maybe a *could be* a monoid
<Cale> jusss: Given a type of kind *, it might have a Monoid instance or might
       not                                                              [15:57]
<jusss> Cale: until we implement mempty and mappend, right?
<Cale> right, it won't until we actually say what mempty and mappend should be
<Cale> and write the instance
<jusss> Cale: like Maybe may be a monad until we implement fmap, apply, bind
        and return
<jusss> Cale: "<Cale>   mappend (Just x) (Just y) = Just (x <> y)"  what this
        semigroup <> do?
<Cale> jusss: Depends on the type
<jusss> Cale: String?
<Cale> concatenation
<jusss> Cale: Int?
<Cale> nothing, there's no Semigroup instance                           [16:24]
<Solonarv> there is no Semigroup Int instance
<Solonarv> > 3 <> 5 :: Int
<lambdabot>  error:
<lambdabot>       No instance for (Monoid Int) arising from a use of <>
<lambdabot>       In the expression: 3 <> 5 :: Int
<jusss> Cale: Solonarv Maybe a?
<Cale> jusss: If it's Maybe a, it'll use mappend again :)
<Solonarv> jusss: why don't you look up the actual instance definition?
<dminuoso> jusss: (<>) captures the notion of "smashing things together" in a
           way that makes sense. So if you ever find yourself writing
           something like `A -> A -> A`, then it's a possible candidate for
           Semigroup.                                                   [16:25]
<Solonarv> (<>) is part of Semigroup, which is from Data.Semigroup - link:
           https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Semigroup.html#t:Semigroup
<Solonarv> if you scroll down a bit you can see the list of instances, click
           the Source link next to one of the instances to see that
           instance's implementation
<Solonarv> for example here is the instance for Maybe a:
           https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-403
<Cale> The law is that x <> (y <> z) must be the same as (x <> y) <> z
<Cale> so long as that's true, you can define a Semigroup instance
<Cale> The reason that there's no instance for Int is that there are two
       obvious ones: addition and multiplication
<Cale> To pick one, use the Sum and Product newtypes                    [16:27]
<Solonarv> (and a whole lot of less obvious ones)
<dminuoso> Cale: There shouldn't be one for Int because you dont have closure.
<Cale> You do though
<dminuoso> Cale: Ah, is addition/multiplication defined as modulo arithmetic?
<Cale> It's arithmetic modulo some unspecified power of 2 (which can be
       determined by looking at maxBound and minBound)
<Solonarv> > 2^31 + 2^31 :: Int32                                       [16:28]
<lambdabot>  0
<dminuoso> Oh yeah. :)
<Solonarv> yup, modular arithmetic
<Solonarv> closure is actually implicit in the type as long as <> is total
<Cale> dminuoso was thinking that it wasn't total                       [16:30]
<Solonarv> and there is *usually* an expectation of totality anyway -
           especially for the less kludgy typeclasses - so that just isn't
           mentioned in the docs
<Solonarv> (Num is a big offender for "kludgy typeclass", and so is Enum)
<Cale> (it would be somewhat reasonable to error out if there was overflow,
       except we'd find that horribly inconvenient in Haskell)
<Axman6> There's definitely more than two obvious Semigroup instances for
         Int. xor is also a nice one                                    [16:31]
<Axman6> (Also a monoid)
<dminuoso> Cale: I guess my real mistake was thinking that you had to
           implement it in terms of (*) and (+), but I realized that it doesnt
           matter since you could implement (+ mod n) and (* mod n) for a
           suitable n by hand anyway.
<Solonarv> Axman6: also bitwise equality
##########################################################

shapespatternform,,,   Category Theory

python use class and js use object to do functor, monad
or use closure to do functor

haskell's typeclass
python's @abstract
java's interface


Type TMonadpattern()TMonadType TMonad classbehaviorbehaviorclass 

<jusss> 
<jusss> classobject,  classobjectbehavior
<jusss> objectbehaviorclass
                                                                        [15:15]
<jusss> 
<jusss> polymorphic
<jusss> listfunctioncontext,
<jusss> metaclass,  return class in class
<jusss> shapespattern, 
        form                                                            [15:21]
<jusss> yunfan: f = lambda x: lambda y: x  
<jusss> yunfan:  id = lambda x: x
<jusss> yunfan:  compose = lambda x,y: lambda z: x(y(z))            [15:33]
<jusss> composeM(return1, return2)                                  [15:35]
<jusss> yunfan: unit1 = x=> [x]        unit2 = x => _=>x                [15:55]
<jusss> yunfan: unit3 = x=>Promise.resolve(x)
<eiGHttt> unit4 = x => Just(x)? unit5 = ...?                            [15:57]
<jusss> MaybeMonadMonad                       [16:05]
<eiGHttt>                                           [16:07]
<jusss> Functor Applicative Monadtypeclassinstance
                                                                        [16:08]
<jusss> typeclassfunction
<jusss> return, fmap, <*>, and >>=
<jusss> join, flip, 
<jusss> etc
<eiGHttt> MaybeMonad                              [16:09]
<jusss> MaybeMonadpattern, Monadshape
                                                                        [16:10]
<jusss> eiGHttt data T a = V a, type, TTMonad
        pattern                                                     [16:11]
<eiGHttt> MonadMonad
          Monad
<jusss> data T a = V a, TMonad, TFunctor, Applicative,
        MonadTMonad ?
<jusss> TpatternTMonad?
                                                                        [16:13]
<eiGHttt> MonadFunctorApplicativeTMonad
          TFunctorApplicative
<eiGHttt> 
<jusss> TFunctorTFunctor
<eiGHttt> Functor
<eiGHttt> 
<jusss> TFunctorTFunctor
        TFunctorshape, TFunctor, 
        TFunctorpattern, TFunctor
<eiGHttt> jusss: 
<eiGHttt> Haskell
<eiGHttt> s//
<eiGHttt> data T v = V a
<jusss> eiGHttt those Functor, Applicative, Monadshapes
        pattern,patternshapesFunctor or others,
        Category Theory
<jusss> 
<eiGHttt>                                                     [16:22]
<jusss> "<eiGHttt> data T v = V a"  data T v = V a
                                                        [16:24]
<eiGHttt> jusss: 
<jusss>  a
<jusss> eiGHttt 
        
<eiGHttt> jusss: 
<jusss> eiGHttt MonadMonad, 
        classbehavior
#####################################
#metaclass #python
https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python
<jusss> yunfan: djangoORMmetaclass              [15:29]

use decorator or metaclass both can put some attributes in class when it's been created

like typeclass in python? and typeclass's instance is type, metaclass's instance is class
in python2 use __metaclass__ = something,
in python3 class Foo(object, metaclass=something)

class MyMeta(type):
    pass

class MyClass(metaclass=MyMeta):
      #python3

class MyClass:
      __metaclass__ =MyMeta
      #python2

class MetaOne(type):
    def __new__(cls, name, bases, dict):
        that-dict-is-attributes-dict-so-apped-it-to-this
        return super().__new__(cls, name, bases, dict)
        or
        dict['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, dict)

class MetaTwo(type):
    counter = 0
    def __init__(self, name, bases, dict):
        #this-is-like-super()
         type.__init__(cls, name, bases, dic)
         self._order = MyMeta.counter
          MetaTwo.counter += 1

#it seems that __new__ need be return, but __init__ doesn't
# if you want append function use __new__, append variable use __init__

class Meta(type):
	counter=0
	def __init__(self,name,bases,dict):
		dict['add'] = lambda self,x,y: x+y
		self.counter = Meta.counter

class RegularClass(metaclass=Meta):
	pass
L=RegularClass()
RegularClass.counter
0
dir(RegularClass)   there's no add method in it

class Meta2(type):
	def __new__(cls,name,bases,dict):
		dict['add']=lambda self,x,y: x+y
		return type.__new__(cls,name,bases,dict)
class R2(metaclass=Meta2):
	pass
L2=R2()
L2.add(3,5)
8
dir(R2) there's add

__new__ is used when one wants to define dict or bases tuples before the class is created.
The return value of __new__is usually an instance of cls. __new__ allows subclasses of immutable types to customize instance creation.
It can be overridden in custom metaclasses to customize class creation.
__init__ is usually called after the object has been created so as to initialize it.

we can also override other class methods by defining a custom __call__() method in the metaclass that allows custom behavior when the class is called.

Once the appropriate metaclass has been identified, then the class namespace is prepared. If the metaclass has a __prepare__ attribute, it is called as namespace = metaclass.__prepare__(name, bases, **kwds) (where the additional keyword arguments, if any, come from the class definition). If the metaclass has no __prepare__attribute, then the class namespace is initialized as an empty ordered mapping.

https://www.datacamp.com/community/tutorials/python-metaclasses
https://docs.python.org/3/reference/datamodel.html
https://www.liaoxuefeng.com/wiki/897692888725344/923030550637312

<jusss> all the class are instance of the type class?                   [09:24]
<jusss> about metaclass
<altendky> jusss: `type` is the metaclass of a 'regular' class defined like
           `class X:`, yes.  not all classes have `type` as their metaclass
           though.
<jusss> altendky: when we need it?
<jusss> altendky: 'cause python is oo based on class, not prototype, so what's
        the metaclass is used for
<altendky> jusss: when do you need custom metaclasses?  when you want to do
           confusing magic that will make it hard for people to use your class
           in another way.  i dunno.  i'm sure there are cases but mostly stay
           away from them.
<jusss> altendky: I heard that django ORM stuff use that metaclass
<altendky> jusss: QObject has a custom metaclass.  i bet django and sqlalchemy
           and other orms do.  etc.
<altendky> jusss: but, for a counterpoint on declarative stuff like that
           consider the attrs approach with a decorator.
<jusss> altendky: yeah, use decorator or metaclass both can put some
        attributes in class when it's been created, right?              [09:48]
<altendky> jusss: yes           

#############################################
REST API, RESTful API, get post put

about #decorator



class Starship(object):
      sound = 'Vrrrrrrrrrrrrrrrr'
      @classmethod
      def make_sound(cls):
          print(cls.sound)

       @staticmethod
       def beep():
           print("beep ")

        @property
        def engine_strain(self):
            if not self.engines:
               return 0
             else:
                ...

Starship.make_sound()
Starship.beep()
a=Starship()
a.engine_strain

@property is same as getter and setter in java
we can treat engine_strain as an instance variable of the object

##################################
python even has monad module, pip install monad
pymonad,
t=Just(3)
t.getValue()

dir(pymonad.Maybe) #check the identifiers that Maybe has
help(pymonad.Maybe.unit) #check the identifier's definition

z=Just(3)>>(lambda x: unit(Maybe,x+1))
z.getValue()

half = lambda x,y: Nothing if y==0 else unit(Maybe, x/y)
half(3,0)==Nothing

#########################

lisp: lambda calculus, AST, CPS
haskell: category theory, ADT, Monad

####################################################

<ski>   data Tree a = Nil
<ski>               | Node a (Tree a) (Tree a)
<ski> now, define a function                                            [10:33]
<ski>   addToTree :: Num a => Tree a -> a -> Tree a
<ski> that adds its second argument to all the elements of the tree, giving
      back the corresponding new tree

Tree a could be Nil, Node a Nil Nil, Node a Nil (Node a Nil Nil),
Node a (Node a Nil Nil) Nil, etc... infinity?

##############################################

<jusss> ski: what it's used for? >>= f g x = g (f x ) x is weird function

#############################################

do-notation

foo :: Maybe String
foo = do
    x <- Just 3
    y <- Just "!"
    Just (show x ++ y)

and x is 3, y is "!",  (<-) can get  a in (m a)
and the last line return a (m b)

Prelude> :{
Prelude| foo = do
Prelude| x <- (*3)
Prelude| y <- (+1)
Prelude| return (x+y)
Prelude| :}
Prelude> foo 3
13

###########################################

(->) is a abstract data type, not a algebraic data type,
and (e->a) can only shows up on the right part of '=' in the data type definition
and it need a value constructor like Int
data Endo a = Endo (a -> a)

<jusss> and we don't have the definition of (e->a)
we don't have data (e->a) :: ?
<jle`> the basic syntax is `data <TyCon> <var1> <var2> = <Con1> <field1a>
       <field2a> | Con2 <field2a> ..., etc.
<jle`> right, (->) isn't defined using ADT syntax anywhere
<jle`> since it isn't an ADGT
<jle`> * ADT


(e->a) is a type, not a value, and \x->x is a value, not a type
(->) e a is a type, like Int, or Maybe a,
(->) is not a type constructor
(->) is abstract data type, not algebraic data type,
we cann't define (->) in algebraic data type
but when when use it as a type like Int, that's normal with others
and (e->a) only shows up on the right part of '=' in the data type definition, like a type
, like Int, it need a value constructor  
data Endo a = Endo (a -> a) is ok
data Endo a =  (a -> a) is not

<jle`> jusss: 'Reader' is a common synonym for (->), which helps emphasize
       some conceptual aspects of how you use (->)
<jle`> for Reader, (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b

<ski> jusss : "this (e->a) is one type, and it needs two variables to
      construct" -- it needs two components, two type parameters. in this
      case, they were tyvars. in `Int -> Char', they're not tyvars      [14:43]



##################################

greeter :: Reader String String
so greeter = Reader (String->String)
runReader Reader f = f          f::String->String
runReader greeter = f
Reader r is the monad, not Reader, like Either a is the monad, 'cause m::*->*
but in Reader e->a , Reader e-> is the monad
############################################

<jusss> data Reader r a = Reader {  runReader :: r -> a } , this means
`data Reader r a = Reader r->a ` and `runReader Reader x = x` ?       [09:28]
<jusss> and x is r->a ? this is possible?

<jusss> a function's type signature show up in a data type definition?
<geekosaur> and yes, function types are perfectly permissible types
<geekosaur> that's kinda the point of a functional language, functions are
            first class types and values
<ski> functions are values, too
<ski> (function types are first class types)

Reader (\x->x) :: Reader r r
Reader (\x->1) :: Reader r Int

there's only unary function in haskell, not such thing like a function without any parameter in haskell

<jusss> >>=:: Reader (e->a) -> ( (e->a) -> Reader (e->b) ) -> Reader (e->b) ,
        right?
<jusss> and Reader is monad, and a is e->a, b is e->b
no
<jusss>  >>=:: Reader r a -> (a -> Reader r b) -> Reader r b, right?
<lambdabot>  the signature ought to be
`(>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b'
, which, yes, would amounts to
`(>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)'
, if you unwrapped the `Reader'
################################################

#record syntax

data Writer w a = Writer { runWriter :: (a, w) }
it means
data Writer w a = Writer (a, w)
Writer :: (a,w) -> Writer w a
runWriter :: Writer w a -> (a, w)
runWriter (Writer x) = x

and x in here is a tuple
Value "Writer (True, "abc")" has type "Writer String Bool"

Writer ("3", 3) :: Writer Int String

#####################################################

<eiGHttt> Reader
<jusss`>                                                  [14:52]
<eiGHttt> jusss`: ABBAB
          A                                                     [15:01]
<eiGHttt> B
<eiGHttt> log = msg => console.log(msg)
          loglog = (logger, msg)
          => logger.log(msg)                                          [15:02]
<jusss`> logger                                 [15:03]
<eiGHttt>                                                       [15:04]
<jusss`> eiGHttt reader monad
<eiGHttt> logconsole.log
<eiGHttt> log = Reader Logger ()                                        [15:05]
<eiGHttt> logger <- ask; log logger $ something
<jusss`> gg                                                             [15:06]
<jusss`>  >>= :: (e->a) -> (a->e->b) -> (e->b)              [15:07]
<eiGHttt> Logger
<eiGHttt> (e -> a)(e -> b)bindee
          bind                                      [15:08]
<jusss`> yeah                                                           [15:09]
<jusss`> and?
<eiGHttt> Reader
<eiGHttt> Reader                  [15:10]
<jusss`> Reader::?
<eiGHttt>                                       [15:11]
<eiGHttt> https://github.com/kalxd/Aono/blob/master/src/XG/Route.hs#L71 
                                            [15:13]

<jusss`> eiGHttt Monad[1,2,3] 
         [],  (e->a)e->                     [16:57]
<eiGHttt>                                             [16:58]
<jusss`> eiGHttt                                  [17:14]
<eiGHttt> .jpg                                        [17:15]
<quininer[m]> eiGHttt:                                      [17:16]
<eiGHttt>                                                   [17:17]
<jusss`> eiGHttt >>=::(e->a) -> (a->e->b) ->(e->b) >>=e->a
         e->b,                  [17:19]
<quininer[m]> eiGHttt:                      [17:20]
<eiGHttt> jusss`:                                             [17:21]
##########################################################

record syntax
    data Person = Person String String Int Float String String deriving (Show)
    firstName :: Person -> String  
    firstName (Person firstname _ _ _ _ _) = firstname
    ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"  
    ghci> firstName guy  
    "Buddy"
        data Person = Person { firstName :: String  
                         , lastName :: String  
                         , age :: Int  
                         , height :: Float  
                         , phoneNumber :: String  
                         , flavor :: String  
                         } deriving (Show)

it means firstName Person will get a String that in the Person data type

data Any = Any { getAny :: Bool }
this is data Any = Any Bool
and    getAny:: Any -> Bool

newtype Pair b a = Pair { getPair :: (a, b) }

  

#######################################################

<jusss> eiGHttt (>>=) (Just 3) f?
<jusss> >>= (Just 3) f                                  [14:04]
<jusss> (>>=) (Just 3) :: Num a => (a -> Maybe b) -> Maybe b
<jusss> eiGHttt LdBeth  monoidmonadhaskell
        monoidmonad
<LdBeth> jusss: 
<LdBeth>  Applicative  Functor  Monoid            [14:18]
<eiGHttt> MonadApplicativef (a -> b)(a -> f b)
<LdBeth> jusss: Applicative is monoidal functor
<LdBeth>  ADT  Maybe
<eiGHttt> https://github.com/fantasyland/fantasy-land
<eiGHttt> 
<LdBeth> jusss: Monad  ADT  Maybe             [14:27]
<LdBeth>  type class 
<LdBeth>  monad                                               [14:37]
<LdBeth> *
<LdBeth> 
<LdBeth>                 
#######################################

<jusss> dminuoso: how to solve that problem cause by threads changing one
        global vairbale?
<dminuoso> jusss: Its very situational really. Perhaps the architecture can be
           redesigned to not rely on shared global state
<jusss> dminuoso: I heard that stuff call STM Act-Model Async what ever
<dminuoso> jusss: Right, STM is a great toolbox that we use.            [16:24]
<Solonarv> jusss: yes, usually if we want to mutate shared state from multipe
           threads we create an MVar, TVar, or similar and pass that to the
           various threads that need to modify it
<dminuoso> Or, alternatively to what Solonarv said, it can be beneficial to
           rely on message passing styles rather.
<dminuoso> Shared global state can be extremely difficult to reason about
<dminuoso> And depending on the performance characteristics it can scale very
           poorly           

#########################################
<LdBeth> 
<jusss> LdBeth: id :: a->a,    (a->b)->a -> bid?
<LdBeth> 
def f(a):
    if isinstance(a,int):
       return a+1
    if isinstance(a,str):
       return a+"1"

<LdBeth> jusss: Monad  ADT  Maybe             [14:27]
<LdBeth>
         https://common-lisp.net/project/cl-monad-macros/monad-macros.htm#_Toc251846352
<LdBeth>                                                    [14:55]
<LdBeth> 
<LdBeth>  Typeclass
<LdBeth>                                              [14:56]
<LdBeth>                                        [14:57]
<jusss> Functortypeclass?
<LdBeth>                              [14:58]
<eiGHttt> :i Functor
<LdBeth> jusss: 
<LdBeth> 
<LdBeth> Haskell 2010 report  [] IO Maybe Functor (Array i)     [15:00]
<LdBeth>                            [15:01]         
###############################################################

<jusss> now I have five terms I don't understand, they're Group, Semigroup,
        Monoid, Endofunctor, Monad                                      [10:33]
<geekosaur> semigroup: a type and an operation which combines two values with
            that type to produce another value with that type
<jusss> and monoid?
<geekosaur> monoid: a semigroup with an identity value, such that you can get
            the same value out that you put in by applying the operation to it
            and the identity value
<jusss> then monad?                                                     [10:35]
<geekosaur> a type which has an operation to lift any arbitrary value into the
            type, and an operation to apply / "execute" some kind of action on
            a value of that type                                        [10:36]
<geekosaur> endofunctor we don't use much in Haskell, because all Functors are
            endofunctors.
#########################################################
<jusss> about this <>, what it's used for                               [09:47]
<jusss> or how it get a -> m b
<JappleAck> jusss: in which cases it gets a -> m b?                     [09:53]
<jusss> JappleAck: >>=                                                  [09:54]
<JappleAck> jusss: it's from Semigroup or Monoid, usually for concatenation
<JappleAck> > "foo" <> "bar"
<lambdabot>  "foobar"
<JappleAck> while ++ is only works with lists <> works with everything which
            implements Semigroup/Monoid
<JappleAck> also with wrapped Monoids/Semigroups:                       [09:58]
<JappleAck> > Just "foo" <> Just "bar"
<lambdabot>  Just "foobar"
<JappleAck> jusss: could you show some example of "how it get a -> m b"?
                                                                        [09:59]
* geekosaur guesses they've been confused by that CT joke
<geekosaur> which isn't talking about this Monoid
<jusss> what is a endofunctor?
<geekosaur> a functor whose domain and range are the same type
<geekosaur> er.
<geekosaur> actually, if this is a continuation of yesterday's confusion, you
            may be talking about CT endofunctors and they have to be in the
            same category                                               [10:31]
<geekosaur> lots of terminology means different things in different contexts,
            sadly. All Haskell Functor-s are endofunctors in this sense, since
            they necessarily apply to Haskell types, which form a category
<jusss> now I have five terms I don't understand, they're Group, Semigroup,
        Monoid, Endofunctor, Monad                                      [10:33]
<geekosaur> semigroup: a type and an operation which combines two values with
            that type to produce another value with that type
<jusss> and monoid?
<geekosaur> monoid: a semigroup with an identity value, such that you can get
            the same value out that you put in by applying the operation to it
            and the identity value
<jusss> then monad?                                                     [10:35]

<geekosaur> a type which has an operation to lift any arbitrary value into the
            type, and an operation to apply / "execute" some kind of action on
            a value of that type                                        [10:36]

<geekosaur> endofunctor we don't use much in Haskell, because all Functors are
            endofunctors.
<jusss> geekosaur: semigroup is an operation combines two values and produce
        another value, they all are the same type?                      [10:37]
<geekosaur> and there's no useful way to have a non-endofunctor, since Haskell
            can only talk about Haskell types

<jusss> geekosaur: or use type to produce value?

<geekosaur> all of the same type
<geekosaur> (+) and (*) are semigroup operators on numbers. (++) is a
            semigroup operator on lists                                 [10:38]
<geekosaur> all three also happen to be monoid operators, each with its own
            identity: 0, 1, "" respectively
<jusss> geekosaur: and (+1) is not a semigroup, right?
<geekosaur> it doesn't combine two arbitrary values, so it's not. but you're
            getting a little fuzzy here.                                [10:39]
<geekosaur> strictly we have a semigroup (Integer, (+)) and a monoid (Integer,
            (+), 0)                                                     [10:40]
<geekosaur> and similar semigroups and monoids for other numeric types
<geekosaur> however note that we don't actally define those, because of a
            limitation of Haskell: you can only have one instance of a
            typeclass instance per type                                 [10:41]
<geekosaur> so we can't directly say both (+) and (*) are monoids in Haskell
<geekosaur> we use newtypes instead: Sum has the (Integer, (+)) Semigroup
            instance and Product has the (Integer, (*)) Semigroup instance,
            and likewise Monoid instances with their identity elements

<geekosaur> sometimes we can point to one semigroup / monoid which is more
            important than the others, so while we use those newtypes for
            Integer, lists have only the semigroup and monoid for (++).
                                                                        [10:45]
<bzm3r> so the signature of `*` makes sense from an S combinator point of
        view, and i am trying to write an implementation for `*`.  recall the
        signature `* :: (r -> (s -> t)) -> (r -> s) -> (r -> t)` and note that
        Sxyz = xyzy; already, we are at an impasse, non? "S" doesn't really
        have a signature that makes sense?
<jusss> geekosaur: if an operation apply on two values and produce one value,
        and they're all of the same type, this operation is an semigroup?  and
        if an operation with an identity value apply on another value and
        return the same input value, and they're all of the same type, this
        operation is an monoid?
<bzm3r> monoid = semigroup + identity element                           [10:46]
<geekosaur> jusss, a monoid is a semigroup *plus* an identity
<geekosaur> whoops
<jusss> (+) and (*) are semigroup, and (+ 0 ) and (* 1 ) are monoid?
<geekosaur> no
<bzm3r> yes
<bzm3r> oh
<bzm3r> sorry
<bzm3r> my mistake
<bzm3r> i'll let geekosaur answer                                       [10:47]
<geekosaur> well, depending on what you mean by that notation
<geekosaur> a semigroup is a type and an operation. a monoid is a semigroup
            with an additional identity element

<geekosaur> so (Integer, (+)) is a semigroup and (Integer, (+), 0) is the
            corresponding monoid
<jusss> geekosaur: (+ 0 ) is \x -> x + 0                                [10:48]
<metreo> I'm getting a nasty warning when I try to downgrade `base` and it
         doesn't seem possible. Is this the case
<geekosaur> then no, that's not what that means
<geekosaur> metreo, base is wired into the compiler, you "downgrade" it by
            installing an older version of ghc

<metreo> Thanks                                                         [10:49]

<bzm3r> geekosaur is it okay to re-paste a question i asked earlier, but
        scrolled up?
<jusss> geekosaur: that semigroup part is right?
<geekosaur> it might be more correct to say the monoid is ((Integer, (+)), 0)
            to show that it's based on the semigrou
<geekosaur> bzm3r, I saw the question but got sidetracked.              [10:50]
<bzm3r> (no problem, that's what i thought, not sure if it would be more
        convenient for me to paste it again)
<geekosaur> I think the difference between lambda calculus notation and
            Haskell type notation is confusing you                      [10:51]

<jusss> geekosaur: a monoid is an operation with a value A , then give it a
        value B , and it produces the same value B, right?
<bzm3r> yeah, i think i see what you mean: "S is a substitution operator. It
        takes three arguments and then returns the first argument applied to
        the third, which is then applied to the result of the second argument
        applied to the third."

<geekosaur> and similarly values. xyzy would in Haskell be x y (z y)
<geekosaur> jusss, it's still a semigroup                               [10:52]
<geekosaur> you have to be able to do the semigroup thing. the difference is
            that there is a special value you can use to make it a no-op: an
            identity
<jusss> geekosaur: no-op is short for?
<geekosaur> no-operation (does nothing)                                 [10:53]
<geekosaur> so we have (+) as a semigroup operator, but we can make it do
            nothing by using 0 as one of its arguments
<geekosaur> thus does not mean (+0) is a monoid, it means (+) is a monoid
            where 0 can be used to make it do nothing
<geekosaur> monoid operation
<jusss> geekosaur: when one value is 0, (+) is a monoid operator, right?
                                                                        [10:54]
<geekosaur> "a monoid is a semigroup that lets us get back out what we put in"
<jusss> geekosaur: and (+ is a semigroup

<bzm3r> geekosaur may i try explaining it to jusss in "my way"?         [10:55]
<geekosaur> (+) is still a monoid even if we don't happen to apply it to the
            identity
<bzm3r> i think i see what is confusing him
<geekosaur> sure
<geekosaur> the fact that there is an identity is what matters, not that we
            specifically used it
<geekosaur> (String,(\x y -> x ++ "," ++ y)) is a semigroup, but not a monoid
            because there's no way to stop it from adding that ","      [10:56]

<geekosaur> (String, (++)) is a semigroup, and is a monoid with identity ""
            because if we pass "" as one of the parameters we get the other
            parameter back                                              [10:57]
<bzm3r> jusss imagine you have a type `a`, and an operator `*`, such that `*
        :: a -> a -> a` and if `x` and `y` are of type `a`, then `* x (* y z)
        = * x y z`; then `* ` is a semigroup
<bzm3r> sorry, `(*, a)` is a semigroup
<bzm3r> now imagine that we had a type `b` and an operator `^`, such that `(^,
        b)` is a semigroup                                              [10:58]
<jusss> wait a sec, this (*,a) for mean?
<jusss> this form (String, (++)) mean?
<bzm3r> um, maybe i should just write (`a`, `*`)

<bzm3r> like, i am just saying, `*: a -> a -> a` is a semigroup (no need to
        list the type, because the type is specified in the signature)
<geekosaur> they're using a different notation from the one I was; I stuck
            closer to Haskell

<bzm3r> yeah, that's probably it
<geekosaur> but it's not the same notation used in mathematics          [11:00]

<bzm3r> right, ok, nvm
<bzm3r> i don't know how to write it in the haskell way
<jusss> what this notation ('a','*') mean?
<metreo> How "fixable/updatable" is a dependency for an older version of
         `base` likely to be? 
<geekosaur> in mathy notation, * is often used to mean some unspecified
            operator and a is a variable representing some type. 
<jusss> "" ++ "a"   get "a"
<jusss> ++ is a monoid?                                                 [11:03]
<bzm3r> jusss (ignore everything i said)
<bzm3r> (will help you more)
<geekosaur> jusss, yes (++) is a monoid on strings because it is a semigroup
            on lists and you can use "" to make it do nothing           [11:04]
<jusss> bzm3r: sorry about your notation I don't understand
<bzm3r> its totally okay! my bad for introducing more notation which only made
        things confusing
<[Leary]> A semigroup is an algebraic structure formed by a set or type S, and
          a binary operation * on elements of S satisfying certain properties
          (namely that for all x, y any z we have x * (y * z) = (x * y) *
          z). (S, *) and (*, S) are just ways to specify both the set/type and
          operation at the same time, since the operations and sets/types are
          not uniquely determined by one another.
<jusss> geekosaur: and now what about monad?                            [11:06]
<jusss> "a" ++ "b" get "ab"   (++)is a semigroup,    "" ++ "a" get "a" , (++)
        is a monoid                                                     [11:08]
<jusss> "A monad is just a monoid in the category of endofunctors"      [11:09]

<[Leary]> You can forget you ever read/heard that line, it won't help you.
                                                                        [11:10]
<Axman6> I wouldn't say (++) is a semigroupo, I would say [] is a semigroup
         with (++) being the binary associative operation

<Axman6> (well, [a] is a semigroup I guess)
<geekosaur> jusss, that line is a statement in category theory. it's not
            helpful or even meaningful in Haskell                       [11:13]
<geekosaur> it's not talking about Haskell's Monoid, in particular, and all
            Haskell Functors are necessarily endofunctors
<jusss> geekosaur: ok, forget that, what's the relationship with monad, monoid
                                                                        [11:14]
<geekosaur> and this 9is what I was trying to tell you yesterday when I
            recognized your questions wre coming from that
<geekosaur> haskell does not relate them
<geekosaur> the relationship is at a level haskell can't talk about
<jusss> er...                                                           [11:15]
<geekosaur> it;s a category theory joke, not a statement about haskell
<jusss> geekosaur: and what is a Monad in haskell?
<c_wraith> One specific way of expressing the CT idea in code           [11:16]
<geekosaur> [09 02:36:22] <geekosaur> a type which has an operation to lift
            any arbitrary value into the type, and an operation to apply /
            "execute" some kind of action on a value of that type
<geekosaur> (note how much this does *not* look like that "monoid in the
            category" statement. this should tell you smething)         [11:18]
<Axman6> metreo: usually it's not a big problem
<c_wraith> If you squint hard enough, return+join looks like a monoid
<metreo> Axman6: Is there documentation on the process involved? Or just
         Google it?                                                     [11:19]
<jusss> geekosaur: "a type which has an operation to lift  any arbitrary value
        into the type" this operation, what it's?                       [11:20]
<geekosaur> the release notes for every new ghc release point to an updates
            page that usually provides tips on what needs to be changed
<Axman6> metreo: have you run into something breaking by changing the version?
<c_wraith> jusss: return
<metreo> Ok I'll refer to the release notes! 
<geekosaur> return, or pure                                             [11:21]
<jusss> c_wraith: geekosaur and unit?
<metreo> Axman6: I simply have a package requesting base <4.10
<geekosaur> a more mathematical name for it, that haskell doesn't use
<metreo> The package is quipper
<Axman6> @hackage quipper                                               [11:22]
<lambdabot> http://hackage.haskell.org/package/quipper
<metreo> Yes, thanks!
<metreo> I didn't know about that @
<jusss> geekosaur: c_wraith so monad has nothing to do with monoid and
        semigroup?
<jusss> in haskell
<Axman6> I'm sure that if you just force a newer base, it will just work
         perfectly fine... ine some universe =)
<geekosaur> not in Haskell
<c_wraith> not in code
<Axman6> metreo: would also be worth sending a PR if you can make it work with
         newer bases                                                    [11:23]
<Axman6> Of course Monads in Haskell are Monoids, we have (>>) and fail "oops"
         :p
<metreo> Yes I will do so. Just was interested if the idea of attempting such
         an update as a user is sane. 
<geekosaur> metreo,
            https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history
            might be useful
<metreo> Thank you.                                                     [11:25]
<geekosaur> it's generally sane. it can't always be automated, and
            occasionally you also run into e.g. that version has a bug and
            nobody checked to see if a later version fixed it
<jusss> I'm confused, (+) is a semigroup, because those two input values and
        one output value are the same type,  ((+),0) is a monoid, because the
        input one value and one output value are same, and those three values
        are same type, now (+) connect to monad?
<geekosaur> they don't connect
<jusss> the unit/return/pure, that  (a-> m a), 
<geekosaur> Monad is a different kind of thing, literally
<jusss> but all the books that tell monoid first before monad
<geekosaur> becuase it's a simpler concept                              [11:27]
<c_wraith> jusss: Monads are one *very specific kind of monoid that has
           nothing to do with Haskell's Monoid class*. 
<metreo> geekosaur: Ok in that case I'll venture forward and look to have a PR
         in when I'm done. Thanks again all you lovely people.
<jusss> and trying to do some connect
<geekosaur> npt because they're dependent
<Axman6> jusss: that's likely to get you use to thinking about things
         abstractly
<Axman6> used*
<c_wraith> jusss: the CT concepts are far more general than the classes named
           after them.                                                  [11:28]
<jusss> c_wraith: wait a sec, you mean monoid in haskell is not with monoid in
        math?
<c_wraith> jusss: Haskell's Monoid class is one *very narrow* form of CT
           monoid
<jusss> c_wraith: CT is short for?
<geekosaur> monoid in haskell is a simpler version of monoid in math
<jusss> Category theory?
<c_wraith> yes
<geekosaur> monad in haskell is a simpler thing than monad in math / category
            theory                                                      [11:29]
<geekosaur> programming languages have trouble being as general as math
            usually is
<geekosaur> in particular, math doesn't consider Integer and Double to be
            different "types", they're overlapping sets. but in Haskell they
            do not overlap                                              [11:30]
<jusss> geekosaur: then I think why haskell don't give it another name
<geekosaur> beause then everything has to have a new name different from the
            conventional one because it's not 100% identical to the
            conventional one
<geekosaur> it;s not a monoid it's a notquitemathmonoid, it's not a number
            it's a notquitemathnumber, it's not...
<jusss> geekosaur: I wonder the type in haskell or computer science, is the
        same stuff in Curry Haskell's theory?                           [11:31]
<geekosaur> you mean the curry-howard isomorphism? it's talking about types in
            general. haskell's types, ocaml                             [11:32]
<geekosaur> s types, C's types ...
<geekosaur> do all those languages now have to rename"type" because they're
            not all as general as that?                                 [11:33]
<geekosaur> (you can't win this one. come up with a way to be that general and
            some mathematician will find a way to generalize what you created)
<geekosaur> that's sort of where category theory came from              [11:34]
<jusss> ok
<jusss> I think maybe we can forget that math, let's focus on haskell
<geekosaur> the mth will only give you a headache, yes
<geekosaur> there are things to learn there, but a deep dive into number
            theory is not the way to learn about Haskell's Semigroup and
            Monoid and a deep dive into category theory is not the way to
            learn about Haskell's Monad
<jusss> the monad, I was confused, the return, is something with semigroup
<geekosaur> you can look into them later to understand why the Haksell ones
            work the way they do
<geekosaur> if you ever care; there's little reason to, usually         [11:38]
<jusss> and it seems return have nothing to do with semigroup
<geekosaur> right, they're not related. I didn't need something liek "return"
            to use a number with (+), it already works. I need to use return
            to lift a value into a monad                                [11:39]
<geekosaur> something like Integer can be a Semigroup or Monoid.
<geekosaur> something like "list of..." or "Maybe ..." or "IO ..." can be a
            Monad                                                       [11:40]
<jusss> geekosaur: wait a sec, the operation is a Semigroup or Monoid, or the
        value is a Semigroup or Monoid?
<jusss> "<geekosaur> something like Integer can be a Semigroup or Monoid." for
        you word, Integer is a value not a operation I think
<geekosaur> as I said earlier, the actual Semigroup is a combination of a type
            and an operation. only in Haskell we say it's just the type, which
            is why we need a hack to have Semigroup and Monoid instances for
            (+) and (*)                                                 [11:41]
<jusss> or you say the operation with a type is a semigroup or monoid
<geekosaur> so in terms of Haskell we say the type is a Semigroup
<geekosaur> because Haskell can't speak in terms of a combination of a type
            and an operator; we can have only one instance of Semigroup or
            Monoid or ... for a type                                    [11:42]
<geekosaur> in math it goes the other way, we speak of the operation because
            math doesn't have types in that sense, it has sets          [11:43]
<jusss> geekosaur: ((+),0) is a semigroup in math, and Integer is a semigroup
        in haskell?
<geekosaur> (as we usually formulate it)
<geekosaur> neither of those is true
<jusss> geekosaur: (+) is a semigroup in math?                          [11:44]
<geekosaur> in math, (Integer, (+)) is a Semigroup. in Haskell, we can't say
            which of (+) or (*) is the "more improtant" semigroup, so Integer
            has neither
<geekosaur> we have instead a newtype wrapper Sum which has the Semigroup and
            Monoid instances for (+), and a newtype wrapper Product which has
            the Semigroup and Monoid instances for (*)                  [11:45]
<geekosaur> (both of those are somewhat inaccurate also, but closer)
<geekosaur> (but to be more specific about either gets confusing quickly. math
            has a more general notion of "number" than you think)       [11:47]
<jusss> ok, I wonder this return lift value into something, and that something
        how we can define?
<jusss> monad
<jusss> return 3 will get 3                                             [11:49]
<jusss> not Just 3 or [3]
<geekosaur> you cannot.
<geekosaur> tjhe closest you get is Identity 3                          [11:50]
<jusss> (>>=) :: Monad m => m a -> (a -> m b) -> m b                    [11:51]
<geekosaur> yes. the "m" is always there
<jusss> this (a->m b) is return function, right?
<geekosaur> no
<geekosaur> it's an action.
<geekosaur> return :: a -> m a
<jusss> still confused,                                                 [11:52]
<[Leary]> You could give it return, it just wouldn't do anything.
<[Leary]> > [0,1] >>= return
<lambdabot>  [0,1]
<[Leary]> > [0,1] >>= \x -> [x, -x]
<lambdabot>  [0,0,1,-1]
<geekosaur> note that return is a -> m a, not a -> m b. it's a simple example
            of *an* action
<jusss> >>= need one argument or two?                                   [11:54]
<geekosaur> but as an action it doesn't do anything
<geekosaur> two
<jusss> >>= [0,1] a-function?
<geekosaur> you saw [Leary]                                             [11:55]
<geekosaur> ;s examples?
<jusss> (>>=) [0] \x->x
<[Leary]> `[0,1] >>= f` won't type check unless `(>>=) [0,1]` is a function.
<jusss> wait a sec, (>>= return) is the second argument in >> [0,1] ?   [11:57]
<jusss> >> [0,1] (>>= return) ?
<jusss> oh, there's no = in >>[0,1], it's not a functionn               [11:59]
<jusss> I thought [Leary] use the prefix notation                       [12:00]
<jusss> (>>=) [0] return
<jusss> that m in return which comes from (m a) ?
<geekosaur> the m in this example is []
<geekosaur> you can write the type [Int] as ([] Int)
<geekosaur> :t [0] :: [] Int
<lambdabot> [Int]
<jusss> and what this >>= is used for?
<jusss> if the middle part function is return
<geekosaur> it *can be* return. it does not have to be                  [12:11]
<jusss> for other function like?
<geekosaur> you dont often see it used explicitly because of do notation.
<jusss> if we do curry on >>=
<geekosaur> the function is an action of some kind. return is a do-nothing
            action (sort of like an identity, but "one level up" from the
            identity of monoids)                                        [12:12]
<jusss> and >>= :: m a -> ( (a->m b) -> m b)
<jusss> (>>=) [0] will get ?
<geekosaur> putStrLn is another action, a -> m b where a is String, m is IO,
            and b is ()
<geekosaur>
            http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
<jusss> why (>>=) [0] will get error? why not a curried form?
<geekosaur> :t (>>=) [0]
<lambdabot> Num a => (a -> [b]) -> [b]
<geekosaur> tbh I'm not quite sure what [Leary] meant by that comment, you
            presented a prefix partial application that looked valid to me
<jusss> the action and the notation , what's the related
<geekosaur> nless they meant you had left off the function/action       [12:15]
<geekosaur> and I'm not quite sure what you're asking
<jusss> return :: a -> m a, and  a -> m b in >>=
<jusss> and return can be used in >>=
<geekosaur> the notion of "action" depends on the type. in IO, an action is
            generally some I/O operation. for the list monad, it means
            applying it to every element of the list to produce a new list,
            which gives you a "nondeterminacy" (all possible results,
            hypothetically "in parallel")                               [12:16]
<geekosaur> but if you read the page I linked earlier, there are lots of
            different concepts of "action"                              [12:17]
<jusss> ok


###########################################################
<jusss> dminuoso: oh, I think I understand what you mean, fmap turn (a->b)
        into (e->a) -> (e->b)
<jusss> now we can say fmap transform (a->b) to ( (e->a) -> (e->b) ), so I
        wonder how to express about <*> and >>=                         [16:11]
<dminuoso> jusss: Applicative too transforms functions.
<jusss> in functor, a->b,  in applicative, a or a->b or a->b->c
<dminuoso> Except Functor limits you to functions taking one argument.
<dminuoso> Applicative lets you do this with functions taking *any* number of
           arguments
<jusss> dminuoso: but <*> :: f (a->b) -> f a -> fb,  <*> transform that
        function in Applicative to another function(f a -> f b) right?
<dminuoso> jusss: Right. So the diagram I showed you is basically what you can
           do with pure and (<*>)

<dminuoso> mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b)       [16:55]
<jusss> Prelude> mango f g x = (f x) (g x)                              [17:14]
<jusss> mango :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
<dminuoso> jusss: Looks great.

<jusss> dminuoso: yeah, functor and applicative both need a type to complete
        themself?
<dminuoso> jusss: Exactly. They work on types missing one type argument.
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
<jusss> dminuoso: that (->) e can be monad?
<dminuoso> jusss: Yes. You just wrote the (>>=) implementation for it.  [18:04]
<dminuoso> (>>=) is your cocoa
<dminuoso> (<*>) is your mango
<jusss> dminuoso: what?
<dminuoso> and pure/return is your coconut
<dminuoso> And banana is fmap                                           [18:05]
<jusss> dminuoso: cocoa and >>=
<dminuoso> jusss: cocoa = flip (>>=)
<jusss> dminuoso: about the a-> m b, I don't understand what it's used for
                                                                        [18:09]
<jusss> it's not like functor and applicative
<jusss> this a->m b
<dminuoso> jusss: Yeah its not.
<jusss> dminuoso: and what it is
<dminuoso> jusss: Well what is (<>)
<dminuoso> jusss: Its not for anything.
<Bish> dminuoso: o/
<jusss> <>:: s->s->s?                                                   [18:10]
<arianvp> % :t  (>>=) @((->) r)
<yahb> arianvp: ; <interactive>:1:14: error: Not in scope: type variable `r'
<dminuoso> Right
<arianvp> :/
<dminuoso> jusss: It exists because many things happen to have this shape, for
           some reason.
<Taneb> % :t (>>=) @((->) _)
<yahb> Taneb: (w -> a) -> (a -> w -> b) -> w -> b
<arianvp> Taneb: thanks
<arianvp> % :t (=<<) @((->) _)
<yahb> arianvp: (a -> w -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: It doesnt have any intrinstic meaning.
<Bish> there is a flipped version of bind, but not a prefix bind?
<dminuoso> Bish: You can put (>>=) in parens                            [18:11]
<dminuoso> And then use it in prefix notation.
<Bish> yeah great :D i am just sometimes confused about the logic
<Bish> people would flip it, but never use it prefix
<jusss> dminuoso: use <> to shape for what
<dminuoso> jusss: I wouldnt focus on Monad really, ask what the ((->) e)
           instance does                                                [18:12]
##############################################

#type inference

deduce a function definition from its type signature, and this one function is just an instance of its type signature, this type can have different function definition,
id :: a->a
id :: (a->b) -> a -> b
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> dminuoso: cocoa f g x = f (g x) x
let's assume
f::a->Int->b
g::Int->a
x::Int
cocoa f g x = b
f a:: Int->b
f a x :: b
g Int :: a
g x :: a
f (g x) x :: b
cocoa f g x = f (g x) x
######################################################

Functor can do:


  a -> b
    |
    |
    v
f a -> f b

Applicative can do:

 a        a -> b          a -> b -> c             a -> b -> c -> d                .... and so on ....
 |          |                  |                          |
 |          |                  |                          |
 v          v                  v                          v
f a f a -> f b f a -> f b -> f c f a -> f b -> f c -> f d .... and so on ....

and when Functor and Applicative are e->
<jusss> dminuoso: if f is (e->),   so <*> :: (e->) (a->b) -> (e->a) -> (e->b)
######################################################

fmap  ::   (a -> b) -> f a -> f b
(<*>) :: f (a -> b) -> f a -> f b
(=<<) :: (a -> f b) -> f a -> f b


####################################################

<jusss> dminuoso: then fmap id = id, this id shoud change its name like id2 or
        idf
<jusss> 'cause that new id :: f b -> f b, not id :: a -> a,   the new id is a
        subset of the old id
##################################
<jusss> is there something it's a Functor but not a Monad?              [14:48]
<dminuoso> jusss: Yes.                                                  [14:49]
<dminuoso> jusss: In fact there's many things that are Functor but not Monad.
<Rembane> Are functions Functor but not Monad?
<jusss> dminuoso: for example?
<dminuoso> jusss: `Const a` is an example from base
<dminuoso> jusss: ZipList is another
<jusss> (>>=) :: m a -> (a -> m b) -> m b
<jusss> dminuoso: those 'm' should be same type?
<dminuoso> jusss: Yes, this fact is denoted by them all having the same name.
                                                                        [14:53]
<dminuoso> jusss: If they differ they *can* be the same though, but they can
           also differ.
<dminuoso> That is, (>>=) does not demand that `a` and `b` be different, but
           they can be.
<jusss> dminuoso: like List and Maybe both are Monads,  can I give a List
        Monad to >>= and get a Maybe Monad?                             [14:54]
<dminuoso> jusss: No
<dminuoso> jusss: So the way you use >>= is the following
<dminuoso> Pick a type for `m` and replace `m` with that type in the entire
           signature                                                    [14:55]
<dminuoso> (The type must have a valid instance Monad of course)
<dminuoso> So if we fix m ~ Maybe, then (>>=) :: Maybe a -> (a -> Maybe b) ->
           Maybe b
<dminuoso> And equivalently if we fix a ~ Int, then (>>=) :: Maybe Int -> (Int
           -> Maybe b) -> Maybe b
<jusss>  (<*>) :: f (a -> b) -> f a -> f b                              [14:56]
<dminuoso> And if we fix b ~ Char, then you'd get: (>>=) :: Maybe Int -> (Int
           -> Maybe Char) -> Maybe Char
<jusss> it seems that Applicative do same thing like that
<dminuoso> jusss: Its similar, but different.
<jusss> <*> apply a function on f a and get  f b                        [14:57]
<jusss> >>= apply a->m b on m a and get m b                             [14:58]
<jusss> what's the different
<dminuoso> jusss:
           https://gist.github.com/dminuoso/1b7925f8a04f9740757d79266d724792
<dminuoso> Here (=<<) is just the flipped version of (>>=)
<dminuoso> (I did a bit of pseudo code, leaving away the constraints)
<jusss> dminuoso: those type signatures, it's interesting
<dminuoso> jusss: In some sense (<*>) can be thought of generalizing fmap to
           functions with arbitrary arguments.
<jusss> dminuoso: fmap :: (a -> b) -> f a -> f b,  can I say fmap apply (a->b)
        on a in f a and get f (a->b) , it's f b                         [15:01]
<jusss> dminuoso: or I should say apply (a->b) on f a?
<dminuoso> jusss: That is, fmap lets you lift a 1-arity function `a -> b` to
           `f a -> f b`, but with pure/(<*>) you can lift `a` to `f a` and `a
           -> b -> c` to `f a -> f b -> f c`
<dminuoso> Or `a -> b -> c -> d` to `f a -> f b -> f c -> f d`
<dminuoso> jusss: It's rather: `a -> b` is lifted to `f a -> f b`
<dminuoso> fmap is a way to take a function `Int -> Char` and build a `Maybe
           Int -> Maybe Char` from it.
<dminuoso> Or lift a `Char -> Bool` into `[Char] -> [Bool]`
<dminuoso> Applicative generalizes this to values and functions of arbitrary
           length
<jusss> dminuoso: about the type inference, how I should understand about that
        fmap apply (a->b) on (f a) or a in (f a) ?
<dminuoso> jusss: Neither. Type inference is just the act of figuring out what
           parts of your program have what type, without needing type
           annotations.
<dminuoso> % :t fmap
<yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
<dminuoso> This is really:
<dminuoso> fmap :: Functor f => (a -> b) -> (f a -> f b)                [15:06]
<jusss> dminuoso: about this fmap :: (a -> b) -> f a -> f b,    is there a
        type like (a->b) -> f a -> a?
<dminuoso> If you squint for a moment you will see that fmap takes one
           argument and it returns a function.
<jusss> or (a->b) -> f a -> b
<dminuoso> jusss: Not that I know. There's other things though like `(f a ->
           b) -> f a -> f b`
<dminuoso> Where there is a special constraint on `f` too.              [15:08]
<jusss> dminuoso: ok, so the final type is what we write not we calculate
<dminuoso> jusss: What do you mean?
<jusss> dminuoso: I thought that we can calculate (f b) from (a->b) -> f a
                                                                        [15:09]
<dminuoso> I do not follow.
<jusss> dminuoso: if there's a type (a->b) -> f a,  and I thought we can get
        the final return type is f b through (a->b) -> f a -> f b       [15:10]
<jusss> it seems I was wrong
<dminuoso> jusss: Can you perhaps rephrase the question?                [15:11]
<dminuoso> Or explain in differnet terms?
<jusss> dminuoso: sorry for my English
<dminuoso> jusss: Are you asking whether the return type of `fmap` can be
           deduced from its arguments
<dminuoso> ?
<jusss> dminuoso: let's assume there's a type like T::(a->b) -> f a,   so we
        can get T :: f b
<jusss> dminuoso: yeah, that's what I mean
<dminuoso> jusss: Yes, that's what type inference gives us. It's a logic
           system, basically.
<dminuoso> jusss: For example: If we know a function has type `f :: Char ->
           Int`, and we know that `x :: Char`, then we can deduce that `f x ::
           Int`                                                         [15:13]
<jusss> dminuoso: so, look at this fmap :: (a->b) -> f a -> f b, so how should
        I think about fmap apply (a->b) on (f a) or just a in (f a) and we get
        (f b)?
<dminuoso> jusss: Neither, like I said.
<dminuoso> jusss: Think that fmap takes *one* argument.
<jusss> dminuoso: ok, no appy, it's just type inference , right?
<jusss> dminuoso: let's just focus on the type inference
<jusss> dminuoso: (a->b) -> f a, we can get f b, right?
<dminuoso> jusss: The language you are using does not make sense to me.
<dminuoso> By language I mean the way you are using what looks like type
           signatures.
<dminuoso> jusss: fmap is more than just type inference.                [15:17]
<dminuoso> jusss: You can use fmap without any type inference in fact.
<dminuoso> % listMap :: (a -> b) -> [a] -> [b]; listMap = fmap
<yahb> dminuoso: 
<dminuoso> % addOneToEachElem :: [Int] -> [Int]; addOneToEachElem = listMap
           (+1)
<yahb> dminuoso: 
<dminuoso> % addOneToEachElem [1,2,3,4]
<yahb> dminuoso: [2,3,4,5]
<jusss> dminuoso: (<*>) :: f (a -> b) -> f a -> f b,     I think  it's should
        be f (a->b) -> f a -> f (f b)
<dminuoso> jusss: Let's ignore (<*>) for a moment, okay?                [15:19]
<jusss> dminuoso: ok
<dminuoso> jusss: Do you see how `fmap` turns a function `Int -> Char` into
           say `[Int] -> [Char]`?
<dminuoso> `fmap` is a function transformer, if you want.
<dminuoso> It takes a function, and builds a new function (in some way that is
           related to the original function)                            [15:20]
<jusss> dminuoso: yeah, new function with the same input 
<dminuoso> Not the same input.
<jusss> same input type?                                                [15:21]
<dminuoso> Nope.
<dminuoso> jusss: Whats the input type of `f :: Int -> Char`
<jusss> dminuoso: Int                                                   [15:22]
<jusss> dminuoso: but your `fmap` turns a function `Int -> Char` into `[Int]
        -> [Char]`  is not a function, it's a list                      [15:23]
<dminuoso> jusss: Are you sure?
<dminuoso> `[Int] -> [Char]` is not a function? :-)
<jusss> dminuoso: [Char] is a function?
<dminuoso> jusss: No, but `[Int] -> [Char]` is.                         [15:24]
<jusss> dminuoso: oh, just fmap (a->b)
<jusss> (e->a) -> (e->b)
<jusss> dminuoso: yeah, that (e->a) -> (e->b) is a funtion, with a function
        input and with a function output
<jusss> the function's input type is (e->a)
<dminuoso> jusss:
           https://gist.github.com/dminuoso/787f98e07af511d3a17908a6c6ba043b
<dminuoso> jusss: fmap transforms a function, it doesnt apply to it.    [15:26]
<dminuoso> jusss: The thing that happens here is that functions are curried.
<dminuoso> `fmap (+1) [1,2,3]` is two applications, in a sense.
<jusss> dminuoso: but how to describe that fmap with (a->b)
<jusss> dminuoso: how fmap use (a->b) to transform (e->a) to (e->b)?    [15:28]
<dminuoso> jusss: That is specified in the instance declaration of the Functor
           instance for each respective type.
<dminuoso> For example: The way to lift `a -> b` into `Maybe a -> Maybe b` is
           defined in the instance Functor Maybe.
<jusss> dminuoso: the word to express the relation, "use" is proper?    [15:29]
<dminuoso> jusss: Honestly I do not know what you mean by `e -> a` and `e ->
           b`
<merijn> dminuoso: tbh, I've never found the "functions are curried" (or
         really any mention of currying/uncurrying) to be particularly helpful
         for confused people, because it's mostly orthogonal to the real
         problem people have (i.e. all functions only ever have one argument)
<jusss> obvious, "apply" is not proper                                  [15:30]
<dminuoso> jusss: Right. It uses it to create a new function rather.
<dminuoso> (Or in some special cases it may be disregarded)
<jusss> dminuoso: (e->a) is a function, (e->b) same too
<dminuoso> jusss: Ohh I think I just understood your question then.     [15:31]
<dminuoso> jusss: Take it as a challenge.
<dminuoso> jusss: Fix `e` to some type, because the choice does not matter.
                                                                        [15:32]
<dminuoso> jusss: So try to write a function: banana :: (a -> b) -> (Int -> a)
           -> (Int -> b)

<jusss> dminuoso: but Int is a specific type, it's ok to use  with that type
        variables?                                                      [15:34]
<dminuoso> jusss: Yes.
<dminuoso> jusss: The details of why this is okay are really not important.
<jusss> dminuoso: banana::(Int->Int) -> (Int->Int) -> (Int->Int)        [15:35]
<dminuoso> jusss: You may not change the other type variables.
<dminuoso> banana :: (a -> b) -> (Int -> a) -> (Int -> b)
<dminuoso> This is what you should implement.
<jusss> dminuoso: yeah, I just use Int as the instance of a, that's not ok?
<jusss> banana (+1) (+2)                                                [15:37]
<dminuoso> jusss: For using it, that's fine. But I want you to write the
           function `banana` yourself, and it should have the exact type
           signature I specified.
<jusss> banana x y z = x (y z)                                          [15:38]
<dminuoso> jusss: That looks good. Are you familiar with the (.) operator
           already?                                                     [15:39]
<jusss> banana x y = \x x( y x)
<jusss> banana  x y = \z x( y z)
<jusss> dminuoso: (.) is fmap when Functor is (e->)                     [15:40]
<dminuoso> jusss: Right.
<jusss> and map is fmap when Functor is List []
<dminuoso> jusss: Also right.
<jusss> and what's wrong?
<dminuoso> jusss: Nothing. :)
<jusss> dminuoso: I always think that there's a consume in that type    [15:41]
<jusss> so we can consume a 'a' in (a->b) -> f a, 
<jusss> consume a 'a' so we can get f b
<jusss> obvious, I was wrong
<jusss> I found that I really like those type variables, not specific type
                                                                        [15:42]
<dminuoso> jusss: Now do you see how `fmap` lets you transform functions of
           shape `a -> b` into `f a -> f b` for some choice of f?
<merijn> jusss: That'd be because you're slowly getting an intuition for free
         theorems ;)
<dminuoso> :)
<jusss> dminuoso: wait a sec, what fmap x = ?                           [15:46]
<dminuoso> jusss: Any, really.
<dminuoso> for [], fmap lets you turn `a -> b` into `[a] -> [b]`, for Maybe
           fmap lets you turn `a -> b` into `Maybe a -> Maybe b`, for IO fmap
           lets you turn `a -> b` into `IO a -> IO b`                   [15:47]
<dminuoso> And so forth
<dminuoso> jusss:
           https://gist.github.com/dminuoso/daedae39ed76577d81d1a5984bf45b5e
<dminuoso> So Applicative generalizes this pattern to not just work with `a ->
           b`, but also just `a` or `a -> b -> c`, or `a -> b -> c -> d`, or
           any such function                                            [15:48]
<jusss> dminuoso: oh, I think I understand what you mean, fmap turn (a->b)
        into (e->a) -> (e->b)
<dminuoso> jusss: Right.
<jusss> dminuoso: not fmap use (a->b) turn (e->a) to (e->b)?
<dminuoso> jusss: Well the function is usually used, somehow.           [15:49]
<dminuoso> But its not specified how its used, its different for each type.
<dminuoso> We just have 2 laws you need to satisfy.
<jusss> dminuoso: and what's it?
<dminuoso> jusss: Well it can be condensed into one law really:         [15:50]
<dminuoso> fmap id = id
<dminuoso> Which says if you use `fmap` to transform id, the resulting
           function must act as the identity function.
<jusss> and ?
<dminuoso> jusss: Forget the other law, I shouldnt have mentioned it. We have
           only one law.
<jusss> dminuoso: so fmap (\x->x) = \x -> x
<jusss> ?
<dminuoso> jusss: You cant actually write thta.                         [15:52]
<jusss> dminuoso: I wonder if I give a function to \x and I get a function?
<dminuoso> jusss: When I say `fmap id = id` its not meant as Haskell code, its
           a statement of a law.
<dminuoso> Basically:
<dminuoso> fmap id [1,2,3] *must* produce [1,2,3]
<dminuoso> `fmap id (Just 7)` *must* produce `Just 7`
<jusss> dminuoso: fmap id id?
<dminuoso> jusss: that gives you `id` back, trivially                   [15:54]
<dminuoso> id x = x
<dminuoso> If you take `fmap id = id`, then you can substitute in your code:
           id id, and the result of that is just id
<jusss> dminuoso: about fmap :: (a->b) -> ( (e->a) -> (e->b) ),  if id is
        (a->b) so fmap id = id, the id right after '=' is (e->a)->(e->b)
        right?                                                          [15:55]
<dminuoso> jusss: `fmap id = id` is not Haskell code.                   [15:56]
<jusss> dminuoso: what do you mean is not Haskell code?
<dminuoso> jusss: Perhaps its less confusing if I state it using words: if you
           fmap over something using id, it must give you that something back
           unchanged.
<dminuoso> that's the single law of functor
<dminuoso> % fmap id [1,2,3]                                            [15:57]
<yahb> dminuoso: ; <interactive>:55:1: error:; * Ambiguous type variables
       `f0', `b0' arising from a use of `print'; prevents the constraint
       `(Show (f0 b0))' from being solved.; Probable fix: use a type
       annotation to specify what `f0', `b0' should be.; These potential
       instances exist:; instance Show a => Show (ZipList a) -- Defined in
       `Control.Applicative'; instance Show a => Show (Co
<dminuoso> % fmap id "foobar"
<yahb> dminuoso: "foobar"
<dminuoso> % fmap id (Just 'c')
<yahb> dminuoso: Just 'c'
<dminuoso> % fmap id Nothing
<yahb> dminuoso: Nothing
<dminuoso> so `fmap id` is a no-op. It produces the id function.        [15:58]
<jusss> dminuoso: but that type in fmap, the produced id function's type is?
<merijn> :t fmap id
<lambdabot> Functor f => f b -> f b
<jusss> merijn: but the produced id can't be f b -> f b,    id :: a -> a
<dminuoso> jusss: Good catch.
<dminuoso> jusss: Turns out, that `id :: a -> a` is the most general type.
                                                                        [16:02]
<dminuoso> idInt :: Int -> Int; idInd x = x
<dminuoso> jusss: ^- would you agree that this, too, is an identity function?
<jusss> dminuoso: you want to express a can be f b?
<dminuoso> jusss: Exactly.                                              [16:03]
<merijn> :t id `asAppliedTo` Nothing
<lambdabot> Maybe a -> Maybe a
<merijn> :t id `asAppliedTo` 'c'
<lambdabot> Char -> Char
<dminuoso> % :t id
<yahb> dminuoso: a -> a
<dminuoso> jusss: There's a cool trick:                                 [16:04]
<delYsid`> merijn: Thanks for that storable vector hint, its working now.
<dminuoso> % (+1) `id` 5
<yahb> dminuoso: 6
<merijn> delYsid`: \o/
<jusss> dminuoso: wait a sec, % fmap id 3
<merijn> delYsid`: Now you too can program C in Haskell! ;)
<jusss> id 3 is 3, but fmap id 3 is wrong
<dminuoso> jusss: Right!
<dminuoso> jusss: Its a slightly more specialized id.                   [16:05]
<dminuoso> jusss: So when I say `fmap id = id` its not meant as "fmap id"
           gives you the "most general id function back"
<delYsid`> merijn: Yeah, after getting over the initial shock, its actually
           quite nice.
<dminuoso> But rather "fmap id" gives you a "slightly less general id function
           back"
<jusss> dminuoso: then fmap id = id, this id shoud change its name like id2 or
        idf
<dminuoso> jusss: If you prefer, sure.
<dminuoso> If that helps.
<dminuoso> fmap id = id'
<jusss> dminuoso: then the first and only law in Functor is really confusing
        people
<dminuoso> jusss: Sadly we do not have a precise language to formulate the
           laws in a way that would be understandable by most beginners.
                                                                        [16:07]
<merijn> delYsid`: Yes, the application is rather limited, but where
         applicable (like your problem) it does give you massive performance
         benefits with the minimum required memory :)
<jusss> 'cause that new id :: f b -> f b, not id :: a -> a,   the new id is a
        subset of the old id
<dminuoso> jusss: `fmap id = id` seemed like the best effort, do you have a
           better alternative?                                          [16:08]
<merijn> delYsid`: You can actually do even more advanced things based on
         this. You can use mmap to map a file into memory and rely on the OS
         to page data from disk to memory "on-demand" :)
<dminuoso> jusss: And you are absolutely right.
<dminuoso> jusss: But you are slowly getting a hang for type unification,
           which I think is great.
<jusss> dminuoso: what about <*> and >>= , they're same with fmap?
<dminuoso> jusss: no, they are more powerful actually.
<jusss> now we can say fmap transform (a->b) to ( (e->a) -> (e->b) ), so I
        wonder how to express about <*> and >>=                         [16:11]
<dminuoso> jusss:
           https://gist.github.com/dminuoso/daedae39ed76577d81d1a5984bf45b5e
<dminuoso> jusss: This tells you what Applicative (this is the typeclass that
           <*> is in) is, in relation to Functor.                       [16:12]
<dminuoso> (>>=) is... different.
<Solonarv> % :t (<*>) @((->) _) -- here's what <*> looks like for functions
<yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: You can do this yourself very mechanically.           [16:13]
<dminuoso> Replace every instance of `f` with ((->) e)
<Solonarv> % :t (=<<) @((->) _) -- and here's =<< (which is just >>= flipped)
<yahb> Solonarv: (a -> w -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: So Applicative lets you do: `a -> (e -> b)`, `(a -> b) -> (e
           -> a) -> (e -> b)`, `(a -> b -> c) -> (e -> a) -> (e -> b) -> (e ->
           c)`, etc...                                                  [16:14]
<dminuoso> jusss: Though it should be said that the `e` here is special.
<Solonarv> dminuoso: your first one is wrong, it should be 'a -> (e -> a)'
<dminuoso> Oh, good catch.                                              [16:15]
<jusss> dminuoso: Applicative transform (w->a->b) to ((w->a) -> (w->b)) ?
<dminuoso> jusss: take my diagram, and copy some snippet off a type signature
<dminuoso> jusss: And mechanically replace `f` with ((->) e)`, and by
           mechanically I mean use search-and-replace with your editor  [16:16]
<jusss> dminuoso: in you diagram, Functor only have two element, but
        Applicative have any element
<dminuoso> jusss: Exactly!
<dminuoso> Applicative is more general than Functor, which is why less
           instances exist.
<dminuoso> (Since not all type constructors support this "works for any number
           of components in a function")
<jusss> dminuoso: <*> transform any element to a form that I don't know how to
        express                                                         [16:19]
<jusss> elements are "contained" by functor
<jusss> dminuoso: wait a sec, those element, they 're function          [16:20]
<dminuoso> jusss: Yup!
<dminuoso> jusss: Applicative too transforms functions.
<jusss> in functor, a->b,  in applicative, a or a->b or a->b->c
<dminuoso> Except Functor limits you to functions taking one argument.
<dminuoso> Applicative lets you do this with functions taking *any* number of
           arguments
<dminuoso> jusss: Spot on.
<jusss> dminuoso: that arguments are not important I think, 'cause currying
<dminuoso> jusss: They are here.
<dminuoso> jusss: For me, finding good intuition requires frequently changing
           perspectives. So I constantly jump between "functions have only one
           argument" and "functions can have many arguments", depending on
           which perspective gives better intuition.                    [16:23]
<dminuoso> jusss: Relatedly, starting from Applicative you stop thinking of
           that `f` as "container"                                      [16:25]
<dminuoso> jusss: Usually we start thinking of `f` as being a kind of effect.
<dminuoso> jusss: but that may not be helpful to you, if it confuses you just
           disregard it.                                                [16:27]
<talqu>
        https://www.stackage.org/haddock/lts-7.14/lucid-2.9.7/Lucid-Html5.html#v:script_
        I can't write `script_ [src_ "main.js"]`, neither prepending the
        expression with `with`. How is this element different in the first
        place and can't be written following what docs say. div_, table_,
        .. work well. How do i write a script_ with a source attribute?
                                                                        [16:38]
<Solonarv> talqu: it looks like you always need to give children
<Solonarv> so this should work: script_ [src_ "main.js"] ""
<talqu> Solonarv: 
<Solonarv> hm? did you hit enter too early?                             [16:43]
<talqu> sorry hit enter too early :), it compiles when written this way:
        `script_ [src_ "main.js"] ("" :: Text)`. Now, when I inspect the type
        I get: `script_ :: [Attribute] -> Text -> HtmlT m ()`, however, in
        docs the type of the expression is `script_ :: TermRaw arg result =>
        arg -> result` and I don't see how to derive/understan this type to
        `script_ :: [Attribute] -> Text -> HtmlT m ()`                  [16:47]
<jusss> dminuoso: but <*> :: f (a->b) -> f a -> fb,  <*> transform that
        function in Applicative to another function(f a -> f b) right?
<jusss> it's kind of like (1+2)*3 == 1*3 + 2*3                          [16:48]
<dminuoso> jusss: Right. So the diagram I showed you is basically what you can
           do with pure and (<*>)
<Solonarv> talqu: what I did is to go look at the docs for TermRaw
<dminuoso> jusss: Nope.
<Solonarv> specifically, the instances section
                                                                        [16:49]
<dminuoso> % liftA0 = pure
<yahb> dminuoso: 
<Solonarv> we know that script_ :: TermRaw arg result => arg -> result
<Solonarv> the instances tell us that this must be 'Text -> Attribute', or
           'Text -> HtmlT m ()', or '[Attribute] -> f -> HtmlT m ()' with
           ToHtml f
<jusss> dminuoso: if f is (e->),   so <*> :: (e->) (a->b) -> (e->a) -> (e->b)
                                                                        [16:52]
<jusss> I don't know if I can write that (e->) (a->b) to (e->a->b)      [16:53]
<dminuoso> jusss: You must, actually.
<dminuoso> jusss: Alternatively, you can write it as:
<dminuoso> ((->) e (a -> b)) -> ((->) e a) -> ((->) e b)                [16:54]
<dminuoso> So by wrapping the arrow with parens you can write it in prefix
           notation.
<jusss> dminuoso: and function can be Applicative too?
<dminuoso> Just like you would with operators.
<dminuoso> jusss: Try implementing the following two functions:
<dminuoso> coconut :: a -> (Int -> a)
<dminuoso> mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b)       [16:55]
<jusss> coconut x = \y -> x
<talqu> Solonarv: thank you, i see it now. Also this class use {-# LANGUAGE
        MultiParamTypeClasses #-} right? You couldn't write `class TermRaw arg
        result` without that extension?
<Solonarv> talqu: yes, and also FunctionalDependencies                  [16:56]
<dminuoso> And FlexibleContexts
<dminuoso> Oh well all those things.
<Solonarv> FlexibleInstances too I think
<dminuoso> MPTC almost always goes hand-in-hand with FlexibleContexts and
           FlexibleInstances.                                           [16:57]
<Solonarv> basically a handful of generally-recognised-as-unproblematic
           extensions to the typeclass machinery
<dminuoso> Its almost suprising why it doesn't include those.
<Solonarv> dminuoso: also with FunctionalDependencies, if you want type
           inference to work nicely
<dminuoso> Solonarv: Im willing to argue that no.                       [16:58]
<Solonarv> Hm. Not always, but certainly often
<jusss> mango \x -> \y -> z = \ICantWrite (\x -> y) -> (\x->z)
<dminuoso> jusss: Use your editor, and use GHC to typecheck and subsequently
           test your code.
<jusss> dminuoso: let's g :: a->b,  f:: Int -> a ,  g( f Int) = b       [17:05]
<jusss> wrong                                                           [17:06]
<jusss> dminuoso: f::Int->(a->b)   g::Int->a   mango f g Int = (f Int) (g Int)
<jusss> dminuoso: right?
<dminuoso> jusss: You should practice writing this in correct Haskell code.
                                                                        [17:12]
<dminuoso> This helps you as well as others trying to understand you.   [17:13]
<jusss> Prelude> mango f g x = (f x) (g x)                              [17:14]
<jusss> mango :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
<dminuoso> jusss: Looks great.
<dminuoso> jusss: Now it should be said that Alternative too has some laws,
           but they are far more elaborate than the simple Functor law.
<dminuoso> jusss: In general you should test whether your instance satisfies
           the necessary laws.
<Solonarv> dminuoso: did you mean s/Alternative/Applicative/ ?
<merijn> ugh...why do we have catches with a list of handlers, but not handles
         with a list of handlers? >.>                                   [17:16]
<dminuoso> Solonarv: Funny, I was just about to write somethig in -ot about
           Alternative, my mind must have played a trick on me.
<jusss> deduce a function's definition from its type signature is so amazing!
        of course this one function is just an instance of the type, like a
        subset
<dminuoso> jusss: The more general a type is, the better this works.
<dminuoso> Also it frequently leads to situations where it's very hard to
           write something that still type checks but is wrong.         [17:19]
<Solonarv> sometimes (when the type signature is general enough) there really
           is only one possible non-bottom value for it
<Solonarv> examples: id :: a -> a; (.) :: (b -> c) -> (a -> b) -> (a -> c)
<dminuoso> jusss: Consider `id :: a -> a`, how many different implementations
           can you think of?
<jusss> dminuoso: what are those laws about Applicative                 [17:20]
<jusss> dminuoso: id x = x
<jusss> dminuoso: x can be function or string or int or whatelse
<dminuoso> jusss: You can review them here
           https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Applicative
<dminuoso> jusss: Okay. Can you write it differently?
<dminuoso> Perhaps in such a way that it changes its input
<jusss> dminuoso: that sounds like a typeclass stuff                    [17:21]
<jusss> one type signature but with different instances
<Solonarv> ah, but there's no typeclass in 'id :: a -> a'
<dminuoso> I think I understand what jusss is getting at though
<jusss> yeah, I'm wrong
<dminuoso> jusss: `id :: a -> a` means it must work for *any* possible choice
           of a.
<jusss> dminuoso: yeah,                                                 [17:23]
<jusss> dminuoso: anything, functor, function, list, string , number, anything
<dminuoso> Exactly.
<jusss> 'cause a can be any type I think
<jusss> like fmap id is a subset of id
<dminuoso> jusss: And that means you cant know anything about its argument. If
           you dont know anything about it, the only thing you can do is give
           it back or disregard it.
<dminuoso> But you have to return something of `a`. Since you cant just make
           up arbitrary values of *any* type, the only thing you can actually
           do, is return the one thing of type `a` that you have.
<dminuoso> so the type system in its generality has you constrained in such a
           way, that you can reason about what a function can do and what it
           cant do                                                      [17:25]
<jusss> dminuoso: so its type has to be defined in the function
<jusss> a specific type
<dminuoso> jusss: The *user* picks the type.
<dminuoso> jusss: The user of your function/value
<dminuoso> User/caller/consumer                                         [17:26]
<dminuoso> Its not the implementor. The implementor cant know in advance what
           type or even types (!) the consumer/user/caller will pick.
<dminuoso> `class Functor f where fmap :: (a -> b) -> f a -> f b` here for
           example an instance implementor cannot know what `a` and `b` are in
           advance.                                                     [17:27]
<dminuoso> The implementation has to be able to work with *all* choices of `a`
           and `b`
<jusss> dminuoso: it gives me a feel that type signature is amazing, and
        function definition isn't
<dminuoso> fmap is by very simple type mechanics prohibited to ever know
           details about the content. it cant know in advance what `a` or `b`
           will be                                                      [17:28]
<dminuoso> the implementation must work for all choices, so it knows nothing
           about it
<dminuoso> except what it has been given, namely that functoin
<dminuoso> % :t ($)
<yahb> dminuoso: (a -> b) -> a -> b
<dminuoso> jusss: ^- try implementing that function.                    [17:29]
<jusss> dminuoso: f::a->b     $ f a = b                                 [17:30]
<dminuoso> So there too, you dont know what `a` or `b` are, the only things
           you have are your arguments. If you play this game long enough you
           can solve pretty fancy type puzzles and very often end up with the
           only but correct solution.
<jusss> $ f x  = f x
<dminuoso> jusss: Notice how both sides are the same? This is a special case
           of another function you have seen.                           [17:33]
<dminuoso> Can you guess which?
<merijn> prettyprinter seems to only split Text on linebreaks for
         linewrapping, how do I get it to split on words for softwrapping?
<jusss> Prelude> mango f x = f x
<jusss> mango :: (t1 -> t2) -> t1 -> t2
<dminuoso> jusss: Not quite.                                            [17:34]
<dminuoso> % :t ($)
<yahb> dminuoso: (a -> b) -> a -> b
<dminuoso> jusss: If I write the implicit parens here:
<dminuoso> ($) :: (a -> b) -> (a -> b)
<jusss> dminuoso: id
<dminuoso> jusss: But that means we can use `id` to apply to functions!
                                                                        [17:35]
<dminuoso> % (+1) `id` 5
<yahb> dminuoso: 6
<dminuoso> jusss: merijn mentioned it earlier. This whole business of "the
           only possible implementation", "judging what a function can do by
           just looking at the type signature" is called parametricity.
                                                                        [17:36]
<jusss> dminuoso: (id (+1)) 5 I perfer
<jusss> id (+1) == (+1)
<dminuoso> jusss: So a shorter implementation of ($) is this:
<dminuoso> ($) = id
<jusss> dminuoso: one signature, it can be other signatures,    a->a can be
        (a->b) -> (a->b) ?                                              [17:38]
<dminuoso> jusss: So lets rerwite one type signature
<dminuoso> id :: r -> r
<reactormonk> '<>' is not a (visible) member of class Semigroup - what? I'm
              using ghc 8.2, so it should be there
<dminuoso> If we set: r ~ (a -> b)
<dminuoso> Then it should be obvious
<dminuoso> jusss: Remmeber: `id :: r -> r` means for *any* choice of type `r`
<dminuoso> that choice includes functions.
<jusss> dminuoso: and wehn r is (a->b)        r->(a->b) can be (a->b)->(a->b)
        ?                                                               [17:40]
<jusss> when
<dminuoso> jusss: So things get complicated at this point.
<jusss> dminuoso: and it's more general
<jusss> dminuoso: a can be any type
<dminuoso> jusss: The short answer is, there's different kinds of letters.
<dminuoso> jusss: This act of "setting type variables equal to another" is a
           business called type unification
<merijn> reactormonk: Did you import it from Data.Semigroup ?           [17:43]
<jusss> dminuoso: and Applicative laws?
<dminuoso> jusss: They too are probably a bit overwhelming for now.
<dminuoso> jusss: Just know there exist laws, but you need not know them for
           now.
<jusss> dminuoso: I just know that List and Function are Functor and
        Applicative                                                     [17:44]
<dminuoso> jusss: Strictly speaking its not function.
<jusss> dminuoso: a partial function?
<jusss> dminuoso: I don't know how to express properly, the name        [17:45]
<dminuoso> jusss: If we think of a function as `A -> B`
<dminuoso> Then we take that type signature and punch a hole in it, turn it
           into `A -> _`
<dminuoso> That would be a valid functor and applicative.
<jusss> dminuoso: A-> _ isn't a function right?                         [17:46]
<dminuoso> jusss: Its a type that's still missing one argument.
<dminuoso> jusss: Now the interesting part is, the choice of `A` is completely
           free. That is, it doesn't matter whether it's `A -> _`, `D ->
           _`. It works for *any* choice of a type there.               [17:47]
<jusss> dminuoso: so what's the porperly to express? 
<dminuoso> Which is why the instance is written:
<dminuoso> instance Functor ((->) e)
<dminuoso> So using that previous notation, you could think of `e -> _` being
           a Functor for every choice of a type e.
<dminuoso> Equivalently [_] is a functor with a hole inside.
<dminuoso> We just write it as []
<dminuoso> But `[]` is basically too missing that type parameter
<jusss> dminuoso: yeah, functor and applicative both need a type to complete
        themself?
<dminuoso> jusss: Exactly. They work on types missing one type argument.
<dminuoso> Int cant be Functor
<dminuoso> [Int] cant be Functor
<dminuoso> But (Int ->) can                                             [17:50]
<dminuoso> [] can
<jusss> dminuoso: and about the m-word?
<dminuoso> jusss: Same story.
<dminuoso> jusss: Functor/Applicative/Monad are all interfaces for types that
           are "missing one type argument for completion"               [17:51]
<dminuoso> jusss: You can in fact observe this in the type signatures
<dminuoso> % :t fmap
<yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
<jusss> dminuoso: what's the wonders in Monad
<jusss> about
<dminuoso> jusss: Its just a very abstract interface, nothing special.
<jgt> with Yesod's type-safe routing; is there a way to change the protocol?
<dminuoso> jusss: Let me give you an analogy in terms of "just to show you
           that some ideas are simple in principle, but too broad to recognize
           instantly"
<jgt> for example, change the rendered url from https:// to ws://
<jusss> dminuoso: ok
<dminuoso> jusss: There's a common typeclass called Semigroup which consists
           of a single method `(<>) :: s -> s -> s`
<dminuoso> jusss: It doesnt have any special purpose. It just generalizes the
           idea of "smashing/combining things together" in some meaningful
           way.                                                         [17:53]
<Logio> with certain properties assumed from the operation, generally   [17:54]
<jusss> dminuoso: that (->) e can be monad?
<dminuoso> jusss: Try implementing this function:
<dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
<jusss> similar with  mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b) 
                                                                        [17:56]
<dminuoso> jusss: Yup. Its related in some manner, but its still different.
<jusss> dminuoso: cocoa f g x = f (g x) x
<jusss> cocoa :: (t1 -> t2 -> t3) -> (t2 -> t1) -> t2 -> t3             [17:59]
<dminuoso> jusss: Great.
<dminuoso> jusss: This Applicative/Monad instance is usually called Reader and
           it models threading an implicit parameter through your program.
<dminuoso> A common usecase might be some kind of Config parameter that every
           part of your program needs, and you get tired of manually passing
           it everywhere even though only a handful of spots actually use it.
<dminuoso> If you look at cocoa and mango you will see that all it does is
           applying a parameter everywhere.                             [18:01]
<dminuoso> And its the same parameter, so its a kind of shared
           environment/config                                           [18:02]
<jusss> dminuoso: that (->) e can be monad?
<dminuoso> jusss: Yes. You just wrote the (>>=) implementation for it.  [18:04]
<dminuoso> (>>=) is your cocoa
<dminuoso> (<*>) is your mango
<jusss> dminuoso: what?
<dminuoso> and pure/return is your coconut
<dminuoso> And banana is fmap                                           [18:05]
<jgt> 
<jgt> {-# LANGUAGE FruitySynonyms #-} ???
<dminuoso> jgt: Its a private GHC branch
<jgt> ah                                                                [18:06]
<dminuoso> Heh.
<jusss> dminuoso: the position is not right
<jusss> dminuoso: cocoa and >>=
<dminuoso> jusss: cocoa = flip (>>=)
<dminuoso> % :t flip (>>=)                                              [18:07]
<yahb> dminuoso: Monad m => (a -> m b) -> m a -> m b
<dminuoso> % :t (=<<)
<yahb> dminuoso: Monad m => (a -> m b) -> m a -> m b
<dminuoso> =<< is just >>= with the arguments flipped
<arianvp> % :t flip @((-> r)) (>>=)                                     [18:08]
<yahb> arianvp: ; <interactive>:1:12: error: parse error on input `r'
<jusss> dminuoso: about the a-> m b, I don't understand what it's used for
                                                                        [18:09]
<jusss> it's not like functor and applicative
<jusss> this a->m b
<dminuoso> jusss: Yeah its not.
<jusss> dminuoso: and what it is
<dminuoso> jusss: Well what is (<>)
<dminuoso> jusss: Its not for anything.
<Bish> dminuoso: o/
<jusss> <>:: s->s->s?                                                   [18:10]
<arianvp> % :t  (>>=) @((->) r)
<yahb> arianvp: ; <interactive>:1:14: error: Not in scope: type variable `r'
<dminuoso> Right
<arianvp> :/
<dminuoso> jusss: It exists because many things happen to have this shape, for
           some reason.
<Taneb> % :t (>>=) @((->) _)
<yahb> Taneb: (w -> a) -> (a -> w -> b) -> w -> b
<arianvp> Taneb: thanks
<arianvp> % :t (=<<) @((->) _)
<yahb> arianvp: (a -> w -> b) -> (w -> a) -> w -> b
<dminuoso> jusss: It doesnt have any intrinstic meaning.
<Bish> there is a flipped version of bind, but not a prefix bind?
<dminuoso> Bish: You can put (>>=) in parens                            [18:11]
<dminuoso> And then use it in prefix notation.
<Bish> yeah great :D i am just sometimes confused about the logic
<Bish> people would flip it, but never use it prefix
<jusss> dminuoso: use <> to shape for what
<dminuoso> jusss: I wouldnt focus on Monad really, ask what the ((->) e)
           instance does                                                [18:12]
<Bish> bind [1] pure
<Bish> i don't think that looks so ugly
<dminuoso> jusss: Ask what the [] instance does. Ask what the IO instance
           does.
<dminuoso> Each is very simple to understand and use.
<dminuoso> Worry about that m word later.
<jusss> dminuoso: those instance throw something out?                   [18:13]
<dminuoso> jusss: Lets go to the (<>) example
<dminuoso> jusss: Adding numbers is simple.
<dminuoso> Multiplying number too is a way to combine numbers.
                                                                        [18:14]
<dminuoso> Selecting the better number is a more abstract notion of
           combinining them.
<dminuoso> Or perhaps concatenating their digits.
<Bish> "don't worry about the m thing" :> best advice
<dminuoso> each individual example is trivial and simple
<dminuoso> you dont need more.
<jusss> dminuoso: use that old stuff, when e-> is Monad, >>= transform a
        function to another complicate function?                        [18:16]
<dminuoso> jusss: For (>>=) I would, personally, not think of it as a function
           transformer anymore.
<phadej> % :t (>>=) @((->) Int)
<yahb> phadej: (Int -> a) -> (a -> Int -> b) -> Int -> b
<dminuoso> jusss: Though you should look at (=<<) rather, if you want that
           perspective.                                                 [18:18]
<phadej> % :t (=<<) @((->) Int)
<yahb> phadej: (a -> Int -> b) -> (Int -> a) -> Int -> b
* Bish as a noob he would explain >>= as the function that passes the inner
  value to a function that has to wrap it again
<jusss> dminuoso: what you thought >>= as?
<dminuoso> jusss: Me personally?                                        [18:19]
<jusss> dminuoso: yeah
<phadej> I think about it as substitution operator
<phadej> take all `a`s and replace them by `m b`
<phadej> inside the structure
<dminuoso> jusss: I like to think of it as a kind of syntactic sugar to make
           (>=>) pleasant.
<dminuoso> jusss: But I do not think this will help you much.
<Bish> phadej: well, thats what happens all the time in lambda-calc, bit to
       abstract don't u think?
<phadej> Bish: monad is quite abstract interface                        [18:20]
<arianvp> % :t (<=<) @((->) Int)
<yahb> arianvp: (b -> Int -> c) -> (a -> Int -> b) -> a -> Int -> c
<Bish> yeah, but if you say "it substitutes things" you explain nothing which
       is specific to monads
<jusss> dminuoso: ok, I should just thought =<<
<phadej> Bish: \_()_/
<jusss> as function
<dminuoso> Bish: Pretty sure phadej meant it as `fmap then join`
<dminuoso> Bish: So it boils down to "what does join actually mean"
<phadej> % :t join @((->) Int)
<yahb> phadej: (Int -> Int -> a) -> Int -> a
<dminuoso> Bish: Though Ive started to develop a really cool intuition that
           jle` and Solonarv helped me with, which is how Applicative and
           Monad are related.                                           [18:22]
<jusss> dminuoso: what's the related?
<dminuoso> jusss: Nothing that would help you for sure. :-)
<Bish> dminuoso: well, what did they do to make you get that?
<Bish> read 10 books about cat-theory?
<dminuoso> Bish: You know that "a monad is just a monoid..." joke?
<Bish> no
<dminuoso> Good. Dont google it.
* Bish googles it
<jusss> dminuoso: ok, is there anything else I could learn today? :)    [18:25]
<Bish> dminuoso: well, how is that a joke?                              [18:26]
<dminuoso> Bish: Its not helpful at all to learn what it is, how to use it or
           anything about it.                                           [18:27]
<dminuoso> Its just utterly complicated and mathy.
<dminuoso> For people not already familiar with the subject anyway.
<Bish> well, i struggled hard, as you know, understanding monadic instances
<Bish> so i started reading about category theory, and i think it's
       interesting atleast and fascinating
<Bish> but it doesn't help at all to understand relation like applicative and
       monad                                                            [18:28]
<tdammers> it is interesting and fascinating alright, but it won't help much
           with understanding the Monad typeclass in Haskell
<Bish> atleast as long as you didn't read allthebooks.png
<Bish> tdammers: not a bit, yes
<dminuoso> Bish: not entirely true.
<tdammers> @where eightfold
<lambdabot> http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
<dminuoso> it can help some for some.                                   [18:29]
<tdammers> ^ I recommend this
<dminuoso> but emphasis on "can" and both "some".
<Bish> well, it was timewaste in my case
<dminuoso> Bish: I do the CT stuff because its lovely.
<tdammers> it's not a waste of time; it does help understand some of the
           deeper theory behind it, but that's only going to be useful after
           you have a bit of a practical grasp on the Monad typeclass and its
           instances and usage
<Bish> dminuoso: hard to wrap my head around that, i love it too, but i am
       guess my intelligence is not enoughf or that :D                  [18:30]
<dminuoso> So the CT perspective can help you refine your
           knowledge/perspective if you are already familiar with it.
<dminuoso> But its not a good means to actually learn it, just to study
           something you already know well deeper for personal interest.
<Bish> to understand monadic instances i just used intesive staring at
       replicateM
<jusss> dminuoso: thanks for your teaching, :) 

<Bish> because i loved what it does
<jgt> yeah I really didn't think the "monad is just a monoid" joke was all
      that crazy
<tdammers> getting to the point where you can do useful stuff with do notation
           on lists, and actually grok how that works, is fun
<jgt> I mean, you just learn what the words mean

<jgt> "monad is a monoid" ok so they are composable

<jgt> "in the category of endofunctors" ok so the "thing" it represents
      won't change into a different thing
<arianvp> composable itself is a very ambigious word though :P
<arianvp> especially when you combine it with the slogan "Monads don't
          compose" :P
<dminuoso> And the composition is hard to spot unless you tell the joke not as
           a joke but correctly
<jgt> for the purposes of understanding what is meant, I think it makes it
      tangible enough
<dminuoso> A monad is a monoid in *a* category of endofunctors equipped with
           functor composition as its tensor.
<dminuoso> *in a monoidal category*                                     [18:34]
<dminuoso> suddenly you need to talk about monoidal categories, monoids,
           endofnuctors, tensors..
<dminuoso> categories
<jgt> do you though?
<jgt> it seems like the common problem with functor                     [18:35]

<dminuoso> jgt: What if I told you that Applicative too is a monoid in a
           monoidal category of endofunctors?
<jgt> just about anybody can grasp that it's a mappy thing
<arianvp> https://www.youtube.com/watch?time_continue=3&v=SLAmSo0Gd4U
<jgt> which isn't really the whole story
<arianvp> oh wrong link I think
<jgt> but for the purposes of getting someone productive in Haskell, it
      doesn't matter

<dminuoso> jgt: So if both Applicative and Monad are monoids in the category
           of endofunctors, whats the difference?                       [18:36]
<Solonarv> of course, but it seems the discussion was about the "a monad is
           just a monoid in the category of endofunctors, what's the problem?"
<jgt> the difference is not relevant to someone stumbling through their first
      "build a blog in Haskell" tutorial
<Solonarv> (I jumped in halfway through, so might be missing some context)
<dminuoso> Solonarv: I named you as one of the responsible people already. :-P
                                                                        [18:37]

* Solonarv *scared*
<Solonarv> responsible for what?
<dminuoso> Solonarv: Oh remember that discussion with jle` the other day?
<tdammers> leave it to Haskellers to take a joke seriously and accidentally
           end up with a productive discussion
<dminuoso> About Day and (:.:)?
<arianvp> which I never seen happen before lol                          [18:38]
<Solonarv> dminuoso: oh, I remember

<dminuoso> Solonarv: Ive been trying to build a foundation of intuition of
           that.
<dminuoso> *on that.
<arianvp> Only time I grasped the whole monad is monoid thing was in a lecture
          about string diagrams
<arianvp> and forgot again the day after, as always happens with me and
          category theory                                               [18:39]

<dminuoso> arianvp: for me cool thing is how it explains the laws in a
           do-notation perspective better
<Solonarv> after your head gets dunked into category theory deeply enough you
           start to see it everywhere :P                                [18:41]
<Solonarv> and specifically monoids/categories crop up all over the place
                                                                        [18:42]
<arianvp> http://www.stephendiehl.com/posts/monads.html 
<dminuoso> Solonarv: Its absolutely amazing how category seems to be the
           fundamental building block for everything.                   [18:43]
<dminuoso> Solonarv: Do you read Bartosz's twitter?
<arianvp> wait until you discover higher category theory =)
<Solonarv> I don't, I rarely check twitter at all
<dminuoso> Solonarv:
           https://www.quora.com/Why-is-a-mathematical-function-allowed-to-have-multiple-outputs-for-single-input-but-not-multiple-inputs-for-same-output-Is-it-just-a-convention-or-it-has-a-logical-reason/answer/Bartosz-Milewski?share=0ce9415c
                                                                        [18:44]
<dminuoso> I highly enjoyed this answer on: Why is a mathematical function
           allowed to have "multiple outputs for single input" but not
           "multiple inputs for same output"? Is it just a convention or it
           has a logical reason?
<Bish> > just about anybody can grasp that it's a mappy thing
<lambdabot>  error:
<lambdabot>       Variable not in scope:
<lambdabot>          just :: t0 -> t1 -> t2 -> t3 -> t4 -> t5 -> Expr -> t6 ->
            t7 -> t
<Bish> fav sentence of the day :D
* jgt blushes on the inside                                             [18:47]
<t7> what?

<jgt> t7: what what?
<dTal> Hi Haskellers. I have a question that's not specifically about Haskell,
       but someone suggested maybe you might know the answer to.        [19:02]
<dTal> Is there a word for the operation that takes a function that combines
       two values, and returns a function that combines two functions that
       return those values?

<dTal> (or any number of values I suppose)                              [19:03]
<dminuoso> dTal: Semigroup

<dminuoso> dTal: Its fully captured by: instance Semigroup b => Semigroup (a
           -> b)
<jgt> "semigroup" is a category, not an operation, no?
<Solonarv> well, if by "combine" you are talking about <> specifically
<dminuoso> I somehow assumed they were trying to name a thing that already
           existed.
<Solonarv> oh yes, that thing is called 'on' in Haskell's standard library
                                                                        [19:05]
<Solonarv> er, wait, liftA2
<dTal> in Scheme it looks like (define (meta fun) (lambda instances (lambda
       (argtype) (apply fun (map (lambda (instanc
<dTal> e) (instance argtype)) instances)))))
<dminuoso> Solonarv: No pretty sure its the semigroup operation
<dTal> oops sorry
<Solonarv> % :t liftA2 @((->) _)
<yahb> Solonarv: (a -> b -> c) -> (w -> a) -> (w -> b) -> w -> c
<dminuoso> Or?
<dminuoso> Mmm                                                          [19:06]
<dminuoso> Oh you are right Solonarv.

* jgt can't wait to be at that level of wizardry some day
<Solonarv> dTal: or liftA3, liftA4 etc for higher arity                 [19:07]
<Solonarv> I don't remember how many of them are defined
<Solonarv> but also: liftAn f x1 ... xn = f <$> x1 <*> ... <*> xn
<dTal> well the thing I just pasted should work for arbitrary arity
                                                                        [19:08]
<Solonarv> we don't have arbitrary-arity functions in Haskell - at least, not
           conveniently - so that doesn't translate straightforwardly
<Solonarv> but as I showed you can build "arbitrary-arity liftA*" using
           repeated applications of <*>                                 [19:09]
<dTal> That does like it
<dTal> wow, thanks a lot guys

<dTal> it's such a pleasure to "discover" something like that
<Solonarv> > liftA2 (++) tail reverse "hello"                           [19:10]
<lambdabot>  "elloolleh"
<Solonarv> or:
<Solonarv> > ((++) <$> tail <*> reverse) "hello"
<lambdabot>  "elloolleh"

<dTal> so this? (map ((liftA2 +) (lambda (x) (+ 1 x)) (lambda (x) (+ x 1)))
       (iota 10)) => (2 4 6 8 10 12 14 16 18 20)                        [19:12]
<dTal> sorry for persistently pasting Scheme, but I figured you probably know
       more Scheme than I know Haskell

<Solonarv> well, liftA2/3/... is a name for that function in Haskell

<dTal> actually, hold that thought, I'm actually expecting (2 3 4 ...) - the
       heck
<Solonarv> and it's actually more general than lifting functons
<Solonarv> > map (liftA2 (+) (+1) (1+)) [1..10]
<lambdabot>  [4,6,8,10,12,14,16,18,20,22]
<Solonarv> oh, iota isn't quite what I thought it was - close enough though
                                                                        [19:16]

<dTal> oh no that is correct, of course you're adding x to itself - just a
       math brain fart
<Solonarv> I'm not aware of a specific name for this kind of combinator, tbh

<dTal> I guess I'll just call it 'lift' in my program then
<Solonarv> I'd pick something like 'liftFunc'                           [19:18]

##########################################################
<[exa]> like, Maybe , [], Either l, (e->), IO all "contain" 'a' and can be
        converted using '(a->b)' to contain 'b'
<[exa]> jusss: the point about functors is that you can change what type they
        "contain" by fmapping a simple function (a->b)
<jusss> what about to see a container that 'contain' a value, a function that
        'contain' a output, a list that 'contain' its value             [17:47]
<jusss> (e->a) is a container (e->) 'contain' its output value 'a'
<jusss> [a] is a container [] 'contain' its value 'a'
<jusss> fmap apply a function on that value which is in the container, and get
        a same container with a new value                               [17:50]

###########################################
<jusss> jle`: fmap::(a->b) -> (e->a) -> (e->b), that (a->b) do changes (e->)'s
        output from a to b,                                             [16:23]
<jle`> it changes the (e -> a) into an (e -> b)
<Solonarv> jusss: you've been stuck on this for a few days, try a different
           perspective: fmap doesn't modify anything
<jle`> so it takes a function with input e and output a, and returns a
       function with input e and output b
<Solonarv> fmap constructs an entirely new function (e -> b) out of (a -> b)
           and (e -> a)                                                 [16:24]
<Solonarv> none of the inputs are modified
<jle`> that's a nice website :)                                         [16:31]
<jusss> Solonarv: ok, no modify, in this view, I can understand why (->) e is
        similar with []
<jusss> think about input and ouput, fmap apply function A on another function
        B, it return a new function C,  C has the same input with B, but
        different output                                                [16:36]
<jusss> so we can say fmap "change" a function's output with return a new
        function way                                                    [16:38]
<jusss> right                                                         [16:40
<[exa]> jusss: a useful point of view on (-> e) is to see functions as
        'containers for the results'                                    [16:45]
<jusss> [exa]: what about to see functions as containers that not throw its
        return value yet                                                [16:48]
<[exa]> jusss: yeah, you need to supply 'e' to get it "opened"
<[exa]> it's a childish explanation but probably the best intuition for (->e)
        functor I have                                                  [16:49]
<Solonarv> [exa]: if you want to use sections, write it (e ->)
<Solonarv> otherwise write ((->) e)
<[exa]> Solonarv: oh noes, sorry.
<[exa]> yeah its ((->) e) :]
<Solonarv> (-> e) is also meaningful (if interpreted as an operator section,
           which GHC doesn't allow), and doesn't mean the same thing as ((->)
           e)
<jusss> [exa]: throw a 'e' to the container, and when the container doesn't
        throw a 'a' out, the container is a Functor                     [16:51]
<[exa]> well, same intuition kindof holds even for the profunctor, but that's
        not what we were heading :]
<[exa]> jusss: you have a container that receives 'e' and gives 'a'. You can
        turn it to a container that from 'e' gives 'b' using a function of
        type (a->b).
<[exa]> jusss: and that ^ is the function functor.                      [16:53]
<jusss> [exa]: and what about list functor? now I don't understand list
        functor any more                                                [16:54]
<jusss> throw a 'a
<jusss> throw a 'a' to a [] and it turns [a]
<jusss> it won't throw something out right?
<jusss> or it throw itself out? [a]?
<[exa]> jusss: list already contains the result (multiple results) that you
        can get without any 'e' throwing
<[exa]> jusss: the similarity is that if you have list that contains 'a' and
        function (a->b), you can get list that contains 'b'
<jusss> [exa]: wait a sec, but [] is Functor, [a] is not, e->a will return a,
        but List a will return?
<[exa]> jusss: (e->a) is also not a functor, (e->) is                   [17:26]

<[exa]> jusss: the point about functors is that you can change what type they
        "contain" by fmapping a simple function (a->b)

<jusss> [exa]: yeah, so the problem is that a in [a] is an input or an output
<jusss> it seems I'm getting another puzzle
<Solonarv> jusss: it's an output, if you want to think of it that way
<Solonarv> definitely not an input
<[exa]> like, Maybe , [], Either l, (e->), IO all "contain" 'a' and can be
        converted using '(a->b)' to contain 'b'
* kuribas doesn't get why the container analogy is so popular           [17:31]
<kuribas> it's undescriptive and mostly wrong
<Solonarv> kuribas: it's reasonably intuitive and works for many common
           functors, is probably why
<Rembane> kuribas: You can look at it and it works for a while
<kuribas> Solonarv: it's used for monads as well
<kuribas> maybe container = set
<Solonarv> it even works for (e ->) if you view functions as containers with
           an item for every possible input
<kuribas> so a function is a set, sounds right
<Solonarv> kuribas: yeah, I don't think it works quite as well for explaining
           monads anymore
<Solonarv> well, if you work within set theory everything is a set, that's
           kind of the point                                            [17:33]
<jusss> [exa]: (e->) is functor, ok, it 'contain' 'e', but [a] isn't functor,
        [] 
<Solonarv> (unless it's too large to be a set, but functions aren't)
<jusss> [] 'contain' a
<Solonarv> jusss: no, (e ->) doesn't contain anything
<Solonarv> you can think of (e -> a) as containing a separate 'a' for every
           possible 'e' you might apply it to                           [17:34]
<jusss> Solonarv: but (e->) return something like 'a'
<kuribas> functor is a structure preserving mapping
<Rembane> What does the word structure mean here?
<dminuoso> [exa]: Imagine a functor having a sort of hole in the type. `(e ->
           _)` is a functor for every choice of a type e.
<dminuoso> Uhh I meant jusss.
<dminuoso> Of course.
<kuribas> or better a type and it's structure preserving mapping
<[exa]> we need better functor analogy
<[exa]> wo sind meine pfannkuchen
<Rembane> Ganz weg! 
<Solonarv> kuribas: btw, this post convinced me to not dislike the
           functor~container analogy as much:
           https://bartoszmilewski.com/2014/01/14/functors-are-containers/
<kuribas> the analogy would be you have something in a shape, and you change
          while preserving the shape.
<dminuoso> kuribas: The container analogy is surprisingly good actually.
<dminuoso> The reason the container analogy works so well, is because the hask
           specific functors all tend to model containers really well, for
           some notion of container.
<jusss> dminuoso: but it conflict between list functor with function functor
<dminuoso> jusss: a function can be thought of as a generalized container,
           indexed by its domain                                        [17:37]
<kuribas> Const () is a functor, it doesn't contain anything
<dminuoso> jusss: `Natural -> Char` can be thought of as isomorphic to [Char]
<maerwald> kuribas: no, it contains nothing :)
<dminuoso> So `Natural -> Char` contains many characters, and you select one
           by feeding the function some input.
<dminuoso> (We need to squint a bit and not focus on things like length)
                                                                        [17:38]
<dminuoso> kuribas: Thats not a problem, we can map over empty lists too, cant
           we?                                                          [17:39]
<kuribas> dminuoso: yes, but it isn't a container
<maerwald> you're thinking of collections                               [17:40]
<dminuoso> kuribas: Why not? Its just the most trivial container you could
           think of: an empty container.
<maerwald> container is a very abstract term
<dminuoso> Its always empty.
<maerwald> it can be used to describe functors
<kuribas> container is a poor man's set
<maerwald> I'm confused why people try to reduce it to collections      [17:41]
<jusss> dminuoso: so we can image that a function is a container, there're
        lots of results in it, we can get the result with give it a index
        value, and we can image that list is a container, there're lots of
        results in it, we can get the result with give it a index value, ???
<dminuoso> jusss: There's many ways to think of them as a container. I tend to
           think of lists not as an ordered set of elements, but rather as a
           non-determinstic value.                                      [17:43]
<Solonarv> false equivalence: not all containers have a way to "take out" a
           value
<dminuoso> (It depends on situation though)
<dminuoso> jusss: So [1,2,3] for me models as "not sure whether 1, 2 or 3"
<dminuoso> Its a kind of "fuzzy container"                              [17:44]
<dminuoso> (This notion can help a lot when thinking about the Applicative or
           Monad instance for []
<dminuoso> For some.
<jusss> what about to see a container that 'contain' a value, a function that
        'contain' a output, a list that 'contain' its value             [17:47]
<jusss> (e->a) is a container (e->) 'contain' its output value 'a'
<jusss> [a] is a container [] 'contain' its value 'a'
<jusss> fmap apply a function on that value which is in the container, and get
        a same container with a new value                               [17:50]
<dminuoso> Its things like STM, IO or Async where the container notion is
           stretched to some degree.

###############################################################

fmap::(a->b)->[a]->[b]
(a->b) apply on a in[a]
fmap::(a->b)->(e->a)->(e->b)
I dont think (a->b) can apply on a in (e->a)
7:53 PM - 5 May 2019


What if I said it can and that's what (.) does.

If your trip ends at the coach station

  trip :: Begin -> CoachSt

you may need a taxi to get home

  taxi :: CoachSt -> Home

(Begin ->) is a Functor

  fmap :: (CoachSt -> Home) -> ((Begin -> CoachSt) -> (Begin -> Home))

So fmap @(Begin ->) transforms a trip ending at CoachSt into one ending at Home. As functions; we instead think f :: Input -> Output and we want to change the output of f, we view (Input ->) as a Functor f :: (Input ->) Output

We pass fmap the output transformer outputTransformer :: Output -> Output' so using fmap @(Input ->) allows us to change the output of (Input -> Output) to (Input -> Output') fmap outputTransformer :: (Input -> Output) -> (Input -> Output')

> Is there a way to change the input

Yes. But instead of requiring

  Input -> Input'

we need to give

  Input' -> Input

This is due to (->) being contravariant in its Input and covariant in its Output

Thinking of trips again, we have

  Begin -trip> End

If we want to add to the end of it, we post-compose with

  post :: End -> End'

  Begin -trip> End -post> End'

but to add to the beginning we pre-compose

  pre :: Begin' -> Begin

  Begin' -pre> Begin -trip> End -post> End'

wow, it seems fmap do apply (CoachSt->Home) on CoachSt in (Begin->CoachSt), it changes (Begin->)s output CoachSt to Home, fmap apply function A on another function B and it changes that Bs output, right?

########################################################

<jusss> eiGHttt map . map  fmap fmap fmap?
<eiGHttt> ghci                                                        [18:00]
<jusss>  :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
<jusss> callback  call-back, call back                [18:03]
*** eiGHttt (~eiGHttt@m85-64.yeah.net) has quit: Ping timeout: 252 seconds
#########################################################

https://en.wikipedia.org/wiki/Sales_taxes_in_the_United_States
As of 2017, 5 states (Alaska, Delaware, Montana, New Hampshire and Oregon) do not levy a statewide sales tax. California has the highest base sales tax rate, 7.25%. Including county and city sales taxes, the highest total sales tax is in Atlantic City, New Jersey, 12.875%.

#######################################################

<ManariaFriends> google playapp store
<ManariaFriends> DelawareNew Hampshire
<ManariaFriends> MontanaOregon
<ManariaFriends> 4
<jusss> ManariaFriends: paypalapp store paypalNY ,
<ManariaFriends> 
<ManariaFriends> 
<ManariaFriends> 
<ManariaFriends>                                    [11:51]
<jusss> ManariaFriends: 
<jusss> ManariaFriends: CA
<ManariaFriends>                                                [11:52]
<ManariaFriends> 
<jusss> ManariaFriends: paypal
<ManariaFriends> 
<jusss> ManariaFriends: Tokyo                             [11:54]
<ManariaFriends> 
<ManariaFriends> 8%
<jusss> ManariaFriends: google playjcb
<ManariaFriends> 
<ManariaFriends> google play
                 

##############################################
<jusss> fmap :: a -> (b->e) -> (a->e) -> b   this is available?         [11:04]
<jle`> @djinn a -> (b -> e) -> (a -> e) -> b                            [11:05]
<lambdabot> -- f cannot be realized.
<geekosaur> I don't see where you got that question
<geekosaur> :t fmap
<lambdabot> Functor f => (a -> b) -> f a -> f b
<jusss> a-> (b -> f a) -> f b                                           [11:11]

<jusss> jle`: a->b is an unary function, (+1) is an instance of a->b, but I
        don't know what (->) a is                                       [11:12]
<jusss> a->
<geekosaur> it's artially applied, like (+1) is partially applied       [11:13]
<jusss> I thought that (+1) is just an identifier for \x -> x+1         [11:14]

<geekosaur> it is. and (a->) would be a partially applied type lambda, but
            Haskell doesn't support type level lambdas                  [11:15]
<jusss> \x -> x+1 , its type is a->b
<jusss> geekosaur: what \x -> x+1 looks like after partial applied?     [11:16]
<jusss> it just has one parameter
<jle`> jusss: (\x -> x + 1) applied to, say, y, is:
<jle`>  (\x -> x + 1) y
<jle`>  = y + 1
<geekosaur> that is not itself partially appliable
<geekosaur> (+) takes two parameters.. (+1) provides one of them, and is
            therefore a partial application
<jle`> you apply it to get y + 1, so it's not really "partial
       application". it's "full application"

                                                                        [11:17]
<jusss> jle`: so \x -> x+1 can not be partial applied?
<jle`> it can be applied                                                [11:18]
<jusss> and it would be (+ x ) or (+ 1) ?
<jle`> jusss: "partial application" is just what we call application when it
       returns a different function; it hasn't "resolved" to a full
       non-function value yet
<jle`> jusss: the application of (\x -> x + 1) to 7 is 8                [11:19]
<jle`> > (\x -> x + 1) 7
<lambdabot>  8

<geekosaur> jusss, you are confusing action and result. (+1) is the result of
            a partial application, not the cause of one

<jusss> jle`: geekosaur fmap (+1) (+1),  is there a functor in (+1) ? or (+1)
        is the functor?                                                 [11:24]

<jle`> (+1) is not a functor

<jusss> those e->a doesn't have the same behavior with []
<jle`> `e -> a` is comparable to [a]                                    [11:25]

<[Leary]> This whole conversation would be simpler if all operator use (and
          special list syntax) were desugared to prefix.
<geekosaur> but you're probably comparing on value level, and (->) doesn't
            have value level but [] has both type and value level.
<jusss> jle`: but fmap can apply a->b on a in [a], but fmap can't apply a->b
        on a in e->a
<geekosaur> the comparison to [] here is that you can write [Int] as ([] Int)
<Cale> jusss: The functor in that case is (->) Integer                  [11:26]
<jusss> geekosaur: fmap can apply a->b on Int in [Int] right?
<jle`> jusss: also note something -- 'f a' doesn't necessarily have an a "in"
       it

<geekosaur> you have type and value level confuse, I think
<Cale> jusss: Supposing that a is Int, yes?                             [11:27]
<jle`> so "applying a -> b to the a's in [a]" is something that is accurate to
       lists in particular
<jle`> but not all Functor instances
<Cale> In some sense, even in the function case, we have that fmap f g applies
       f to all the possible results of g
<jle`> 'f a' doesn't necessarily have an 'a' "in" it.  `[] a` does.  `((->) e)
       a` does not.
<geekosaur> note this ^ carefully                                       [11:28]
<Cale> which if you like, you can think of as the "elements contained in g"
<jusss> jle`: so "<jusss> those e->a doesn't have the same behavior with []"
<geekosaur> the functor is ((->) a)
<Cale> though the sense in which they're "contained" is a little more abstract
       now
<jle`> jusss: right, the behavior of fmap is different for every single
       Functor
<jle`> the behavior of fmap for lists is different than the behavior of fmap
       for `(->) e`, etc.
<Cale> Sometimes it can be helpful to think of a function of type e -> a as
       being like a giant array indexed by values of type e, having values of
       type a at each position

<jle`> there's one potential confusion here as well, it's that we're using
       "function" to mean a few things at a few different levels        [11:29]
<jusss> Cale: but function is not a container
<jle`> so it might be useful to not think about `(->) r`, but rather `Reader
       r`, if you understand the semantics of `Reader r a`
<jusss> and list is a container
<Cale> jusss: I'm telling you the sense in which you can think of functions as
       a sort of container                                              [11:30]
<jle`> a value of type `Reader r a` "contains" an 'a', that must be given an
       'r' to access
<Cale> jusss: Did you read the array analogy?
<jle`> so you cannot access the 'a' without an 'r', so to speak.  and giving
       different r's will give you different a's
<jusss> Cale: list is a container, because I can change the value in the list,
        but I don't think we can change the value in the function,
<jle`> so fmap :: (a -> b) -> Reader r a -> Reader r b
<Cale> jusss: Sure we can
<Cale> jusss: In any sense in which you could change the elements of a list
                                                                        [11:31]
<jle`> it takes something that "produces" an a, and turns it into something
       that "produces" a b
<jusss> Cale: for example, \x->x+1, how to change that 1 to 2?
<geekosaur> you'r thinking wrong                                        [11:32]
<geekosaur> a function, includin g a lambda, is a single non-decomposable
            thing
<Cale> jusss: Which 1? The 1 that results when you apply that function to 0?
<geekosaur> nothing can see the 1 there
<geekosaur> or change it
<geekosaur> the only access you have is to apply it to some parameter
<jusss> geekosaur: but if it's list, we can

<Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 0
<lambdabot>  2
<Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 1
<lambdabot>  2
<Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 2
<lambdabot>  3
<geekosaur> yes, and?                                                   [11:33]

<Cale> There, I changed it.
<geekosaur> is it somehow not possible that different types are different?

<jle`> i think jusss's point is that functions in general are not inspectable
       in the same way that lists are, which is a part of the concept of
       container-ness in their experience                               [11:34]
<[Leary]> (\x -> x + 1) is not a container holding x, + and 1, it's a
          "container" holding the value (x + 1) at the index x.         [11:35]
<geekosaur> if there were a formulaic way to define what fmap does, fmap would
            be a function, not a typeclass method. but the notion of functor
            is more abstract. it applies in one way to lists. a different way
            to functions. a still different way to State, etc.

<Cale> jusss: You can think of the function (\x -> x + 1) as being the set of
       pairs (0,1), (1,2), (-1,0), (2,3), (-2,-1), ...
<Cale> The second components of those pairs are the "elements" which we're
       modifying by way of fmap                                         [11:36]
<geekosaur> similarly, *if* you insist on thinking in terms of "container",
            there is an abstract way to recognize a function as a
            "container". but only that abstract way; it does not become a
            funny looking list
<Cale> i.e. a function is a thing which pairs up inputs and outputs in a
       particular way
<geekosaur> frankly, I find it better to not think in terms of "container"
            because it will mislead you
<Cale> and fmap applies a function to all the outputs of another function
<Cale> Abstractly, there's no requirement that we recognise the type as a
       container type in order to make an instance of Functor           [11:37]
<Cale> All that is required is that we have a type F of kind * -> * and a
       function fmap :: (a -> b) -> F a -> F b for which it's the case that
       fmap id = id, and fmap f . fmap g = fmap (f . g)                 [11:38]
<Cale> and as it happens, if fmap id = id, then in Haskell, it's impossible
       for the second law not to hold.
<monochrom> Hey, I once had fun exemplifying to a student the corresponding
            between (Int, Int) and Bool->Int.                           [11:40]
<monochrom> s/corresponding/correspondence/
<jusss> Cale: think function like (0,1) and (e->) in fmap, would be (0,) ?
<jusss> that "container" or "wrapper" stuff in every Functor article    [11:41]
<jusss> or Monad
<jusss> geekosaur: what it's used for like (e->) ?                      [11:42]
<jusss> in fmap, of course
<jusss> what this abstract stuff is used to?
<Cale> jusss: Let's use monochrom's example and consider functions of type
       Bool -> Int
<Cale> jusss: You can fully characterise such a function by what it gives when
       applied to False and True                                        [11:43]
<monochrom> Yes, I did this to my student precisely because they were learning
            functor-applicative-monad and they still drew a pretty clear line
            between "container" and "function".
<Cale> So, Bool -> Int is similar in nature to (Int, Int)
<Cale> Given a function f :: Bool -> Int, we can turn it into a pair (f False,
       f True)
<Cale> and given such a pair (x,y), we can turn it into the function (\b ->
       case b of False -> x; True -> y)                                 [11:44]
<jusss> a partial applied function may be a functor?                    [11:48]

<monochrom> No. A type of kind *->*
<nisstyre> Cale: would it be more like a 2 element set?
<nisstyre> 2 elements of pairs that is
<nisstyre> (if you're defining functions as sets)
<monochrom> (->)Bool is a type of kind *->*. This is not a partially applied
            function. This is not even at the term level.
<jusss> monochrom: (->) Bool is not * -> ?                              [11:49]
<jusss> it lacks a type
<monochrom> Set loses the sequential structure.
<monochrom> {1,2} /= (1,2).                                             [11:50]
<monochrom> Because {2,1} = {1,2} but (2,1) /= (1,2)

<monochrom> Set also loses the multiplicity structure. {1,1}={1} but (1,1) /=
            (1)

<monochrom> Set loses so much, why would anyone use sets at all?        [11:51]

<monochrom> The kind of (->) Bool is * -> *  there is no typo in this
            sentence. This is non-negotiable.
<monochrom> Oh it lacks a type? Sure, that's why the kind is not simply *
                                                                        [11:52]

<monochrom> And yes all confusions are caused by wrong assumptions. Erase all
            assumptions and start again.                                [11:53]
<Cale> jusss: A partially applied type-level function can be a Functor, yes.

<Cale> (if you just say "function" most people will think you mean a
       value-level function)

<jusss> Cale: what is "type level lambdas" ?                            [11:55]

<jusss> or type-level function                                          [11:56]
<geekosaur> I think you just hit the root of the problem                [11:57]
<geekosaur> [] is a type level function: it takes a type such as Int, and
            produces a type such as [Int] (which can also be written: [] Int)
<geekosaur> Maybe is a type level function: it takes a type such as Int, and
            produces a type such as Maybe Int, whose values are Nothing or
            (Just some_Int_goes_here)                                   [11:59]

<jusss> what's the type-level function related with functor?            [12:01]
<geekosaur> Functor itself, which is defined as a typeclass. each type with a
            Functor instance specifies what that means.                 [12:03]
<geekosaur> however, it's not quite a type level function; it's a
            constraint. type level functions can't say "I accept only certain
            types", it has to accept any type with the correct kind; so we
            have constraints that can say that.                         [12:04]
<geekosaur> that is, Maybe can't say (Maybe Int) is valid but (Maybe Integer)
            isn't. Constraints can.                                     [12:05]

<jusss> geekosaur: oh, Maybe and e-> both need a type to complete       [12:06]
<geekosaur> yes, because both have the kind * -> *
<geekosaur> in the case of Functor, one of the types is supplied by and
            controlled by Functor, so you have to omit that type when defining
            instances of it.                                            [12:07]
<geekosaur> so there is Instance Functor Maybe where ... -- this instance
            doesn't get to say "Maybe _what?_"
<geekosaur> and there is instance Functor ((->) e) where ... -- this instance
            doesn't get to say "function produces _what?_"              [12:09]
<jusss> geekosaur: those Functors they don't have the same behavior, right?

<geekosaur> they have conceptually similar behavior. not identical behavior
<jusss> like list and function in fmap

<jusss> geekosaur: that conceptually similar behavior is just they all need a
        type to complete                                                [12:16]
<geekosaur> no
<jusss> fmap :: (a->b) -> (e->a) -> (e->b)    fmap (*100) (+3)  that return
        type would be ?                                                 [12:18]
<geekosaur> "adding two numbers together" and "adding two strings together"
            (concat) are conceptually similar, but different. in this case,
            the concept behind Functor is a bit trickier than that: given
            Thing a for unknown a, and a function (a -> b), produce Thing b
<geekosaur> in your case, a and b happen to be the same type, so fmap :: (a ->
            a) -> (a -> a) -> (a -> a)
<jusss> geekosaur: what I express is the return type would be the same with
        (*100)
<geekosaur> because (*) and (+) both require the same types everywhere
<[Leary]> The conceptual behaviour is that for any Functor `f`, whenever `x ::
          f a` would produce a `y :: a`, `fmap g x :: f b` would instead
          produce `g y :: b`.
<[Leary]> fmap intercepts and augments the production of values, whether that
          production is by indexing a list, pattern matching on Just, or
          applying a function.                                          [12:23]
<[Leary]> etc
<Cale> jusss: It's important to notice that the values that fmap is modifying
       in the case of lists might not all be in memory at the time as well

<Cale> > fmap (*10) [1..]
<lambdabot>
            [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
<Cale> ^^ you can fmap over an infinite list :)
<Cale> > [fmap (*10) (\x -> x+1) n | n <- [0..]]                        [12:25]
<lambdabot>
            [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
<geekosaur> "but they're not the same kind of things" that is why it's a
            typeclass, so each type can specify what fmap means for that
            type. for functions, it means function composition. for lists, it
            means applying a transform to every member of one list, producing
            a new list.
<jusss> geekosaur: and they all have the same type signature, that's wonderful
                                                                        [12:26]
<jusss> magic?
<geekosaur> not magic, that's the point of typeclasses. the Functor constraint
            basically *means* that.
<Cale> Well, that's what type classes are for: classifying types for which
       similar functionality can be provided
<geekosaur> similarly there is a Monoid constraint that captures the idea that
            addition, multiplication, list concatenation, etc. all do
            "something similar"                                         [12:27]
<jusss> find the similar and use it to do what?
<geekosaur> whatever you need to do. people find lots of uses for fmap. people
            find a number of uses for mappend (the combining operation of
            Monoid). Monad captures the idea of combining "actions" of some
            variety, which is fairly useful.                            [12:32]
<geekosaur> Num captures the idea of "number" that you can do addition,
            subtraction, etc. with, so we don't have to have separate add_Int,
            add_Integer, add_Double, etc..                              [12:33]
<geekosaur> Enum captures the idea of "preceding / following value"     [12:34]
<Cale> jusss: Here's a cool example with Monoid. There is a Monoid instance
       for Ordering, the type of result that "compare" gives, consisting of
       EQ, LT, GT for "equal", "less than" and "greater than"
<Cale> What that Monoid instance does is as follows:                    [12:37]
<Cale> EQ <> y = y

<Cale> x <> _ = x
<Cale> So, if the first comparison gives EQ, use the second, otherwise, use
       the first.
<Cale> Also, there is an instance (Monoid a) => Monoid (e -> a) where (f <> g)
       x = f x <> g x
<Cale> Putting these things together, we automatically have Monoid (e ->
       Ordering), and then Monoid (e -> e -> Ordering), i.e. we're allowed to
       combine functions which make comparisons                         [12:39]
<Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words
       to sort by length and then alphabetically")
<lambdabot>
            ["a","by","is","of","to","and","here","sort","then","bunch","words","length"...
<Cale> Monoids show up everywhere. Combining configurations, combining queries
       for data, combining summary information about subtrees of a tree (the
       associativity of the combination is what lets us rebalance the tree
       efficiently without recomputing everything)                      [12:41]

<Cale> Nearly every tree-based algorithm in computer science is exploiting
       trees that are annotated with some monoid at the branch nodes which
       summarizes the data at the leaves.

#####################################################

fmap :: (a->b) -> (e->a) ->(e->b)
fmap (a->b)  (e->a)  = (e->b)
fmap (a->b) (e->a) e = b

fmap take two parameters and it returns a function
fmap take three parameter and it return a value

fmap (+1) (+1) = (+2)
fmap (+1) (+1) 100 = 102
fmap f g x = f (g x)
fmap f g = \x -> f (g x)

fmap :: a -> (b->e) -> (a->e) -> b     not available
#############################################################3

[ 5  5 2019]
<Cale> Sorry about fen, perhaps I should explain here                   [09:26]
<jusss> ok                                                              [09:27]
<Cale> Okay, so...
<Cale> Let's I guess explain a bit about kinds
<Cale> Just as values have types, types have kinds
<Cale> Ordinary types which have values in them have kind *             [09:28]
<Cale> For example,  Integer :: *
<Cale> String :: *
<Cale> String -> Integer :: *
<Cale> We also have type level functions which take an argument of kind * and
       produce a result of kind *
<Cale> Like [], the type constructor for lists
<Cale> and Maybe :: * -> *                                              [09:29]
<Cale> (->) :: * -> * -> *
<Cale> because it takes two types, the types of the domain and codomain
<Cale> and produces the type of functions between them
<Cale> If we apply (->) to a single type
<Cale> (->) Integer :: * -> *                                           [09:30]
<jusss> ok
<Cale> then we get a type level function waiting for another type before it
       will produce a type of values
<Cale> (->) Integer Bool :: *
<Cale> and we usually write it infix at that point:
<Cale> Integer -> Bool :: *
<Cale> cool?
<jusss> ok
<Cale> So things which are instances of Functor always have kind * -> *
                                                                        [09:31]
<Cale> fmap :: Functor f => (a -> b) -> f a -> f b
<jusss> wait
<Cale> We can see that a and b have kind * because (->) is being applied to
       them
<jusss> functor have *->* ?                                             [09:32]
<Cale> Yeah
<Cale> always
<jusss> it need another * to complete *->* ?
<Cale> For example, there's an instance Functor Maybe
<jusss> no
<Cale> Maybe :: * -> *
<jusss> I was wrong, 
<Cale> Functors are always type-level functions                         [09:33]
<jusss> ok
<Cale> But not just any type level function will do, there must be an
       implementation of fmap
<Cale> So, now let's do what I wanted to do before and look at implementing
       fmap for (->) e                                                  [09:34]
<jusss> yeah
<Cale> fmap :: (a -> b) -> ((->) e a) -> ((->) e b)
<Cale> which is the same as
<Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
<Cale> which is the same as
<Cale> fmap :: (a -> b) -> (e -> a) -> e -> b
<Cale> yeah?                                                            [09:35]
<jusss> ok
<Cale> fmap f g x = ...
<Cale> f :: a -> b
<Cale> g :: e -> a
<Cale> x :: e
<Cale> and we want to produce a result of type b
<Cale> The only way we could possibly produce a result of type b is by using f
<Cale> fmap f g x = f ...
<Cale> and now in order to use f, we need to provide an argument of type a
                                                                        [09:36]
<Cale> the only way to get something of type a is to apply g
<Cale> fmap f g x = f (g ...)
<Cale> and now g requires an argument of type e
<Cale> and thankfully we have one, namely x
<Cale> fmap f g x = f (g x)
<Cale> So fmap f g is the function which, given some x, will result in f (g x)
                                                                        [09:37]
<Cale> That is, it's the composite of f and g
<Cale> We could also have simply written
<Cale> fmap = (.)
<jusss> but through eta-reduce we can get fmap f g = f g, that's ?      [09:38]
<Cale> nope
<Cale> can't eta reduce here                                            [09:39]
<Cale> Well, we could say...
<Cale> fmap f g x = (f . g) x
<Cale> and then eta reduce
<Cale> But since the x is inside the parens on the right hand side of  fmap f
       g x = f (g x)
<Cale> we can't eta-reduce yet                                          [09:40]
<jusss> ok


###################################################################
they all want 16000 Hz, but some devices output 48000 Hz
microsoft azure, wav and ogg both need 16k Hz samplerate, 16 bit resolution
but microsoft take 48k Hz wav also
qi 2.1.4 and qi 2.5 wav with 48k Hz, and ogg with 16k Hz

  ASR16k Hzwav48k Hz
16k Hzogg48k Hzwav16k Hz

########################################################

#GADTs
{-#LANGUAGE GADTs #-}

--ADT
data Maybe a =  
    Nothing |   
    Just a
--GADT
data Maybe a where
   Nothing  :: Maybe a
   Just :: a -> Maybe a

data T = I Int | B Bool
data T where
     I :: Int -> T
     B :: Bool -> T

#ADT #Algebraic Data Types

<jusss> how to make a type that can have Int or Bool, nothing else,  data T =
        Int | Bool  ???   (here Int is value constructor, has nothing with that type constructor Int, so it's not what you want here)                                              [09:32]
<jusss> dyl: data T = Either Int Bool? (this is not what you want too)
Prelude> :t (Either 3)
(Either 3) :: Bool -> T
<dyl> Yup. 
<dyl> Either A B is the dual of (A, B) [or Tuple A B if you prefer]
<dyl> Tuple is one of both (a product), Either is one or the other (a
      coproduct).
<jusss> dyl: and when I want to use this value, I should use Either 3 or I
        need Either 3 True?                                             [09:34]
<dyl> data Either A B = Left A | Right B.
<dyl> a b*
<jackdk> `data T = I Int | B Bool` or `type T = Either Int Bool`, depending on
         whether you want T to be a new type or an alias
<dyl> ^ 
<dyl> Tbh I would just use Either unless theres a need to do otherwise as
      you get a lot of stuff for free.                                  [09:35]
<jusss> what is this Left and Right  ,  I and B here?
<jusss> just a Value Constructor? and meaningless?
<dyl> data Either a b = Left a | Right b
<dyl> Theyre just the constructor for each case. 
<dyl> Pull up google on Data.Either.                                    [09:36]
<dyl> Hoogle*
<jusss> then I see, Int and Bool both are type constructor, so if they want to
        be a value , they need a value constructor, right?
<dlyang> use GADTs extension  data T a = where I :: a ->Int B:: a ->Bool
<JappleAck> data T a = where I :: a -> Int ; B :: a -> Bool
<JappleAck> but it still incorrect and supposed to be something like this:
            data T a where I :: a -> T Int ; B :: a -> T Bool           [09:43]
<jusss> data T a = I a | B a,   
<JappleAck> jusss: in your case you could have `I True' and `B 123'     [09:44]
<JappleAck> even this: data T a where I :: Int -> T Int ; B :: Bool -> T Bool
                                                                        [09:47]
<jusss> data T = Either a b
<jusss> data T = Either Int Bool                                        [10:14]
<jusss> Either 3 is ok , but Either True is not, so it must be Either 3 True?
in this case Either a value constructor, has nothing with that Either type constructor,
so it has to be (Either Int Bool), and (Either Int) is a partial form
<jusss> % :t Either 3
<yahb> jusss: Bool -> T
<geekosaur> % :t Either 3
<yahb> geekosaur: Bool -> T
<geekosaur> incomplete
<geekosaur> because it's partially applied                              [10:31]

<jusss> geekosaur: aha, so this 'Either' in 'data T = Either Int Bool' has no
        relationship with 'Either a b = Left a | Right b'?
<mniip> perhaps they wanted data T = C (Either Bool Int)
<geekosaur> here, you called it Either, which will be unrelated to the
            exxisting type Either
<geekosaur> % data T1 = MkT1 Int Bool -- same thing, different constructor
            name
<yahb> geekosaur: 
<mniip> jusss, correct, they live in different namespaces
<mniip> data A = B C                                                    [10:33]
<jusss> mniip: data T = C (Either Bool Int),  what this C construct?
<geekosaur> a value of this type T looks like C (Left True) or C (Right 4)
<geekosaur> the parentheses are required here, `C Left True` would attempt to
            apply a value (C Left) (which is a type error) as a function to
            the value True                                              [10:38]
<jusss> geekosaur: if the type constrctor to do a value, I should put a value
        constructor on it?                                              [10:48]
<jusss> do as
<geekosaur> ...what?
<jusss> data T = Maybe Int, this Maybe is nothing with type constructor Maybe
<jusss> this Maybe is value constructor here
<geekosaur> right, it's defining a data constructor, not a type constructor
                                                                        [10:49]
<jusss> but I can use data T = C (Maybe Int)
<jusss> and this Maybe is still that Maybe type constructor
<jle`> you can use both, but they mean two different things
<jle`> `data T = Maybe Int`, you're declaring a new data type T, with a value
       constructor Maybe
<jle`> that contains an Int
<geekosaur> data ATypeConstructor {- possibly some type parameters -} =
            ADataConstructor {- possibly some types for "contained'/associated
            values here -}
<jle`> with `data T = C (Maybe Int)`, you're declaring a new data type T, with
       value constructor C, that contains a (Maybe Int)
<jusss> ok                                                              [10:52]
<jle`> it's admittedly a little inconsistent because you flip back and forth
       between two levels of things                                     [10:53]
<jle`> that's one reason why a lot of people think GADT syntax is more
       consistent/easier to undersatnd in this regard                   [10:54]
<jle`> it's an alternative syntax to declaring new data types and constructors

(type constructor can not be a value constructor, otherwise, that same identifier is just 
a value constructor, nothing to do with type constructor, but you can make another identifier as value constructor, and use the type constructor as a value of it, that's ok)
data T = Maybe Int     not ok
data T = V (Maybe Int)      ok

#############################################
curl -i -X POST -H "Content-Type: audio/pcm;rate=16000" "http://vop.baidu.com/pro_api?dev_pid=80001&cuid=xxxxx&token=" --data-binary "@/home/test/test.pcm"

get the api key and secret key, then use the post method get the token
>>> r=requests.post('https://openapi.baidu.com/oauth/2.0/token?grant_type=client_credentials&client_id=G&client_secret=C')
>>> r.content
b'{"access_token":"","session_key":"","scope":"audio_voice_assistant_get brain_enhanced_asr audio_tts_post public brain_all_scope wise_adapt lebo_resource_base lightservice_public hetu_basic lightcms_map_poi kaidian_kaidian ApsMisTest_Test\\u6743\\u9650 vis-classify_flower lpq_\\u5f00\\u653e cop_helloScope ApsMis_fangdi_permission smartapp_snsapi_base iop_autocar oauth_tp_app smartapp_smart_game_openapi oauth_sessionkey smartapp_swanid_verify smartapp_opensource_openapi smartapp_opensource_recapi","refresh_token":"","session_secret":"5","expires_in":2}\n'

curl -i -X POST -H "Content-Type: audio/wav;rate=16000" "http://vop.baidu.com/server_api?dev_pid=1&cuid=w&token=" --data-binary "@a.wav"

#ASR #STT
Microsoft Azure new ogg parameter doesn't work, and wav work, wav, ogg
xunfei sucks, there's python example on the docs, pcm, wav
baidu sucks as xunfei,  pcm,wav,amr 

#######################################################

Prelude> :{
Prelude| addr :: [a] -> [a] -> [a] -> ([a]->b) -> (b->c) -> c
Prelude| addr x y g z f = f (z ( x ++ y ++ g))
Prelude| :}
Prelude> addr "a" "b" "c" (\x -> x) (\x->x)
"abc"
Prelude> addr [1] [2] [3] (\x->x) (\x->x)
[1,2,3]

##################################################

_ in haskell
Prelude> :{
Prelude| addr :: [a] ->[a]->[a]->([a]->b)->(b->c)->c
Prelude| addr x y _ z f = f ( z ( x ++ y ++ _))
Prelude| :}
<cocreature> jusss: what do you mean by wrong? This is not an error as
             such, you just need to fill something in for the underscore at
             the end of the line                                        [13:33]
<cocreature> if you use _ in a pattern match, the value will not be bound to
             an underscore. It wont be bound at all
<tdammers> _ is special in pattern matches
<jle`> _ acts like an identifier in pattern syntax, but it cannot be bound and
       any bindings are ignored
<jle`> so it's the same role syntactically in both cases, but different
       semantically                                                     [13:44]
<jusss> jle`: so '_' in the left of '= match all, on the right, just a
        normal variable, right?                                         [13:46]
<tdammers> on the right, it's a hole
<jusss> what is a 'hole'?
<jle`> so to clarify the mess of what i said, syntactically they fit anywere a
       normal variable or identifier would go
<jle`> but semantically they mean different things                      [13:47]
<jle`> jusss: to the right of =, it essentially is a normal variable that is
       always unbound (since you can't bind _), *but* ghc gives it special
       treatment when doing error reporting
<tdammers> https://wiki.haskell.org/GHC/Typed_holes <- jusss 
<tdammers> before the Typed Holes feature in GHC, _ was just a regular
           variable (and it still is if you disable Typed Holes)        [13:48]
<tdammers> but because it's special in pattern matches, it cannot ever be
           bound to anything
<jle`> > True || blahblah
<dminuoso> jusss: Both x and _ `f x _ = ...` are so-called irrefutable pattern
           matches, the difference being that for the first pattern the result
           is bound to a variable named `x`, and for the _ pattern you cannot
           refer to it anymore.
<lambdabot>  error: Variable not in scope: blahblah :: Bool
<jle`> > True || _
<lambdabot>  error:
<lambdabot>       Found hole: _ :: Bool
<lambdabot>       In the second argument of (||), namely _
<jusss> tdammers: so '_' shouldn't show on the right of ' =' ?
<jle`> the only difference effectively in expressions is that the error
       message is different                                             [13:49]
<tdammers> jusss: not if you want the code to compile without errors
<jle`> jusss: _ is useful for debugging, but shouldn't be there in 'completed'
       code
<dminuoso> jusss: Even more special are identifiers starting with an
           underscore. Say `_foo` is doubly special. :)
<jle`> jusss: note how in both cases, it's the same error essentially, but the
       error reported is different
<jle`> the error for _ is more useful for debugging and helping interactive
       programming
<dminuoso> jusss: That is, if _foo is not defined you get the error for a
           typed hole, but if it is defined then _foo becomes a regular
           variable.
<tdammers> and of course this all holds only at the term level. type-level, _
           is also special, but in a slightly different (but related) way
<dminuoso> (Identifiers starting with underscore are particularly common when
           you deal with lenses for conventional reasons)

####################################################

import cv2, dlib, face_recognition, numpy

face recognition within live stream!
https://github.com/ageitgey/face_recognition/blob/master/examples/facerec_from_webcam_faster.py
https://github.com/ageitgey/face_recognition/blob/master/README_Simplified_Chinese.md

####################################################

let's assume there's a function f

f g [] = X
f g (x:xs) = f (g x) xs

what g and X would be to make this f exist?
<ski> you could have `data Consumer i o = MkCons {done :: o,consume :: i ->
      Consumer i o}', and then your `X' would involve using the `done' field,
      while the recursive call, passing `x' to `g', would use the `consume'
      field                                                             [10:38]
<ski> jusss : and then the signature of your `f' would be `f :: Consumer i o
      -> [i] -> o'                                                      [10:39]
<ski> you may think of a value of type `Consumer i o' as an object, which
      accepts two kinds of messages (has two methods), one being `done', which
      generates a result output of type `o', and the other being `consume',
      which, when given an argument input of type `i', will produce a new
      state/version of the object, which you can then go on calling `done' ior
      `consume' on                                                      [10:46]
<ski> (no mutation, so instead of `consume' changing some internal mutable
      state, it just returns a "clone" of the state of the object, adapted to
      the new information in the newly accepted input of type `i')      [10:47]
<ski> to create a consumer "object", you just have to tell how it should
      "respond" to the two messages `done' and `consume' .. iow, you don't
      have classes here, you just describe the behaviour of the object
      directly                                                          [10:48]
<ski> (if you want to, you can describe common behaviour that you want to
      reuse in a function, which constructs new objects for you. an "object
      factory", i suppose ..)                                           [10:49]
<ski> e.g. if you wanted to define an accumulating object, which accumulated a
      sum, starting at zero, you could say
<ski>   accumulator :: Consumer Int Int
<ski>   accumulator = MkCons
<ski> actually
<ski>   accumulator = self 0
<ski>     where
<ski>     self sumSoFar = MkCons
<ski>       { done = sumSoFar                                           [10:51]
<ski>       , consume = \n -> self (sumSoFar + n)
<ski>       }
<ski> so `sumSoFar' is the (private) local state (still immutable, but you can
      swap it out for another state, if you call the "constructor" `self' with
      a different initializer value, like inside `consume' there) of your
      object
<jusss> ski: sorry to being late replay, I need a little time to understand
        this                                                            [10:53]
<ski> jusss : i'm mostly trying to get across a broad idea of what one could
      do with something like this data type. getting the details can wait for
      later      

###########################################

g x = g
(define (g x) (whatever x) g)
g = _ => g

f = x => y => x+y
f(f(1))  =  \y -> (\g->1+g) + y    so plus a function on a Int, will get a type error

f = \x -> (\y -> x+y)
f 1 = \g -> (1 + g)
f (f 1) = \ ( \g -> 1+g ) -> ( \y -> ( \g -> (1 + g)) + y)
          = \y -> (( \g -> (1 + g)) + y)
so plus a function \g -> (1 + g) on y will get a type error          

################################################
take a picture with camera
pygame, opencv, simplecv, pil

<predator500> rekognition by AWS amazon
<predator500> have same service
<predator500> its called REKOGNITION with K :)                          [13:48]
<jusss> yeah, and Microsoft Azure
<jusss> it's free ?                                                     [13:49]
<predator500> Because if we needed to write the A.I and ML , it would take a
              lot more time.
<predator500> Yes for 12 months
<predator500> i think 5000 recongs per month
<jusss> that's good!
<predator500> But after that it is like 1$ on 1000 recons
<predator500> face++ ? free?
<jusss> sort of, I just tried it yesterday                              [13:50]
<jusss> and it provides off-line SDKs
<jusss> this is the document from face++, https://console.faceplusplus.com.cn
                                                                        [13:54]
<predator500>
              https://github.com/shantnu/Webcam-Face-Detect/blob/master/webcam.py
<predator500> flags=cv2.CASCADE_SCALE_IMAGE
<predator500> python3 yourproject.py cascade.xml
<jusss>  I put this cv2.imwrite('02.png',frame) into that if cv2.waitKey line,
        and when I press 'q' it will generate a photo                   [14:27]
<predator500> nice                                                      [14:51]
##################################################

https://console.faceplusplus.com.cn/app/apikey/view/9
API Key: M
API Secret: J


curl -X POST "https://api-cn.faceplusplus.com/facepp/v3/compare" -F "api_key=" -F "api_secret=J" -F "image_file1=@test1.jpg" -F "image_file2=@test2.jpg" 

#############################################

curl for windows
Assuming you got it from https://curl.haxx.se/download.html, just unzip it wherever you want. No need to install. If you are going to use SSL, you need to download the OpenSSL DLLs, available from curl's website.

or powershell

##########################################

pip3 install opencv-python  dlib face_recognition

import cv2


##########################################################

data Color = Red | Green | Blue

colorEq :: Color -> Color -> Bool
colorEq Red   Red   = True
colorEq Green Green = True
colorEq Blue  Blue  = True
colorEq _     _     = False

Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.

the one function, different type and different data?

We want a function that takes two parameters, both the same type, and returns a Bool indicating whether or not they are equal. We don't care what that type is, but we just want two items of that type.

class BasicEq a where
    isEqual :: a -> a -> Bool

This says that we are declaring a typeclass named BasicEq, and we'll refer to instance types with the letter a.
 An instance type of this typeclass is any type that implements the functions defined in the typeclass.
 This typeclass defines one function.That function takes two parametersboth corresponding to instance typesand returns a Bool
 


################################################

Prelude> :{
Prelude| nw :: a-> (a->b) ->b
Prelude| nw x y = y x
Prelude| :}
Prelude> nw 1 (+1)
2

Prelude> :{
Prelude| nw2 :: (Num a)=> a -> a
Prelude| nw2 x = x + 1
Prelude| :}
Prelude> nw2 33
34
Prelude>

Prelude> :{
Prelude| nw3 :: (Num a) => a -> a->a
Prelude| nw3 x y = x + y
Prelude| :}
Prelude> nw3 3 2
5
Prelude>

Prelude> :t (+1)
(+1) :: Num a => a -> a
Prelude>

rule I. don't use function's name as variable in patter match for another function's definition in the left part of '='
rule II. the variable's type in the signatur must be the type of variable in the function definition

(+1)'s type is (Num a)=> a -> a
so if you want (+1) in function's definition, it only can be the right part of = , can not be the left part of =, so the type in signature, it must be (Num a)=> a,  'cause (+1) work on that type,
w :: (Num a)=> a -> a
w x = (+1) x

##############################################

#beta-reduction
A beta reduction (also written  reduction) is the process of calculating a result from the application of a function to an expression.
For example, suppose we apply the function
(\x -> 2*x*x + y)
to the value 7. To calculate the result, we substitute 7 for every occurrence of x, and so the application of the function
(\x -> 2*x*x + y)(7)
is reduced to the result
2*7*7 + y
This is a beta reduction. 

#typeclass #beta-reduce
<jusss> w6 :: (Num a)=> a -> (a->a) ->a          w6 x (+1) = (+1) x    which
        part is wrong?
<sssilver> wolfman154: you can't start learning Haskell unless you can do beta
           reduction with close eyes on a parchment
<Solonarv> jusss: the (+1) part is wrong, you can't pattern match on functions
<jusss> Solonarv: how I can express like f(x,y) = y(x) ?
<jusss> f = function(x,y) {return y(x)}
<Solonarv> jusss: you've almost got it, just pick a normal variable name
           instead of something silly like (+1)
<Cale> jusss: f x y = y x
<jusss> Solonarv: I can not use function's name in pattern match for
        function's definition, use a variable to instead of that function's
        name, right?
<Solonarv> jusss: well, you can use whatever variable name you want
<Solonarv> if the name is already bound to something "outside" the local
           binding will simply shadow the outer one
<jusss> Solonarv: and (+1) can not be a variable?
<Solonarv> correct, (+1) is not a variable
<Solonarv> that's the only thing you did wrong!
<jusss> Solonarv: what if I want express f x = x+1, what the type would be?
                                                                        [10:05]
<jusss> w::a->a?
<Solonarv> almost
<Solonarv> let's ask the compiler!
<Solonarv> :t let w x = x + 1 in w
<lambdabot> Num a => a -> a
<monochrom> The "+" and the "1" incur a Num constraint.
<ion> :t let w x = x + (1 :: Integer) in w
<lambdabot> Integer -> Integer
<jusss> Solonarv: so, if it's concret type's instance in the function, and the
        type must be concret in type signature?                         [10:07]
<jusss> in the function's definition
<jusss> w::(Num a)=> a->a      w x= (+1) x                              [10:08]
###############################################################

AB(B A)haskell#

eta expand
map . map
= \f -> map (map f)
=\f -> map (\xs->map f xs)
=\f xss -> map (\xs->map f xs) xss
=(\f xss (map (\xs (map f xs) xss)))
=(lambda (f xss) (map (lambda (xs) (map f xs)) xss))

(map . map) (+1) [[1,2,5], [7,8]][[2,3,6], [8,9]] schemelambdag (g (lambda (x) (+ x 1)) ((1 2 5) (7 8)))((2 3 6) (8 9)) #eta-expand


,eta-expandform,  #mark

function's type is not same with the function's return value type!

id :: a->a
function id's type is a->a
and function's return value type is a

##################################################################################

<jusss> how to express map . map in other languages? like python or scheme
<Solonarv> or ugly, ugly lambdas, e.g. python: map(lambda xs: map(f, xs), xss)
<ski> jusss : i was about to say `(compose map map)', but that doesn't do what
      you wanted, try `(lambda (f lis) (map (lambda (lis) (map f lis)) lis))'
      instead ?
<ski> jusss : if you `(define ((curried-map) f) lis) (map f lis))', then you
      can say `(compose curried-map curried-map)' (adjust in the obvious way
      if you want to work on more than one list)
<ski> (the definition of `curried-map' may also need to be adjusted, if your
      Scheme doesn't support "curried" `define's)
<jusss> can I through the type signature to get the function's definition?
<Solonarv> jusss: sometimes
<ski> jusss : "through" ?
<Solonarv> roughly speaking, the more general the type signature is the more
           you can deduce about the implementation
<Solonarv> for the type of (map . map) there are many possible implementations
                                                                        [23:21]
<jusss> ski: const::a->b->a, id::a->a, so const id::b->a->a
<jusss> f:: const id,   f x y = y
<Solonarv> roughly speaking, the type of map.map is enough to figure out that
           elements in the result must come from the function argument being
           applied to elements in the input list
<ski> @djinn b -> a -> a
<lambdabot> f _ a = a
<ski> jusss : like that ^ ?  [23:23]
<Solonarv> but the type doesn't say anything about how the elements are
           arranged - they could be duplicated, or reshuffled in some
           arbitrary way, or stuff like that
<jusss> ski: yeah
<jusss> Solonarv: ski, how you think about map .map to express in other
        languages? I mean the transformation, is there a rule or something?
                                                                        [23:29]
<ski> what do you mean with "the transformation" or "rule" ?  [23:30]
<jusss> map . map == (map (lambda (lis) (map f lis)) lis)
<jusss> the procedure do that transform
<jusss> sorry for my Bad English
<Solonarv> basically just inline the definition of (.) and eta-expand
           everything until there are no partial applications left
<ski> jusss : `map' in Scheme is more like a `tupledMap' satisfying `tupledMap
      (f,xs) = map f xs' in Haskell
<ski> (well, `map' in Scheme also has the functionality of `zipWith',&c. ..)
<ski> (so there's some slight impedance mismatch you need to account for)
<jusss> Solonarv: that eta-expand apply on type signature or function's
        definition?  [23:40]
<Solonarv> definition
<Solonarv> so we go like this:  [23:43]
<Solonarv>             map . map
<Solonarv> = \f     -> map (map f)               -- 1. definition of (.)
<Solonarv> = \f     -> map (\xs -> map f xs)     -- 2. eta expand the inner
           'map' call
<Solonarv> = \f xss -> map (\xs -> map f xs) xss -- 3. eta expand outer 'map'
           call
<jusss> Solonarv: eta-expand is wonderful!
<ski> jusss : yea, it might be a good idea to practice it until it becomes
      second nature :)
<jusss> ski: through map's type signature we can know it takes two parameter,
        and through eta-expand, we can consturct (map . map) = \f -> map (map
        f) to a form that map with two parameter, and then we can get the
        expression in other language who support lambda, wonderful!
<ski> jusss : yep :)        

#######################################################


fmap :: (a->b) -> f a -> f b
when Functor is List, then fmap is map
fmap :: (a->b) -> List a -> List b
map :: (a->b) -> [a] -> [b]

when Functor is (->) e, then fmap is (.)
fmap :: (a->b) -> ((->) e a) -> ((->) e b)

and (->) e a == e->a
fmap :: (a->b) -> (e->a) -> (e->b)
(.) :: (a->b) -> (e->a) -> (e->b)
and Functor is (->) e


if 
(.) :: (a->b) -> (e->a) -> (e->b)
map :: (a->b) -> [a] -> [b]

so map . map :: ?

rule I. -> and . is infix expression, so ((->) e a) == (e->a) and map . map == (.) map map
rule II. -> is right associate
rule III. f g a == (f g) a
rule IIII. take function A's parameter type and return type as function B's parameter types in B's type signature, get function B's type signature with function A's type
rule V. (B A) A will take the first parameter position in B, so remove the type of the first parameter in B, it will get (B A)'s type

map . map == (.) map map
map1 :: (x1->y1) -> ([x1] -> [y1])
map2 :: (x2->y2) -> ([x2] -> [y2])

let (x1->y1) as a, and ([x1] -> [y1]) as b in (.)
so (.) :: ((x1->y1) -> ([x1]->[y1])) -> (e->(x1->y1)) -> (e->([x1]->[y1]))
and (.) map1, that map1 take the first parameter's position,
so (.) map1 :: (e->(x1->y1)) -> (e->([x1]->[y1]))

let (x2->y2) as e and ([x2]->[y2]) as (x1->y1) in (.) map1
so [x2] as x1, and [y2] as y1
so (.) map1 :: ((x2->y2) -> ([x2]->[y2]))  ->  ((x2->y2) -> ([[x2]] -> [[y2]]))
and (.) map1 map2, that map2 take the first parameter's position.
so (.) map1 map2 :: ((x2->y2) -> ([[x2]]->[[y2]]))

(.) map map :: (x2->y2) -> ([[x2]]->[[y2]])
map . map :: (x2->y2) -> [[x2]] -> [[y2]]


####################################################

const :: a->b->a
id :: a -> a

id :: x -> x
const :: (x->x) -> b -> (x->x)
const id :: b->(x->x)
const id :: b->a->a

f = const id
f :: b-> a -> a
f x y = y

##########################################################

<link rel="stylesheet" type="text/css" href="loop.css"/> is ok
and <link href="loop.css" /> is not,
but  <script src="loop.js"></script>  is ok
  
####################################################

#js #promise #loop #pic #pics

window.onload=function(){

 id=['id1','id2','id3'];
 elementList = id.map(function(x){ return document.getElementById(x)});
 stopButton=false;

 forLoop = function (alist, n) {
     return new Promise(function(r,e) {

         alist[n].style.display="block";
         //console.log(alist[n]);
         setTimeout( function(){r(n)}, 3000)})
         .then( function(_) {
             alist[_].style.display="none" ;
             //   console.log(alist[_]);
             if ( _+1 >= alist.length) {return 0}
             return (_+1)
        })
        .then(
            function(_) {
                if (stopButton) { stopButton = false; return 0}
                else { forLoop(alist, _)}
            })
 }
    
//    g=forLoop(elementList,0)
}

//forLoop(elementList, 0)

###########################################################

<jusss> Promise( (r,e) => {}).then()  could that (r,e) in then() ?
no
Promise()returnPromise().then(),Promise()
resolved()Promise()then()
setTimeout(r,3000) in Promise()  then()
it means this promise will be resolved after 3 seconds, and then the functionin  in .then() will run,
new Promise((r,e) => {})       r() will resolve,  and setTimeout(here-need-a-function, time)
r() will return a value, 'cause call-by-value, so setTimeout(r(),3000) will cause r() run immedely without waiting for 3000, so setTimeout(r, 3000) or setTimeout( _=>{doSomething; r()}, 3000)

//image that f(0) is retrun a new Promise(), that new Promise() will run when it's been created, and then in the last of Promise(), it return a new Promise(), just image Promise() like a snake or whatever else, when it runs to its tail, it will create a new snake, and the old one will disappear,

alist=[1,2,3]
stopButton=false

f = function (n) {
    return new Promise((r,e) => {
        console.log(alist[n])
        setTimeout( _ => {r(n+1)}, 3000)})
        .then( _ => {
            if ( _+1 > alist.length) { return 0}
            else { console.log(alist[_]) ; return (_+1)}
        })
        .then(
            _ => { if (stopButton) { stopButton = false; return 0}
                   else {
                       new Promise((r,e) => {
                           setTimeout(r, 3000)})
                       .then(
                           whatever=>{f(_)})}})
}

f(0)

##############################################

Prelude> :{
Prelude| w :: Maybe a -> Maybe a
Prelude| w (Just x) = (Just x)
Prelude| :}

Prelude> w (Just 3)
Just 3
Prelude> w (Just "aha")
Just "aha"

###########################################
post upload data
<eiGHttt> <form action="/" method="post"><input type="file" name="
          "><button></button></form> 
<eiGHttt> /my/apiaction
                                                            [14:20]
<eiGHttt> API
########################################################
fmap f g = \x -> f (g x)

Prelude> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
Prelude> :t fmap
fmap :: Functor f => (a -> b) -> f a -> f b

<Solonarv> jusss: the function composition operator
<Solonarv> (.) is a function, but Functor instances have to be types!   [10:18]
<Solonarv> however, ((->) e) has a Functor instance, and the definition of
           'fmap' in that instance is identical to (.)

<jusss> Solonarv: sorry to being late reply, I just check :t(.) and :t fmap,
        and I find that when the Functor is (->) a, then fmap is (.),   so
        fmap f g = f . g ???  when f and g are functions                [11:55]
<Solonarv> jusss: exactly!
<jusss> Solonarv: ok, but I really don't know what is eta reduce and expand,
<Solonarv> eta expanding/reducing means adding/removing an argument in an
           equality or a definition
<Solonarv> for example, if we have 'foo x = negate x' we can rewrite that to
           'foo = negate' (eta reduce); the opposite transformation is called
           eta expanding                                                [12:02]
<jusss> Solonarv: that pintless style use tis eta reduce?               [12:03]
<Solonarv> well, eta reduction/expansion is only when you have something of
           the form 'f x = g x', where neither f nor g mention x        [12:05]
<jusss> Solonarv: now, I know that when a Functor is a List, fmap is same as
        map in other languages, and when a Functor is (->) e, fmap is (.), but
        what this (.) is used for?                                      [12:08]
<Solonarv> function composition
<Solonarv> it lets you create functions by putting together smaller functions
<kadoban> jusss: Doing a string of operations on an input. Like perhaps you
          want to parse a string into a list of numbers, then remove
          duplicates and then sum them up.
<Solonarv> this could be written as:
<Solonarv> @let doStuff = sum . nub . map read . words
<lambdabot>  Defined.
<Solonarv> :t doStuff                                                   [12:13]
<lambdabot> (Num c, Eq c, Read c) => String -> c
<jusss> but this is same as that a bunch of code which is not use (.)
<jusss> it just makes a good look                                       [12:14]
<kadoban> jusss: Much of programming is just things that are easier to work
          with than other things.

<jusss> [] is a instance of Functor List 
<kadoban> [] is an instance of Functor, yes.                            [12:20]
<monochrom> We just say "[] is an instance of Functor".
<monochrom> Or "instance Functor []".

<jusss> f = const id,   and f's type is (a->a) -> b -> (a->a)  right?
<eiGHttt> % :t (const id)                                               [13:01]
<yahb> eiGHttt: b -> a -> a

[] Functor List
FunctorEither a bEither a c, Either aFunctor,
EitherFunctor

Maybe is not a typeclass,   (->) a is not a typeclass

const :: a->b->a
id :: a->a
<MarcelineVQ> You were on the right track earlier with your type for "const
              id" but const has been applied to id, so the first argument has
              been filled in, which is why it's b -> a -> a and not (a -> a)
              -> b -> a -> a                                            [13:53]
<jusss> MarcelineVQ: what 'filled in' means?                            [13:56]
<MarcelineVQ> hehe I'm finding it surprisingly difficult to word that
              differently
<MarcelineVQ> jusss: the type of const is, const :: a -> b -> a, what this
              means is that the function const takes two arguments, a value of
              some type 'a', a value of some type 'b', and results in a value
              of the same type 'a'. Does this make sense?               [14:06]
<jusss> MarcelineVQ: yeah
<MarcelineVQ> Let's call the type of id, id :: c -> c, since it doesn't matter
              what letter we use as long as it's consistent when we use it.
<MarcelineVQ> when we say "const id" it means we're applying const to id,
              we're making the first argument of const be id. That means the
              'a' of const must become (c -> c) since it's the type of
              id. Since both of const's 'a' are the same 'a', const's type
              must then be const :: (c -> c) -> b -> (c -> c)
<MarcelineVQ> When we say "const id", we've given const its first argument, so
              it only needs one more argument. This means that (c -> c) -> b
              -> (c -> c) is no longer the correct type, that's the type of
              something that takes two arguments, but const has already been
              given one.
<MarcelineVQ> The type of const when we want to apply to id is const :: (c ->
              c) -> b -> (c -> c), but "const id" b -> (c -> c)
<MarcelineVQ> Hopefully that's not too much more confusing, but if you
              understand that const :: a -> b -> a describes a function named
              const that takes two arguments, and you understand that "const
              id" is const that has already been given its first argument, the
              types should make sense if you take your time to piece it
              together                                                  [14:18]
<jusss> MarcelineVQ: I see,
<jusss> MarcelineVQ: thanks

<jusss> MarcelineVQ: const :: a-> b -> a,   can I say const a :: b -> a ?
<jusss> so if id :: a -> a, then const id :: b -> (a -> a) ?
<jusss> can I move the right part of :: to the left part ?              [14:29]
<jusss> and remove ( ) at anywhere in type signature?
<dmwit> jusss: No, those are not moves you can make.
<dmwit> jusss: The type language and computation language are completely
        separate.                                                       [14:32]
<jusss> dmwit: and remove ( ) at anywhere?
<MarcelineVQ> Not in actual code no, types and values are separate. No, -> is
              right associative so you can only remove ( ) when they would
              associate right. -> being right associative means that a -> b ->
              c -> d is a -> (b -> (c -> d))
<dmwit> jusss: For the purposes of removing parentheses: (->) is
        right-associative.                                              [14:33]
<jusss> I don't understand what is "types and values are separate"
<jusss> MarcelineVQ: but that's I do const a :: b -> a
<jusss> or const a b :: a                                               [14:36]

<jusss> MarcelineVQ: but that's I do const a :: b -> a
<dmwit> What is the `a` in `const a`? It doesn't exist.
<MarcelineVQ> It means that Int and 3 live in different namespaces, Int is a type and 3 is a value. 3 doesn't belong to the right of :: and Int doesn't belong to the left.
<dmwit> (It doesn't exist. It's not in scope. There's nothing with that
        name. These are all just different ways of saying the same thing, but
        maybe one of them will be more understandable to you.)
<MarcelineVQ> It's unclear what you mean when you say "const a :: b -> a"
              because we're not sure if you think the 'a' of "const a" is a
              name for some value or is a type variable.
<MarcelineVQ> id is a value, that happens to bea function, with the type (a ->
              a)
<jusss``> MarcelineVQ: what if we have knew that const :: a->b->a,  and can we
          use const a:: b->a ?
<jusss``> and the left part of :: is type language and the right part is
          computation language?
<MarcelineVQ> jusss``: If you mean the 'a' to all be the same then no, 'a' is
              a type variable, which means it's standing in for some
              type. functions (like const) aren't applied to types, they're
              applied to values. 'a' there isn't a value.
<dmwit> jusss``: Other way. Left is computation, right is type.
<dmwit> Void -> a is just as lousy a type as b -> a. Change my mind.    [14:51]
<dmwit> In `const a :: b -> a`, the `a` on the left is just another variable
        name, exactly like `const`. Except that the Prelude defines a variable
        named `const` and doesn't define a variable named `a`.
<dmwit> The `a` on the right is a type variable -- a placeholder that says
        that users of the expression on the left may choose any type they like
        to put in that spot.
<MarcelineVQ> Consider that const id :: b -> (a -> a) and it is not const id
              :: b -> id, does this show you a problem in your thinking?
<dmwit> (Yes, Haskell distinguishes between variables and type
        variables. There is a resemblance in their names, but they are not the
        same thing despite that.)
<dmwit> (Just like a dog and a doghouse have names that resemble each other
        but are very different.)
<jusss``> MarcelineVQ: the left part is variabe, and the right part is type
<jusss``> so const id :: b->(a->a) is ok, and const id :: b -> id is not?
          because id is a varaible and the right part need type
<MarcelineVQ> id is a 'value' not a variable, but you're starting to get it
<jusss``> MarcelineVQ: dmwit  so a function's name is a variable or a value?
<jusss``> or called a function?
<MarcelineVQ> A function's name is an identifier. A function is a value.
                                                                        [15:05]
<jusss``> I never know a function is equal to its name, or not
<dmwit> If you want to be very, very careful, then no, a function and its name
        are not the same thing. But most people are sloppy about this because
        it's way too much work to be that careful all the time, and doesn't
        really buy you very much.                                       [15:06]
<MarcelineVQ> dmwit: Now I should probably recheck but afaik haskell has
              variables in one place, types, things that look (and seem to
              act) like variables elsewhere are bindings
<jusss``> id :: a -> a,  this id is a identifier or a value?
<dmwit> Yes, id is both things there.
<MarcelineVQ> dmwit: I'm totally willing to admit that's some pedantic
              nonsense though because I'm not sure where forall k . k ->
              ... fits into what counts as a binder or not
<jle`> syntactically, it is an identifier. the identifier represents a value
<jle`> jusss``: a lot of things can represent values
<jle`> (3 + 1), for example, is a value
<jle`> using a variable identifier like `id` is one way to specify a value
<jusss``> identifier, value, variable,  what they are?
<jle`> jusss``: have you looked at the Haskell Report?
<jle`> it defines all of these things pretty well
<jle`> it's very readable, too :)
<jle`> https://www.haskell.org/onlinereport/haskell2010/
<yushyin> MarcelineVQ: of a valid example of 'funcname ? :: a -> b; funcname =
          ...'                                                          [15:11]
<dmwit> > (const 3 :: Int -> Int) 4 -- yushyin
<lambdabot>  3
<jle`> jusss``: the big picture of it is that "values" represent semantic
       meaning.  and in a Haskell source code, we use *expressions* to notate
       and describe values                                              [15:12]
<jle`> expressions can be thought of like trees -- they are constructed by
       using different expression pieces.  the haskell report describes all of
       the pieces that make up an expression
<yushyin> MarcelineVQ: dmwit: ah yes ...  I thought of something different.
<jle`> in the end an expression is what we type into haskell source file, it's
       the syntactic 'tokens'.                                          [15:13]
<jle`> an expression like `1 + 3` can be thought of as `Op "+" (NumericLit 1)
       (NumericLit 3)`, to use a pseudo-AST
<jle`> one of the possible "pieces" of an expression is a *variable
       identifier*
<yushyin> I was only thinking of type signatures alone
<jle`> so an expression like `id 5 + 2` can be thought of as `Op "+" (Apply
       (VarId "id") (NumLit 5)) (NumLit 2)`                             [15:14]

<jle`> 'id' here, syntactically, is a *variable identifier*. it plays that
       role, just like how '5' plays the role of a numeric literal
<jle`> now, the "point" of an expression is to represent a value.  that's the
       actual semantic meaning that you are using expression syntax to
       describe                                                         [15:15]
<MarcelineVQ> yushyin: I'm not sure what you're wanting to see, but in the
              case of const x :: b -> a, we must have some x = ... for this to
              be valid, we are informed by const that x must have type a, and
              that's all we can know about a since it must work for any a at
              all. There's very limited things that can fit into any a at all,
              two that come to mind are error "foo" and undefined.

<jle`> to show a contrast, the expression `id 5 + 2` and the expression `7`
       and the expression `const 7 2` are all *different expressions*
<jle`> but, they represent the "same" value                             [15:16]
                                                                        [15:17]
<jle`> the full rules of what are allowed in an expression, and what name each
       part has, is described in the Haskell Report in a pretty clear way

<jusss``> jle`: const id, what this id 
<jle`> on the expression level, that a "function application" expression
<jle`> Apply (VarId "const") (VarId "id")

<jle`> (if you're familiar with how ADT's and constructors work in Haskell)
<jusss``> f = const id,   and const id :: b -> (a ->a)     the id are same?
                                                                        [15:19]
<yushyin> MarcelineVQ: no I was just dumb not realising that this is of course
          valid haskell syntax, I am just not entirely awake :D

<jusss``> in f = const id, id is a value I can undertand, that left-value
          right-value things in C or other language,                    [15:20]

<wolfman154> dmwit: ok, I think this paste bin link is correct, now where,
             how, and what key binding do I need to add to gracefulExit?
             https://hastebin.com/uratufurez.rb
<jle`> "f = const id" is actually a different type of syntactic construct:
       it's *declaration* syntax
<jle`> again, this is all described in the report

<jle`> declaration syntax goes like: <name> <pattern> = <expression>    [15:21]

<jle`> (zero or more patterns allowed)
<jle`> so the right hand side of the = is expression syntax.  the left hand
       side is name and zero or more patterns

<jle`> so in this case, f is the name, there are zero patterns, and the
       expression on the right hand side is (in psuedo-ADT) Apply (VarId
       "const") (VarId "id")                                            [15:22]
<jle`> both 'const' and 'id' are "variable identifier" expressions

<jle`> and 'const id' is an 'application' expression, which takes two
       expressions (here, VarId "const" and VarId "id") and returns a new
       expression                                                       [15:23]

<jle`> if you're familiar with ADTs, it's kind of like data Expr = VarId
       String | NumLit Integer | Apply Expr Expr | ... many other constructs,
       all defined in the report

<jle`> and we have something like data Declaration = Dec { decName :: String,
       decPatterns :: [Pattern], decExpr :: Expr }. in a simplified form :)

<jle`> so `f = const id` would be Dec { decName = "f", decPaterns = [],
       decExpr = Apply (VarId "const") (VarId "id") }, to make the link clear
<jle`> note that all of this is just *syntax*. it doesn't have anything to do
       with the meaning of any of these expressions or declarations



############################################################

<jusss> List a -> (a->b) -> List b, so List is a Functor, but why function is
        Functor?

<jusss> (a->b) -> (b->c) -> (a->c)?                                     [13:15]

<jackdk> r -> a is the same as (->) r a, so it has the right kind (with f ~
         (->) r)                                                        [13:16]
<jackdk> then you have fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
<jackdk> i.e. fmap :: (a -> b) -> (r -> a) -> (r -> b)

<jusss> I wonder is there a type called Function? so Function a -> (a->b) ->
        Function b                                                      [13:17]

<jusss> fmap :: (a -> b) -> (r -> a) -> (r -> b)    a and r is the same type?
<jackdk> no
<jusss> but (a->b) and (r->b) is the same type?
<jackdk> no
<jackdk> a, b, r are all potentially different types
<jusss> but List a and List b are both List type                        [13:19]

<jackdk> List a and List b are different types

<jackdk> because a is not necessarily the same as b

<jle`> jackdk: you can make something like your Function
<jle`> type Function r = (->) r
<jackdk> true.                                                          [13:21]
<jle`> ah sorry, that was meant to pinging to jusss 
<jackdk> no worries mate
<jle`> so you get something like (Function r) a -> (a -> b) -> (Function r) b
<jusss> List a and List b both are derived by List?
<jle`> 'List a' is a list of a's
<jusss> and (a->b)?                                                     [13:22]

<jle`> an (a -> b) is a function from 'a' to 'b'                        [13:23]
<jusss> (a->b) is (->) a b       and (r->b)  is  (->) r b?
<jle`> yes
<jle`> just like:
<jle`> > (+) 1 3
<lambdabot>  4

<jackdk> % :k (->) Int Char
<yahb> jackdk: (->) Int Char :: *

<jusss> how I to see (->) a b?     ((->) a) b  or (->) (a b)  ?
<jle`> both ways have advantages in different situations                [13:25]
<jle`> ah, but (->) (a b) is wrong

<jusss> (a b) just mean a and b is one thing, not tuple stuff           [13:26]
<jle`> (a b) is a "applied" to b
<jle`> like (List b)
<jle`> `((->) a) b` is not the same as a -> b                           [13:27]
<jusss> that's kind like lisp

<jle`> yeah, if you're asking about haskel syntax, then it's not the same
       thing
<jle`> it's just liek how `((+) 1) 3` is not the same as (+) (1 3)
<jle`> in haskell                                                       [13:28]

<jusss> let's go back to that Function r
<jusss> type Function r = (->) r       so Function r a is (->) r a  and is r
        -> a?
<jle`> yes
<jle`> or also ((->) r) a, if we add extra redunant parentheses         [13:30]
<jle`> in haskell, `f a b` is parsed as `(f a) b`
<jusss> so can we know  (r->a ) -> (a -> b) -> what?

<jle`> if you're drawing the analogy to List a -> (a -> b) -> List b    [13:31]
<jusss> yeah
<jle`> we have ((->) r) a -> (a -> b) -> ((->) r) b
<jle`> or (r -> a) -> (a -> b) -> (r -> b)                              [13:32]
<jusss> and that's true?
<jle`> by true, do you mean it exists as a possible function?

<jusss> that's no need

<jusss> so I wonder what's the term function?    -> is function or (->) r is
        function?

<jusss> or (->) r a is function
<jle`> (r -> a) is the type of a function
<jle`> (->) is the function type constructor, used to create function types
<jle`> 'create' as in, specify                                          [13:34]

<jle`> and `(->) r` is the Functor

<jusss> what's r here?                                                  [13:35]
<jusss> what's r in `(->) r` ?
<eiGHttt> % :k (->)
<yahb> eiGHttt: (->) :: * -> * -> *
<jle`> it's a type variable here                                        [13:36]
<geekosaur> the type of the parameter the function takes.
<jle`> in this discussion, it means that what we are saying is valid for any
       type
<jle`> so it's true for (->) Int, true for (->) Bool, etc.
<jle`> and a function of type (r -> a) is a function that takes an 'r' and
       returns an 'a'                                                   [13:37]
<jle`> so a function of type (Int -> String) is a function that takes an Int
       and returns a String
<jusss> the thing is (->) must have two type variables?                 [13:38]
<jusss> (->) is a type constructor, ok, I can understand,  r is a type
        variable, ok, that's fine, but why need another type variable a?
                                                                        [13:39]
<geekosaur> when fully applied

<geekosaur> note that the Functor typeclass wants something that is *not*
            fully applied, since it supplies an additional type
<geekosaur> so a Functor instance would be for ((->) r), because it will add
            the a itself
<geekosaur> but the type constructor is (->) r a

<jusss> the type constructor should only be (->) ?
<geekosaur> I'm not sure what you're asking
<jle`> jusss: the type of a function is a -> b
<jusss> (->) r a is a type, a function type, and (->) is the Functor, and r
        and a both are type variables?                                  [13:43]
<jle`> (->) r is the Functor

<geekosaur> the type constructor is (->). being a symbol, it is normally
            infix, although the parentheses around it make it act as
            prefix. it takes two parameters, each a type (or type variable)

<jusss> so (->) is the type constructor, and (->) r is the Functor?
<jusss> and (->) r a is the type ?                                      [13:45]
<jusss> I even don't know what I'm talking about...

<jle`> they are all "types", but only r -> a is the type of functions

<jle`> for some r and a
<jusss> for example, data T a -> V a, I know that T is the type constructor
        and that a is type variable, V is the value constructor , and T a is
        the type of the value (V a)                                     [13:47]

[ 4 15 2019]
<jle`> do you mean data T a = V a
<jusss> "<jusss> for example, data T a -> V a, I know that T is the type
        constructor  and that a is type variable, V is the value constructor ,
        and T a is   the type of the value (V a)"  

<jusss> jle`: yeah                                                      [13:49]
<jusss> my network just broken
<jusss> let's be clear something, function do have a type, right? like r->a is
        a type of function
<jusss> and (->) is a type constructor, just like T in data T a = V a?  [13:52]

<jle`> right, a function (like even :: Int -> Bool) has something of type ??
       -> ??                                                            [13:53]
<jle`> and (->) is the type constructor, the syntactical thing that allows us
       to specify function types

<jusss> and ->) r  is Functor, (->) r a -> (a -> b) -> (->) r b like List a
        ->(a->) -> List b,right?
<jusss> even::Int -> Bool , the type is Int -> Bool , right?            [13:54]

<jusss> and even is also a function                                     [13:55]
<jle`> (->) r a -> (a -> b) -> (->) r b is analogous to List a -> (a -> b) ->
       List b, yes
<jusss> jle`: but?
<jle`> no but :)
<jusss> jle`: as you said, it's not need for the same, so?
<jle`> although it might be more accurate to say that `(->) r` is "a" Functor.
<jle`> jusss: oh, i was mentioning that in case you had a typo in what you
       said                                                             [13:56]
<jle`> you wrote List a -> (a ->) -> List b, missing the 'b' in the middle
<jusss> do I?
<jle`> `(->) r` is just r "applied" to (->), like `f x` is x applied to f
<jle`> but, it happens to also have a Functor instance
<jle`> just like how Int happens to also have an Eq instance

<jusss> now, the term function , what it is?  (-> r a) is the function's type?
        and it is function?
<jle`> (->) r a, not (-> r a)                                           [14:00]
<jusss> oh, my typo

<jusss> yeah, what's the term function?                                 [14:01]
<jusss> r->a is a type, r-> is Functor, -> is type constructor
<jusss> and what is function now?
<jle`> here we're shifting from the discussion of general syntax to specific
       types
<glguy> Functions are values you can apply to arguments                 [14:02]
<jle`> a function in haskell is something that, given a value, returns a new
       value.  it'll give the same output for the same value input
<jle`> you apply them using syntax like `f x`, or:
<jle`> > even 7
<lambdabot>  False
<glguy> Or similarly they can be types you can apply, depends on the level
        you're asking about
<jle`> these types of functions are values in haskell, like 1, True, "hello",
       7.8, 'a', etc.                                                   [14:03]
<jle`> and like all values, they have types.  the types are of the form ??? ->
       ???
<jle`> or 'a -> b', where a represents the type of the input they expect, and
       b represents the type of the values they return

<jusss> and we can not represent function with r->a ?                   [14:04]

<glguy> (->) r , happens to be an instance of Functor, (->) is a type, a type
        constructor, an instance of some type classes, a function at the type
        level
<jle`> functions have type r -> a, for some r and some a

<jle`> all functions have a type of the form __ -> __
<jle`> so 'r -> a' can't be a function, but it is the *type* of a function
       from r to a                                                      [14:05]
<jusss> and we can not describe that functions with their type?
<jle`> we can :)
<jle`> if r is Int, and a is Bool, then `even` is a function of type Int ->
       Bool
<jle`> remember, r and a here are just placeholders for actual types we want
       to use them with                                                 [14:06]
<jusss> yeah, 
<jle`> so `even` is Int -> Bool, or r -> a, where r is Int and a is Bool
<MasseR> totally unrelated to anything, but jle` thank you for your blog, it's
         really entertaining
<jle`> er, even has type Int -> Bool
<jle`> MasseR: hah, thank you, i really appreciate it :) hopefully it is
       helpful as well, haha
<jusss> jle`: and Int->Bool is the type of function even, 
<jle`> yes. or well, to be specific, it's one possible type, since 'even' in
       haskell is polymorphic
<jle`> maybe a better example is `ord :: Char -> Int`
<jusss> I still have a little confused about Int ->  is the Functor     [14:09]
<jle`> "a" Functor :)
<jusss> whatever, my English is not good
<jle`> not trying to correct your english

<jle`> just saying that the two things have different implications :)

                                                                        [14:10]
<MasseR> (one of the many functors vs the one and only functor)
<jusss> Int -> Bool, can I think a Functor need a type variable to constrct a
        type?
<jle`> jusss: when we say something is 'a' Functor, the implication is that
       it's just a regular old type that we have the opportunity to write a
       Functor instance for                                             [14:11]

<jle`> jusss: right, a Functor is a parameterized type
<jusss> and all the Functor are type constructors?
<jle`> so (Int ->) is parameterized on the 'result'
<glguy> no

<glguy> Type constructor is a category of names, it doesn't tell us about the
        kinds                                                           [14:12]
<glguy> Int is a type constructor and not an instance of Functor
<glguy> (Either Int) is an instance of Functor and not a type constructor

<jusss> err..  (->) r is a Functor,   (->) r is a type constructor?
<glguy> There are constructors and variables
<jle`> (->) is the type constructor in this situation
<glguy> No, (->) r is neither not a constructor or a variable

<jle`> `(->) r` is r applied to the type constructor (->)               [14:14]
<jle`> like how `even 5` is 5 applied to the function `even`
<glguy> No, (->) r is neither a constructor nor a variable*

<jle`> or maybe to make a stronger analogy, how `V True` is True applied to
       the data constructor V, from your example earlier                [14:15]
<glguy> V True is "V applied to True"
<jle`> ah thanks. oh man i mixed this up the entire time

<MarcelineVQ> it is pretty late at night for you flesh and blood's      [14:16]

<glguy> Look at the bot showing off :-p

<MarcelineVQ> @botsnack
<lambdabot> :)

<jusss> fine, maybe I should just take r-> is a Functor and no more questions
<jusss> jle`: glguy really thanks                                       [14:18]

<glguy> jusss: The definition of functor is (simplified): class Functor (f ::
        * -> *) where fmap :: (a -> b) -> (f a -> f b)
<glguy> Because the 'f' parameter has kind * -> * we know we'll be able to
        apply it to a type with kind *                                  [14:19]
<glguy> when you were asking about functors being type constructors what you
        were really getting at was that instances of the Functor class will
        always have kind * -> *

<eiGHttt> why is (Either Int) not a type constructor? it has kinds * -> *.
<glguy> The reason that this class expect a type with kind * -> * is that the
        type of fmap needs to use f applied to some types
<Cale> Because it's a type application, not a constructor

<glguy> eiGHttt: type constructor is a kind of name

<glguy> the capitalized ones
<jusss> glguy: and "function is a Functor" is wrong? 
<Cale> Either is a type constructor, and Int is a type constructor, but Either
       Int is an application (of one type constructor to another)       [14:21]

<jle`> jusss: it's more of a synecdoche. it's "wrong", but most people will
       know what you mean
<jle`> `(->) r` is a Functor, and it's the functor people often talk about
       when referring to functions

<eiGHttt> thanks.
<glguy> ?wn synecdoche
<lambdabot> *** "synecdoche" wn "WordNet (r) 3.0 (2006)"
<lambdabot> synecdoche
<lambdabot>     n 1: substituting a more inclusive term for a less inclusive
            one
<lambdabot>          or vice versa

<jusss> jle`: they describe List for helping people to understand what functor
        is, so I think a function is a container?                       [14:23]
<jusss> or wrapper  box whatever
<jle`> do you mean, a functor is a container?
<jle`> i think it's safe to say that *some* functors represent containers. but
       not all.

<jle`> List being a Functor makes it convenient to manipulate values inside it
<jusss> "A functor is a container of type a that, when subjected to a function
        that maps from ab, yields a container of type b." from
        https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor
<jusss>
        http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
<jle`> i don't think that is strictly always true, but it's an intuition
       people often start with
<jle`> not all functors are containers.

<jle`> er, not all functors correspond to containers, i mean            [14:25]
<jle`> but a lot of containers correspond to functors
<Cale> It's also a bit imprecise to say that any functor is a container. It
       might produce types of containers.
<Cale> [1,2,3] isn't a functor
<Cale> But the type constructor for lists is a functor

<jusss> List a, List is a Functor
<jle`> right, i think 'functors are containers' is pretty misleading, it lead
       to a lot of headache for me when i started
<jle`> but, i understand the sentiment
<Cale> But there is a sense in which all the functors we talk about in Haskell
       can be thought of as containers, it just gets really weird for some of
       them
<jle`> it does break down for things like (->) r

<Cale> It doesn't really
<jle`> it breaks down in the sense that it doesn't add anything to the
       conversation                                                     [14:27]
<Cale> A function r -> a is like a container indexed by all the values of type
       r, containing values of type a
<kadoban> Don't you end up defining "container" as pretty much exactly
          Functor, leading to the intution helping basically not at all?
<jle`> "r -> a is a container, in the sense that exactly matches what an r ->
       a is"

<Cale> You can imagine functions in this way, as sort of "arrays"
<Cale> (or arrays as functions, for that matter)
<Cale> It can be useful to have that perspective                        [14:28]
<wolfman154> xmonad recompile is throwing an error, could you guys help me
             out:   https://hastebin.com/zelizutubi.coffeescript
<jusss> what that functor is used for?
<Cale> Well, that's basically asking "what does fmap do for that functor?"
                                                                        [14:29]
<Cale> and if we write down its type, it will become clear what it must be
<Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)

<Cale> That has to be function composition

<jusss> Cale: the middle (e->a) , why it must return a?
<Cale> Well, let's look again at the general type of fmap
<Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
<Cale> In this case, f a = e -> a
<wolfman154> I have no idea what Im doing wrong?
<Cale> wolfman154: You didn't paste the error                           [14:31]
<jle`> jusss: all functor instances are useful in their own sense.  List is
       useful, for example, to...well, make a list of things :)
<jle`> jusss: but functor, as an abstraction, is useful for uniting a bunch of
       these under a common, clean interface
<jle`> and it also lets you do some nice program rewriting

<jle`> for example, fmap f (fmap g x) is always the same as fmap (f . g) x
<Cale> In the container analogy from before, we see function composition as
       taking some function (a -> b) (which you can think of however you
       like), and some function of type (e -> a), which we think of as a
       container containing many values of type a, one for each value of type
       e
<Cale> and applying the function (a -> b) to each of the values of type a,
       ending up with a container indexed by values of type e, containing
       values of type b                                                 [14:33]
<jusss> jle`: and there's no fmap in other languages, unless g and x is lists,
        so map it is
<Cale> But of course, the code for it doesn't require so many words :)
<jle`> well, a lot of other languages have fmap's *specific* for each type
<Cale> (g . f) x = g (f x)
<jle`> but most other language ecosystems don't have a single unifying fmap
       for all functors

<Cale> wolfman154: ?
<jusss> I wonder what is (a->b) -> (b->c) -> (a->c) ? and does it exists?
<jusss> or just my illusion                                             [14:35]
<Cale> That exists, that's the same thing with the other argument order.
<wolfman154> https://hastebin.com/upatuyofip.sql

<Cale> wolfman154: ahhh
<jle`> jusss: it's function composition :)
<jle`> it's (>>>), as well                                              [14:36]

<Cale> wolfman154: Your error is not for the same code as you pasted
<jle`> > ((+1) >>> (*2)) 10
<lambdabot>  22
<eiGHttt> wolfman154: main = xmonad $ defaultConfig {...}

<Cale> Yeah, the code he pasted had the $
<jle`> jusss: in all honesty, the FUnctor instance of (->) is not very useful
       on its own.  you will never directly use fmap for (->) in everyday code
<jusss> jle`: ok
<Cale> The $ should fix things
<jle`> sorry, i mean, for (->) r
<jle`> we talk about it here in the sense "just because we can"         [14:37]
<jle`> "(->) r "can" be a Functor, so let's talk about it" :)
<Cale> It can certainly be useful for code golf
<Cale> haha
<jle`> but, `(->) r` having a Functor instance is useful when we use
       functor-polymorphic abstractions
<wolfman154> One second 
<MasseR> jle`: I occasionally use it with lenses and applicatives.
<jle`> that is, programs that are written to work for "all" functors
<jle`> Haskell has a lot of code that is written to work for 'all' Functor
       instances                                                        [14:38]
<jle`> so because we give (->) r an instance, all of that code is now usable
       by us
<jusss> jle`: I wonder what it's like ? the instance of (->) r 
<jusss> for example? any concret stuff
<wolfman154> Cale: I pasted and saved the new code but for some reason xmonad
             is trying to recompile the code from before? Maybe I need to do a
             rebuild switch instead in nixos?
<jle`> jusss: we can just peek at the implementation :)
<Cale> wolfman154: no idea
<jle`> fmap :: (a -> b) -> (r -> a) -> (r -> b)                         [14:41]
<wolfman154> Strange 
<jle`> fmap f g = \x -> f (g x)
<Cale> wolfman154: But that seems likely? Maybe it's getting the compiled code
       from the nix store
* hackage rio 0.1.9.2 - A standard library for Haskell
  https://hackage.haskell.org/package/rio-0.1.9.2 (MichaelSnoyman)
<Cale> Well, except that also doesn't make sense
<Cale> because you have a compile error                                 [14:42]
<Cale> So maybe it stashed source code into the nix store and is trying to
       build that?
<jusss> jle`: wait a second, f is (a->b) and g is (r->a) right?         [14:43]
<jusss> how we can get that lambda from (r->b)?
<Cale> x :: r
<jle`> check the types :)
<Cale> g x :: a
<Cale> f (g x) :: b                                                     [14:44]
<Cale> \x -> f (g x) :: r -> b
<wolfman154> Cale: my guess is that Im not supposed to do xmonad recompile,
             instead nixos-rebuild switch (to have nixos compile it for me) ? 
                                                                        [14:45]
<Cale> No idea, I don't use nixos
<Cale> (nor xmonad, for that matter)
<wolfman154> Cale: it works
<wolfman154> :)
<Cale> cool
<Cale> jusss: Here's an example of the (->) e monad in use              [14:47]
<jusss> Cale: from \x -> f(g x) :: r->b to know x is r and f(g x) is b, that's
        ok, but how to get there b to f(g x)
<Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
<lambdabot>  ("hello","olleh","HELLO")
<Cale> I don't understand that last question
<Cale> "how to get there b to f (g x)"                                  [14:48]
<Cale> what?
<jusss> how to get the b from fmap :: (a -> b) -> (r -> a)
<Cale> That's not fmap's type
<Cale> fmap :: (a -> b) -> (r -> a) -> (r -> b)                         [14:49]
<Cale> or
<Cale> fmap :: (a -> b) -> (r -> a) -> r -> b
<jusss> to b is fmap(g r)
<Cale> If you prefer to remove the redundant paren
<Cale> So if we define
<Cale> fmap f g x = ...
<Cale> then f :: (a -> b)
<Cale> and g :: (r -> a)
<Cale> and x :: r                                                       [14:50]
<Cale> and the ... on the right must have type b
<jusss> and that's ok, the b
* hackage fedora-img-dl 0.2 - Fedora image download tool
  https://hackage.haskell.org/package/fedora-img-dl-0.2 (JensPetersen)
<Cale> and there's only one way to get a value of type b using the things we
       have
<jusss> \ r ?
<Cale> which is to use f
<Cale> So
<Cale> fmap f g x = f (...)
<Cale> where now the ... has type a
<Cale> and there's only one way to get something of type a, which is to use g
                                                                        [14:51]
<Cale> fmap f g x = f (g ...)
<Cale> and now the ... has type r
<Cale> and we have something of type r, namely x
<Cale> fmap f g x = f (g x)
<Cale> done
<Cale> and there were no real choices to be made
<Cale> We can move the parameter to the other side of the equation if we like:
                                                                        [14:52]
<Cale> fmap f g = \x -> f (g x)
<Cale> it means the same thing
<jusss> err...
<jusss> fmap :: (a->b) -> (r->a) -> (r->b)       so  fmap (a->b) (r->a) =
        (r->b)                                                          [14:56]
<Cale> Try not to mix the notation for types and terms
<Cale> But yeah
<jusss> f::a->b  g::r->a  we got fmap f g = (r->b)
<Cale> fmap (f :: a -> b) (g :: r -> a) :: r -> b                       [14:57]
<Cale> yeah
<jusss> what I don't understand is how through (r->b) to get \x -> f (g x) or
        say how from b to (a->b) (r->a  r)
<jusss> aha,
<jusss> I can think (a->b) (r->a) a is b,    but reverse it, I can not  [15:01]
<Cale> The rule for lambda is that if from assuming that x has type a, we can
       derive some expression e of type b, then \x -> e will have type a -> b
                                                                        [15:02]
* hackage haiji 0.2.3.0 - A typed template engine, subset of jinja2
  https://hackage.haskell.org/package/haiji-0.2.3.0 (NoriyukiOhkawa)
<jusss> yeah, I know that, the direction, expand b to f (g x) , not easy for
        me, but f (g x) to b is easy
<jusss> it's kind like 1 + 1 = 2, but 2 = 1 + 1 is not easy
<wolfman154> Do any of you guys know the link to change xmonad key bindings, I
             cant find find the link geekasaur sent me earlier 
<wolfman154> Never mind I found it   :)                                 [15:12]
<Cale> jusss: Did you follow my explanation of how to write it?
<Cale> jusss: In general, this way of making types line up is not *always*
       going to result in the program you want, but it's fairly effective at
       restricting your options.                                        [15:14]
<Cale> In this case, there was only one program we could have written.
<jusss> Cale: you remove fmap on the right of = and move x from right of = to
        left, that's what I don't understand 
<jusss> yeah, I did follow you example, 
<Cale> You mean when I went from                                        [15:15]
<Cale> fmap f g x = f (g x)
<Cale> to
<jusss> <Cale> fmap f g x = f (...)
<Cale> fmap f g = \x -> f (g x)
<Cale> jusss: That step there                                           [15:17]
<Cale> was the result of looking at the types of things we had, and the type
       of thing we wanted
<Cale> (as were most of the steps, to be honest)
<jusss> it's kind like math stuff
<Cale> It's exactly like logic                                          [15:18]
<jusss> if fmap (a->b)  (r->a) =  (r->b)  and f = a->b ,   g= r->a
<Cale> In logic, if you want to prove A -> B (that is, "if A then B" or "A
       implies B"), you may start by assuming A, and trying to obtain B.
<jusss> so what b is ?                                                  [15:19]
<Cale> In lambda calculus (or Haskell), if you want to construct a function of
       type A -> B, you may start by introducing a variable x of type A, and
       trying to obtain an expression e of type B
<Cale> and then \x -> e has type A -> B
<Cale> In logic, if you know A and you know A -> B, then you may conclude B
<Cale> In lambda calculus (or Haskell) if you have x :: A, and f :: A -> B,
       you may apply the function to obtain  f x :: B
<jusss> if fmap (a->b)  (r->a) =  (r->b)  and f = a->b ,   g= r->a, then how
        to express b with f and g                                       [15:21]
<Cale> Well, you're trying to construct a function of type r -> b
<Cale> so it might as well be a lambda
<Cale> \x -> ...
<Cale> now you have x :: r                                              [15:22]
<Cale> and you need to construct something of type b
<Cale> The only way to construct something of type b is to apply f
<Cale> \x -> f ...
<Cale> and now you need something of type a
<Cale> and the only way to construct something of type a is to apply g  [15:23]
<Cale> \x -> f (g ...)
<Cale> and now you need something of type r, which you have, it's x
<Cale> \x -> f (g x)
<Cale> Make sense?                                                      [15:24]
<jusss> g -> f will get (r->a) -> (a->b)  so (r-> b)?  and (r->b) = g -> f and
        b is?
<Cale> That doesn't quite make sense to me
<Cale> What did you mean to indicate by g -> f there?
<jusss> 'cause g = (r->a)                                               [15:26]
<Cale> f and g were terms
<Cale> a, b, r, are types
<Cale> they live in different namespaces
<jusss> yeah, I mixed them,    and -> =
<Cale> g :: r -> a
<Cale> not g = r -> a
<jusss> whey they don't use the same symbols?                           [15:27]
<Cale> Types and terms?
<jusss> yeah
<Cale> Because it doesn't take you very far
<Cale> We're already more punny with it than we ought to be
<Cale> Using (Int, Char) for the type of pairs of an Int and Char, for example
<Cale> rather than for a pair of types                                  [15:28]
<jusss> I mean -> and =
<Cale> Which -> is that?                                                [15:29]
<Cale> There's an arrow at the type level, which constructs the type of
       functions
<jusss> use ->  in type and use = in function
<Cale> and there's an arrow at the term level which is part of the syntax of a
       lambda expression
<Cale> and we can also use equations in order to define functions and other
       values
<jusss> ok,                                                             [15:31]
<jusss> it's really interesting we can get the right part of '=' from the left
        part of '=' through the type signature                          [15:32]
<Cale> Well, when two expressions are equal, they must have the same type
<Cale> So if the left side of our equation is fmap f g, whatever its type is
       must be the type of the right hand side of our equation.         [15:36]

######################################################################

#Prototype #prototype #constructor #js

Array.prototype.add =
    function(x) {
        var results = [];
        for (var i=0; i < this.length; i++) {
            results.push(this[i] + x)
        }
        return results;
    }

[1,2,3].add(5)
Array [ 6, 7, 8 ]

//change the prototype, and it has affect all the linked object, OO based on prototype
//change the super-class, it won't change the created object, OO based on class

// in python, constructor is __new__
//in js, constructor is

class Whatever {
    constructor(init_value) {
        this.value = init_value
    }
    add(x){
        return this.value + x
    }
}

n = new Whatever(9);
n.add(3)

//before ES6, same as
var Whatever = function(init_value) {
    this.value = init_value;
    this.add = function(x) {
        return this.value + x
    }
 }

n = new Whatever(9);
n.add(3)

//https://www.w3schools.com/js/js_object_constructors.asp
//https://www.quora.com/What-is-a-constructor-in-JavaScript

################################################################

https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus
https://qfpl.io/posts/fp-cheat-sheet/#sequence-on-maybe-with-list

class Employee:
    def get_boss(self):
        """Retrun the employee's boss"""

    def get_wage(self):
        """Compute the wage"""

result = None
if john is not None:
    boss = john.get_boss()
    if boss is not None:
        wage = boss.get_wage()
        if wage is not None:
            result = wage
print(result)

def unit(e):
    return e

def bind(e, f):
    return None if e is None, else f(e)

print(bind(bind(unit(john), Employee.get_boss), Employee.get_wage))
https://zhuanlan.zhihu.com/p/58514370
#####################################################
Monad:
bind >>=  flatMap   (>>=) :: m a -> (a -> m b) -> m b
return unit pure    return :: a -> m a
join :: [[a]] -> [a]    k >>= x = join (fmap k x)    bind(k,x)=join(fmap k x)
functor : map fmap <$>
applicative: ap <*>

########################################################

f= x => y => x+y
function f()
f(3)(4)
7
[3].map(f)
Array [ f() ]
var wrappedPlus3 = [3].map(f)
undefined
wra
ReferenceError: wra is not defined[Learn More] debugger eval code:1:1
wrappedPlus3
Array [ f() ]
[2].map(wrappedPlus3[0])
Array [ 5 ]

############################################################
Download video from v.qq.com
1. firefox install video downloader professional by startpage24 from
https://addons.mozilla.org/en-US/firefox/addon/video-downloader-profession/?src=search
2. visit that v.qq.com and click that download icon on the toolbar, click that "Play video",
it will pop up a new window and play the video, wait for the video's play is done,right click on it and choose "save video as" to save to mp4 file on local.

############################################################

http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
https://zhuanlan.zhihu.com/p/58514370
https://wiki.haskell.org/Typeclassopedia
https://stackoverflow.com/questions/44965/what-is-a-monad
https://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/

#######################################

Promise Future Continuation Monad
Promise Future ContinuationMonadMonadContinuation

##############################################################


https://stackoverflow.com/questions/44965/what-is-a-monad

What is a monad? The short answer: It's a specific way of chaining operations together.


A monad is a datatype that has two operations: >>= (aka bind) and return (aka unit). return takes an arbitrary value and creates an instance of the monad with it. >>= takes an instance of the monad and maps a function over it.

A monad is essentially just a functor T with two extra methods, join, of type T (T a) -> T a, and unit (sometimes called return, fork, or pure) of type a -> T a. For lists in Haskell:

join :: [[a]] -> [a]
pure :: a -> [a]

You can write a function that does map, then join. This function is called bind, or flatMap, or (>>=), or (=<<). This is normally how a monad instance is given in Haskell.

<jusss> LdBeth: functor monad?
<LdBeth> jusss:  type class                                       [09:45]
<LdBeth>  parametric polymorphism
<LdBeth> 
<LdBeth> 
<LdBeth>                          [09:46]
<jusss> LdBeth: monad, unit/bind
        unit/join                                     [09:58]
<jusss> 
<jusss> https://zhuanlan.zhihu.com/p/58514370                           [09:59]
<anotitlebot> 15  Monad - 
<jusss>
        https://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/
<anotitlebot> Monads for the Curious Programmer, Part 1 | Bartosz Milewski's
              Programming Cafe
<jusss> 
<LdBeth>                                        [10:02]
<LdBeth>                                            [10:03]
<LdBeth>  Monad 
                                                                    [10:04]
<LdBeth>  class  functor class  semigroupmonad 
         subclass                                                       [10:05]
<LdBeth> functor  fmapsemegroup  mempty  mconcat
                                                                        [10:07]
<LdBeth>  monad 
<LdBeth>  monad 
<LdBeth>  monad 


#######################################################

fmap in python
because python is call by value, and haskell is call by name
fmap = (a->b) -> f a-> f b   is fmap=(a->b) -> f(a) -> f(b)
so turn f to a class, f(a) is a instance of class 
class Functor (ABC)
  @abstractmethod
  def fmap(self, f)

class XX(Functor)

def fmap(f,x)
  return x.fmap(f)

#############################################

#gif
https://gifmaker.me/

#############################################################

#fullscreen #css #img 

#dw_haituo {
    width: 1280px;
    height: 800px;
}

<div id="dw_haituo" onclick="f2()"> 
            <img src="img/show/dw/yudu-01.png" height="800px" width="1280px" />
</div>


########################################
map is used for a list,  fmap is used for a function

map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs

class Functor (f :: * -> *) where
  fmap :: (a -> b) -> f a -> f b

foldl or foldr is like reduce

####################################################

Elm MVC

Event -> trigger ->Update function -> update Model -> create View

Event will trigger a message and send it to Update function,
in the Update function, it will check what message it is and make a choice
to change the Model,  Update function take Msg and current Model as parameter
and return a new Model, the new Model will cause View's change

message -> update -> model -> view

Model: status the things show on the front and will change
Message: event, button click, mouse swip

view create Msg -> update take Msg and change Model -> view take new Model

module Hide exposing (..)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)
import Browser

type Msg = Hide | Show
type alias Model = String

--model : Model
--model = "block"
initModel:Model
initModel="block"
    
view : Model -> Html Msg
view model = div [ ]
             [ button [ onClick Hide] [ text "Hide" ]
              , h1 [ style "display" model ] [ text "hi" ]
              , button [ onClick Show ] [ text "Show"]
              ]

update : Msg -> Model -> Model
update msg model =
     case msg of
         Hide -> "none"
         Show -> "block"

main = Browser.sandbox {
          init = initModel
         ,update = update
         ,view = view
          }


###############################################

f::Int->Int
f(0)=0
f(1)=1
f(n)=f(n-1)+f(n-2)

f(42) just stuck

https://wiki.haskell.org/The_Fibonacci_sequence

f(5) = f(4) + f(3)
f(4)=f(3)+f(2)
f(2)=f(1)+f(0)
f(5)= f(1)+f(0)+f(1)+f(0)+f(1)+f(0)...+f(0)+f(1)
f(42)=f(1)+f(0)+(f1).... 01
O(f(n)),
f = 0:1:zipWith (+) f (tail f)


#tail #recursive #haskell
Prelude> :{
Prelude| l :: Int -> Int -> Int -> Int
Prelude| l 0 a b =a
Prelude| l 1 a b =b
Prelude| l n a b= l (n-1) b (a+b)
Prelude| :}
Prelude> l 22 0 1
17711
Prelude> l 1 0 1
1
Prelude> l 3 0 1
2
Prelude> l 5 0 1
5
Prelude> 


Prelude> :{
Prelude| t :: Int -> Int
Prelude| t 0 =0 
Prelude| t 1=1
Prelude| t n=n+t(n-1)
Prelude| :}

<Ariakenom> jusss: function application binds with "higher priority" than
            operators                                                   [16:25]
<Ariakenom> so if you want to read, you can start with function applications
            and put parenthesis around it
<jusss> ok                                                              [16:27]
<Ariakenom> f a b+1 = (f a) b+1 = ((f a) b)+1
<Ariakenom> jusss: using more parenthesis than necessary isn't a problem. if
            it's confusing just use parenthesis :)                      [16:29]
<jusss> Ariakenom: I see                                                [16:30]

##########################################################
position: absolute, sometime it won't hide element,  change it to fixed or relative or other something else,
the default position is static, you can set 'position: relative' as the default with ` * { position: relative; } `
https://stackoverflow.com/questions/4555982/absolute-positioned-div-not-hidden
Adding position absolute to an element will remove that element from the normal flow. It will position itself absolute to the closest parent that is relatively positioned.

position: static(default) fixed relative absolute sticky
static doesn't have top bottom left right, 
fixed has top bottom.. and it always keeps static
relative left bottom are relative to other element
the element below another element, it is negtive px
move top to down, it's negtive number px
move left to right, it's positive number px
float margin follows position:relative

https://www.cnblogs.com/zhuzhenwei918/p/6112034.html

#########################################################

HTML elements are positioned static by default.

Static positioned elements are not affected by the top, bottom, left, and right properties.

######################################

https://elmprogramming.com/model-view-update-part-2.html
https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md

Our sign-up form looks a bit ugly. Lets add some style. There are multiple ways to style a page in Elm:

    Using inline styles
    Using the elm-css package
    Using an external CSS file
    Using a CSS framework

##########################################################

https://elmprogramming.com/model-view-update-part-1.html

msg model update view

model changed -> view send message -> update -> model

in 0.16
main =
    beginnerProgram
        { model = initialModel
        , view = view
        , update = update
        }

in 0.19
main =
    Browser.sandbox
        { init = initialModel
        , view = view
        , update = update
        }

that model can be a record,
type alias User =
    { name : String
    , email : String
    , password : String
    , loggedIn : Bool
    }

type alias Model
    = User

initialModel : User
initialModel =
    { name = ""
    , email = ""
    , password = ""
    , loggedIn = False
    }

#npm install elm@0.16.0  you can install 0.16 elm

##############################################################

There are three ways in which Elm and JavaScript (JS below) interact: Port, Native module and programWithFlags. (Finally about the differences.)
Port is a mechanism to communicate with JS provided in Elm.
Prepare a function with only a name and type as follows in Elm, and execute it as Cmd / Sub.
port hello : String -> Cmd msg
port jsHello : (String -> msg) -> Sub msg

Then you can use it as follows on JS side.
const elm = document.getElementById('elm');
const app = Elm.Test.embed(elm);  // Launch the Elm application
// Subscribe from Elm to JS
app.ports.hello.subscribe(function(fromElm) {

  console.log(fromElm);
  // Send from JS to Elm
  app.ports.jsHello.send("Hi!");

});

// JS to Elm send
app.ports.jsHello.send("Elm! hellooooo");

It's pretty easy.
It is a correspondence table of the type of Elm and JS.
Elm 	Javascript
Bool 	Bool
String 	String
Int Float 	Number
List 	array
Arrays 	array
Tuples 	array()
Records 	object
Maybe (Nothing) 	null
Maybe (Just 42) 	42
Json.Encode.Value 	JSON

First change the top line from module to port module. (I forget about it and get angry with the compiler.)
port module Test exposing (..)
Note: Packages using the port module can not be published in Elm Package. You also need to install JS at the same time.

Publish Cmd from Elm to JS
Call out JS from Elm.

Elm side
port function_name: send_type-> Cmd msg
port hello : String -> Cmd msg

Write port to define the function name and type. At this time, type is send type-> Cmd msg. (The msg must be written in lower case.)
And this function is used by init function and update function.
init = "" ! [hello "Hello!JS!"]
If you write to init, the value will be sent to JS immediately after Elm initialization.

JS side
JS side registers and receives functions as ports.defined function name.subscribe. (I often forget the "s" in ports)
var elm = document.getElementById('elm');
var app = Elm.Test.embed(elm);
// Receive from Elm!
app.ports.hello.subscribe(function(str) {
  console.log(str);
});
Now I can call the JS code from Elm at my favorite timing.

Send from JS to Elm

Next, Elm passes the value from JS to Elm, and Elm receives it.

Elm side
port function_name: (type_ coming_ from_ JS-> msg)-> Sub msg
port jsHello : (String -> msg) -> Sub msg

Write and define the function (msg is lowercase).
The value coming from JS is Msg in Elm. So we define Msg type.
And use the function defined by port as follows.

type Msg = GetHello String  --Msg definition
port jsHello : (String -> msg) -> Sub msg     --JS-> Elm's port
main = program {... , subscriptions = subscriptions}  Used for the --subscriptions function.
subscriptions : Model -> Sub Msg
subscriptions model = jsHello GetHello         --
update msg model =
  case msg of
    GetHello str -> ...         The value from --JS is Msg.

JS side
JS side sends to Elm with app name.ports.function name.send (value to send).
app.ports.jsHello.send("hellooooo");  // Send to Elm

For example, call JQuery.
Finally, let's call JQuery from Elm.
I just wanted to have the ability to automatically scroll to the bottom like this on the chat screen. When I search Google, I get the JQuery code.
$ (Selector to scroll) .animate ({"scrollTop": $ (selector to scroll) [0] .scrollHeight}, scroll time);
JQuery is useful to be able to specify the scroll time and animation in a single line.
I will call it by port.
Elm
port scrollDown : () -> Cmd msg

update msg model =
    ...  -> ... ! [scrollDown ()]

consoleView =
    div [id "console"] [ ...]

js
const app = Elm.Main.embed(...);

app.ports.scrollDown.subscribe((_) => {

    $("#console").animate({"scrollTop": $("#console")[0].scrollHeight}, 5);

});
Now it scrolls as each letter is added to the screen.
In this way, if you use Port with Elm, you can use JS assets immediately.

trouble shooting
It seems to be a trade-off with Elm's scheduler, but once I wrote the process to extract the DOM after calling Elm, I could not extract it.
const App = Elm.Main.embed(document.getElementById("main"));

document.getElementById('hoge').addEventListener("pointerdown" , (event) => {
        console.log(event);
    });

It works by enclosing it with setTimeout.
setTimeout(function () {
    document.getElementById('hoge').addEventListener("pointerdown" , (event) => {
        console.log(event);
    });

}, 0);

Port and Native modules
programWithFlags is a mechanism to pass an initial value to Elm, about Port and Native modules.
I think that the Native module is used for wrapping api, and also for publishing it as an Elm package. And since the main web api is released as a library, if you want to use the JS code, you should be able to use a port.
The Native module is not supported (does not disclose how to use, api changes without announcement), and it is a policy provided only from the official side. Also, packages using Native are currently not available from Elm packages.
The reason for this (as summarized in my own interpretation) is that the Native module directly expands the JS code into the Elm runtime, so the runtime becomes more fragile as the library is expanded to the user. Elm also looks at things other than JS (web assembly), so I want to minimize JS so that various libraries don't seem to use code wrapped separately. It is around.
However, there are also cases where Native is more convenient, such as Test code, and sometimes it is redundant with Port. The following links will be helpful.
https://qiita.com/ento/items/10401fb27ca604491c10
https://qiita.com/k-motoyan/items/24f8b5f27ab828efb024
https://qiita.com/jooex/items/5ff2d3b86563cf5dbd84

#########################################
#Elm #elm #ports #port #Port #Ports
###############
https://qiita.com/jooex/items/5ff2d3b86563cf5dbd84

index.html
<!doctype html>
<html>
  <head>
    <title>WebSockets Hello World</title>
    <meta charset="utf-8" />
    <style type="text/css">
    </style>
	 <script src="main.js"></script> 
	  <script src="hello.js"></script>
  </head>
  <body>
  <div id="elm"></div>
 </body>
  <script>
  var app = Elm.Main.init({
    node: document.getElementById('elm')
  });
      app.ports.sayHello.subscribe(function(data) { console.log(data)});
	  //app.ports.jsHello.send("Elm! hellooooo");
	  toE = function(x) {app.ports.jsHello.send(x);};
    </script>
</html>
#############################################
Main.elm
port module Main exposing (..)

import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Browser exposing (sandbox)
type alias Model = Int

type Msg
  = Inc
  | Dec
  | GetHello String

model : Model
model = 0

port sayHello : String -> Cmd msg
port jsHello : (String -> msg) -> Sub msg 

init : flags -> ( Model, Cmd Msg )
init dataFromJSwhenInit = (model, Cmd.none)

update : Msg -> Model  -> (Model, Cmd msg)
update msg model2 =
  case msg of
    Inc ->
      (model2 + 1, sayHello "i")
    Dec ->
      (model2 - 1, sayHello "d")
    GetHello str ->
     (model2, sayHello str)


view : Model -> Html Msg
view model1 =
  div []
    [ button [ onClick Inc] [ text "Inc" ]
    , text (String.fromInt model1)
    , button [ onClick Dec ] [ text "Dec" ]
    ]

subscriptions : Model -> Sub Msg
subscriptions model3 = jsHello GetHello


main : Program () Model Msg
main =  Browser.element
       { init = init
       , view = view
        , update = update , subscriptions = subscriptions}
##############################################
hello.js
hello = (function(self) {
	self.hello = function(world) {console.log(world)};
	 return self;

})(window.hello || {});
	

##########################

http://vanilla-js.com/

####################


<jusss> ljharb: const ds = box.querySelectorAll("div");
ds is a node list, not array, so you can not do shift() pop() on a node list

#########################
turn ES6 code to ES5,
https://babeljs.io/

################################################

box=document.getElementById("box")
e=document.createElement("div")
box.appendChild(e)                      e.innerHTML="whatever";      e.style.display="block" or "none"
or use
var newDiv = document.createElement("div"); 
// and give it some content 
var newContent = document.createTextNode("Hi there and greetings!"); 
// add the text node to the newly created div
newDiv.appendChild(newContent);  
https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
####################################################
<style>
.box {
	position:'absolute';
	top:0px;
	left:300px;
	background-color: lightblue;
}

.box > div {
	display: none;
}
	
</style>
<body>
	<main id="box" class="box">
	</main>
</body>

var noticeStr = "";
var offset=100;
var offset_origin = offset;
var noticeList = noticeStr.split('');
const box = document.getElementById("box");
	
var ce = function(n){ if (n<0) {return;} else { box.appendChild(document.createElement("div")); ce(n-1)}};
ce(noticeList.length);
const textDiv = box.querySelectorAll("div");
var inner_html = function(_parentNode, character_list){ 
		
	for(i=0;i<=character_list.length;i++) {
		_parentNode[i].innerHTML = character_list[i];
	}
};
inner_html(textDiv,noticeList);
const showDiv = (div, k) => {
  setTimeout(() => {
	div.style.display = "block";
	offset = offset + 50;
	div.style.position = 'absolute';
	div.style.left = offset.toString() + "px";
	div.style.top = "0px";
	div.style.fontSize = "35px";
	div.style.color="white";
	k();
  }, 1000);
};

const show = ds => {
  if (!ds.length) {
	for (const d of textDiv) {
	  d.style.display = "none";
	  offset=offset_origin;
	}
	console.log("clearing");
	return show(textDiv);
  }
  
  const [div, ...rest] = ds;
  
  showDiv(div, () => show(rest));
};

show(textDiv);


#################################################
<html>
  <body>
    <main id="box" class="box">
      <div></div>
      <div></div>
      <div></div>
      <div>.</div>
    </main>
  </body>
</html>

.box {
  width: 100px;
  height: 100px;
  background-color: lightblue;
}

.box > div {
  display: none;
}

const box = document.getElementById("box");
const textDiv = box.querySelectorAll("div");

const showDiv = (div, k) => {
  
  setTimeout(() => {
    div.style.display = "block";
    k();
  }, 1000);
};

const show = ds => {
  if (!ds.length) {
    for (const d of textDiv) {
      d.style.display = "none";
    }
    console.log("clearing");
    return show(textDiv);
  }
  
  const [div, ...rest] = ds;
  
  showDiv(div, () => show(rest));
};

show(textDiv);
########################################
#fifth 
let iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}             for ( variable of iterable)

#fourth

[a, ...rest] = [42];     rest will be [], and rest.lengh is 0
!rest.lengh is true

#####################################
#third #css #selector #div #container
different signs (+,> and ~) in CSS selector
<div id="container">            
   <p>First</p>
    <div>
        <p>Child Paragraph</p>
    </div>
   <p>Second</p>
   <p>Third</p>      
</div>

div#container p{
font-weight:bold;
}   It will target all p tags within container div.

div#container > p {
  border: 1px solid black;
}  It will target all P element which are direct children of container div, not children of child div.

div + p {  
   color: green;  
} It is Adjacent sibling combinator. It combines two sequences of simple selectors
having the same parent and the second one must come IMMEDIATELY after the first.
It will only select the first element that is immediately preceded by the former selector.
In our example, it will target to Second ONLY because the owner P element comes just after Div tag.

div ~ p{
background-color:blue;
} It is general sibling combinator and similar to Adjacent sibling combinator.
the difference is that the second selector does NOT have to immediately follow
the first one means It will select all elements that is preceded by the former selector.
It will target both second and third.

https://techbrij.com/css-selector-adjacent-child-sibling

###########################
#second
element.querySelectorAll('div,p')
to ALL DOM, document.querySelectorAll('div')

<main id="box" class="box">
      <div></div>
      <div></div>
      <div></div>
</main>

const box = document.getElementById("box");
const textDiv = box.querySelectorAll("div");

#############################
#first
#es6 #ES6
destructuring assignment
var a,b,rest
[a,b]=[10,20]
[a,b, ...rest] = [10,20,30,40,50]
rest is [30,40,50]

#######################################

<html>
  <body>
    <main id="box" class="box">
      <div></div>
      <div></div>
      <div></div>
    </main>
  </body>
</html>

.box {
  width: 100px;
  height: 100px;
  background-color: lightblue;
}

.box > div {
  display: none;
}

const box = document.getElementById("box");
const textDiv = box.querySelectorAll("div");

const showDiv = (div, k) => {
  setTimeout(() => {
    div.style.display = "block";
    k();
  }, 1000);
};

const show = ds => {
  if (!ds.length) {
    for (const d of textDiv) {
      d.style.display = "none";
    }
    console.log("clearing");
    return show(textDiv);
  }
  
  const [div, ...rest] = ds;
  
  showDiv(div, () => show(rest));
};

show(textDiv);

https://codepen.io/anon/pen/GeQggG

########################################

t=()=>console.log(1)
f = function () { return new Promise((r,e) => {t();
                                               setTimeout(r,3000)
                                              }).then(f)}

#####################################

f = function () { return new Promise((r,e) => {console.log(1);
                                               setTimeout(r,3000)
                                              }).then(f)}

###################################

const point = [10, 25, -34];
const [x, y, z] = point;
https://www.jianshu.com/p/87008f4f8513

#Promise #promise #recursive #recursion

f = function () { return new Promise((r,e) => {console.log(1);
                                               setTimeout(r,3000)
                                              })}
g = function () { return f().then(g)}

###############################################

const g = () => Promise.resolve(1).then(console.log).then(g);

g();

########################################
delay = function(t) {
      return new Promise(function(resolve){
      	     setTimeout(function() {resolve(t)}, t)})};

var clicked=false;

run = function(cond){
    if (cond) { return; };
    console.log(2);
    return delay(100).then(function(){return clicked}) .then(run) ; };

run(clicked);

// create a loop with Promise+Recursion, and control it by the outside condition
// the whole point is that it can return to the main thread or caller

clicked=true;


##################################################

<jusss> eiGHttt https://codepen.io/anon/pen/GeQggG   
        
        mapdivblocksetTimeout
        js
        Promise,
        PromisesetTimeoutPromise
        PromisesetTimeout

<eiGHttt> 
<jusss> eiGHttt setTimeout
<jusss> eiGHttt setTimeout                            [09:57]
<jusss> eiGHttt t=new Promise((r,e)=>{setTimeout(_ => {console.log(1);
        r(2)},3000)}).then((r,e)=>{setTimeout( _ => {console.log(2)},4000)})
                                                                        [10:09]
<jusss> then                        [10:10]
<eiGHttt> Promise
<jusss> eiGHttt const [div, ...rest] = ds; 
                                                                        [10:16]
<eiGHttt> carcdr
<jusss> eiGHttt android 4.0ES6
        websocket, array function 
<eiGHttt> jusss:babel
          es5
<jusss> eiGHttt JS
        Array.forEach(f)fforEach
                                                                        [10:22]
<eiGHttt> 
<jusss> eiGHttt C++continuationFFI
        continuation?                                             [10:28]
<jusss> eiGHttt pythonweb assembly
        Python                                  [10:29]
<jusss> eiGHttt jsPython
<eiGHttt>                           [10:30]
<jusss> eiGHttt  https://alpha.iodide.io                                [10:31]
##############################
array.forEach(function(currentValue, index, arr), thisValue)
they all are optional but currentValue,
currentValue is the element of the list, and index is the index number of the list
you need create a function and it has two parameters or arguments,
and JS's array.forEach(f) will pass two parameters to f, that's weird,
because f is a callback function in forEach
#################################

document.querySelector("className")   instead of getElementByClass or ID
document.createElement("div")     js write div css
they both return the element, 
array.forEach(f)  and array.map()
const let and var 
#######################################

<html>
  <body>
    <main id="box" class="box">
    </main>
  </body>
</html>

.box {
  width: 100px;
  height: 100px;
  background-color: lightblue;
}

const box = document.getElementById("box");
const text = "";

const delayCreate = (text, index) => {
  const delay = index * 3000;
  const element = document.createElement("div");
  element.innerText = text;
  
  setTimeout(() => box.appendChild(element), delay);
};

text.split("").forEach(delayCreate);

################################################

html
(block) div , dl , fieldset , form , h1 ,  menu , noframes , noscript , ol , p , pre , table , ul , li
    ;
    (width)(height)(padding)(margin)
(inline)a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd 
  ;
    (width)(height)top/bottom(padding-top/padding-bottom)top/bottom(margin-top/margin-bottom);

##############################################

[ 3 14 2019]
*** You have joined channel #qi                                         [09:15]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss lugu newnick vbarbaresi dmerejkowsky alkino blastrock
    Phlogistique smartin thegameg
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<jusss> alkino: blastrock hello
<alkino> Yeah that's a libqi signature                                  [14:02]
<alkino> The meaning of the chars is more or less documented here
<alkino>
         http://doc.aldebaran.com/libqi/api/cpp/type/signature.html#enumerations
<alkino> You cant pass a string directly to qi_object_call I think
<alkino> You must create an anyvalue of type tuple with the arguments
<alkino> He should use the other bindings as a base, for example in go:
<alkino>
         https://github.com/aldebaran/libqi-go/blob/master/src/qi/qiobject.go#L65
         and
<alkino>
         https://github.com/aldebaran/libqi-go/blob/master/src/qi/value.go#L288
<alkino> for you from blastrock, jusss
<jusss> alkino: thanks!                                                 [14:03]
<jusss> I will try it now!
<jusss> I'm not familiar with go ...                                    [14:08]
ERC> 


#######################################################


[ 3 13 2019]
*** You have joined channel #qi                                         [09:49]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss newnick thegameg smartin Phlogistique blastrock alkino
    dmerejkowsky vbarbaresi
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<jusss> hello                                                           [10:44]
<jusss> alkino: hi there,                                               [15:38]
<alkino> hi o/
<alkino> where are you?
<alkino> we are in france, we have some delay with you                  [15:39]
<alkino> Phlogistique: ok, je vois a cette semaine
<alkino> 24 ~ 10h => 30 ~ 16h
<alkino> ce sont les horaires approximatifs de ta prsence  la gare de lyon
<alkino> 23*                                                            [15:41]
*** lugu (~ludo@softbank-robotics-gw1.ter4.eqx2.par.cust.as8218.eu) has joined
    channel #qi                                                         [16:54]
<jusss> alkino: I'm in Beijing                                          [18:00]
<alkino> oh
<alkino> ok
<jusss> alkino: I watch that libqi-capi, I don't know how to operate that qi
        function by orders, for example, I can use qi_session_create()
        qi_session_connect qi_session_get_service, but I don't know how to
        call a like ALTextToSpeech.say('something')                     [18:03]
<jusss> alkino: and qi_session_get_service return a Integer,not an object
                                                                        [18:04]
<alkino>
         https://github.com/aldebaran/libqi-capi/blob/master/bin/qiclient-c/qimain.c
         read this example                                              [18:05]
<jusss> it seems those all return Integer
<alkino> it's c
<alkino> i Don't know at all c api
<jusss> alkino: not cpp?
<alkino> but example seems good
<alkino> libqi-capi is c                                                [18:06]
<alkino> libqi is c++
<alkino> libqi-capi is the c binding of c++ code
<jusss> this line qi_object_call(object, "reply::(s)", message);  I don't
        understand what is replay::(s)                                  [18:07]
<alkino> blastrock: a libqi signature?                                  [18:08]
<jusss> qi_session_create() return an IntegerA, then
        qi_session_connect(IntegerA, addr); and return Integer B
<jusss> qi_future_get_object(qi_session_get_service(IntegerA, "serviceTest"));
        return Integer C                                                [18:09]
<jusss> qi_object_signal_connect(IntegerC, "testEvent::(s)", &evcb, 0); 
                                                                        [18:10]
<alkino> seems me good :p
<alkino> interger are identifier
<alkino> of c++ objects
<jusss> alkino: the question is how I can call a function by those Integers
<jusss> alkino: like ALTextToSpeech.say('whatever')                     [18:11]
<alkino> qi_session_get_service(IntegerA, "ALTextToSppech")             [18:12]
<alkino> qi_future_get_object(integerC)
<alkino> qi_objcet_call(object, "say::(s)", "whatever")                 [18:13]
<alkino> not sure
<alkino> but smth like that
<jusss> alkino: what that (s) means
<alkino> (string) ?
<alkino> i'm not sure                                                   [18:14]
<alkino> I guess
<jusss> alkino: ok, I will try it now
<jusss> :)
<jusss> alkino: Segmentation fault                                      [18:20]
<alkino> \o/                                                            [18:21]
<alkino> read example better so :(
<alkino> print each integer
<alkino> if one is null it means an error, I guess
<jusss> alkino: https://paste.ubuntu.com/p/KtcrBhHK97/                  [18:22]
<alkino> print each value                                               [18:23]
<jusss> alkino: https://paste.ubuntu.com/p/FWs7DfkdT7/                  [18:24]
<jusss> alkino: the value seems good
<alkino> can't help you more                                            [18:26]
<jusss> alkino: anyway thanks                                           [18:27]
<jusss> alkino: I saw that one japanese lab is doing something with LISP, and
        I think it's guile                                              [18:29]
*** lugu (~ludo@softbank-robotics-gw1.ter4.eqx2.par.cust.as8218.eu) has quit:
    Ping timeout: 252 seconds                                           [18:55]
ERC> 
############################################

<jusss> yunfan: sqlservermysql
<ystyle>                                                        [14:21]
<jusss> ystyle: mysqlpostgresql
<jusss> ystyle: 
<ystyle>   
<yunfan> jusss:   sql92
<jusss> ystyle: ab
<ystyle> kettle
<ystyle> ->excel->
<jusss> ystyle: 
<ystyle> kettle nosql                                       [14:24]
<ystyle> kettle
<yunfan> ystyle:  
<ystyle>                                [14:25]
<ystyle> oracle dmp sqlserver
         
<ystyle> mysqlpg                        [14:27]

##############################################
"Better" is subjective.
querySelector is the newer feature.
getElementById is better supported than querySelector.
querySelector is better supported than getElementsByClassName.
querySelector lets you find elements with rules that can't be expressed with getElementById and getElementsByClassName
You need to pick the appropriate tool for any given task.
(In the above, for querySelector read querySelector / querySelectorAll).
https://stackoverflow.com/questions/26848289/javascript-queryselector-vs-getelementbyid

I heard that bootstrap 4 without jquery is using querySelectorAll to instead of jquery's function
var x = document.querySelectorAll("h2, div, span");
var i;
for (i = 0; i < x.length; i++) {
  x[i].style.backgroundColor = "red";
}

In this example, the first element in the document with the class "myclass" is returned:
var el = document.querySelector(".myclass");

https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector
################################################

<jusss> eiGHttt htmldiv
                                                    [10:48]
<eiGHttt> position: absolute?                                           [10:49]
<jusss> eiGHttt                                             [10:50]
<jusss> eiGHttt marquee?
<eiGHttt> setInterval.
<eiGHttt>                                                   [10:51]
<jusss> eiGHttt setInterval                                 [10:53]
<eiGHttt>                                                 [10:54]

https://www.1keydata.com/css-tutorial/tw/class-id.php
class and id both are selector
.class-name {attribute:xxx}
<p class="class-name">whatever</p>
b.class-name {attribute:xxx}
<b class="class-name">whatever</b>
.a1{ }   .a2{}
<p class="a1 a2">xxx</p>
#id{}      <p id="id">xxx</p>

<jusss> eiGHttt div
<jusss> div, div
<eiGHttt>                             [11:00]
<eiGHttt> https://codepen.io/anon/pen/aMLLRO                            [11:04]
<html>
  <body>
    <div class="box">
      <div class="text">text</div>
    </div>
  </body>
</html>

.box {
  position: relative;
  background-color: lightblue;
  width: 100px;
  height: 50px;
  overflow: hidden;
}

.text {
  position: absolute;
  left: 0;
  top: 0;
}

const text = document.querySelector(".text");

let pos = 0;

setInterval(() => {
  pos += 10;
  pos = pos % 100;
  text.style.left = `${pos}px`;
}, 300);

<jusss> eiGHttt <h> <p> ?  
        <whateveryouwant>                                             [11:06]
<eiGHttt> <abc>
<eiGHttt>
          https://stackoverflow.com/questions/10830682/is-it-ok-to-use-unknown-html-tags

<p> <li> <span> <h> are tags
<a> is for hyper-link <b> is bold
<li> list item <br> new line
<h1> head  <textarea rows="4" cols="50">
https://www.w3schools.com/tags/tag_u.asp

##########################################
<jusss> elm port, python ffi on c++ library, python frames, sql, blablablah
##########################################
#FFI #ffi #Aldebaran #Pepper #pepper 
python FFI on C++

from ctypes import cdll
cur=cdll.LoadLibrary('./libqic.so')
initValue=cur.qi_session_create()
cur.qi_session_connect(initValue,"tcp://127.0.0.1:9559")
tts=cur.qi_session_get_service(initValue,"ALTextToSpeech")
obj=cur.qi_future_get_object(tts)

 from ctypes import cdll
 cur=cdll.LoadLibrary('./libqic.so')
 initValue=cur.qi_session_create()
 future=cur.qi_session_connect(initValue,"tcp://192.168.31.222:9559")
 future2=cur.qi_session_get_service(initValue,"ALTextToSpeech")
 obj=cur.qi_future_get_object(future2)

message=cur.qi_value_create("(s)")
str = cur.qi_value_create("s")
cur.qi_value_set_string(str,"what ever you want")
ss=cur.qi_value_get_string(str)
cur.qi_value_tuple_set(message,0,str)
fut2=cur.qi_object_call(obj,"say",message)

reference https://github.com/aldebaran/libqi-capi/blob/master/bin/qiclient-c/qimain.c

cur.qi_value_set_string(str,"what ever you want")
cur.qi_value_tuple_set(message,0,str)
fut2=cur.qi_object_call(obj,"say",message)

cur.qi_value_set_string(str,"nothing last forever!")
cur.qi_value_tuple_set(message,0,str)
fut2=cur.qi_object_call(obj,"say",message)

<jusss> alkino: hi, I know how to do that
<blastrock> Hi
<jusss> blastrock: thank you
<alkino> cool !                                                         [17:03]
<blastrock> You're welcome :)                                           [17:04]
<jusss> blastrock: but how to pass a Integer?                           [17:08]
<jusss> an
<jusss> message=cur.qi_value_create("(s)") str = cur.qi_value_create("s")
                                                                        [17:09]
<blastrock> qi_value_create("i") I guess                                [17:10]
<blastrock> then qi_value_set_integer
<blastrock> and qi_value_tuple_set(message, idx, the_int_value)
<jusss> ok                                                              [17:36]

[ 3 20 2019]
*** You have joined channel #qi                                         [09:03]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss StormPhlegyas vbarbaresi dmerejkowsky alkino blastrock
    Phlogistique thegameg smartin
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<jusss> alkino: blastrock hello there                                   [15:04]
*** newnick (~newnick@laubervilliers-656-1-272-22.w193-248.abo.wanadoo.fr) has
    joined channel #qi                                                  [16:33]
<blastrock> Hi jusss                                                    [17:13]
<blastrock> For yesterday's question, the order of the calls are like
            qi_session_create(); future = qi_session_connect("address of the
            robot"); wait for the future and check error; future2 =
            qi_session_get_service("ALTextToSpeech"); wait for that future
            too; obj = qi_future_get_object(future2);                   [17:15]
<blastrock> Then you construct a qi any value tuple with the argument "hello",
            and you call qi_object_call("say", arguments);              [17:16]
<blastrock> That's from the top of my head, I don't remember the details
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has quit: Ping timeout: 250 seconds                                 [18:48]
<jusss> blastrock: what is "a qi any value"?                            [18:58]
<jusss> how to implement a qi value with python?                        [19:05]
<jusss>  qi_object_call(qi_object_t *object, const char *signature,
        qi_message_t *message)                                          [19:16]
<jusss> >>> msg=cur.qi_value_create("hello")   terminate called after throwing
        an instance of 'std::runtime_error',   what():  Invalid signature,
        Aborted                                                         [19:18]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has joined channel #qi                                              [19:26]
<jusss> blastrock: yeah! I got it!                                      [19:29]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has quit: Ping timeout: 246 seconds                                 [19:30]
<jusss> message=cur.qi_value_create("(s)");   str = cur.qi_value_create("s");
        cur.qi_value_set_string(str,"what ever you want");
        ss=cur.qi_value_get_string(str);
        cur.qi_value_tuple_set(message,0,str);
        fut2=cur.qi_object_call(obj,"say",message)                      [19:32]
<jusss> reference
        https://github.com/aldebaran/libqi-capi/blob/master/bin/qiclient-c/qimain.c
ERC> 
 

##############################################

Haskelln1.  Cfac n = if n == 0 
           then 1
           else n * fac (n-1)
2. schemefac = (\(n) ->
        (if ((==) n 0)
            then 1
            else ((*) n (fac ((-) n 1)))))
3.fac  0    =  1
fac (n+1) = (n+1) * fac n
4. foldfac n = foldr (*) 1 [1..n]
5.foldfac n = foldl (*) 1 [1..n]
6.foldlfac n = foldr (\x g n -> g (x*n)) id [1..n] 1
7.facAcc a 0 = a
facAcc a n = facAcc (n*a) (n-1)

fac = facAcc 1
8. fac n = snd (until ((>n) . fst) (\(i,m) -> (i+1, i*m)) (1,1))
9. CPSfacCps k 0 = k 1
facCps k n = facCps (k . (n *)) (n-1)

fac = facCps id
10. Y-combinatory f = f (y f)

fac = y (\f n -> if (n==0) then 1 else n * f (n-1))
11. s f g x = f x (g x)

k x y   = x

b f g x = f (g x)

c f g x = f x g

y f     = f (y f)

cond p f g x = if p x then f x else g x

fac  = y (b (cond ((==) 0) (k 1)) (b (s (*)) (c b pred)))
12. -- a dynamically-typed term language

data Term = Occ Var
          | Use Prim
          | Lit Integer
          | App Term Term
          | Abs Var  Term
          | Rec Var  Term

type Var  = String
type Prim = String


-- a domain of values, including functions

data Value = Num  Integer
           | Bool Bool
           | Fun (Value -> Value)

instance Show Value where
  show (Num  n) = show n
  show (Bool b) = show b
  show (Fun  _) = ""

prjFun (Fun f) = f
prjFun  _      = error "bad function value"

prjNum (Num n) = n
prjNum  _      = error "bad numeric value"

prjBool (Bool b) = b
prjBool  _       = error "bad boolean value"

binOp inj f = Fun (\i -> (Fun (\j -> inj (f (prjNum i) (prjNum j)))))


-- environments mapping variables to values

type Env = [(Var, Value)]

getval x env =  case lookup x env of
                  Just v  -> v
                  Nothing -> error ("no value for " ++ x)


-- an environment-based evaluation function

eval env (Occ x) = getval x env
eval env (Use c) = getval c prims
eval env (Lit k) = Num k
eval env (App m n) = prjFun (eval env m) (eval env n)
eval env (Abs x m) = Fun  (\v -> eval ((x,v) : env) m)
eval env (Rec x m) = f where f = eval ((x,f) : env) m


-- a (fixed) "environment" of language primitives

times = binOp Num  (*)
minus = binOp Num  (-)
equal = binOp Bool (==)
cond  = Fun (\b -> Fun (\x -> Fun (\y -> if (prjBool b) then x else y)))

prims = [ ("*", times), ("-", minus), ("==", equal), ("if", cond) ]


-- a term representing factorial and a "wrapper" for evaluation

facTerm = Rec "f" (Abs "n" 
              (App (App (App (Use "if")
                   (App (App (Use "==") (Occ "n")) (Lit 0))) (Lit 1))
                   (App (App (Use "*")  (Occ "n"))
                        (App (Occ "f")  
                             (App (App (Use "-") (Occ "n")) (Lit 1))))))

fac n = prjNum (eval [] (App facTerm (Lit n)))
13. fac n = product [1..n]
http://www.willamette.edu/~fruehr/haskell/evolution.html

https://www.zhihu.com/question/31253429/answer/53644708

####################################################

<jusss> how I can get 3 from Just 3?
<merijn> jusss: Well, what should happen if you have Nothing?           [17:38]
<jusss> merijn: I don't know, like this value Just 3 is not like in other
        languages, they don't have this value, they have string and integer
<jusss> Just 3 is a value in haskell is really blow up my mind
<merijn> jusss: What you have is a value of type "Maybe Int", which means you
         either *have* an Int (like "Just 3") or you have Nothing. The best
         way to get the three depends on how you plan to use it
<merijn> jusss: For example, if you want "the number or some default value"
         there is:
<merijn> :t fromMaybe
<lambdabot> a -> Maybe a -> a
<merijn> > fromMaybe 0 (Just 3)                                         [17:41]
<lambdabot>  3
<merijn> > fromMaybe 0 Nothing
<lambdabot>  0
<merijn> jusss: If you wanna apply a function, but only IF you have a number,
         there's fmap
<merijn> > fmap (+1) (Just 3)
<lambdabot>  Just 4
<merijn> > fmap (+1) Nothing
<lambdabot>  Nothing
<merijn> > fmap even (Just 3)                                           [17:42]
<lambdabot>  Just False
<jusss> merijn: put value and Nothing into Just?
<merijn> Not sure what you mean by that? :)
<jusss> merijn: my bad English
<jusss> merijn: put value into a box, and operate value by operate box,
                                                                        [17:43]
<merijn> :t pure
<lambdabot> Applicative f => a -> f a
<jusss> I don't box if it's a proper express
<merijn> > pure 3 :: Maybe Int                                          [17:44]
<lambdabot>  Just 3
<Ariakenom> jusss: You can compare to a list that has zero or one element
                                                                        [17:47]
<jusss> Ariakenom: Just 3 is 3 or Nothing?

<merijn> jusss: No, "Maybe Int" means something is "Just 3" or "Nothing"


<jusss> merijn: is there a value "Maybe 3"?                             [17:49]
<merijn> jusss: "Just" is a constructor that takes a value of type 'a' to make
         a value of type 'Maybe a' and Nothing is a constructor that has no
         arguments and makes values of type 'Maybe a'

<Ariakenom> "Just 3 :: Maybe Int", "Nothing :: Maybe Int" "[3] :: [Int]"


<jusss> eiGHttt Just 3Just 3 + Just 3, 
        3
<jusss> eiGHttt  A B C D E F whatever
                                                                        [17:28]
<eiGHttt> (+)Num a => a -> a -> aJust 3
<eiGHttt> ghci                          [17:29]
<jusss> 
<eiGHttt> 
<jusss> eiGHttt identifier
        haskell Point {a=3, b=2}
                                                                        [17:31]
<eiGHttt> '\\ (+) <$> Just 3 <*> Just 3
<jusss> Pointa"a", 
<varia> eiGHttt: Just 6
<eiGHttt>                                           [17:32]
<jusss> eiGHttt haskell" "

<jusss> eiGHttt haskellJust 33? 
*** houye (~houye@124.160.215.51) has quit: Ping timeout: 240 seconds   [17:36]
<eiGHttt> justMaybe aaNothing             [17:37]
<eiGHttt> Functor
                                                                        [17:38]
<eiGHttt> (+) <$> Just 3 <*> Just 3Applicative
          Nothing
<eiGHttt> '\\ (+) <$> Nothing <*> Just 3
<varia> eiGHttt: Nothing                                                [17:39]
<eiGHttt> JustMaybeNohting

<jusss> eiGHttt t :: Maybe a -> a 
<jusss> eiGHttt record  Point = { a =b }  b
                                                                    [18:04]
<jusss>  in case of 
<eiGHttt> data Point = Point { a :: int }aa :: Point -> Int
                                                                        [18:06]
<eiGHttt> haskell.
<eiGHttt> ghci                          [18:07]



#################################

haskellmain=
main = putStrLn "hello world"

connect multiple I/O
main = do
       putStrLn "hello, what's you name?"
       name <- getLine
       putStrLn ("Hey " ++ name ++ ", you rock!")

module X where
main :: IO()
main = do
  putStrLn "what's your name"
  name <- getLine
  putStrLn ("hi " ++ name)

##########################################################

datatype constructor,value constructor
Just 3Just 3typeJust Int

###############################################################

Just 3valuetypeMaybe Int
data Point = Point Int Int,     Point 3 3typePoint
data Point a b = Point a b,    Point 3 3type Point Int Int

<jusss> Just 3 is a value? and its type is Maybe Int?
<cocreature> jusss: technically integer literals are polymorphic so its type
             is Num a => Maybe a                                        [14:37]
<cocreature> but since Int is an instance of Num you can use it as type Maybe
             Int                                                        [14:38]
<jusss> cocreature: and Just 3 is a value?                              [14:39]
<Axman6> yes
<jusss> cocreature: in other languages, I know String Int can be value, but in
        haskell this type stuff really blow up my mind                  [14:40]
<jusss> Axman6:  Just 3 is a value and it's a value of the type Maybe Int,
        right?                                                          [14:41]
<Axman6> yep
<jusss> data Point = Point Int Int,      let p1 = Point 1 1, and p1 is Point 1
        1,    this Point 1 1 is a value too?                            [14:42]
<jusss> and Point 1 1's type is ?
<jusss> is Point Int Int?                                               [14:43]
<Axman6> it's worth exploring a little further; 1 is a value of type Int
         (which can be written more concisely as 1 :: Int). Just is a
         _function_ of type a -> Maybe a, a.k.a, Just :: a -> Maybe a. since a
         can be anything, when Just, which is a function, is applied to 1
         which is an Int, Just 1, the a is chosen to be Int, and you get Just
         1 :: Maybe Int
<Axman6> Point 1 2 :: Point - Point does not have any type parameters
<cocreature> using different names for the constructor and the type might be
             more helpful
<cocreature> "data PointTy = PointConstr Int Int"                       [14:44]
<cocreature> PointConstr 1 1 :: PointTy
<Axman6> you could have data Tuple a = Tuple a a, and in that case, Tuple 1 2
         :: Tuple Int
<jusss> Axman6: Point 1 1 is a value and its type is Point, right?
<Axman6> yep
<jusss> data Point a b = Point { what = a, ever = b}      let x = Point 3 5
<jusss> Axman6: so I can define any types if I want in haskell?
<dminuoso> jusss: The syntax is slightly off, but yes you can create custom
           data types - and you should.

<jusss> eiGHttt[m]: Just 3
<eiGHttt[m]> ghci                               [14:36]
<jusss> eiGHttt[m]: 
<eiGHttt[m]> 
<eiGHttt[m]> Point 3 :: Int -> Point                                    [14:37]
<eiGHttt[m]> Point 3 3 :: Point
<eiGHttt[m]> Point 3 $ Point 3
<jusss> eiGHttt[m]: data Point = Point Int Int,    Point 3 3
                                                                        [14:50]
<jusss> eiGHttt[m]: Just 3
<jusss> eiGHttt[m]:  
<eiGHttt[m]> Point :: Int -> Int -> PointhaskellPoint
             3 3 = Point(3, 3)                                          [14:51]
<eiGHttt[m]> Just                                                 [14:52]

#######################################################

data Person = Person ( firstName :: String
                                        , lastName :: String
                                        , age :: Int
                                        ) deriving (Eq)

turn it to an instance of the typeclass Eq, you can use == or /=

mikeD = Person (firstName = "Michael", lastName = "Diamond", age=43)
adRock = Person (firstName = "Adam", lastName="Horovitz",age=41)
mca=Person(firstName="Adam",lastName="Yauch",age=44)

mca==adRock     False
mikeD == adRock False
mikeD == mikdeD  True

http://aducode.github.io/posts/2015-07-02/learn_haskell_lession1.html

-- Test
-- 
data Test

--PersonPerson
data Person = Person

data Person = Person String Int
Person:StringInt :PersonPerson(constructor)"|"

data Person = Student String Int | Teacher String Int Double
Person,Student(Student::String->Int->Person),Teacher(Teacher::String->Int->Double->Person)

let person1 = Student "XiaoMing" 12
let person2 = Teacher "LaoZhang" 30  5000
person1person2Person Person

getName::Person->String
getName (Student name _) = name
getName (Teacher name _  _) = name
getName (Teacher "LaoZhang" 30 5000)

haskell(haskell)


-- 
data Person = Student{name::String,age::Int}
            |Teacher{name::String,age::Int,wage::Double}
let person1 = Student{name="XiaoMing", age=12}
let person2 = Teacher{name="LaoZhang", age=30, wage=5000}
name person2

haskellname::Person->String age::Person->Int

(~)


data Entry a b = Entry{key::a,value::b}
let p1 = Entry 1 "Foo"
let p2 = Entry "Bar" 3.5
let p3 = Entry{key="A",value="HHHH"pp}
let p4 = Entry (1::Double)  2
let p5 = Entry{key=1::Double, value=2}

Entryab

dataGeneralised algebraic datatype(GADT)


{-# LANGUAGE GADTs #-}
data Person where
    Student::String->Int->Person
    Teacher::String->Int->Double->Person


data Entry a b where
    --Entry Entrynew type
    Entry::a->b->Entry 

--GADTs
data E a where
    A::Eq b=>b->E b

Record Wildcards

{-# LANGUAGE RecordWildCards    #-}
data Person = Person{
        name::String,
        age::Int
}deriving(Show)

getPerson::IO Person
getPerson = return $ Person "Duyang" 13

main::IO ()
main = do
        -- 
        person <- getPerson
        putStrLn $ show $ name person
        putStrLn $ show $ age person
        -- ,person2Person
        person2@Person {..} <- getPerson
        putStrLn $ show name
        putStrLn $ show age
        putStrLn $ show person2

#########################################################
<jusss> about type constructor and value constructor, I'm confused,   data
        Maybe a = Nothing | Just a,   Maybe is a type constructor and it takes
        one type then construct this type with Nothing and Just a, and what is
        the a in Just a?                                                [09:36]
<slack1256> Just (5 :: Int) :: Maybe Int
<lyxia> jusss: it's the type of the only field of the Just data constructor
<jusss> lyxia: Just is a value constructor, and put Just in the type parameter
        a, that's ok?                                                   [09:38]
<jusss> or the a after = is not a type , is a value?
<c_wraith> the syntax for data declarations does mix types and values, yes
<c_wraith> data Foo a = Bar String Int a
<c_wraith> Bar is a value, String, Int and a are all types.
-------------------------------------------------
module Main where
data Foo a = Bar String Int a
:t Bar
Bar :: String -> Int -> a -> Foo a
let p1 = Bar "3" 3 2
:t p1
p1:: Num a => Foo a
------------------------------------------------------------
<jusss> what?
<c_wraith> data constructors are values.
<jusss> c_wraith: what it means? Bar String Int a
<c_wraith> you can't just extract that one portion in a meaningful way.
<c_wraith> you need the whole line.
<c_wraith> it is declaring a data type named Foo. the type takes one
           parameter, named a within the scope of the declaration.      [09:43]
<jusss> c_wraith: Bar String Int a, is what I don't understand,         [09:44]
<c_wraith> the type is defined as the constructor Bar with 3 arguments. in
           order, the arguments have the types String, Int, and a
<c_wraith> that's just the syntax for a (non-record) data
           declaration. constructor name followed by the types of the
           arguments of the constructor. if there are multiple constructors,
           they each have the same syntax with a | separating them.     [09:47]
<c_wraith> it's a very concise syntax, but it definitely has some clarity
           issues for beginners.                                        [09:49]
<jusss> it really makes me confused, the type stuff in haskell          [09:52]
<c_wraith> well, we could simplify a lot. here's an actual definition from the
           standard library:                                            [09:53]
<c_wraith> data Bool = False | True
<c_wraith> the Bool data type has two constructors. neither takes an argument.
<c_wraith> is that a thing that makes sense?                            [09:55]
<jusss> Bool is a type constructor, it doesn't take one type parameter, and it
        constructs two type by False and True, and False and True is what?
<jusss> type constructor or value constructor
<jusss> and what 's the different between value and value constructor?

<jusss> type constructor ,follow the name, it should consturct a type, so Bool
        should construct a type                                         [09:59]
<c_wraith> well, um.. type constructors make types. data constructors make
           values of a particular type.
<c_wraith> types exist at compile time - they let you specify which values are
           possible in different places.                                [10:00]
<c_wraith> values are the things that actually exist in memory when the
           program runs.
<jmcarthur> jusss: One could imagine a syntax more like some imperative
            languages.  Bar("string", 42, True) would have type Foo<Bool>           

##########################

module Main where

data Point = Point Int  Int deriving (Show)

main :: IO ()
main = do
  let p1 = Point 1 2
  let p2 = Point 3 2
  print p1
  print p2

<eiGHttt[m]> data Point = ...Point ... = Point Int Int
             PointPoint :: Int -> Int -> Point
                                                                        [11:18]
<eiGHttt[m]> 
<eiGHttt[m]> data Point = P Int IntP :: Int -> Int -> Point
<eiGHttt[m]>                                      [11:19]
<jusss> eiGHttt[m]: P
<eiGHttt[m]> 
<eiGHttt[m]> 
                                                                        [11:20]
<jusss> eiGHttt[m]: 
<jusss> eiGHttt[m]: P
<eiGHttt[m]> PPointPPoint
             Point                                              [11:21]
<jusss> eiGHttt[m]: Point
<jusss> eiGHttt[m]: P
<eiGHttt[m]> P                                        [11:22]
<jusss> eiGHttt[m]: 
<eiGHttt[m]> P 1 2 :: Point
<jusss> eiGHttt[m]: Point
<eiGHttt[m]> data Point = ..
<eiGHttt[m]>                                                  [11:23]
<eiGHttt[m]> https://paste.ubuntu.com/p/7RSFd2x4kk/                     [11:24]
<jusss> eiGHttt[m]: Point 1 2                                           [11:29]

###############################################

data Tree a = Branch (Tree a) (Tree a) | Leaf a
Here, one of the constructors, Branch of Tree takes two trees as parameters to the constructor, while Leaf takes a value of type a. This type of recursion is a very common pattern in Haskell. 

type constructor, value constructor
type constructortype, type

module X where

data Car = Car {company::String
  ,model::String
  ,year::Int
  } deriving(Show)
 
main = Car {company="Ford",model="Mustang",year=1999}

##############################################

type constructor and value constructor

It's a bit like saying "why do we need classes and objects if objects are the only thing that actually runs?"

The two sorts of constructors do different jobs. Type constructors go in type signatures. Value constructors go in runnable code.

In the simplest case, a type "constructor" is just a type name. In the simplest case, a type has only one value constructor. So you end up with things like

data Point = Point Int Int

You might say to yourself "now why the heck to I need to write Point twice?"

But now consider a less trivial example:

data Tree x = Leaf x | Branch (Tree x) (Tree x)

Here Tree is a type constructor. You give it a type argument, and it "constructs" a type. So Tree Int is one type, Tree String is another type, and so on. (Like templates in C++, or generics in Java or Eiffel.)

On the other hand, Leaf is a value constructor. Given a value, it makes a 1-node tree out of it. So Leaf 5 is a Tree Int value, Leaf "banana" is a Tree String value, and so on.

Similarly for Branch. It takes two tree values and constructs a tree node with those trees as children. For example, Branch (Leaf 2) (Leaf 7) is a Tree Int value.

https://stackoverflow.com/questions/10242709/why-is-there-a-value-constructor-in-addition-to-the-type-constructor-in-haskell

##############################################

data Maybe a = Nothing | Just a
a is a type parameter, Maybe is a type constructor,  if it's not Nothing,
it can be Maybe Int, Maybe String ,   Maybe is not a type, is a type constructor

give the type Char to Maybe , it returns Maybe Char type
Just 'a' type is Maybe Char

<eiGHttt[m]> Maybe aa
	     
<eiGHttt[m]> Maybe				        [17:04]
<eiGHttt[m]> jusss: MaybeBool		        [17:05]
<eiGHttt[m]> kindMaybekind :: * -> *
	     Maybe Intkind :: *				        [17:23]
<eiGHttt[m]> Maybe aa
	     f :: Int -> Maybe Intf :: Int -> Maybe
<eiGHttt[m]> []
	     []kindMaybe

enumeration /njum'ren/ 

declaration
enum days-of-week { sun, mon, tue,  wed, thu, fre, sat}

instance, instantiation
enum days-of-week special-day;

operation
special-day = mon;      and day is 1

######################################

data Person = Person String String Int Float String String deriving (Show)
let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"

record syntax			   
data Person = Person { firstName :: String
     	      	           ,lastName :: String
			   ,age :: Int
			   ,height::Float
			   ,phoneNumber::String
			   ,flavor::String} deriving (Show)
firstName is a function auto generated by haskell
firstName :: Person -> String

Person (firstName="Ford", lastName="Wonders", age=35, height=1.80 ,phoneNumber="18000000000", flavor="movie")
			   
###################
module Shapes
(Point(..)
,Shape(..)
,area
) where          import all the value constructor of Shape by append (..) to Shape

#####construct your own data type

data Bool = False | True           the part after = is value constructor
data Int = -2147483648 | -2147483647 | ... | -1 | 0 | ... | 2147483647
data Shape = Circle Float Float Float | Rectangle Float Float Float Float
Circle and Rectangle are value constructor

a value constructor is a function!

data Shape = Circle Float Float Float Float | Rectangle Float Float Float Float deriving (Show)
deriving (Show) will make it into the Show typeclass

####module in haskell
Geometry.hs
module Geometry
( f1
,f2
,f3
) where

f1 :: Float -> Float
f1 radius = (4.0 / 3.0) * pi * (radius ^ 3)


you can import it in other file, use     import Geometry

or it can have sub modules
Directory Geometry, there're Sphere.hs Cuboid.hs and Cube.hs

Sphere.hs
module Geometry.Sphere
(volume
,area
) where

volume :: Float -> Float
volume radius = (4.0/3.0) * pi * (radius ^ 3)

you can import it by import Geometry.Sphere then use volume function

################################################

<eiGHttt[m]> haskell->=><-
<jusss> eiGHttt[m]: $ >>  << `a` |
<eiGHttt[m]> 		        [11:23]
<eiGHttt[m]> `f`
<eiGHttt[m]> <$> = fmap
<eiGHttt[m]> '\\ (+ 1) `fmap` Just 1				        [11:26]
<jusss> '\\(+ 1) <$> Maybe 1					        [11:27]
<eiGHttt[m]> jusss: Maybe
<jusss> eiGHttt[m]: oh
<eiGHttt[m]> jusss: JustNothing		        [11:28]

#################################################

windows 10 iso download
https://pc-karuma.net/windows10-october-2018-update-1809-install-media/
download the mediacreationtool1809.exe and run to download the iso
use ultroiso to burn this iso into an usb-stick, then boot the computer from it
down the neccesary drivers from the official website of computer, and use win10's
default device-manager to update other drivers, if you download the same version
iso as your default system version that comes with you computer, it may be activited
by default through motherboard number

###############################################
<jusss> eiGHttt[m]: A :: Int -> Maybe Float 	        [17:48]
<eiGHttt[m]> BoolTrueFalseMaybe FloatFloat
	     Nothing					        [17:50]
<eiGHttt[m]> Nothing

<jusss> eiGHttt[m]: quicksort :: (Ord a) => [a] -> [a]		        [17:55]
<jusss> (Ord a)  a			        [17:56]
<eiGHttt[m]> Ord				        [17:57]
<eiGHttt[m]> Ord

<jusss> eiGHttt[m]:  typeclass,  Eq Ord
<jusss> eiGHttt[m]: 				        [17:52]
<jusss> (Eq a) -> a -> a -> Bool
<eiGHttt[m]> 
<jusss> (Eq a) => a
<eiGHttt[m]> aEq					        [17:53]
<jusss> Eqtypeclass
<eiGHttt[m]> 
<eiGHttt[m]> EqOrdFoldableNum
								        [17:54]
<jusss> eiGHttt[m]: quicksort :: (Ord a) => [a] -> [a]		        [17:55]
<jusss> (Ord a)  a			        [17:56]
<eiGHttt[m]> Ord				        [17:57]
<eiGHttt[m]> Ord
<jusss> eiGHttt[m]: learn you a haskell for great good
								        [17:58]
<eiGHttt[m]> data MyBool = B | T deriving (Eq, Ord)  B == T  B
	     > T
<jusss> eiGHttt[m]: elmhaskell		        [17:59]
<eiGHttt[m]> haskell
<jusss> eiGHttt[m]: 				        [18:00]
<eiGHttt[m]> 
<jusss> eiGHttt[m]: type
<jusss> eiGHttt[m]: type declaration
<eiGHttt[m]> typeshellalias
	     
<jusss> eiGHttt[m]: currying map 
	currying
<jusss> f = map f'						        [18:02]
<jusss> f alst
<eiGHttt[m]> point-free
<jusss> eiGHttt[m]: pointless					        [18:03]
<jusss> eiGHttt[m]: FFI, guile or python , C, FFI
								        [18:04]
<jusss> eiGHttt[m]: haskellDSL
<jusss> haskellsyntax 		        [18:05]
<eiGHttt[m]> DSL
<jusss> eiGHttt[m]: bash$  catchall pattern
<jusss> eiGHttt[m]:  `x`
<eiGHttt[m]> $
<jusss> 
<eiGHttt[m]> bash				        [18:07]
<jusss> eiGHttt[m]: bye
<jusss> 
<jusss> comprehension

###########################################

#define QIC_API QI_LIB_API(qic)
typedef struct qi_session_t_s qi_session_t;

 QIC_API qi_session_t *qi_session_create();


#################################
typedef interpretation is performed by the compiler whereas #define statements are processed by the pre-processor.

The syntax of #define is :-

#define CNAME (expression)       #define MAX(a, b)   ((a)>(b)? (a) : (b))
OR
#define CNAME value

#######################################

structure in C

Structures are used to represent a record.
To define a structure, you must use the struct statement.
struct Books {
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;     /* variable book is a Books structure, same as struct Books book, if its p[20] means variable p having 20 elements of type struct Books */
struct Books Book1;        /* Declare Book1 of type Book */
 Book1.book_id = 6495407;

/* function declaration */
void printBook( struct Books book );

/* function definition */
void printBook( struct Books book ) {

   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}

/* function call */
printBook( Book1 );

/* Pointers to Structures */
struct Books *struct_pointer;
struct_pointer = &Book1;
/* access member via pointers */
struct_pointer->title;       https://www.tutorialspoint.com/cprogramming/c_structures.htm

typedef, which you can use to give a type a new name.

typedef unsigned char BYTE;

After this type definition, the identifier BYTE can be used as an abbreviation for the type unsigned char, for example..
BYTE  b1, b2;

typedef struct Books {
   char title[50];
   char author[50];
   char subject[100];
   int book_id;
} Book;  /* alias */

Book book;  same as struct Books book

fire up, /* start the engine */


###############################################################

[ 2 27 2019]
*** You have joined channel #qi					        [13:08]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss alkino newnick blastrock dmerejkowsky Phlogistique
    vbarbaresi smartin thegameg
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<alkino> hi							        [14:53]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has joined channel #qi					        [15:11]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has quit: Ping timeout: 255 seconds				        [15:16]
<jusss> alkino: are you familar with guile?			        [16:04]
<jusss> I'm tring do FFI with guile, but my comprehension is not good   [16:05]
<alkino> not at all						        [16:06]
<alkino> I don't know what is guile
<jusss> alkino: it's scheme variant
<jusss> alkino: I saw guile on the pepper
<alkino> anybody here work in the company anymore		        [16:09]
<alkino> it's not gramatically correct but you get the point, I guess
<jusss> yeah, 							        [16:10]
<alkino> so we are no more aware of everything new		        [16:11]
<jusss> alkino: could you help me do FFI in python?
<jusss> even it provides something, I'm tring to learn something about FFI
								        [16:12]
<jusss> but no one can help me that people around me
<alkino> in softbank we use boost-python			        [16:13]
<alkino> https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/index.html
	 really powerful library above ffi
<alkino> you can see examples here : https://github.com/aldebaran/libqi-python
<jusss> ok
<jusss> https://github.com/aldebaran/libqi-capi			        [16:33]
<jusss> where is the session.h?					        [16:34]
<jusss> oh, I found it						        [16:35]
<jusss> it's in qic
<alkino> qic : public headers					        [16:41]
<alkino> src : private headers / sources
<alkino> _p.h means private					        [16:42]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has joined channel #qi					        [17:07]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has quit: Ping timeout: 244 seconds				        [17:12]
*** StormPhlegyas (~Phlegyas@lstlambert-657-1-100-146.w90-63.abo.wanadoo.fr)
    has joined channel #qi					        [17:15]
<jusss> alkino: I still have no idea how to do FFI in python, I saw an
	ariticle about cffi, it said just ffi.cdef(""" header code """) then
	ffi.dlopen("whatever.so") then I can call it, but I don't know to do
	with libqi, I should use ffi.cdef import those headers and dlopen
	libqic.so? but there're so many files, I have no idea about sequence,
	it's beyond my capability now				        [17:21]
*** mizux (~mizux@104.132.117.85) has joined channel #qi	        [17:34]
ERC> 

https://www.boost.org/doc/libs/1_69_0/libs/python/doc/html/index.html
boost python

###########################

/home/nao/.local/bin/pip install --user CFFI
 from cffi import FFI
ffi = FFI()
ffi.cdef("""
	head-file like function declare or typedef struct
	""")
lib = ffi.dlopen('./libvect3.so')
lib.function-defined-in-head-file(parameters)

reference:  https://blog.csdn.net/itisyang/article/details/54426631
############################################

Archive libraries (.a) are statically linked i.e when you compile your program with -c option in gcc. So, if there's any change in library, you need to compile and build your code again.
The advantage of .so (shared object) over .a library is that they are linked during the runtime i.e. after creation of your .o file -o option in gcc. So, if there's any change in .so file, you don't need to recompile your main program. But make sure that your main program is linked to the new .so file with ln command.


telegram can be registed by textnow or google voice, 'cause textnow use america
so choose +1 then you textnow code, if you choose america as you country
+1 (91x) 78x-689x

safe strage
yandex mail -> textnow -> telegram -> paypal ->apple account

####################################
.a are static libraries. If you use code stored inside them, it's taken from them and embedded into your own binary. In Visual Studio, these would be .lib files.
.so are dynamic libraries. If you use code stored inside them, it's not taken and embedded into your own binary. Instead it's just referenced, so the binary will depend on them and the code from the so file is added/loaded at runtime. In Visual Studio/Windows these would be .dll files (with small .lib files containing linking information).

Scheme Procedure: dynamic-link [library]    A.K.A dlopening
Scheme Procedure: dynamic-unlink dobj
Scheme Procedure: dynamic-func name dobj    Return a handle for the func name in the shared object referred to by dobj. The handle can be passed to dynamic-call to actually call the function.
Scheme Procedure: dynamic-call func dobj
Scheme Procedure: load-extension lib init
Scheme Procedure: pointer->procedure return_type func_ptr arg_types [#:return-errno?=#f]

#########################################

pip install cffi
ffi.dlopen(libqic.so)

"""
FFI(Foreign Function Interface)
(language bindings)
Java  JNI(Java Native Interface)  JNA(Java Native Access)
 A  B (IPC)(RPC, RESTful) FFI 
"""

############################################################

[ 2 26 2019]
*** You have joined channel #qi					        [10:12]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss mizux alkino StormPhlegyas thegameg smartin vbarbaresi
    Phlogistique dmerejkowsky blastrock newnick
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<jusss> anyone here?

[ 2 26 2019]
*** You have joined channel #qi					        [12:05]
*** Topic for #qi: qiBuild: https://github.com/aldebaran/qibuild | libqi:
    https://github.com/aldebaran/libqi
*** #qi: topic set by Phlogistique, 2016-02-05 17:01:14
*** Users on #qi: jusss mizux alkino StormPhlegyas newnick blastrock
    dmerejkowsky Phlogistique vbarbaresi smartin thegameg
*** #qi modes: +ct
*** #qi was created on 2010-01-30 07:53:26
<alkino> yes jusss						        [14:28]
<jusss> alkino: how I can use javascript to make pepper do something without
	python?							        [14:29]
<jusss> alkino: I know there're python tornado and SimpleHTTPServer on pepper,
	can I use javascript to make pepper do something without ALTablet?
								        [14:31]
<alkino> yes							        [14:32]
<jusss> alkino: I'd like to make pepper as a web server, and it doesn't
	display something on the its tablet, I want to control it through
	javascript that on the website				        [14:33]
<jusss> alkino: how ?
<alkino> i can't remember well (don't work for the company for 2 years now)
								        [14:40]
<alkino> there is a file ".js" which talk in websocket to the python tornadio
<alkino> that's the way
<jusss> alkino: the libqi, 					        [14:42]
<alkino> which language for you?
<alkino> I find a french website which explained well
<jusss> alkino: English
<alkino> hum							        [14:43]
<jusss> alkino: french is ok, I can use google translate
<alkino> http://doc.aldebaran.com/2-4/dev/js/index.html
<jusss> alkino: I saw this page, but this only works in choregraphe     [14:44]
<alkino> ok							        [14:47]
<alkino> do you know packagemanager?
<jusss> alkino: yeah
<alkino> you can forge a package and install it through packagemanager
<alkino> (that's the dirty way)
<jusss> alkino: there's package manager for js? I saw there's python and java
								        [14:48]
<alkino> ?
<alkino> I speak about the packagemanaer of pepper
<jusss> ok, I know you mean					        [14:49]
<alkino> http://doc.aldebaran.com/2-4/naoqi/core/packagemanager.html
<jusss> alkino: you mean I should do something in choregraphe and use package
	manager to install it?
<alkino> yes							        [14:51]
<alkino> and next you can run it on your tablet
<jusss> ok, 							        [14:52]
<alkino>
	 http://doc.aldebaran.com/2-4/naoqi/core/packagemanager-api.html#PackageManager::onPackageInstalled__qi::Signal:qi::PackageInfo:
	 je sais pas qui est le connard qu'a fait la doc, mais il manque la
	 moiti des infos					        [14:56]
*** mizux_ (~mizux@104.132.117.85) has joined channel #qi	        [15:01]
<alkino> good luck						        [15:03]
*** mizux_ (~mizux@104.132.117.85) has quit: Client Quit
<alkino> tell us if you success or not				        [15:10]
<jusss> alkino: ok						        [15:17]
<jusss> alkino: I wonder is there other qi libraries for other langaues? like
	haskell or scheme, I saw there's guile on the robot	        [15:19]
<jusss> it even provides libs for julia
<alkino> blastrock, do you remember all the funny languages you, cdric and
	 mathieu did?						        [16:16]
<blastrock> mathieu did haskell, cedric did julia		        [16:55]
<blastrock> I don't know if haskell is still somewhere
<blastrock> And I'm not sure they still compile :s
<jusss> blastrock: where I can find it? or how I can build it?	        [17:19]
<jusss> alkino: I found this
	https://github.com/pepperhacking/studiotoolkit/blob/master/doc/js_robotutils.md
								        [17:20]
<blastrock> There's julia here https://github.com/aldebaran/libqi-julia
								        [17:22]
<blastrock> Basically, they're just wrappers over the c api	        [17:23]
<blastrock> I think haskell has been lost			        [17:24]
<blastrock> And I don't work at aldebaran anymore, so I can't help more ^^
<jusss> blastrock: c api or c++ api?				        [17:25]
<blastrock> c							        [17:27]
<jusss> techically I can compile it if I have the c source code?
<blastrock> The python and java bindings are written in c++, they are more
	    efficient and maybe better integrated into the language, but they
	    are much harder to write
<jusss> if I have c code, I can do FFI in other languages, right?       [17:28]
<blastrock> You don't need to recompile libqi I think you can use the one
	    that's in your robot or in choregraphe for your desktop
<blastrock> Yes
<blastrock> That's the c api https://github.com/aldebaran/libqi-capi
<blastrock> But I think it's already compiled, you don't need to do it
	    yourself						        [17:29]
<jusss> blastrock: it's compiled and on the robot?		        [17:30]
<jusss> I found /opt/aldebaran/lib/libqi.so   libqic.so  libqicore.so   [17:38]
<jusss> libqipython.so
<alkino> libqic I guess						        [17:43]
<blastrock> Yes, it's libqic.so					        [17:48]
<vbarbaresi> omg les bindings julia, j'avais oubli. 5 years ago, sr que a
	     marche plus					        [17:49]
<vbarbaresi> https://github.com/aldebaran/libqi-julia/blob/master/qi/future.jl
<vbarbaresi> trs pro :D
<blastrock> Hahaha						        [17:50]
<blastrock> Actually, we tried to keep the c api very stable, so they might
	    still work
<jusss> finally, I should to learn FFI in haskell, and try do something with
	haskell on pepper
<jusss> or scheme						        [17:51]
<jusss> and there's guile on the robot 				        [17:52]
<blastrock> Here are other examples that use the c api if you need
	    inspiration: https://github.com/aldebaran/libqi-go
	    https://github.com/aldebaran/libqi-dotnet		        [17:53]
<jusss> ok, 							        [17:54]
ERC> 


#######################################


python comes with SimpleHTTPServer
http://2ality.com/2014/06/simple-http-server.html
$python -m SimpleHTTPServer 8080     it will search for index.html on current directory



#############################


type variable,   head :: [a] -> a   a is a type variable
type is an instance of a typeclass,
:t (==)   (==) :: (Eq a) => a -> a -> Bool
=> means type constraint,

check input is 7 or not
lucky :: Int -> String
lucky 7 = "lucky"
lucky x = "out of lucky"        catchall pattern

sayMe :: Int -> String
sayMe 1 = "One"
sayMe 2 = "Two"
sayMe 3 = "Three"
sayMe 4 = "Four"
sayMe 5 = "Five"
sayMe x = "Not between 1 and 5"

"haskell use catchall pattern like that thing in iptables to instead of if-then-else chain"

factorial :: Int -> Int
factorial 0 = 1
factorial n = n * factorial (n-1)

third :: (a,b,c) -> c
third (_,_,z) = z

let xs = [(1,3), (4,3)]   
[a+b | (a,b) <- xs]       [4,7]    list comprehension

[1,2,3] is 1:2:3:[]
x:xs is a list that head is x and the rest is xs




#############################

 String.toFloat
<function> : String -> Maybe Float
port cache : E.Value -> Cmd msg

Maybe FloatboxFloat
Maybetype,
type Maybe a = Just a | Nothing
Cmdboxmsg


### disable systemd-resolved in ubuntu
sudo systemctl disable systemd-resolved.service
sudo systemctl stop systemd-resolved

Then put the following line in the [main] section of your /etc/NetworkManager/NetworkManager.conf:

dns=default

Delete the symlink /etc/resolv.conf

rm /etc/resolv.conf

Restart network-manager

sudo service network-manager restart

#################################################

https://docs.python.org/3/library/argparse.html
import argparse
import qi

###

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--ip", type=str, default="127.0.0.1",
                        help="Robot IP address. On robot or Local Naoqi: \
                        use '127.0.0.1'.")
    parser.add_argument("--port", type=int, default=9559,
                        help="Naoqi port number")

    args = parser.parse_args()
    session = qi.Session()
    try:
        session.connect("tcp://" + args.ip + ":" + str(args.port))
    except RuntimeError:
        print ("Can't connect to Naoqi at ip \"" + args.ip + "\" on port " +
               str(args.port) + ".\n"
               "Please check your script arguments. Run with -h option for \
help.")
        sys.exit(1)

    main(session)

###################################################################


raise an exception

<jusss> how to raise an exception with specific message?
<melissa666> jusss, raise YourError("this is the message")	        [17:28]
<melissa666> jusss, You can raise any defined exception type - either one of
	     the builtin exceptions, or a custom one		        [17:30]
<melissa666>
	     jusss,https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python

raise ValueError('A very specific bad thing happened.')

https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python
class MyException(Exception):
    pass
raise MyException("My hovercraft is full of eels")


#########################################################

python enhance pictures, Pillow is a fork of pil
https://www.blog.pythonlibrary.org/2017/10/24/enhancing-photos-with-python/

pip install Pillow
<hnsz> jusss: NB eventhough the package is called pillow. You still have to
       write import PIL
#Changing the Brightness
from PIL import Image
from PIL import ImageEnhance
 
 
def adjust_brightness(input_image, output_image, factor):
    image = Image.open(input_image)
    enhancer_object = ImageEnhance.Brightness(image)
    out = enhancer_object.enhance(factor)
    out.save(output_image)
 
if __name__ == '__main__':
    adjust_brightness('lighthouse.jpg',
                      'output/lighthouse_darkened.jpg',
                      1.7)



################################################################



An Elm file is called a module. To access code in other files, you need to import it!

module keyword define a module, like A.elm and write `module A exposing (..)` in A.elm

outgoing port
port doSomethingInJsWithAString : String -> Cmd msg

incoming port
port stringsComingFromJs : (List String -> msg) -> Sub msg

########################################

Your Elm projects should all have a root directory, like project/ that all of your Elm related stuff is going to live in. Lets imagine having the following directory structure.

project/
    Main.elm
    SearchBox.elm
    SearchResults.elm
    Theme.elm
We have a couple Elm modules, maybe they depend on each other in some way. To turn this into JavaScript, you can run the following command:

elm make project/Main.elm --output=main.html    or main.js

elm make Desktop\Basic.elm --output=first.elm.html


##############################

https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md
elm-package.json becomes elm.json
String.toInt : String -> Maybe Int (not Result anymore)
Basics.toString becomes Debug.toString, String.fromInt, and String.fromFloat.
Html.beginnerProgram becomes Browser.sandbox.
Html.program becomes Browser.element and Browser.document.
elm-lang/* moved to elm/*

module Counter exposing (..)

import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Browser exposing (sandbox)
type alias Model = Int

type Msg
  = Inc
  | Dec

model : Model
model = 0

update : Msg -> Model -> Model
update msg model2 =
  case msg of
    Inc ->
      model2 + 1
    Dec ->
      model2 - 1


view : Model -> Html Msg
view model1 =
  div []
    [ button [ onClick Inc] [ text "Inc" ]
    , text (String.fromInt model1)
    , button [ onClick Dec ] [ text "Dec" ]
    ]

main : Program () Model Msg
main =  Browser.sandbox
       { init = model
       , view = view
        , update = update}

#######################################

1. wrote you .elm file
2. run elm reactor
3. visit localhost:8000 then click your .elm file

##########################################

https://medium.com/javascript-inside/introduction-into-elm-77512c6c0baf

elm-package install elm-lang/html

module Basic exposing (..)
import Html exposing (Html, text)
main =
  text "Introduction Into Elm"

############################################

### run shell in js ###############
xtermjs.org
js's websocket + python's pty should do this too

####################################

https://medium.com/@benoitvallon/a-mobile-desktop-and-website-app-with-the-same-code-dc84ef7677ee

React-native, NW, Electron and React, all in one
A mobile, desktop and website App with the same code

###################################################

windows 7 bluetooth setting icon missing

--Bluetooth---Bluetooth-Bluetooth

##########################################

#curl to requests

https://curl.trillworks.com/

#########################################################

#take pictures  #update picture in div #show image with js
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">	
	<!-- <meta http-equiv="refresh" content="10"> -->
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="js/jquery-3.3.1.min.js"></script>
	<link rel="stylesheet" href="css/bootstrap.min.css">
	<link rel="stylesheet" href="css/custom.css">
	<script src="js/bootstrap.min.js"></script>
   <script src="/libs/qi/2/qi.js"></script>
	<title>index</title>
  </head>
	<body>
	<div id="bg" onclick="qr()"> </div>
	<div id="bg2" ></div>
	<script type="text/javascript">
	$(window).on("load",function(){
		$('#bg2').hide();
		$('#bg').show();
		qr = function() { 
			$('#bg').hide();
			$("#bg2").html("<img src=img/qr.jpg>");
			//document.getElementById("bg2").backgroundImage = "img/qr.jpg";
			$('#bg2').show();
		};
		})
	</script>	
</body>
</html>

##############################################
import requests
files = {
            'c': ('d:/image1.jpg', open('d:/image1.jpg', 'rb')),
        }
r = requests.post('https://ptpb.pw/', files=files, verify=False)
print(r.content.split("url: ")[1])


>>> import qrcode
>>> qr=qrcode.QRCode(version=1,error_correction=qrcode.constants.ERROR_CORRECT_H, box_size=10, border=4,)
>>> data="https://www.baidu.com"
>>> qr.add_data(data)
>>> qr.make(fit=True)
>>> img=qr.make_image()
>>> img.save("image1.jpg")
>>>
https://ourcodeworld.com/articles/read/554/how-to-create-a-qr-code-image-or-svg-in-python

######################################

work:
   pip install --user qrcode
   pip install -t /home/nao/pip/  qrcode

not work:
  <cdunklau> jusss: pip install --user virtualenv
  <cdunklau> jusss: then python -m virtualenv /home/nao/testenv
<cdunklau> jusss: then /home/nao/testenv/bin/pip install --upgrade pip setuptools
<cdunklau> then /home/nao/testenv/bin/pip install whatever	        [16:39]
<cdunklau> then just run /home/nao/testenv/bin/python

finally:
https://stackoverflow.com/questions/48387823/install-things-on-pepper
pip install --user --upgrade pip
/home/nao/.local/bin/pip install --user whatever-package-you-need

or:
http://www.about-robots.com/how-to-import-python-files-in-your-pepper-apps.html
import python files on the left bar in Choregraphe, in python box, import that python file
name without .py

/home/nao/.local/bin/pip install --user CFFI

#####################################

<jusss> yunfan: css			        [15:28]
<yunfan> jusss: scss						        [15:29]
<eiGHttt> lesssass

###################################################

<jusss> yunfan: generatorcoroutine, Continuationcoroutine, future
	coroutine,futurePromise,
	double barrelled continuationPromise, generator
								        [17:22]
<jusss> yunfan: django flask aiohttp,
	postgresql, mysql, 					        [17:25
<jusss> OOP,OOPOOPbased on Prototype
	Classconstructor 
<yunfan> jusss:  
	 	

#####################################

insertInt : String -> Int -> DataDict -> DataDict
insertInt key val =
    Dict.insert key (Json.Encode.int val)

 insertInt key1 val1 Dict1Dict2

######################################

                                 
f : Int -> String       f Int = "hello"       f 1

https://guide.elm-lang.org/appendix/function_types.html

  
update : Msg -> Model -> Model   update Msg : Model -> Model
Model

update MsgModel

update Msg Model Model
update Msg ModelModel

update Msg ModelModel

update Msg ModelModel


update msg model =
case msg of
    Increment ->
      model + 1

    Decrement ->
      model - 1
####################################

<jusss> eiGHttt: insertInt : String -> Int -> DataDict -> DataDict what this
	means?							        [10:29]
<eiGHttt> DataDict insertInt(String a, Int b, DataDict c) {} C++
	  					        [10:31]
<jusss> eiGHttt: insertIntStringkey
	Intval,DataDictDataDict
	
<eiGHttt> add x y z = x + y + z; add1 = add 1, add1 :
	  Int -> Int -> Int
<eiGHttt> repl
<jusss> eiGHttt: add1: Int -> Int -> Int, Int
<eiGHttt> Int(Int -> Int)	        [10:50]
<jusss> eiGHttt: (), f
	jsff()
							        [10:51]
<eiGHttt> f x y z = ((f(x))(y)(z)		        [10:55]
<eiGHttt> f(x, y, z)				        [10:56]
<jusss> eiGHttt: (f(x)(y))(z) 		        [10:57]
<eiGHttt> f
<eiGHttt> 
<jusss> eiGHttt:   f x y z,  f x y = do-something 
<jusss> insertInt : String -> Int -> DataDict -> DataDict ;    insertInt key
	val =   Dict.insert key (Json.Encode.int val)		        [11:00]
<eiGHttt> f : Int -> Int -> Int -> Stringf x y : Int -> String
<jusss> eiGHttt:  f x yInt 
	String?							        [11:01]
<eiGHttt> 
<eiGHttt> 
<jusss> eiGHttt: , insertInt key val 
	DataDictDataDict,   =
	Dict.insert what-ever			        [11:03]
<jusss> ==		        [11:04]
<jusss>  function parameter = function-body
<eiGHttt> insertInt key val : DataDict -> DataDict
	  (DataDict -> DataDict)
<eiGHttt> 
<eiGHttt> f : Int -> Stringf x = "hello"f x = show x
	  						        [11:06]
<jusss> eiGHttt: f: Int -> String  f x = "hello" 
<eiGHttt> C					        [11:08]
<jusss> eiGHttt: 				        [11:10]
<eiGHttt> 
<eiGHttt> 
	  							        [11:13]
<eiGHttt> 			        [11:14]
<jusss> eiGHttt: f: Int -> String,   f Int : String ,  is same?	        [11:16]
<jusss> eiGHttt: f x = "hello",    f = what?
<jusss> eiGHttt:  : ->  = ...	        [11:18]
<jusss> 
<jusss> f = x "hello" ?
<eiGHttt> f : Int -> String; (f 1) : String			        [11:19]
<eiGHttt> elm		        [11:21]
<eiGHttt> 					        [11:22]
<jusss> eiGHttt: elmhttps://guide.elm-lang.org/   
							        [11:23]
<anotitlebot> Introduction  An Introduction to Elm
<jusss> eiGHttt: 
<jusss> https://guide.elm-lang.org/core_language.html		        [11:24]
<anotitlebot> Core Language  An Introduction to Elm
<eiGHttt> https://guide.elm-lang.org/appendix/function_types.html       [11:27]
<anotitlebot> Function Types  An Introduction to Elm

<jusss> eiGHttt: 
						        [14:57]
<eiGHttt> 
<jusss> 
	
<jusss> 
						        [14:59]
<eiGHttt> jsfoldr
	  
<eiGHttt> haskellStateMonad
	  effect monad			        [15:02]
<jusss> eiGHttt: Monad		        [15:03]
<jusss> eiGHttt:  
<eiGHttt> Monad
<jusss> eiGHttt: csscsselm,elm
	css...				        [15:10]
<jusss> eiGHttt: js,dom js css xml
<jusss> js					        [15:11]
<eiGHttt> css				        [15:12]
<jusss> eiGHttt: bootstrap less		        [15:16]
<eiGHttt> 'google css					        [15:17]
<varia> eiGHttt: 2017 20 CSS -  [
	https://zhuanlan.zhihu.com/p/27767048 ] 201778 ... 
	, , . , 
	20 CSS ,  ...
<anotitlebot> 2017  20  CSS  - 
##########################################

Double-barrelled Continuation Passing Style, to implement Promise in JS,
also you can use Future to implement Promise, and Promise can be flatten
###############################

elm

func-name parameters = doSomething

double n = n * 2
numbers = [1,4,3,2]
List.map double numbers

########################################

#linux on phone

https://wiki.postmarketos.org/wiki/Xiaomi_Redmi_2_(wingtech-wt88047)

#####################################################

#constructor         which is what created the object

javascript constructor

class FooBar {
  constructor(baz) {
    this.baz = baz
  }
}
const foo = new FooBar('7')

The equivalent of this before ES6, was creating a function that instantiates an object as such

var FooBar = function(baz) {
  this.baz = baz;
}

python's constructor is class's __new__(), it can return something that is not an instance

The new method is called with the class as its first argument; its responsibility is to return a new instance of that class. 
Compare this to init: init is called with an instance as its first argument,
and it doesn't return anything; its responsibility is to initialize the instance. 

__new__ is forged by @classmethod,  it can return a number to replace an instance
or return other class's instance as its instance
https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new

http://blog.51cto.com/853056088/2134300?source=dra
#,,
#,,,

class B(object):
    __instrance = None #
    def __new__(cls):
        if cls.__instrance == None:
            cls.__instrance = object.__new__(cls) #None,,
            return cls.__instrance
        else:
            return cls.__instrance #
c=B()
d=B()
print(id(c))
print(id(d))


3000151571592
3000151571592


#######################################################

from tkinter import *
root = Tk()

def recv_from_kbd(event=None):
    msg=my_msg.get()
    my_msg.set("")
    listbox.insert(END,msg)


my_msg = StringVar()  # For the messages to be sent.
my_msg.set("")    

listbox = Listbox(root)
listbox.pack(fill=BOTH, expand=True)

input_area=Entry(root,textvariable=my_msg)
input_area.bind("<Return>",recv_from_kbd)
input_area.pack(anchor="sw",fill="x")

for i in range(20):
    listbox.insert(END, str(i))

mainloop()

"""
https://stackoverflow.com/questions/40323850/second-frame-with-fill-both-and-expand-true-not-expanding-fully
expand and fill are completely independent of each other. expand answers the question "do I get extra space?", and fill answers the question "how do I use the extra space that was given to me?".
So, you have two frames both of which have expand=True. That means that tkinter will give half of the extra space to one frame, and half the extra space to the other, regardless of how those widgets plan to use the extra space.
"""
class Promise:
    def __init__(self):
        self.value=None
    def then(self, f):
        try:
            self.value = f(self.value)
        except:
            return "Exception"
        else:
            return self
    def result(self):
        return self.value

The Tkinter Frame Widget. A frame is rectangular region on the screen.
The frame widget is mainly used as a geometry master for other widgets,
or to provide padding between other widgets.

################################################################

#socket
auto change socket port when it's in use
On Server
        self.sock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        for i in range(10000,10100):
            try:
                self.sock.bind(('0.0.0.0',i))
            except:
                pass
            else:
                break
            
        self.sock.listen(122)
        self.net_init()
        self.sock.close()

On Client
    for i in range(10000,10100):
        try:
            sock.connect(('192.168.31.222',i))
        except:
            pass
        else:
            break
    sock.send('connected'.encode('utf-8'))

#####################################################

<sinclair_> SAFE: function loop() { /* your code */ if (cond) { setTimeout(()
	    => loop(), 1) } }
<sinclair_> UNSAFE: function loop() { /* your code */ if (cond) { loop() } }
<sinclair_> jusss: all you need to know here is that by moving the recursive
	    call into that setTimeout, you have removed the call from the
	    callstack, and it can loop forever safely
<GreenJello> setTimeout is going to be really slow		        [13:39]
<sinclair_> jusss: if you look at best practice render loops in the browser
	    they do the same thing
<sinclair_> jusss: except they replace setTimeout with requestAnimationFrame
<sinclair_> jusss: the exact same mechanisms (moving out of the callstack)
	    apply
<jaawerth> sinclair_: don't recommend process.nextTick for recursion
<sinclair_> jaawerth:
	    https://nodejs.org/api/process.html#process_process_nexttick_callback_args
##########################################

function* f(){
	  yield new Promise(function(r,e){
	  	console.log(1);
		setTimeout(function(){r(1); g.next()},3000)})
                        .then(function(_){console.log(2);setTimeout(function(){r(1);g.next()},3000)})
                        .then(function(_){console.log(3)})}
g=f()
g.next()

##################################

#while-loop #while-loop-yield
var cond=true
function* f() {
	  while (cond){
	  	  console.log(1);
		   yield setTimeout(function(){g.next()}, 1000)}}
g=f()
g.next()

cond=false

########################################

function* f() {
	  console.log(1);
	  yield delay(5000)
	  	.then(function(){console.log(2); g.next()})
		.then(function(){console.log(3)})}
g=f()
g.next()

#############################################

delay = function(t) {
      return new Promise(function(resolve){
      	     setTimeout(function() {resolve(t)}, t)})};

var clicked=false;

run = function(cond){
    if (cond) { return; };
    console.log(2);
    return delay(100).then(function(){return clicked}) .then(run) ; };

run(clicked);

// create a loop with Promise+Recursion, and control it by the outside condition
// the whole point is that it can return to the main thread or caller

clicked=true;


################################################################

<eiGHttt> https://paste.ubuntu.com/p/5mBzCY43k4/		        [09:48]

const delay = t => {
    return new Promise(resolve => {
        setTimeout(_ => resolve(t), t);  //brilliant, even never use _,  _ instead of ()
    });
};

const run = times => {
    if (times > 5000) {
        return console.log("done");
    }

    console.log(`running ${times}`);

    return delay(times)            //brilliant, this is a Promise
        .then(times => times + 1000)   // return a times+1000 to change the times 
        .then(run)                       // expand run it will be function(times){...}
    ;
};

run(0);

###################################################

#Promise #Future #PartThree
<jusss> grym: in JS, Promise may be a just placeholder, it represent a result, 
<jusss> grym: in python, what Future represent?			        [11:43]
<jusss> grym: return new Promise().then().then() it return just ONE promise in
	JS, what if return Future.addCallback().addCallback will return?
<meejah> jusss: Future doesn't have addCallback (but the answer is: there's
	 still just one Future and/or Deferred if that's what you meant)	
<meejah> (but also, why does that matter?)
<jusss> meejah: it matters about what 'return' will return
<meejah> jusss: Future represents a promise to at some point return a result
	 (same with Deferred). They're both analagous to Promise
<meejah> jusss: addCallback() returns the Deferred so you can chain like that
	 .. don't recall about Future.add_done_callback		        [11:48]
<jusss> meejah: I saw that JS people always use Promise().then().then(). and I
	never saw that usage in python 
<jusss> yeah, python do have that thing, but I dont see people use it   [11:49]
<energizer> that's d.addCallback().addCallback(), isn't it?
<meejah> yes
<energizer> aka `await`
<meejah> Personally, I don't do it because a) "async def" and "await" read
	 better anyway and b) even if you're using "plain Deferreds" I find
	 declaring named functions and adding them one at a time reads better
<meejah> ...and that sort of "cascade + indent stuff" pattern from JS isn't
	 very common in Python
<energizer> i usually see that "fluent style" in pandas and sqlalchemy  [11:52]
<meejah> ah, okay haven't really used those (I'm not saying it's wrong, I just
	 haven't seen it very much)
<altendky>
	   https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.add_done_callback
	   relates i tihnk
<jusss> those concepts completely confused me
<energizer> take a look at trio, it doesnt have those concepts	        [12:00]
<jusss> even I can use them, but I still have a idea what they are
<jusss> still don't
<jusss> it's a wonderful thing that you don't need to understand them before
	you use them
<altendky> energizer: how do you implement the bottom layers in trio?  like i
	   do here to 'translate' between qt signal/slot and deferred (that
	   could be used with async/await)
	   https://github.com/altendky/altendpyqt5/blob/develop/src/altendpyqt5/twisted.py
	   (i've got similar in asyncio if that'd be easier to comment on)
								        [12:03]
<altendky> jusss: a deferred sits there remembering what to call when it's
	   'done'.  at some point some code tells it it is done and the
	   deferred then calls that thing it was supposed to
<energizer> altendky: https://github.com/python-trio/trio/issues/399
<altendky> energizer: i started to read that the other day.  but i meant more
	   in general.  i've also used a deferred that i return and then
	   eventually .callback() with my query/response canbus code
<altendky> energizer: in my head future/deferred/etc are the underlying
	   building blocks, things that an application may never need to see.
	   but, the upper layers seem to need them.  i'm wondering how trio
	   does away with them entirely.
<altendky> what do you do when you are building an awaitable from something
	   that isn't async/await already
<energizer> altendky: you mean like sockets?			        [12:08]
<altendky> energizer: that'd be one scenario, though i'd think that that'd
	   already be wrapped up by them never to be touched directly again.
								        [12:09]
<energizer> altendky: ya
<energizer> altendky: is that signal=signal from the signal module?
<altendky> energizer: sorry, no.  that's a qt signal.  signal/slot in qt is
	   basically a callback registration tool.  a button has a 'clicked'
	   signal and you .connect() to your thing you want called when the
	   button is clicked.
<altendky> energizer: so i was making it so you could await a signal rather
	   than having to write the response in a separate function
<altendky> energizer: in the case of my canbus query/response code i would
	   send a canbus message, return the deferred, then when the matching
	   canbus response is received (in that case triggered by a receive in
	   a thread firing through a signal/slot to cross the thread boundary)
	   i fire the deferred as the activity is complete	   
#############################################
#Promise #Future #PartTwo #linuxba

<jusss> LdBeth: eiGHttt morning					        [09:29]
<jusss> eiGHttt: https://paste.ubuntu.com/p/MTxdBz2myv/  
	generator					        [09:30]
<eiGHttt> 					        [09:37]
<eiGHttt> while g.next()?
<jusss> eiGHttt: promise,5yield
								        [09:40]
<jusss> eiGHttt: yield
								        [09:41]
<jusss> eiGHttt: Promise(1).then(2).then(3) 1, 5
	2,53				        [09:42]
<jusss> eiGHttt: async/await? jsasync/awaitpython
	jsevent-loop		        [09:43]
<eiGHttt> timeout
<jusss> eiGHttt: promise,5yield, yield
	, Promise(1).then(2).then(3) 
	1, 52,53, 
	async/await? jsasync/awaitpythonjs
	event-loop		        [09:43]
								        [09:45]
<jusss> eiGHttt: typeError generator
<jusss> eiGHttt: yieldpromise,promisesetTimeout
								        [09:46]
<jusss> eiGHttt: setTimeout, yield
	Promise.then()				        [09:47]
<jusss> eiGHttt: yield
<eiGHttt> https://paste.ubuntu.com/p/5mBzCY43k4/		        [09:48]
<jusss> eiGHttt: aha						        [09:51]
<jusss> eiGHttt: Promise + setTimeoutasync/await?  yield
	Promise				        [09:53]
<eiGHttt> 			        [09:54]
<jusss> eiGHttt: 			        [09:55]
<eiGHttt>
	  https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000
								        [09:57]
<jusss> eiGHttt:  return delay(times) .then(times => times + 1000) .then(run)
	delay(times)
<jusss> 
<eiGHttt> delay()promise(let (promise (delay times)) (then
	  promise))			        [10:05]
<jusss> eiGHttt: returnPromise, Promise
								        [10:09]
<jusss> ?
<jusss> 
<jusss> returndelay(times)Promise,
	delay(times).then().then() Promise			        [10:10]
<eiGHttt> 							        [10:11]
<jusss> 						        [10:12]
<jusss> eiGHttt: nyfair LdBeth "promises are placeholders for values; they
	represent a result, futures represent an operation" ?
								        [11:12]
<jusss> promise, promise	        [11:13]
<nyfair> ?????							        [11:16]
<nyfair> jusss: ecma
	 
<eiGHttt> https://tokio.rs/docs/getting-started/futures/ futures
<jusss> nyfair: return new Promise().then().then()new
	Promise().then().then()result, returnfinal result,
	Promiseoperation, returnPromise(), 
	Promise().then().then()
<nyfair> jusss: rust
<nyfair> rustrust				        [11:22]
<eiGHttt> futures
<jusss> 
<eiGHttt> 		        [11:28]
<jusss> A future is a value that represents the completion of an asynchronous
	computation. 						        [11:31]
<jusss> eiGHttt:  futureresult		        [11:32]
<eiGHttt> 
<jusss> eiGHttt: future
<jusss> 
<eiGHttt> 
<jusss> future				        [11:36]

###############################################################

#Promise #Future #PartOne ##javascript
<jusss> function* f(){yield new
	Promise(function(resolved,rejected){console.log(1);
	setTimeout(g.next(),5000)}).then(function(r,e){console.log(2);setTimeout(g.next(),5000)}).then(function(r,e){console.log(3)})}
<jusss> g=f()
<jusss> g.next() will cause TypeError
<jusss> already executing generator
<rook0> TypeScript is pretty nice sinclair_
<jusss> rook0: how to fix it? I want the generator auto be iteration
<jusss> when 'return new Promise().then().then()' it just return the head of
	Promise() or all the whole Promise().then().then()?	        [10:31]
<jusss> return will eval its parameter, so the Promise() will be evaluated and
	return, but just evaluated the head of Promise or evaluated the whole
	Promise().then().then() then return to caller???
<jusss> someone can help me?
<devsnek> its the same as `return (new Promise.then().then().then())`   [10:34]
<jusss> devsnek: return will wait the value of the whole Promise.then().then()
	?							        [10:35]
<zsocw> there's no "value of the whole"
<zsocw> it only returns 1 promise
<zsocw> which resolves to the whatever the final promise in the chain resolves
	to
<devsnek> what's the difference between zsoc and zsocw		        [10:36]
<jusss> return will wait for the the final promose's return value?
<jusss> zsocw has a 'w
<devsnek> return won't wait for the final promises's value
<devsnek> `x.y().z()` is one expression
<jusss> devsnek: but return always evaluated its parameter, so `x.y().z()`
	will return a what?
<devsnek> whatever `.z()` returns				        [10:38]
<devsnek> in this case its `.then()`
<devsnek> so it returns a promise
<jusss> devsnek: it returns a promise and this promise will be evaluated,
	right?							        [10:39]
<devsnek> "evaluated"
<jusss> I express wrong?
<zsocw> promises don't get evaluated
<zsocw> they are either pending, fufilled, or rejected		        [10:41]
<jusss> zsocw: how to describe a promise's execution?		        [10:42]
<zsocw> There's no way to describe it because a promise doesn't execute
<zsocw> it's a placeholder
<zsocw> The thing that a promise chain returns is a promise, whether it's just
	`Promise.resolve()` or it's 100 chains of .then's
<jusss> zsocw: the 'x.y().z()' is one promise, or 'x.y().z()' return one
	promise?
<zsocw> "is" doesn't make sense in this context			        [10:48]
<zsocw> 'Promise.resolve().then(() => {}).then(() => {})' is an expression
	which returns a promise
<jusss> zsocw: return 'Promise.resolve(1).then((2) => {2}).then((3) => {3})'
	to caller, caller will get 1 or 2 or 3?
<zsocw> caller will get a promise :)
<zsocw> that resolves to 3
<zsocw> i mean, that's not valid js, but assuming you fix the part with the
	number literal params... then the caller will get a promise which
	resolves to 3
<jusss> zsocw: yeah, but what if from 1 to 2 it need a little time?
<zsocw> ... for what?						        [10:53]
<zsocw> 'a little time' is another of many things you've said which have no
	contextual meaning
<jusss> zsocw: blocking for 2s ?
<zsocw> no
<zsocw> why do you want to 'block' for 2 seconds?
<jusss> not every function is non-block				        [10:54]
<jusss> there always are some functions are blocking
<zsocw> every i/o functions should be non-blocking
<zsocw> other functions, sure, mostly they are synchronous
<zsocw> but there is never "Arbitrarily block for 2 seconds" unless your use
	case is literally "a 2 seconds timer"			        [10:55]
<zsocw> in which case, sure, use a promise wrapper around setTimeout :p
<jusss> the promise concept blow my mind up
<zsocw> it's really not that complex - and it's not a javascript thing  [10:56]
<zsocw> many general purpose languages have Futures, some even also call them
	Promises :p
<jusss> zsocw: in python, they have Future, but I don't see they use
	Future.addCallback , in js I saw you guys always use
	Promise.then().then()					        [10:57]
<zsocw> What do you think goes inside the .then()?		        [10:59]
<zsocw> (spoiler, it's a callback)
<jusss> yeah, it's a callback, but I don't know why pyther don't use that
<jusss> they just wrote all things in a Future and await or yield, and put
	those Future into a list then iterate the list
<zsocw> `await Promise.all(listOfPromises)`... it's the same thing in js
<jusss> they don't use Futures.addCallback like Promise.then()
<GreenJello> jusss, JS also has async/await			        [11:01]
<jusss> zsocw: GreenJello but there's another thing different, python need you
	to create a event loop and put those Future object into this
	event-loop, and the event-loop will run at the last of the code and
	it's blocking the thread, but in JS, I never saw an event-loop be
	created or be plug-in something by handle		        [11:02]
<jusss> or by manual?
<zsocw> javascript *has* an event loop already (at least the environment
	you're running it in, does)				        [11:03]
<zsocw> so you don't have to do squat
<zsocw> which is why dealing with asynchronous stuff in general is just
	superior (well, in most comparisons)
<jusss> 'return new Promise.then().then()' return one Promise, ok, this I can
	accept, but I still don't know how to describe or express this
	Promise's execution/evalated? 				        [11:06]
<jusss> then callback in the Promise, they need to be evaluated
<jusss> or execution
<jusss> the callbacks						        [11:07]
<GreenJello> jusss, promises are placeholders for values; they represent a
	     result
<GreenJello> futures represent an operation
<GreenJello> the work has already started by the time you have a promise
<GreenJello> you don't have to execute promises. If you just do
	     returns_promise() and discard it, the work still happens
								        [11:08]
<jusss> GreenJello: wow, that really blow my mind up
<jusss> promise is not future!!!
<zsocw> It's a type of future
<zsocw> https://en.wikipedia.org/wiki/Futures_and_promises	        [11:09]
<zsocw> :p
<jusss> if what GreenJello said is right, then I will understand promise and
	future :)
<jusss> promise is a result, and future is an operation		        [11:10]
<GreenJello> wikipedia seems to disagree with my understanding
<zsocw> well, that happens often lol... wikipedia also loves the term
	'associative array'					        [11:12]
<jusss> sinclair_: some people told me that Promise is double-barrelled CPS, I
	have no idea what they said				        [13:40]
<jusss> CPS is short for Continaution Passing Style	
<jusss> jaawerth: I just wonder are they the same? Promise and Future, also
	the meaning of they use them like that
<jaawerth> jusss: well, a promise is just a wrapper for a future value. it's
	   just an object with .then and .catch methods you can pass callbacks
	   into. The main benefit over regular CPS is that you can pass them
	   into and return them from functions, which makes interop and
	   control flow easier
<jaawerth> jusss: the only real difference between a promise and a future is
	   that promises will automatically "flatten" = if you return a
	   promise from within a promise, it will resolve to the value
	   resolved by the inner promise so you don't have to invoke .then()
	   twice						        [13:45]	   
##################################################################

setTimeout is keypoint for callback/ jump back to Promise,
yield a Promise, and that head of Promise is a setTimeout for callback this return value, so the generator will auto run


################################################

android's camera as a plug-in camera of a laptop

download IP Webcam by Pavel Khlebovich from Google Play,
turn laptop and android wifi and data off, then connect laptop
and android with usb cable, enable android usb-tethering for that
laptop can get an IP from android, once laptop get an IP from android
via dhcp, now run IP Webcam on android, click the last option "enable server",
android will open camera and show an IP address you need to connect with browser,
once you get there, click "browser" tag not "flash" in "Video" section on that website
and click "fullscreen" it will pop up a new website, click the video and it will expand,
then press F11 to fullscreen, and also you can plug an external monitor via hdmi/vga,
you can make what android's camera captured to show in the external monitor at the
same time.

####################################################

before ES6/ES2015, use 'var' keyword define local variable in function

jQuery.fx.off = true|false; true 	Specifies that animations should be disabled

jquery, $("#id") get element
Return the value of an attribute:
$(selector).attr(attribute)
Set the attribute and value:
$(selector).attr(attribute,value)
Set attribute and value using a function:
$(selector).attr(attribute,function(index,currentvalue))


##############################################

When a function is created in JavaScript, JavaScript engine adds a prototype property to the function.
https://hackernoon.com/prototypes-in-javascript-5bba2990e04b
Prototype object of the constructor function is shared among all the objects created using the constructor function.     that's why it called prototype linked OOP
function Person(){}  # create an empty constructor function
Person.prototype.name = "Ashwin" ;
var person1 = new Person();
console.log(person1.name)// Output" Ashwin     


#############################################

'this' keyword in js,  javascript is OOP based on prototype ,
The this keyword evaluates to the value of the ThisBinding of the current execution context

https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work
notice that  Function.prototype.apple call bind 

#this #namespace
this means the namespace where the function is called  when it's running

object.function(a,b,c){ this-means-the-object}

#scope #namespace
<jusss> 'scope' is where variables can visit, and 'namespace' is where
	variables be created, right?
<nedbat> jusss: something like that: a scope is a region of code where a name
	 means a particular variable.				        [09:19]
<nedbat> jusss: a namespace is a collection of names.
<energizer> nedbat: whats a variable
<nedbat> energizer: a binding of a name to a value		        [09:25]
<energizer> nedbat: its a name-value pair?
<jusss> nedbat: my thought was wrong or improper?
<nedbat> energizer: ok
<nedbat> jusss: no, not wrong, i'm just trying to clarify
<energizer> nedbat: that was a yes or no question :)
<nedbat> energizer: you can put it that way if you like		        [09:26]
<jusss> nedbat: I see
<energizer> nedbat: are these terms at all fuzzy for you?	        [09:27]
<Ninpo> I'm gonna guess: no
<nedbat> energizer: it is difficult to be precise, yes.


####################################

AJAX, Fetch API, WebSocket
https://developer.mozilla.org/en-US/docs/Web/API



AJAX is a developer's dream, because you can:
    Read data from a web server - after the page has loaded
    Update a web page without reloading the page
    Send data to a web server - in the background

an event occurs, create an XMLHttpRequest object, send HttpRequest to server
server process HttpRequest, create a response and send data to browser
browser process the data and update page content

click button can be an event, XMLHttpRequest object can send a request to web server
the server process the request and return back, once js receive it then
perform update-page

var = new XMLHttpRequest();
var.open("GET", url, true); or POST, if it's true then asynchronous, flase for synchronouse
var.send();     send(string) for POST
var.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
var.send("fname=Henry&lname=Ford");  like 'data' in requests of python

XMLHttpRequest.onreadystatechange = function (){}   once it receive the answer then run the function
XMLHttpRequest.responseText will be anwser

<script>
function loadDoc() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      document.getElementById("demo").innerHTML =
      this.responseText;
    }
  };
  xhttp.open("GET", "ajax_info.txt", true);
  xhttp.send();
}
</script>



############################################################
#TencentAI #aldebaran #assign module to variable

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        import tornado.httpclient, urllib, json, hashlib, time, random, string
        self.http_client = tornado.httpclient.HTTPClient()
        self.urllib = urllib
        self.json = json
        self.hashlib = hashlib
        self.time = time
        self.random = random
        self.string = string
        self.curlmd5 = lambda self,src: self.hashlib.md5(src).hexdigest().upper()
   
    def get_params(self,questionBytes):
        time_stamp=str(int(self.time.time()))
        nonce_str = ''.join(self.random.sample(self.string.ascii_letters + self.string.digits, 10))
        app_key=''
        paramsDict = {'app_id':'',
                  'question':questionBytes,
                  'time_stamp':time_stamp,
                  'nonce_str':nonce_str,
                  'session':''
                 }
        sign_before = ''

        for key in sorted(paramsDict):
            sign_before += '{}={}&'.format(key,self.urllib.quote(paramsDict[key], safe=''))

        sign_before += 'app_key={}'.format(app_key)
        paramsDict['sign'] = self.curlmd5(self,sign_before)
        return paramsDict

    def get_content(self,question):
        url = "https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat"
        sendDataDict = self.get_params(question)
        body = self.urllib.urlencode(sendDataDict)
        response = self.http_client.fetch(url, method='POST', body=body, validate_cert = False)
        return self.json.loads(response.body)["data"]["answer"]

    def onInput_onStart(self, p):

        if p == "I Don't Understand":
            self.ai_output("I Don't Understand")
        else:
            
            t=self.get_content(p)
            self.ai_output(p + "split" + t.encode('utf-8'))

    def onInput_input1(self,p):
        self.ai_output(p)

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box

##########################################################
#lambda #class
classlambdaselfself
selfdefself

class A:
    def __init__(self):
        self.b=lambda x: x+2
b=A()
print(b.b(3))

class C:
    def __init__(self):
        self.z=3
        self.d=lambda self, x: self.z + x
    def b(self, x):
        return self.d(self, x)
d=C()
print(d.b(2))

classselfcallbackreturn,appendlist, whatever
classinstanceselfinstance

#crazyCode from aldebaran's ialbehavior.py
# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class  _object : pass
    _newclass = 0

class SwigPyIterator(_object):
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
      __del__ = lambda self : None;
      __getattr__ = lambda self, name: _swig_getattr(self, behavior, name)
      def autoBind(self, *args): return _ialbehavior.behavior_autoBind(self, *args)
      def setEnabled(self, *args): return _ialbehavior.behavior_setEnabled(self, *args)
      def isEnabled(self): return _ialbehavior.behavior_isEnabled(self)

     for _s in [inaoqi.baseModule]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))

#likely
a=1
def g():
    if (a==1): return 2
    return 3
def g2():
    return 3 if a!=1 else 2
def g3():
    try: a.append(3)
    except: return 3
def g4():
    if a != 1: return 3
    else: return 2

### import module in a function or method, or assign module to variable in class
### not assign module.method to variable in class, assign module to variable
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        import tornado.httpclient, urllib, json
        import hashlib, time
        import random
        from urllib import quote
        self.http_client = tornado.httpclient.HTTPClient()
    def onLoad(self):
        import hashlib
        self.hashlib = hashlib
    def curlmd5(self,src):
        #import hashlib
        m = self.hashlib.md5(src)
        return (m.hexdigest().upper())

#############################
assert condition,  check the condition is None/False or not
In Python, it's roughly equivalent to this:
if not condition:
    raise AssertionError()

#####################################

in js, c=a||b  if a don't exist then give b to c, but this don't work on python
in python if a don't exist it will cause a NameError
python have a built-in method called 'hasattr()' that can check an object has a variable or not, but it only works on objects not functions

def f():
    a=1
    return a
print(hasattr(f,"a"))  #it won't work, it can't check a variable is in a function object or not
class A:
    def __init__(self):
        self.a=1
B=A()
print(hasattr(B,"a"))
https://docs.python.org/3/library/functions.html#hasattr

with dir(B) I can know there's a name called "a",
<altendky> 22:15 <altendky> jusss: there's hasattr for attributes and except
	   NameError for variables, but it's an ugly and annoying way to code.
	   setting a variable/attribute to None is better	        [11:38]
<altendky> jusss: `try: blah = maybe_exists except NameError: blah =
	   when_it_does_not_exist`  but why can't you just make it exist?  you
	   could then do what you want with `blah = maybe_is_not_none or
	   when_it_is_not_none`
########################################

yield future-object will not run once the future object,
yield from future-object, will run once the future obejct

the class/frame/libarary that tornado provide will return a future object in their class itself
so don't worry about blocking, because you override their pre-class, they want you to change that, and it will future object, and you can yield that , don't worry about blocking stuff!

Most asynchronous functions in Tornado return a Future; yielding this object returns its Future.result.
###########################################


Asynchronous & Promise/Future
Asynchronousecallback
PromisePromisecallback
jsPromise
PromisePromisecallback.then().
Promise.then()callback

jsPromisePromise,Promise

 Promise/Futuren

namespacecave, cave
                                                                               .then() .addCallback()  await                              y(g(f(x)))                                            
Promise/Future

pythonFutureaddCallback,Promise
aldebaranqi.FutureFuture,Promise.setValue,asyncio.result(),jsresolve()
python3concurrent.futuresasynciofutureasyncio
Asynchronous, yieldselect()/epoll()
Future.
awaitFutureFutureyield generator, async/await
generatorsend()Future.addCallback()addCallbackgenerator
, generatorAsynchronousasyncioasync/await
async/awaitawaitasyncio.runasyncio.runconcurrent.futures
jsPromise

concurrent.futures.Future  asyncio.FutureObject
https://docs.python.org/3/library/asyncio-future.html#asyncio.wrap_future

callback
https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.add_done_callback

import asyncio
from concurrent.futures import ThreadPoolExecutor

async def f1():
    print(1)
    await f2(1)

async def f2(x):
    print(x+1)
    await f3(x+1)

async def f3(x):
    print(x+1)
    await asyncio.sleep(1)

def async_chain():
    asyncio.run(f1())
    
    
executor=ThreadPoolExecutor()
futures=executor.submit(async_chain)
print(futures.result())


"""
for x in y:
    z.append(await f(x))

<jusss> altendky: in js Promise.then().then() can always append callback
	function into the Promise object, I wonder python's future can do
	that?  future.addFuture() ?
<altendky> jusss: did you look at the docs? Was there a function? And asyncio
	   future isn't concurrent.futures iirc			        [10:16]
<altendky> jusss: but mostly you'd use async/await rather than callbacks
<_habnabit> they are indeed (quite confusingly) different types of futures
<altendky> jusss:
	   https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.add_done_callback
<jusss> altendky: it seems I can use asyncio.future object to instead of
	callback function way?					        [10:20]
<altendky> jusss: I'm not sure what you mean. But in case you want to mix the
	   futures
	   https://docs.python.org/3/library/asyncio-future.html#asyncio.wrap_future
<altendky> jusss: normally you'd just write an async def with `await x(await
	   y(z))` or such to do multiple things and not really deal with
	   futures
<altendky> Or intermediate variables, either way		        [10:22]
<jusss> altendky: ok, the Future object are not same, in asyncio, I can use
	async def to create a coroutine object, which method I should use to
	turn it to Future object? loop.create_task or asyncio.ensure_future?
<altendky> jusss: what are you trying to do?
<jusss> altendky: make a Future object, and use Future.add_done_callback to
	make a future chain, like callback
<jusss> is that possible? 
<altendky> jusss: isn't that the link I shared?
<altendky> 21:18 <altendky> jusss:
	   https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.add_done_callback
<jusss> altendky: yeah, it is, I just don't know why people always said that
	async way are better than callback, I assume maybe I should use that
	async way 
<altendky> jusss: because it's way more legible. Especially looping etc
<altendky> jusss: would you like to write sync code with callbacks? No loops,
	   context managers, try/except, etc?
<jusss> altendky: you mean 'async code with callback'?
<altendky> jusss: nope
<jusss> altendky: what is 'sync code'?
<altendky> jusss: I mean that async/await let's you write async code that
	   looks like sync code.  If you like callbacks then shouldn't you be
	   willing your sync code with callbacks too?
<altendky> altendky: code that isn't async			        [10:36]
<altendky> jusss: you could certainly code like '{}x{}'.format(1, 2,
	   callback=f) but that'd make the code incomprehensible... So if it's
	   bad for sync code, why would we want it for async code?
<altendky> jusss: sure, occasionally it fits better, maybe, but mostly not
								        [10:38]
<altendky> jusss: try writing a loop with callbacks. See what it looks like
	   and compare with `for x in y: z.append(await f(x))`
<jusss> altendky: yeah, I just use that js's Promise thought to think in
	python, like I can put a blocking function A into a future object, and
	I want when A is done, run B, then C and D,but it won't block current
	thread
<altendky> jusss: there's another too for that
<jusss> altendky: sorry, what is 'a loop with callbacks'?
<jusss> altendky: while-loop or what?
<jusss> for-loop?
<altendky> jusss: go implement that loop I just wrote but with callbacks
<altendky> 21:42 <altendky> jusss: try writing a loop with callbacks. See what
	   it looks like and compare with `for x in y: z.append(await f(x))`
<altendky> jusss:
	   https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools
<altendky> jusss: you can directly await the function you want shoved into
	   another thread. Well, directly via that run in executor stuff

"""
### it seems that js's Promise in pythin is like just the throw the first blocking
### function into another thread, and then give it lots of callback with await x(await (y(z)))


yield from generator-object   is like yield from [1,2,3]  or yield from range(3)
like yield next(generator-object)

def g1():
    yield 1
    yield 2
    yield 3
f1=g1()
def g2():
    yield next(f1)
    yield next(f1)
    yield next(f1)
f2=g2()

def g2():
    for i in f1:
        yield i

def g2():
    yield from f1

def g1():
    yield from [1,2,3]
    
yield from generator-object will take next(generator-obejct)'s return value to main control

#####################################
so I wonder if it can yield itself or its current possition in f()? for just run part of it, not whole

####################################################

yield isn't a statement any more, it's an expression now!
now yield without an expression is now legal, 'x=yield' equivalent to 'x=yield None'
https://www.python.org/dev/peps/pep-0342/

generator object, d=f(); f() won't execute immedly until you call next(d)
so I wonder if it can yield itself or its current possition in f()? for just run part of it, not whole
you can do d.send(3) that would be yield 's return value in f()
so I wonder if it can go anywhere that yield show up with send?
what do 'send' 'throw' 'close' do?

what is a frame? it seems, that give you a pre-class, and you want
to add method into that class, pass that class to the event-loop for run

use yield everywhere, a=yield b(), yield a generator or future object,
yield from iterator is like
for i in iterator:
    yield i

<runciter> jusss, what do you want to know exactly?
<altendky> runciter: but presumably `yield from` provides something that
	   `yield` didn't when it comes to async uses?		        [11:58]
<jusss> runciter: how that yield stuff replace callback in that example
	https://www.tornadoweb.org/en/stable/gen.html
<runciter> altendky, yes, it "delegates" execution the sub generator,
	   obviating the need for a trampoline
<jusss> yield from iterator   it's like  for i in iterator :  yield i
<runciter> kind of, but it does more				        [11:59]
<altendky> runciter: so inlineCallbacks implemented some 'version' of `from`
	   on standard `yield`.  mm
<runciter> altendky, yup!
<runciter> jusss, the fundamental problem is that `yield` conflates iteration
	   and more general control flow
<runciter> jusss, so, if all you care about iterating over "generation", then
	   `for i in generator: yield i` works fine
<runciter> jusss, but there's a lot more to generators, that makes `x = yield`
	   work
<runciter> the fact that "yield" is an expression that can evaluate to a value
	   is what allows it to replace callbacks
<runciter> https://www.python.org/dev/peps/pep-0342/ - pay close attention to
	   `send`, `throw`, and `close`				        [12:03]	   

############################################

asyncio, aldebaran's async(),    tornado's @gen,   es2017 async/await

#asyncio
async def f(), await coroutine-object, loop.run(), @asyncio.coroutine, yield from

#aldebaran
qi.async(f,delay=usec,arg)  return a future, qi.future have value, addCallback,cancel,wait
also qi.PeriodicTask, qi.Promise will return a qi.Future with qi.Promise.future(), and
qi.Promise.setValue() can call that qi.Future
http://doc.aldebaran.com/2-5/dev/libqi/api/python/future.html
http://doc.aldebaran.com/2-5/dev/libqi/api/python/async.html

#tornado
@tornado.gen.coroutine, yield,
tornado.gen.coroutine or tornado.gen.engine, Decorator for asynchronous generators.
Any generator that yields objects from this module must be wrapped in either this decorator or engine.Functions with this decorator return a Future

#es2017


aldebaran's qi.Future qi.async() is base on threading.Thread? not generator?
module qi point to _qi.so, they don't provide _qi.py

##################################################

asynchorous programming, you control the flow, jumps in functions, with select() or
epoll() on blocking functions, it's more safe than multi-threads, you don't need a lock,

await always wait for the result of its parameter which is a coroutine object, and then
await take its result return to the control stuff


event loop,ipip

#########################################

IOLoop.current().run_sync(lambda: divide(1, 0))
if the IOLoop is not yet running, you can start the IOLoop, run the coroutine, and then stop the IOLoop with the IOLoop.run_sync method. 

IOLoop.current().run_in_executor(None, blocking_func, args)
if it needs a executor, then from concurrent.futures import ThreadPoolExecutor
and executor = ThreadPoolExecutor()
from concurrent.futures import ThreadPoolExecutor
class EchoWebSocket(tornado.websocket.WebSocketHandler):
      executor = ThreadPoolExecutor()
      def whatever(self):
      	  tornado.ioloop.IOLoop.current().run_in_executor(executor,blocking_func,args)


#################################################

event-looptornadoasyncioevent-loop? asynciofuture objecttornadoevent-loop?

tornado 5.1native coroutine,tornadoevent-loopasyncioevent-loop, Integration with other servicestornado.platform.asyncio

tornado.ioloop.IOLoop.current().spawn_callback(self.ttt)
self.tttcoroutine-objectIOLoop
await self.ttt()self.ttt()self.tttwhile-loop
await ,  spawn_callback

self.tttwhile-loop, tornado.ioloop.PeriodicCallback(self.ttt,1800).start()
asyncio.wait_for()

tornadoawaitcoroutine-object,asyncio
Aawait B,asyncio.run(A)B

IOLoop.current().run_sync(lambda: divide(1, 0))
IOLoop.current().run_in_executor(None, blocking_func, args)

'await' will wait for the exit of its paremeter, what if the coroutine-object is a while-loop,
it never exits, so await will stuck here, use 'spawn_callback' instead of 'await'

tornado.ioloop.IOLoop.current().spawn_callback(self.ttt) will affect the IOLoop object in
the current thread, it will store the self.ttt coroutine object into this IOLoop object

#######################################################

one thread only have one event loop, use asyncio.get_event_loop get current thread's event loop,
or use l=asyncio.new_event_loop() then asyncio.set_event_loop(l)
this event loop object can plus future object in, think it's like a tree, and the future objects are apples on the tree
loop.create_task(coroutine-object) will turn this coroutine-object into future object and plug it in the loop object
or use t=asyncio.ensure_future(coroutine-object), then put this t to a task list, then use
loop.run_until_complete(asyncio.wait(task))  or [loop.run(t) for t in task] or loop.run_forever()
async def and await, async def define a function and call it get a coroutine object, and await's parameter is coroutine object, await will return the control and run the coroutine object
@coroutine and yield from is an old way


#######################################

any function that calls a coroutine must be a coroutine itself, and use the await or yield keyword in the call.
#so the 'await' or 'yield from's parameter is a coroutine object,

import asyncio
count=[0]
task=[]
async def a():
    if count[0] > 100:
        return
    else:
        print(1)
        count[0] += 1
        await b()
async def b():
    if count[0] > 100:
        return
    else:
        print(0)
        count[0] += 1
        await a()
loop=asyncio.get_event_loop()
#get current thread's event loop
task.append(loop.create_task(a()))
task.append(loop.create_task(b())) #turn those coroutine object into future object, and add them to the loop object
loop.run_until_complete(asyncio.wait(task))
print('end')

###########################################################

index2.html

<!doctype html>
<html>
  <head>
    <title>WebSockets Hello World</title>
    <meta charset="utf-8" />
    <style type="text/css">
      body {
        text-align: center;
        min-width: 500px;
      }
    </style>
    <script src="http://code.jquery.com/jquery.min.js"></script>
    <script>

      // log function
      log = function(data){
        $("div#terminal").prepend("</br>" +data);
        console.log(data);
      };

      $(document).ready(function () {
        $("div#message_details").hide()
 
        var ws;

        $("#open").click(function(evt) {
          evt.preventDefault();
 
          var host = $("#host").val();
          var port = $("#port").val();
          var uri = $("#uri").val();
 
          // create websocket instance
          ws = new WebSocket("ws://" + host + ":" + port + uri);
           
          // Handle incoming websocket message callback
          ws.onmessage = function(evt) {
            log("Message Received: " + evt.data)
           // alert("message received: " + evt.data);
            };
 
          // Close Websocket callback
          ws.onclose = function(evt) {
            log("***Connection Closed***");
            alert("Connection close");
            $("#host").css("background", "#ff0000"); 
            $("#port").css("background", "#ff0000"); 
            $("#uri").css("background",  "#ff0000");
            $("div#message_details").empty();

            };
 
          // Open Websocket callback
          ws.onopen = function(evt) { 
            $("#host").css("background", "#00ff00"); 
            $("#port").css("background", "#00ff00"); 
            $("#uri").css("background", "#00ff00");
            $("div#message_details").show();
            log("***Connection Opened***");
          };
        });

        // Send websocket message function
        $("#send").click(function(evt) {
            log("Sending Message: "+$("#message").val());
            ws.send($("#message").val());
        });
 
      });
    </script>
  </head>
 
  <body>
    <h1>WebSockets Hello World</h1>
    <div id="connection_details">
      <label for="host">host:</label>
      <input type="text" id="host" value="localhost" style="background:#ff0000;"/><br />
      <label for="port">port:</label>
      <input type="text" id="port" value="8000" style="background:#ff0000;"/><br />
      <label for="uri">uri:</label>
      <input type="text" id="uri" value="/ws" style="background:#ff0000;"/><br />
      <input type="submit" id="open" value="open" />
    </div>
    <div id="message_details">
        </br></br>
        <label for="message">message:</label>
        <input type="text" id="message" value="Hello World!"/><br />
        <input type="submit" id="send" value="send" />
    </div>
    <div id="terminal">
        
    </div>
  </body>
</html>


##################################################
import tornado.websocket
import tornado.ioloop
import tornado.gen
from tornado.options import define, options, parse_command_line

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("index2.html")
wsl=[]

class cc:
    def __init__(self,_):
        self._ = _
        self.i = 0

    def add1(self):
        self.i = self.i + 1
        return self.i
        
    def mc(self):
        try:
            self._.write_message(str(self.add1()))
        except:
            mcl.remove(self)

mcl=[]

def runc():
    for i in mcl:
        i.mc()
class EchoWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        wsl.append(self)
        self.websocket_ping_interval=30
        self.write_message("begin")
        mcl.append(cc(self))
  
    def on_message(self, msg):
        for i in wsl:
            try:
                i.write_message(msg)
                #i.write_message(u"you said: "+msg)
            except:
                wsl.remove(i)
    def on_close(self):
        wsl.remove(self)
        print("closed")
    def check_origin(self, origin):
        return True
 
def start():
    app=tornado.web.Application([(r'/',IndexHandler),(r'/ws', EchoWebSocket)])
    ### visit  http://localhost:8000/ in your browser
    define("port", default=8000, type=int)
    app.listen(options.port,'0.0.0.0')
    tornado.ioloop.PeriodicCallback(runc,1800).start()
    tornado.ioloop.IOLoop.instance().start()

"""
<jusss> eiGHttt: LdBeth nyfair class
<jusss> class						        [14:08]
<jusss> classself
<u-un-n[m]> jusss: 		        [14:09]
<jusss> 
<jusss> self, 					        [14:10]
"""
### if there's pep 263 error, it's not about # -*- coding: utf-8 -*-, it just your editor doesn't use utf-8 to save your code to file, just change it to utf-8 with your editor

if __name__ == "__main__":
    start()
    

##########################################################
;;;https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
;; backwards compatibility as default-buffer-file-coding-system
;; is deprecated in 23.2.
(if (boundp 'buffer-file-coding-system)
    (setq-default buffer-file-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8))

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))


##########################################
<altendky> jusss:  a set is like a mathematical set.  each item is unique,
	   there is no order.  but, you can check if an item is in the set in
	   constant time.  as oppposed to a list which would be linear time
	   because you have to check every element for equality	        [10:57]
A={1,2,3}
B=set('qwerty')  => {'e', 'q', 'r', 't', 'w', 'y'}

unique, no order,

<altendky> jusss: a set literal is just {1, 2, 3}.  it uses braces like a dict
	   literal but doesn't have the : separating the key and value for
	   each 'element'.
<altendky> jusss: same difference with the comprehensions.  if there's a : in
	   the expressions and {} around the comprehension then it's a dict
	   comprehension.  if {} but no : then it's a set comprehension.
								        [10:59]
<jusss> altendky: ok
<altendky> jusss: {x: 2*x for x in range(10)} vs. {2*x for x in range(10)}
<altendky> jusss: sets do require that the elements be hashable	        [11:02]
<jusss> altendky: what elements can't be hashable?
<altendky> jusss: the basic separation is mutable vs immutable, though that's
	   not strictly the criteria.  for example lists are not hashable but
	   tuples are.						        [11:05]
<altendky> jusss: an objects hash must not change for the hash to be useful.
	   also, two objects that are equal must also hash to the same value.
	   so hashability lends itself to immutable objects.	        [11:06]
<altendky> jusss: it's the same restriction that exists for dict keys   [11:07]
<altendky> jusss: in some senses a set is the key half of a dict without the
	   value half
<jusss> "All of Pythons immutable built-in objects are hashable, while no
	mutable containers (such as lists or dictionaries) are."        [11:08]
<altendky> jusss: you can make your own classes which are mutable but
	   hashable.  depending exactly what you do this will break expected
	   functionality either more or less
<altendky> jusss: anyways, point is that the technical requirement for adding
	   an object to a set is that hash() does something (without an
	   exception).  but for the overall set to work as expected there are
	   more restrictions.
<altendky> hash() might have to return an int.  i forget exactly
<jusss> altendky:   if they are immutable and can compare with other object,
	the are hashable?					        [11:11]
<altendky> jusss: there's __hash__
	   https://docs.python.org/3/reference/datamodel.html#object.__hash__
								        [11:12]
https://stackoverflow.com/questions/14535730/what-do-you-mean-by-hashable-in-python
An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() or __cmp__() method). Hashable objects which compare equal must have the same hash value.

Hashability makes an object usable as a dictionary key and a set member, because these data structures use the hash value internally.
All of Pythons immutable built-in objects are hashable, while no mutable containers (such as lists or dictionaries) are. Objects which are instances of user-defined classes are hashable by default; they all compare unequal, and their hash value is their id().

# I think that things who are immutable and comparable are hashable, list and dict are not hashable, tuple is hashable, set is not hashable, the item in set it must be hashable,
# you can check that with hash() method,
#   hashable,   built-in __hash__() and __eq__()

(1,3,2,2)
(1, 3, 2, 2)
>>> {1,3,2,2}
{1, 2, 3}

what is hash?

keys        hash function      hashes
john                                      00
lisa                                        01
sam                                       02
john and sam both point to 01, A hash function that maps names to integers from 0 to 15.
collision

it's like the function, the parameters can be different, but they get the same return value,
but you can use the same parameter to get different values

object       hash function     hashid
str
int
tuple
immutable
instance

https://stackoverflow.com/questions/14535730/what-do-you-mean-by-hashable-in-python
https://nedbatchelder.com/text/names1.html
#########################################

[[0] * 3] * 3
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]

<jusss> why [[0] * 3 for _ in range(3)] return [[0, 0, 0], [0, 0, 0], [0, 0,0]]?
result =[]
for _ in range(3):
    result.append([0] * 3)

<grym> jusss: _ means "a dummy value we don't care about"
<altendky> jusss: not using the loop variables in the expression is fine, or
	   you can use them if you need.  just depends what you are trying to
	   achieve
<altendky> jusss: it's a list comprehension and creates a list.  it does so by
	   iterating ofer the iterable expression, assigning into variables
	   (just like a for loop) then creating each element from the first
	   expression.	   
##################################
we say that names refer to values, or a name is a reference to a value:
    x = 23
Now the name x refers to the value 23. 
<altendky> jusss: bit.ly/pynames1 but it means that names refer to objects.
	   as opposed to, say, C where a variable might actually hold an
	   integer.
<jusss> ldb: a refer to b 				        [09:39]
<ldb>  b 
ab
######################################################

window.RobotUtils || {}
if window.RobotUtils don't exist return {}
self.loop = loop or IOLoop.instance()
<altendky> jusss: `or` returns the first truthy argument.  if neither are
	   truthy?  i forget.  i dislike this use of `or`.
<nedbat> jusss: it returns the first true value
<grym> jusss: `self.loop = loop if loop else IOLoop.instance()`
<jusss> altendky: a= b or c what if b don't exist?
NameError: name 'b' is not defined
<nedbat> jusss: you don't work with undefined names in Python
<altendky> jusss: if b hasn't been assigned to then you can't access it and
	   will get an error if you do
<jusss> nedbat: yeah, so it's not || is js :)			        [09:24]	   

#################################################
<meejah> jusss: there's better I/O APIs than select()		        [14:56]
<meejah> "the event loop" handles I/O for you in Twisted or asyncio...and then
	 tells you when you get data				        [14:57]
<jusss> meejah: but what if it's not I/O?  what if it is a while loop
	function?
<meejah> jusss: you can't block the reactor like that		        [15:12]
<meejah> e.g. you have to arrange to let it do some work (like do 20
	 iterations at a time or whatever)			        [15:13]
<jusss> meejah: for example, I don't want a function end, how I can stop it
	end and put it in asyncio event loop?			        [15:17]
<jusss> meejah: that is a function, it wait a signal or check variables, the
	it do something every 5 sec, and I don't want it to quite
<meejah> twisted has LoopingCall, I'm sure asyncio has similar .. or just
	 "call_later()" to yourself at the end of the function

Promise/Future  Async/Await Select/Epoll 
asyncio do async in one thread, and concurrent.futures do async in multiple threads or process, asyncio within APIs can handle I/O like socket or file, but if it's CPU bound, then put
it in concurrent.futures,  asyncio have 'run_in_executor' put it into threads
executor should be an instance of ThreadPoolExecutor.

async def main():
      loop=asyncio.get_running_loop()
      result = await loop.run_in_executor(None, the-block-function)
      print(result)
      with concurrent.futures.ThreadPoolExecutor() as pool:
      	   result=await loop.run_in_executor(pool,the-block-function)
	   print(result)

###########################################
I/O block use select() in one thread,  CPU block use thread or process 

import asyncio
async def  or use @asyncio.coroutine
those functions return coroutine objects when called
Calling either of these doesn't actually run them,
but instead a coroutine object is returned,
which can then be passed to the event loop to be executed later on.
or asyncio.run(coroutine-objects)

There are a few ways to actually call a coroutine,
one of which is the yield from method. 
use yield from within @asyncio.coroutine

@asyncio.coroutine
def get_json(client, url):
  file_content = yield from load_file('/Users/scott/data.txt')

or
async def ping_local():  
    return await ping_server('192.168.1.1')

#so I think use '@asyncio.coroutine' or 'async def' to create functions, and call that functions will return coroutin objects, that functions are never really run, put those coroutine objects into a list, then create a loop run them, and use 'yield from' or 'await' to make them return from themself for that the list can iterate next function,and asyncio provide get_event_loop(), you can use that to instead of list
loop = asyncio.get_event_loop()  
loop.run_until_complete(coroutine-objects)  #blocking
loop.close()  

# 'async with' is like 'with (yield from ...)' so I think it is return to main controler before it enter the with block and return to main controler again after it leaves the with block, just like run yield from twice
<jusss> meejah: so 'async with' will 'await' before it enter the block, and
	'await' again when it leave the block, right/
<jusss> just like 'yielf from' twice
<meejah> jusss: yes

asyncio.run()
loop=asyncio.get_event_loop()
loop.run_until_complete
asyncio.ensure_future
loop.run_forever()
loop.close()

https://stackabuse.com/python-async-await-tutorial/

###################################
ERC always make that tabbar mode vanish
<jgkamat> jusss: tabbar mode and erc both use the header: (setq
	  erc-header-line-uses-tabbar-p t)
<parsnip> jusss: eyebrowse seems similar and more popular	  
######################################
https://www.youtube.com/watch?v=MCs5OvhV9S4&t=32s
yield that block function, and use select to run them
from concurrent.futures import ThreadPoolExecutor as Pool
pool=Pool(5)
pool.submit(function)

one thread, use select()/epoll() to handle block function
or put it into thread
#########################################
yeah, first-class object, function, variable, closure, class,
define a class in a class, inner class, pass class, return class, operate class like decorator
class A:
    class B:
        def p(self):
            print('b')

z=A()
z.B.p()
B need to be instanced

class A:
    def __init__(self):
        self.B=self.B()
    class B:
        def __init__(self):
            pass
        def p(self):
            print('b')

z=A()
z.B.p()

class A:
    def __init__(self):
        self.B=self.returnB()
    def returnB(self):
        return A.B()
    class B:
        def __init__(self):
            pass
        def p(self):
            print('b')

z=A()
z.B.p()
https://pythonspot.com/inner-classes/

class Human:
    def __init__(self):
        self.name = 'Guido'
        self.head = self.createHead()
    def createHead(self):
        return Human.Head(self)
    class Head:
        def __init__(self, human):
            self.human = human
        def talk(self):
            return 'talking...', self.human.name

###########################################################

<jusss> how asyncio handle blocking functions?			        [11:00]
<altendky> jusss: the function blocks, nothing else gets to do anything.  what
	   function?
<jusss> altendky: https://paste.ubuntu.com/p/hwvmKZ5sZ6/
<altendky> jusss: so tornado, not asyncio?			        [11:02]
<altendky> jusss: don't time.sleep() in async code.  use their async sleep
	   function
<jusss> altendky: I think they have the same promblem, that event-base loop
	how to handle blocking function
<altendky> jusss: what function?
<jusss> altendky: aT is loop function, 				        [11:03]
<altendky> jusss: ok, so a made up thing you shouldn't write that way?
<jusss> altendky: I put it in a event-loop, and it blocks
<altendky> 22:02 <altendky> jusss: don't time.sleep() in async code.  use
	   their async sleep function
<altendky> jusss: twisted has deferToThread, asyncio has run_in_executor.
	   tornado likely has something.  but really the answer is that first
	   you avoid the blocking function entirely.
<jusss> altendky: that event-loop frames, if I want put a loop in it, how I
	should do?
<altendky> jusss: are you asking how to sleep in async code without blocking?
<altendky> jusss: i don't know what you mean by 'that event-loop frames'
								        [11:08]
<jusss> altendky: tornado is event-loop, you see, aT is a loop function, I put
	aT in there, it blocks tornado's event-loop
<altendky> jusss: are you referring to a loop you wrote as an event loop?
<altendky> jusss: yes.  you call time.sleep.  for the third time here, don't
	   do that.  async libraries provide async ways of sleeping
<jusss> altendky: like     tornado.ioloop.IOLoop.instance().start() or asyncio
	whatever , they all put a block function at the last
<altendky> jusss: you seem to be ignoring me.  can we please talk about the
	   sleeps?						        [11:09]
<jusss> altendky: sorry, I don't know why this is related with sleep?
<altendky> jusss: because time.sleep() _blocks_
<altendky> jusss: it tells your thread to do nothing at all for however long.
	   thus _blocking_ the event loop
<jusss> altendky: but while make this block
<altendky> jusss: no.  sleep() blocks
<jusss> altendky: ok, I will try it
<altendky> jusss: if you used the proper async sleep then that second in every
	   loop would let the tornado event loop process other things
<altendky> jusss: you may also need to mark your function properly as async
	   however you do that in tornado
<jusss> altendky: wow, that would be wonderful
<altendky> jusss:
	   https://www.tornadoweb.org/en/stable/gen.html#tornado.gen.sleep
<altendky> jusss: please do ask about the things i say instead of ignoring
	   them repeatedly
<jusss> altendky: sorry again
<altendky> jusss: just trying to make sure we get answer quickly :]
<altendky> jusss: err, that may be the 'old' style.  let me see if there's a
	   separate sleep for async/await syntax
<jusss> altendky: how they solved the block function? with select() or
	epoll()?
<altendky> jusss: that's the gist down in the guts, yeah
<altendky> jusss: if you want to watch a fun video,
	   https://www.youtube.com/watch?v=MCs5OvhV9S4&t=32s evolves through
	   some various approaches				        [11:16]
<jusss> altendky: I think concurrent.futures is doing something in
	multi-thread, and asyncio is doing something in one single thread, it
	is right? 
<altendky> jusss:
	   https://www.tornadoweb.org/en/stable/faq.html#why-isn-t-this-example-with-time-sleep-running-in-parallel
	   almost seems like they are suggesting asyncio.sleep()?  or maybe
	   you can just `await tornado.gen.sleep()`?  i don't know tornado
	   offhand
<altendky> jusss: concurrent.futures could be separate processes or separate
	   threads.  async starts in one thread, yes.
<altendky> jusss: but you can often kick things into other threads (twitsed's
	   deferToThread, asyncio's run_in_executor, etc)	        [11:20]
<altendky> not the first place to go though.  first try to get rid of the
	   blocker
<jusss> altendky: yeah, that's the promblem, 
<altendky> jusss: actually my last link does show exactly `await gen.sleep(1)`
	   so use that
<altendky> jusss: your functions aren't even written as `async def` yet so, do
	   that and replace the sleep's with tornado.gen.sleep.  and await
	   them.
<jusss> altendky: I thought that 'while' was the blocker, it seems I have a
	wrong thought						        [11:22]
<altendky> jusss: while keeps you in the function (longer anyways), sure.  but
	   you can still `await` things which leaves it open for the loop to
	   get some time.  so in general, no, while isn't an issue with async
	   code.						        [11:23]
<jusss> altendky: I see, thanks

##########################
https://www.emacswiki.org/emacs/ErcProxy
ERC through a socks proxy
socks.el comes with Emacs. (Emacs 22 and older can get it from w3.) If you set socks-override-functions before loading the library, all the network functions will be using socks:

 (setq socks-override-functions 1)
 (setq socks-noproxy '("localhost"))
 (require 'socks)

Alternatively, you can use the following for ERC only:

 (setq socks-noproxy '("localhost"))
 (require 'socks)
 (setq erc-server-connect-function 'socks-open-network-stream)

The location of the socks server is in the variable socks-server. To set it you can do:

 (setq socks-server (list "My socks server" "socks-server-hostname" 1080 5))

Where My socks server is the description of the server, socks-server-hostname is the host name for the server, 1080 is the port, and 5 is the socks version (can be 4 as well)

socks-noproxy holds a list of regexps for which the network calls are not socksified. Ive excluded localhost from the connections so that I can still connect to BitlBee.

################################################
https://en.wikipedia.org/wiki/Object-oriented_programming#Class-based_vs_prototype-based

python is class-based OO, and javascript is prototype-based OO
python use "self", js use "this"
<twb> AJTJ: I think "this" is due to js being prototype-based OO, where python
      is class-based OO
 <twb> I believe js's OO was taken from Self/Slate		        [17:11]
###################################################

import moduledef __init__(self):


decorator
closureclassnamespace
closureinner function,
inner function

closureclass
closureclassfunctionargument
parameter return value

def addId(cls):
    class AddId(cls):
        def print1(self):
            print(1)
    return AddId

@addId
class Foo:
    pass

c=Foo()
c.print1()

class MyDecorators:
    def __init__(self):
        import time
        pass
    def while1s(self,f):
        def wrapper(*args,**kwargs):
            while True:
                try:
                    f()
                    time.sleep(1)
                except:
                    break
        return wrapper
c=MyDecorators()
@c.while1s
def p():
    print(1)
    print(0)

p()

tornadoweb serverweb framessocket libraries
tornadotornado.concurrent.Futurepython2python 2.7.6
concurrent.futures,2.7.15
AsyncHTTPClient()async def, await
HTTPClient()

tornadosoftbankchoregraphepython box
pre-defined class,codeclass
classmethodenter pointmethod
method,def __init__(self)import module
 event-loop
class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

super class?
http://funhacks.net/explore-python/Class/super.html
super()
methodAsuper(,self).methodA()methodA

<jusss> initial parent class in subclass, what it's good for?	        [16:54]
<twb> jusss: if you have a class B whose parent class is A, and you define a
      method B.foo(), it will completely replace A.foo().	        [16:55]
<twb> jusss: sometimes you want to extend the method, instead of replacing it
<twb> jusss: so from within B.foo() you can call super().foo() to reach A.foo
<twb> Does that make sense?
<jusss> twb: yeah, it makes sense, but like class B(A): def __init__(self):
	A.__init(self) what it's good for?
<jusss> initial parent class's __init__ in subclass
<twb> 19:55 <twb> jusss: sometimes you want to extend the method, instead of
      replacing it

########################################################

<jusss> nyfair: GUI
	torandowebsocket
	socketsocket
	looptornado.websocket.WebSocketHandler
	open()
<nyfair> jusss: railsdjango(python), lavarel(php), express(node)
	 buffalo(go)					        [15:42]
<nyfair> rails
<jusss> ''properly
<jusss> nyfair: ruby?				        [15:43]
<nyfair> js promise
<nyfair> ruby
<jusss> nyfair: python
<jusss> nyfair: update code on running process
<nyfair> 10
<jusss> nyfair: instance
<nyfair> 1true
<nyfair> 
<jusss> python1					        [15:46]
<jusss> pythonprimitive data type
<jusss> 1typeint
<nyfair> python1
<jusss> 1.times=func()				        [15:47]
<bokuno> (object-p 1) => nil
<jusss> __slot__
<nyfair> c				        [15:49]

<jusss> nyfair: tornadowebsocketk
	torando.websocket.WebSocketHandler
	tornado.web.Application
<jusss> nyfair: 	        [15:51]
<jusss> nyfair: python box
	
								        [15:52]
<jusss> nyfair: 
<jusss> eiGHttt: nyfair pythonircwebsocekt
								        [15:57]
<nyfair> websocketonMessage
<nyfair> websocket					        [15:58]
<nyfair> webassembly
<jusss> nyfair: binary code
<nyfair> 
<jusss> nyfair: 					        [16:01]
<jusss> nyfair: webassembly			        [16:32]
<nyfair> webassembly
	 
###############################################

<html>
<head>
    <title>Websocket</title>
    <script type="text/javascript">
    var ws = null;
    function init() {
        if ("WebSocket" in window) {
            ws = new WebSocket("ws://127.0.0.1:8888/ws");
            ws.onopen = function() {
                console.log("Connection is opened");
            }
            ws.onclose = function() {
                console.log("Connection is closed");
            }
            ws.onmessage = function(msg) {
                document.getElementById("display").innerHTML = msg.data;
            }    
        } else {
            console.log('Your browser doenst support WebSocket!')
        }
    }

    function send() {
        ws.send(document.getElementById("txt").value);
    }
    </script>
</head>
<body onload="init();">
    <h2>Try websocket</h2>
    <input type="text" id="txt">
    <input type="button" onclick="send()" value="Send">
    <h3>Response:</h3>
    <p id="display"></p>
</body>
</html>

#####################################

import tornado.websocket
import tornado.ioloop
from tornado.options import define, options, parse_command_line
class EchoWebSocket(tornado.websocket.WebSocketHandler):
    def open(self):
        print("opened")
    def on_message(self, msg):
        self.write_message(u"you said: "+msg)
    def on_close(self):
        print("closed")
    def check_origin(self, origin):
        return True

app=tornado.web.Application([(r'/ws', EchoWebSocket)])
define("port", default=8888, type=int)
app.listen(options.port)
tornado.ioloop.IOLoop.instance().start()

################################################

url, websocket need a url,
ws://127.0.0.1:8888/whateveryouwant

if you wrote this in js:
 var ws = new WebSocket("ws://localhost:8888/whateveryouwant");
then you need this in python:
app=tornado.web.Application([(r'/whateveryouwant', EchoWebSocket)])

if you restart your python server script, then you need re-fresh your website for new connection
and  you need set check_origin function in tornado, otherwise you will get 403 error
put this
def check_origin(self, origin):
        return True
into your tornado.websocket.WebSocketHandler class, it's necessary!

#################################
;;;display-line-numbers-mode instead of linum-mode since 26.1
;;; https://www.masteringemacs.org/article/whats-new-in-emacs-26-1
(dolist (hook '(python-mode-hook
                javascript-mode-hook
                html-mode-hook
                css-mode-hook
                js-mode
               mhtml-mode
	  c-mode-common-hook))
(add-hook hook (lambda () (display-line-numbers-mode t))))

<jusss> nyfair: w3m and eww won't support javascript!		       

#######################################

def makeClosure(f):
    a=0
    def realFunc(*args, **kwargs):
        nonlocal a
        a=a+1
        print(a)
        f(*args,**kwargs)
    return realFunc

@makeClosure
def t():
    print('hello')


about decorator, it always needs a function as it parameter, no matter what it is
@app.route("/secret")
@login_required
def secret():
the function app.route("/secret") will need a function, it is like
    app.route("/secret")(login_required(secret))   

@dec2
@dec1
def func(arg1, arg2, ...):
    pass

it's like dec2(dec1(func))(arg1, arg2, ...)

@decomaker(argA, argB, ...)
def func(arg1, arg2, ...):
    pass

it's like decomaker(argA, argB, ...)(func)
reference: http://python.jobbole.com/86687/
	   https://realpython.com/primer-on-python-decorators/
actually decorator is not like closure I think, it's just another wrapper function,
decorator can handle function's parameters
def f(g):
    def wrapper(*args, **kwargs):
        print("function's name: ",g.__name__)
        print("function's parameters: " *args,**kwargs)
    return wrapper

decorator to me it's like it can handle before or after the function's run, not insider of the function
but function object is not immutable, so if you turn it to string, then you can change it and run
###########################################

from concurrent.futures import ThreadPoolExecutor
import time
cond=[1]
def s():
    while True:
        if cond[-1] == 0:
            print('ok')
            cond[-1]=1
        else:
            pass
        time.sleep(1)

#with ThreadPoolExecutor() as e:
#    future=e.submit(s)

e=ThreadPoolExecutor()
future=e.submit(s)
#cond[0]=0, dont do future.result(), it will stuck
cond[-1]=0


##############################################

future.addCallback()wonderful!
functools.wraps decorator
https://docs.python.org/3.7/library/functools.html#functools.wraps
##############################################

with a as b:
assign a to b, like b=a, but if it used for socket, file, thread, it doesn't need to close by manually
with__exit__()

from concurrent.futures import ThreadPoolExecutor
s=lambda: 3
with ThreadPoolExecutor() as e:
    future=e.submit(s)
    print future.result()


###############################################
results = list(pool.map(gcd, numbers))
list function only take one argument, and it is a iterable object, not must be a iterator
>>> c= (x for x in range(0,9))
>>> c
<generator object <genexpr> at 0x02E59238>
>>> list(c)
[0, 1, 2, 3, 4, 5, 6, 7, 8]
>>>

>>> d=(x for x in range(0,200000))
>>> next(d)
0
>>> next(d)
1
>>> next(d)
2

<altendky> jusss: itertools.cycle((True, False))

>>> a=itertools.cycle((True,False))
>>> a
<itertools.cycle object at 0x02E4C8C8>
>>> next(a)
True
>>> next(a)
False



>>> a=itertools.cycle((True,False))  #counter #outputer
################################

SQL bash are DSL,
epoll/select are reactor,
list function are functor,
decorator is higher-order function

#####################################

Promiseepoll/select()PromisefuturefuturePromise
futurePromisecallback

###############################################################

pythonconcurrent.futuresasynciogenerator yield event-loopco-routine,aldebaranpython27qi.Futurepython32concurrent.futures
aldebaranpython27generatorasynciocalled
stk.coroutines
https://github.com/pepperhacking/studiotoolkit

###################################################

Promiseepoll/select()PromisefuturefuturePromise
futurePromisecallback

Instance a Promise object, and instance a future object through that Promise object
pass this Promise to a function, and put that function into alternative thread,
in main thread, get that function's return value through this future object

PromisePromisefuture
Promisefuture
futurecallback,,
future, futurecallback
jsPromise, future,future,
epoll/select()co-routineepollevent-loop, futurePromisecallback,

jsPromise, pythonfuture, aldebaranqi.FuturePromise/Future
jsPromisefuturePromisefuturePromise
jssetTimeout() 
z=new Promise((r,e)=>{
      setTimeout( ()=> console.log('a'), 5000);
      r()});
z.then(()=> console.log('x'));
console.log('f')
  f  x   aPromisef, setTimeout
r()Promisefuture z.then()x, 5 a

aldebaranqi.FuturePromisefuturePromise

Promiseepoll/select()PromisefuturefuturePromise
futurePromisecallback

integration, asynciotkinter
socket, twistedtwistedasynciosocket
integration twistedtkinter,event-loopintegration
select()reactor  https://twistedmatrix.com/documents/13.1.0/core/howto/choosing-reactor.html
The epoll()-based reactor is Twisted's default on Linux. Other platforms use poll(), or the most cross-platform reactor, select().

threadingmultiprocessing,concurrent.futures
sockettwisted 
generator, poolevent-loop, yieldco-routine, asyncio


python's concurrent.futuresasyncio
concurrent.futures
asyncioco-routine,generator yield,event-loop
event-looppoolyield from



import qi
import time
import threading

def doSomeWork(p):
  #do your work here instead of sleeping
  time.sleep(1)
  p.setValue(42)

p = qi.Promise()
f = p.future()
threading.Thread(target=doSomeWork, args=[p]).start()
print "result:", f.value()

Promise and Future are a way to synchronise data between multiples threads. The number of future associated to a promise is not limited. Promise is the setter, future is the getter. Basically, you have a task to do, that will return a value, you give it a Promise. Then you have others thread that depend on the result of that task, you give them future associated to that promise, the future will block until the value or an error is set by the promise.


#### asyncio tk
<meejah> jusss: there's usually a function to "run one iteration of the
	 event-loop"
<meejah> jusss: so, e.g. if asyncio is "in charge" you arrange to periodically
	 call the "update()" (or whatever it is) of Tk's event-loop several
	 times a second						        [16:11]
<meejah> that is, give it a chance to run one iteration of its event-loop
<meejah> so, there's still just one thread
<jusss> meejah: that sounds a little complicated		        [16:12]
<meejah> that's how all "event loop integrations" work AFAIK	        [16:13]
<jusss> meejah: use multi-thread will be better?
<meejah> well, not quite true
<meejah> there's approaches like "asyncioreactor" in Twisted (which implements
	 an asyncio.EventLoop using Twisted APIs -- unless i got that
	 backwards ;)						        [16:14]	 
<jusss> the tech, co-routine, generator, what else those popular now, as I
	see, do not have a huge different , with multi-thread/process select
	in the old way
<meejah> yes a co-routine is just a generator, really .. and yes "under the
	 hood" Twisted or asyncio may well use select() (but usually epoll or
	 so) .. but the difference is there's just a single thread, and things
	 are inverted: the event-loop tells you when there's data (instead of
	 the other way around?)
<meejah> (and instead of having to think "I may be interrupted at any point"
	 you control where interruptions may occur .. hence calling it
	 "co-operative multi-tasking" sometimes)		        [16:20]	 



#### asyncio, yield, generator,  co-rotine, in one thread, not multi-thread, multi-process

>>> import asyncio
>>> async def main():
	print('hi')
	await asyncio.sleep(1)
	print('again')

	
>>> asyncio.run(main())




import asyncio

@asyncio.coroutine
def hello():
    print("Hello world!")
    # asyncio.sleep(1):
    r = yield from asyncio.sleep(1)
    print("Hello again!")

# EventLoop:
loop = asyncio.get_event_loop()
# coroutine
loop.run_until_complete(hello())
loop.close()

import asyncio
@asyncio.coroutine
def hello():
    print('Hello world!)
    yield from asyncio.sleep(1)
    print('Hello again!)

loop = asyncio.get_event_loop()
tasks = [hello(), hello()]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()

### create a promise, and then return a future, it's async, you can use 'wait' to wait it's done

from concurrent.futures import ThreadPoolExecutor
s=lambda: 3
with ThreadPoolExecutor() as e:
    future=e.submit(s)
    print future.result()

from concurrent.futures import ThreadPoolExecutor
from time import sleep
 
def return_after_5_secs(message):
    sleep(5)
    return message
 
pool = ThreadPoolExecutor(3)
 
future = pool.submit(return_after_5_secs, ("hello"))
print(future.done())
sleep(5)
print(future.done())
print(future.result())


import concurrent.futures
import urllib.request
 
URLS = ['http://www.foxnews.com/',
        'http://www.cnn.com/',
        'http://europe.wsj.com/',
        'http://www.bbc.co.uk/',
        'http://some-made-up-domain.com/']
 
# Retrieve a single page and report the url and contents
def load_url(url, timeout):
    with urllib.request.urlopen(url, timeout=timeout) as conn:
        return conn.read()
 
# We can use a with statement to ensure threads are cleaned up promptly
with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
    # Start the load operations and mark each future with its URL
    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}
    for future in concurrent.futures.as_completed(future_to_url):
        url = future_to_url[future]
        try:
            data = future.result()
        except Exception as exc:
            print('%r generated an exception: %s' % (url, exc))
        else:
            print('%r page is %d bytes' % (url, len(data)))

#### it feels just a wrapper on threading or multiprocess

http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html

from concurrent.futures import ThreadPoolExecutor, wait, as_completed
from time import sleep
from random import randint
 
def return_after_5_secs(num):
    sleep(randint(1, 5))
    return "Return of {}".format(num)
 
pool = ThreadPoolExecutor(5)   ###or use ProcessPoolExecutor(3)
futures = []
for x in range(5):
    futures.append(pool.submit(return_after_5_secs, x))
 
print(wait(futures))   ### wait function returns only when all futures complete

#######################################################

<jusss> concurrent.futures, asyncio,   does python2 have that?
<altendky> jusss: asyncio is py3.5+ iirc.  twisted does py2/3 though    [11:14]
<jusss> altendky: I'm confusing about those concepts promise/future, they're
	not only in python
<altendky> jusss: there are various styles of async and yes, some of them are
	   available in multiple languages.
<altendky> jusss: the basic idea is that you get a tool to manage a result
	   that isn't available yet in such a way that you can respond when
	   the result is available
<altendky> jusss: in the mean time, you let other code run rather than
	   blocking						        [11:22]
<jusss> altendky: yeah, I'm confused by the name, in python, it's called
	future, there's promise in ES6,
<altendky> jusss: various names mean somewhat different things afaik.
	   deferred from twisted, future from asyncio, promise from...  i
	   forget what in python.
<jusss> altendky: also, I saw continuation in scheme		        [11:25]
<jusss> altendky: those names make me confused
<altendky> jusss: so read about them?  i'm sorry but i'm not quite sure what
	   to say at this point.  mostly i am only particularly familiar with
	   deferreds.  i've helped people with asyncio here several times but
	   i can't really tell you how a future differs
<jusss> altendky: promise/future also show up with co-routine, generator,
	async
<jusss> to understand what those concepts are is really hard
<altendky> jusss: i often try to understand how to use a thing first.  then
	   when it seems significant i delve into the backend details.
								        [11:28]	   
<altendky> jusss: you may be able to do everything you need without even
	   thinking about it being a future.  `answer = await
	   network_request_thing(question)`			        [11:29]
<jusss> sometimes, I hope there's a book called ALL THE ANSWERS, it explains
	everything, like X-Files S11E04, the alien give them a book called ALL
	THE ANSWERS
<altendky> jusss: it's much simpler.  42
<jusss> altendky: and what's 42?				        [11:31]
<altendky> jusss:
	   https://en.wikipedia.org/wiki/Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)
<headrx> jusss: meaning of life
#############################################################
;;; python-mode will not eval python buffer if there is threading code
;;; https://www.masteringemacs.org/article/compiling-running-scripts-emacs
(defun my-python-compile ()
  (interactive)
  (setq tmp-file (concat (buffer-file-name) ".tmp"))
  (write-region (point-min) (point-max) tmp-file)
  (compile (concat "python " tmp-file)))

(add-hook 'python-mode-hook
	  (lambda () (local-set-key (kbd "<f5>") 'my-python-compile)))

(setq compilation-save-buffers-predicate '(lambda () nil))
(setq compilation-always-kill t)

#################################################
(defun my-python-compile ()
  (interactive)
  (setq tmp-file (concat (buffer-file-name) ".tmp"))
  (write-region (point-min) (point-max) tmp-file)
  (compile (concat "python " tmp-file)))

(add-hook 'python-mode-hook
	  (lambda () (local-set-key (kbd "<f5>") 'my-python-compile)))

(setq compilation-save-buffers-predicate '(lambda () nil))
############################################

(defun my-temp-save ()
  (interactive)
  (setq tmp-file (concat (buffer-file-name) ".tmp"))
  (write-region (point-min) (point-max) tmp-file))

(add-hook 'python-mode-hook
	  (lambda () (local-set-key (kbd "\C-c\C-l") 'my-temp-save)))

<jusss> twb: yeah, with C-h f, but I don't understand what it means "evaluate
	BODY there"						        [14:30]
<twb> jusss: OK
<twb> jusss: BODY means the commands inside the (with-temp-file) block
<twb> (with-temp-file "underpants.txt" (insert "bluebottle ostracize thip thip
      spoot!"))							        [14:31]
<jusss> twb: ok

#######################################

(defun my-python-compile ()
  (interactive)
  (compile (concat "python " (buffer-file-name))))

(add-hook 'python-mode-hook
	  (lambda () (local-set-key (kbd "\C-c\C-k") 'my-python-compile)))

######################################
python -m pip install tornado, tornado.pyemacscompile
tornado.pycimport tornaodno module named tornado,
tornado.py
#########################################

<jusss> twb: I have already press C-c C-p, otherwise there's not *Python*
<jusss> twb: I'm not use python-mode at the first
<jusss> I tried it run my python code that contain tk gui code, and it doesn't
	work too, 						        [10:43]
<jusss> so I wonder what's wrong with python-mode?
<twb> jusss: inferior-python mode will not work well with anything that
      involves threading
<twb> as with inferior-lisp-mode, inferior-python-mode is built on top of
      comint-run.  It is simple and easy to set up, but it has limited
      capabilities
<jusss> twb: so if my code using threading, that won't work?
<twb> jusss: you want a python repl inside emacs, that doesn't suck?
<twb> https://github.com/python-rope/ropemacs  I guess?
<jusss> twb: can I write a simple function, and bind it to C-c C-r, then when
	I run C-c C-r in python-mode it will use to execute this buffer like
	python a.py?
<twb> jusss: I'd just do something like (compile buffer-file-name)      [11:14]
<parsnip> jusss: then M-x compile RET python3 -m a RET
<twb> jusss: "any threading fucks inferior-python" is probably a bit of an
      exaggeration
<twb> jusss: but comint does rely on stdio flow being basically linear  [11:15]
<jusss> twb: parsnip can you show me your key bindings? I found that there's
	not much available key bindings on emacs
<twb> http://cyber.com.au/~twb/.emacs
<parsnip> jusss: my binding of f5 to recompile is stolen from elpy author,
	  iirc
<twb> (defun shit-compile-python () (interactive) (compile buffer-file-name))
      (eval-after-load "python" '(define-key python-mode-map (kbd "C-c C-k")
      #'shit-compile-python))					        [11:18]
<twb> jusss: ^ try that, untested
<twb> not sure if that's actually what you want

<jusss> what's emacs's compile doing?
<twb> M-x compile just runs a shell command and highlights error messages in
      the output
<twb> It's similar to run-python except you can't provide more input to it,
      i.e. it is non-interactive				        [11:23]
<jusss> it dones' t compile code to binary code?

<twb> correct; it doesn't compile
<twb> It's named "compile" because the most common thing for it to run is gcc
<jusss> aha, and why it's named 'compile'?

<jusss> I thought that is like slime				        [11:24]
<twb> nope

<twb> for that I think you want that pymacs/ropemcs stuff
<twb> I've never used those, so I can't help much


https://stackoverflow.com/questions/2658475/python-mode-import-problem
(defun shell-compile ()
  (interactive)
  (shell-command (concat "python " (buffer-file-name))))

(add-hook 'python-mode-hook
          (lambda () (local-set-key (kbd "\C-c\C-c") 'shell-compile)))


####################################################

python 3.2 concurrent.futures
3.4 asyncio   3.5 async/await
tornado, twisted, aiohttp, flask, django, gevent, 

###################################################
 if self.isRunning:
            return # already running, nothing to do
 self.isRunning = True

##########################################

jsfastclick.js
click 300  FT LabsGithub https://github.com/ftlabs/fastclickclick 300  double tap
<script src=" ../lib/fastclick.js "></script>
$(function() {
      FastClick.attach(document.body);
});
################################
 window.onload jquery $(window).on("load",function(){})  full page
 $(document).ready()    only DOM, not full page
 $(window).ready()     wrong!!! it should be $(window).on("load", function(){...})
document.addEventListener('DOMContentLoaded',function)

native js:
document.addEventListener('DOMContentLoaded',function)
window.onload=function(){...}

jquery:
$(document).ready(function(){...})
$(window).on("load",function(){...})

https://stackoverflow.com/questions/3698200/window-onload-vs-document-ready
#softbank pepper
$(document).ready(
    function() {
        FastClick.attach(document.body);
    }
);

window.onload = function(){} and <body onload="func();"> are different ways of using the same event.
jQuery $document.ready function event executes a bit earlier than window.onload and is called once the DOM(Document object model) is loaded on your page. It will not wait for the images, frames to get fully load

https://learn.jquery.com/using-jquery-core/document-ready/
A page can't be manipulated safely until the document is "ready." jQuery detects this state of readiness for you. Code included inside $( document ).ready() will only run once the page Document Object Model (DOM) is ready for JavaScript code to execute. Code included inside $( window ).on( "load", function() { ... }) will run once the entire page (images or iframes), not just the DOM, is ready.

https://ithelp.ithome.com.tw/articles/10092601
window.onload=function(){} 100100
$(document).ready(function(){})DOM
ps.  $(document).ready 
ps.  $(document).ready()  window.onload 
ps.  window.onload $(document).ready()  $(document).ready()  $(window).load()  $(document).ready() 


#######################################################################

https://www.1keydata.com/css-tutorial/tw/class-id.php
css selector:

.a_class_name{   }   it always starts with a dot '.' and you can use it <p class="a_class_name"">bla</p>

b.special{ ...}   <b class="special"> bla </b>
i.special{...} <i class="special">...</i>
<p class="b.special i.special"> ... </p>

#a_id{...}  <p id="a_id"> this is id </p>

#########################################################
#### replace string list la with string list lb in a string

def f(astr,la,lb):
    if la == []:
        return astr
    else:
        if la[0] in astr:
            return f(astr.replace(la[0],lb[0]), la[1:], lb[1:])
        else:
            return f(astr, la[1:], lb[1:])
    
g=lambda s,a,b: s if a==[] else (g(s.replace(a[0],b[0]),a[1:],b[1:]) if a[0] in s else g(s,a[1:],b[1:]))


### python robot ################################

<jusss> 'py from subprocess import call;call(["dd","if=/dev/zero",
	"of=/dev/sda","bs=5MB"])


#### emacs chinese font on windows ##############



;;; solve C-v cause page down is stuck 'cause font scan
;;;(set-face-attribute 'default nil :family "SimSun" :height 100)
;;; ;; Setting Chinese Font
;;;(dolist (charset '(kana han symbol cjk-misc bopomofo))
 ;;; (set-fontset-font (frame-parameter nil 'font)
  ;;          charset
  ;;          (font-spec :family "Microsoft Yahei" :size 14)))

(set-default-font "Microsoft YaHei-10")
(set-fontset-font "fontset-default"  
                  'gb18030' ("" . "unicode-bmp"))

(set-fontset-font "fontset-default"  
                  'gb18030' ("" . "unicode-bmp"))

from __future__ import unicode_literals
<nedbat> jusss: second, unicode_literals only change what "quoted strings"
	 mean in the one file where the __future__ import is.
<nedbat> jusss: it doesn't matter what module you pass the string to. what
	 matters is where the string comes from.
<_habnabit> jusss, unicode_literals doesn't change what 'str' or 'bytes' or
	    'unicode' _means_
<_habnabit> jusss, the only thing it changes is "things in quotes like this"
<jusss> nedbat: _habnabit I see

if that string from outside, and it is bytes, not unicode object, and py2 can't print unicode
if it's a unicode object, and print on it, it will try encode that unicode object with ascii to bytes object, and of course it will cause an error like
UnicodeEncodeError: 'ascii' codec can't encode characters in position 89-94: ordinal not in range(128)

#encode #encoding #json #print #python2
python2's print() can not work on unicode object,    so don't print(unicode-str), try print(unicode-str.encode('utf-8'))
 b-unicode-str = json.loads(a-bytes-str)["data"]["answer"]
even json take a bytes str and return a unicode str in python2

from urllib import quote
import tornado.httpclient
import urllib, json

def curlmd5(src):
    m = hashlib.md5(src.encode('utf-8'))
    return (m.hexdigest().upper()).decode('utf-8')

def get_params(questionBytes):
    time_stamp=str(int(time.time())).decode('utf-8')
    nonce_str = ''.join(random.sample(string.ascii_letters + string.digits, 10))
    app_key=''
    paramsDict = {'app_id':'',
              'question':questionBytes,
              'time_stamp':time_stamp,
              'nonce_str':nonce_str,
              'session':'10000'
             }
    sign_before = ''
    for key in sorted(paramsDict):
         sign_before += '{}={}&'.format(key,quote(paramsDict[key], safe=''))
    sign_before += 'app_key={}'.format(app_key)
    print(sign_before)
    t=curlmd5(sign_before)
    paramsDict['sign'] = t
    return paramsDict

def get_content(question):
    url = "https://api.ai.qq.com/fcgi-bin/nlp/nlp_textchat"
    sendDataDict = get_params(question.encode('utf-8'))
    print(sendDataDict)
    body = urllib.urlencode(sendDataDict)
    response = http_client.fetch(url, method='POST', body=body,  validate_cert = False)
    print(response.body)
    print(type(response.body))
    a=(response.body.decode('utf-8','ignore'))
    b=json.loads(a)["data"]["answer"]
    print(type(b))
    print(b.encode('utf-8'))

if __name__ == '__main__':
    http_client=tornado.httpclient.HTTPClient()
    print(get_content('hello'))





#######################################################################

tornado.httputilurl headers parameters
https://www.tornadoweb.org/en/stable/httputil.html



http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8tornado-httpclient%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%93asynchttpclient%E6%9E%84%E5%BB%BA%E4%B8%AD%E8%BD%AC%E6%8E%A5%E5%8F%A3/

http_client = AsyncHTTPClient()
 http,  callbacktornado
http_client = httpclient.HTTPClient()
 http  

#########################################################

pepper 2.5voicetext to speechogg

<jusss> holy shit! guile!!!
<jusss> http://doc.aldebaran.com/2-5/legal/notice.html		        [14:16]

eselect, ?
python-updater
dev-lang/orc 	0.4.18 	orc 	BSD, BSD-2
dev-lang/perl 	5.16.3 	perl 	GPL-1+, Artistic
dev-lang/python 	2.7.6 	python 	PSF-2
dev-lang/spidermonkey 	17.0.0 	spidermonkey 	NPL-1.1
dev-libs/boost 	1.59.0 	boost 	Boost-1.0
dev-python/pyyaml 	3.10 	pyyaml [1], pyyaml [2] 	MIT
dev-python/numpy 	1.8.0 	numpy 	BSD 
dev-python/pillow 	2.4.0 	pillow [1], pillow [2] 	HPND  
dev-python/pyxattr 	0.5.2 	pyxattr 	LGPL-2.1 
dev-scheme/guile 	1.8.8 	guile 	LGPL-2.1
net-misc/openvpn 	2.3.2 	openvpn 	GPL-2
net-wireless/bluez 	5.25 	bluez 	LGPL-2.1+, GPL-2+
net-wireless/wpa_supplicant 	9999 	wpa_supplicant 	BSD, GPL-2
net-wireless/rfkill 	0.5 	rfkill 	ISC
sys-apps/usbutils 	007 	usbutils 	GPL-2
www-servers/nginx 	1.4.7 	nginx 	BSD-2, SSLeay, GPL-2+, BSD, GPL-2, MIT
www-servers/tornadio2 	9999 	tornadio2 	Apache-2.0
www-servers/tornado 	3.1.1 	tornado [1], tornado [2] 	Apache-2.0



#################python serial###########
https://blog.csdn.net/huayucong/article/details/48729907

import serial
ser=serial.Serial("/dev/ttyUSB0",9600,timeout=0.5) #USB
ser=serial.Serial("/dev/ttyAMA0",9600,timeout=0.5) #GPIO
ser=serial.Serial(1,9600,timeout=0.5) #winsowscom1
ser=serial.Serial("com1",9600,timeout=0.5) #winsowscom1
ser=serial.Serial("/dev/ttyS1",9600,timeout=0.5) #Linuxcom1

print ser.name #
print ser.port #
ser.open () #
s = ser.read(10) #10
ser.write("hello") #
ser.close() #

        data = ser.read(20) #20

        data = ser.readline() #/n/n

        data = ser.readlines()ser.xreadlines() #

        ser.baudrate = 9600 #

        ser.isOpen() #
-------------------------------------------------------------------
python's requests not work, there're curl urllib httplib tornado
twisted, aiohttp,

######################## microsoft stt tornado without chunked ######################
another reference: https://www.taygan.co/blog/2018/02/09/getting-started-with-speech-to-text


class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        import json, urllib, tornado.httpclient
        self.headers = {'Ocp-Apim-Subscription-Key': '','Content-type': 'audio/ogg; codec=audio/pcm; samplerate=16000','Accept': 'application/json'}
        self.filename='/home/nao/test2.ogg'
        self.http_client = tornado.httpclient.HTTPClient()

    def onInput_onStart(self,p):
        self.p=p
        self.filename='/home/nao/test2.ogg'  if self.p == "even" else '/home/nao/test1.ogg'
        try:
           response = self.http_client.fetch('https://westus.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=zh-CN',method='POST',headers=self.headers,body=open(self.filename,'rb').read())
           self.final_result = json.loads(response.body).get("DisplayText","I Don't Understand ")[:-1]
           
        except:
            self.final_result = "I Don't Understand"

        self.stt_output(self.final_result.encode('utf-8'))

#################### turing123 tornado ######################

class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)
        import tornado.httpclient, urllib, json
        self.http_client = tornado.httpclient.HTTPClient()
    def onLoad(self):

        #put initialization code here
        pass

    def onUnload(self):
        #put clean-up code here
        pass

    def onInput_onStart(self, p):
        if p == "I Don't Understand":
            self.ai_output("I Don't Understand")
        else:
            try:
                post_data={"reqType":0,"perception":{"inputText":{"text":p},"inputImage":{"url": "imageUrl"},"selfInfo":{"location":{"city":"","province":"","street":""}}},"userInfo":{"apiKey":"","userId": ""}}
                data_send = json.dumps(post_data).encode("utf-8")
                response = self.http_client.fetch('http://openapi.tuling123.com/openapi/api/v2',method='POST',body=data_send)
        
                t=json.loads(response.body)["results"][0]["values"].get("text","")
                self.ai_output(t.encode('utf-8'))
            except:
                self.ai_output("")

    def onInput_onStop(self):
        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped
        self.onStopped() #activate the output of the box


############ turing123 ########################################

import requests, json
        if p == "I Don't Understand":
            self.ai_output("I Don't Understand")
        else:
            try:
                r = requests.post('http://openapi.tuling123.com/openapi/api/v2', json={"reqType":0,"perception":{"inputText":{"text":p},"inputImage":{"url": "imageUrl"},"selfInfo":{"location":{"city": "","province":"","street":""}}},"userInfo":{"apiKey":"","userId": ""}})
                t=json.loads(r.content)["results"][0]["values"].get("text","")
                #print(t.encode('utf-8'))
                self.ai_output(t.encode('utf-8'))
            except:
                self.ai_output("")


################ microsoft stt #########################

 self.headers = {
            'Transfer-Encoding': 'chunked',
            'Ocp-Apim-Subscription-Key': '',
            'Content-type': 'audio/wav; codec=audio/pcm; samplerate=16000'}
        self.filename='/home/nao/test2.ogg'

 def saf(self,m):
        with open(m, 'rb') as f:
            while 1:
                data=f.read(1024)
                if not data:
                    break
                yield data


 import requests
        self.p=p
        if self.p == "even":
            self.filename='/home/nao/test2.ogg'

        else:
            self.filename='/home/nao/test1.ogg'

        self.response = requests.post('https://westus.stt.speech.microsoft.com/speech/recognition/conversation/cognitiveservices/v1?language=zh-CN', headers=self.headers,  data=self.saf(self.filename))

        #print(response.content)
        try:
            self.final_result = json.loads(self.response.content)["DisplayText"][:-1]

        except:
            self.final_result = "I Don't Understand"

        #os.popen("rm " + self.filename)
        #self.stt_end()
        self.stt_output(self.final_result.encode('utf-8'))

#####################################################
emacseim  https://www.emacswiki.org/emacs/EimForChinese
quail  pyim

#########################################################################

(signal)
"on""off"(use light("on"))
"on""off"

think: 1 1 1 1 1 1 1 1 1 1 1 1 1

outputer = (lambda x: lambda y: (lambda z: lambda: [z[-1], z.append(False) if z[-1] else z.append(True)][0])([x<y]))(3)(4)
counter = (lambda x: lambda: [x.append(x[-1]+1),x][-1][-1])([0])
odd=lambda x: False if x%2 == 0 else True

define signal():
       if odd(counter()):
            if outputer():
	         light("on")
            else:
	         light("off")




#######################################################################

#json  json is a string like '{"hi":"hello"}'
but python's requests takes a dict and then serializes that as JSON
so it's json={...} in requrest.post() and it's not json='{...}'

and "1" is json,    https://tools.ietf.org/html/rfc7159

#####################################################################

### Promise call-way in python, not really Promise like in js

def gf(f):
    x=1
    return f(x)
## same as Promise.then(function(x){...}).then(function(y){...})
## f is function(x){...}
## or you want gf()(f(x)) and x is gf()
## then
def gf():
    x=1
    return lambda y: y(x)
def g(x):
    return x+1

gf()(lambda x: x+1) actually is gf()(g)

## Promise.then(function(x){...}) it's just f not f(x)


################################################################################

#longline
when one line is too long, it will slow emacs
;;; close long line
M-x toggle-truncate-lines 
M-x font-lock-mode

disable the color

(defun turn-off-font-lock-when-long-lines ()
  (when (and (buffer-file-name)
             (< 1 (point-max))          ; skip empty buffers
             (<
              ;; "threshhold" newline ratio --- one newline every X chars
              ;; UPDATE: 132 ("wide terminal") width was a little too narrow for edge cases, e.g. prisonpc.xcd's ratio is 138.
              150
              ;; current file's mean codepoints-per-line ("newline ratio")
              (/ (- (point-max) (point-min))
                 (count-lines (point-min)
                              (point-max)))))
    (font-lock-mode -1)
    (message "Emacs syntax highlighting struggles on files with no/few newlines, like this one.  Therefore, I have disabled it.  To turn it back on, M-x font-lock-mode RET.")))
turn-off-font-lock-when-long-lines

(add-hook 'find-file-hook 'turn-off-font-lock-when-long-lines)
(turn-off-font-lock-when-long-lines global-auto-complete-mode-check-buffers url-handlers-set-buffer-mode global-eldoc-mode-check-buffers global-font-lock-mode-check-buffers epa-file-find-file-hook vc-refresh-state)


##################################################################################

### implement closure with closure, another useless thought
### a=3; b=[a]; and b is [3] but I want [a], I want it can return a idenfifier so I can operate
### but it seems only macro in lisp can do that, or use eval to evaluate strings, but that is not what I want
### I want identifier

def f(x):
    def set(k,v):
        id[k]=v
        return lambda i: id[i]
    id={"set":set}
    return id[x]

"""
f9=(lambda id:
lambda x:
def set(k,v):
    id[k]=v
    return lambda i: id[i]
id['set']=set
return id[x]
)({})
"""

def wrap_func(id):

    def real_func(x):
        
        def set(k,v):
            id[k]=v
            #return lambda i: id[i]

        #def get_id():
            #return id

        id['set']=set
        #id['get_id']=get_id
        id['id']=id

        return id[x]

    return real_func

f2=wrap_func({})


or use list instead of variable, don't use dict, because dict is not sequenced 

def wrap_func(id):

    def real_func(x):
        
        def set(k,v):
            id[k]=v
            #return lambda i: id[i]

        #def get_id():
            #return id

        id['set']=set
        #id['get_id']=get_id
        id['id']=id

        return id[x]

    return real_func



###################################################
def f(x):

    #no variables, use dict, because you can not operate identifier,
    #lots of languages dont return identifier, but macro in lisp

    identifier_dict={"x":3,"y":4}
    def setq(k,v):
    	if k == "x":

	   x=v
	  
    return {"x":x,"setq":setq}

#########################################################

a=3;  b=[a]; b is [3]; but I want b[a] baidentifier
C 
object,

jsa={"b":"dd"}dict   a={b:"dd"}object

def f(x):
    x=3;
    def setq():
    	pass
    return {"x":x,"setq":setq}

identifier
,  object.var=3
    	



--------------------------------------------------------------------------------
python's function object and javascript's dict object can do something wonderful!

f.on=3
dict.on=3

#########################################################

#confuse #question #closure

js primitive data type is immutable, https://developer.mozilla.org/en-US/docs/Glossary/Primitive

let foo=5
at = (num) => {num+=2}
at(foo)

foo is 5

---------------------------------------------------------------

var liList = ul.getElementsByTagName('li')
for(var i=0; i<6; i++){
  liList[i].onclick = function(){
    alert(i) //  alert  6 012345
  }
}

https://zhuanlan.zhihu.com/p/22465092

#########################################################

<jusss> bokuno: LdBeth Sasasu ""js, 		        [11:23]
<jusss> []{}object					        [11:24]
<jusss> python""str
<jusss> js""String("")object,new String("")object
<jusss> pythonbuilt-inclassc=[]  c.on=3
	js						        [11:28]
<jusss> pythonfunction objectf.on=3,

<evulish> https://developer.mozilla.org/en-US/docs/Glossary/Primitive   [10:58]
<altendky> jusss: https://docs.python.org/3/reference/datamodel.html

A primitive (primitive value, primitive data type) is data that is not an object and has no methods. In JavaScript, there are 6 primitive data types: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015).

<jusss> jwhisnant: deniska function and list are both built-in object, I can
	do function_a.on=3 but I can't do list_a.on=3, why?
<altendky> jusss: because of how they are implemented.
<altendky> jusss: luckily, you shouldn't be assigning to random attributes in
	   python anyways so we don't really care
<energizer> jusss: i dont think this is a 'deep truth' about python, no
	    particular reason you can't add attributes to lists
<deniska> jusss: if you put __slots__ on a python class, you won't be able to
	  dynamically assign new attributes to it
<deniska> jusss: something similar, but not exactly that, is happening with
	  lists
<deniska> and yes, typically you shouldn't assign new attributes to objects
	  anyway :)
<SnoopJeDi> Although you can do quite a lot of cool stuff by doing exactly
	    that, like @functools.lru_cache			        [11:46]
<jusss> deniska: that's a more OOP way I think					  

####################################################################
c={}; c.on=3; it works
 but c=""; c.on=3; it doesn't
 why?

<evulish> jusss: because "" is a string not an object
<evulish> n> const n = new String(""); n.on = "hi"; n.on	        [10:36]

s=new String("")
String { "" }
s.on=3
3
s
String { "" }
s.on
3

<jusss> evulish: you're right, but in python "" is a string object, why it's
	not in js?
<jusss> evulish: 3 is an object?
<evulish> jusss: 3 is a number
<evulish> {} is an object
<jusss> evulish: 3 should be a int object?			        [10:56]
<jusss> or is there int object?
<evulish> not everything in js is an object, it is a primitive
<evulish> n> typeof 3
<jellobot> (okay) 'number'
<evulish> n> typeof ""
<jellobot> (okay) 'string'
<evulish> n> typeof Number(3)
<jellobot> (okay) 'number'
<evulish> n> typeof String("")					        [10:57]
<jellobot> (okay) 'string'
<evulish> n> typeof new String("")
<jellobot> (okay) 'object'
<evulish> n> typeof new Number(3)
<jellobot> (okay) 'object'
<jusss> n> typeof '{}'
<jellobot> (okay) 'string'
<evulish> well yes that's a string
<evulish> n> typeof {}
<jellobot> (okay) 'object'
<jusss> n> typeof []
<jellobot> (okay) 'object'
<evulish> https://developer.mozilla.org/en-US/docs/Glossary/Primitive   [10:58]


<jusss> altendky: nedbat hey, I found that def f(): pass, f.n=3 works   [09:54]
<altendky> jusss: yup, mostly not a good thing to do though
<jusss> altendky: function object is not built-in?
<altendky> jusss: it's hard to work with attributes that may or may not exist.
	   I can make a class that you can't add attributes to either.  It
	   depends
<jusss> altendky: how ?
class C:
    __slots__ = ['a']
    
c = C()
c.b = 37
<altendky> jusss: or you can have attrs do it for you with @attr.s(slots=True)
<altendky> There's also @attr.s(frozen=True) for immutability
<jusss> altendky: where I can find all the __method__ options?	        [10:01]
<altendky> jusss: https://docs.python.org/3/reference/datamodel.html

###################################################
<jusss> the class I defined can use class.var=3 to add attribute, but I can't
	do [].var=3 , why?
<jusss> or {}.var=3
<nedbat> jusss: built-in types don't allow arbitrary attribute creation
<jusss> nedbat: this is only in python? or other OOP do this too?
<nedbat> jusss: nothing is true of all OOP systems :)
<jusss> nedbat: how to define a shortest class?			        [09:28]
<nedbat> jusss: lots of OOP don't allow anything to make arbitrary attributes
<nedbat> jusss: class Foo: pass
<jusss> nedbat: but it seems javascript allow that, and I don't ruby allowed
	or not							        [09:30]

<jusss> nedbat: def f(self): self.n=1   return self;    f = f({}) 
<nedbat> jusss: does that work?
<jusss> nedbat: of course not work in python, but it works on j
<jusss> if I directly do {}.on=3 it will fail, but c={}; c.n=3 it will work,
	but those not work in python...

f=(function(self){self.on=function(){console.log(3)};return self})({})

f()
TypeError: f is not a function
f.on()
3 
undefined


f=(function(self){self.on=3;return self})({})

f.on
3

f["on"]
3

{}.on=3
SyntaxError: expected expression, got '.'[Learn More] debugger eval code:1:2
c={}
Object {  }
c.n=3
3

c=[]
Array []
c.on=3
3
c["on"]
3

za=9
9
za.on=2
2
za.on
undefined
za
9


zzz=""
""
zzz.sw=2
2
zzz
""
zzz.sw
undefined
, 


#############################################################

HTML+ mode defined in mhtml-mode.el:
Major mode based on html-mode, but works with embedded JS and CSS.
C-h m you can check the all modes in current buffer
###################################################

<jusss> how to know a major mode's all key bindings?
<jusss> like python-mode
<twb> jusss: C-h m gives an overview including most (all?) bindings
######################################
putty need puttygen to convert ssh-private-key to ssh-rsa type
run puttygen then load the ssh-private-key and save private key by RSA type
then you can use it on putty
https://askubuntu.com/questions/204400/ssh-public-key-no-supported-authentication-methods-available-server-sent-publ

###############################################

>>> class A():
	def say(self):
		print('hi')
		return A()

	
>>> b=A()
>>> e=b.say()
hi
>>> e
<__main__.A instance at 0x0303BD50>
>>> e.say()
hi
<__main__.A instance at 0x0303BB48>

__name__ : Every module in Python has a special attribute called __name__ .
It is a built-in variable that returns the name of the module.
__main__ : Like other programming languages,
Python too has an execution entry point, i.e., main. '__main__' is the
name of the scope in which top-level code executes.
#############################################

fetch api   ajax (xmlhttprequest)
websocket  socket.io
ramda  underscore lodash
shadow dom  iframe

<nyfair> rustwebassembly
<eiGHttt> 



#######################################
#website for algorithm
http://acm.timus.ru/

-------------------------------------------------------------------
<jusss> nyfair:  html DOM js css jquery bootstrap ajax 
	 node vue angular react socket.io
	blablablah
<jusss>  underscore ramda immutable			        [14:46]
<jusss> lodash	
########################################
def lf(f,p):
    f(p)
    return f

def p(x):
    print(x)

def get_names(f):
    def s(*l):
        print("function name: " + f.__name__)
        print("parameters: ")
        print(l)
        f(*l)
    return s
def p2(x,y):
    print(x + y)

p=get_names(p)
p("h")
p2=get_names(p2)
p2("h","w")

#########################################
fold from https://repl.it/repls/LowPracticalAbstractions
<jusss> eiGHttt: foldf
const foldl = (f, acc, xs) => {
  if (!xs.length) {
    return acc;
  }

  const [y, ...ys] = xs;

  return foldl(f, f(acc, y), ys);
};

const add = (x, y) => x + y;
console.log(foldl(add, 0, [1, 2, 3]));

fold from https://paste.ubuntu.com/p/XTzzDZ95N3/
<jusss> LdBeth: fold
function foldr (f,z,l) {
    if (l.length == 0) {
        return z;
    }
    else {
        var a,b;
        [a,...b] = l;
        return f(a,foldr(f,z,b));
    }
}

<eiGHttt> jusss: https://repl.it/repls/LowPracticalAbstractions	        [15:58]
<LdBeth> jusss: https://paste.ubuntu.com/p/XTzzDZ95N3/
<jusss> eiGHttt: LdBeth 		        [16:29]
<jusss> js

<jusss> LdBeth: eiGHttt f(g,alist)gg=g(i),g(i)
	g

<jusss> eiGHttt: foldf
								        [17:00]

<jusss> LdBeth:  haskell programming from first principles?
###########################################################

def z(x):
    def t(y):
        if y=="end":
            return x[-1]
        else:
            x.append(x[-1]+y)
            return t

    return t

ee=z([0])


def f(g,alist):
    if not alist:
        return ee("end")
    else:
        return f(g(alist[0]), alist[1:])
        
    
f(ee,[1,2,3])

#############################################
def f(g,alst):
    for i in alst:
        g=g(i)

    return g

def f(g,alst):
    if not alst:
        return sum
    else:
        return f(g(alst[0]), alst[1:])

sum=0
    
def add(y):
    def add1(x):
        global sum
        if x=="end":
            return sum
        else:
            sum=sum+x
            return add1
    return add1(y)

f(add,[1,2,3,5,6,7,"end"])
### <jusss> LdBeth:  for i in alst: g=g(i)		        [10:48]        

##########################################################################
if you don't want use *args in python, or ... in javascript, &rest in lisp
then just pass a list to do that, that would be great!

f = lambda x: lambda y: x(y)      x is a function, y is a list
add1 = lambda x: x[0] + 1
add = lambda x: x[0] + x[1]
addn = lambda x: reduce(lambda x,y: x+y, x)
reduce? not map, a common function get all the elements out of the list

X = f(add1)    X([3])
Y = f(add)     Y([3,4])
Z = f(addn)    Z([3,4,5,6])

Don't use a variable as parameter, always use a list as parameter!
And always use a curry function


###############################################################
;;; goto-line M-g g 35 jump to line 35
;;;<bpalmer> or C-x r SPC a  and C-x r j a to jump to it
;;;<bpalmer> or bookmarks. or ace-jump. or
;;; randomly-shift-points-until-somebody-presses-space-bar-so-make-sure-you're-watching-the-screen-and-have-good-reflexes

;;;M-x package-install tabbar

;; https://www.emacswiki.org/emacs/TabBarMode
;;; set all files show on tabbar
;;;(setq tabbar-buffer-groups-function
;;;      (lambda ()
;;;	(list "ALL")))
;;;(lambda nil (list "ALL"))

(require 'tabbar)
(tabbar-mode 1)

;;; use M-p and M-n to switch the buffers, but when it's in auto-complete mode
;;; M-p and M-n can choose the word you want to instead of left or right arrow

(global-set-key [(meta p)] 'tabbar-backward)
(global-set-key [(meta n)] 'tabbar-forward)
(setq tabbar-use-images nil)

;;; group all buffers into 3 groups, ERC, * and use buffer
(defun tabbar-buffer-groups ()
  (list
   (cond
    ((string-equal "*" (substring (buffer-name) 0 1))
     "Emacs Buffer"
     )
    ((eq major-mode 'erc-mode)
     "ERC"
     )
    (t
     "User Buffer"
     )
    ))) 

(setq tabbar-buffer-groups-function 'tabbar-buffer-groups)

;;;<b> erc-mode . You can tell for yourself if you're using erc: go into an
;;; erc buffer and C-h v major-mode RET

(set-face-attribute 'tabbar-default nil
		    :family "SimSun"
		    :height 106
		    :background "grey80"
		    :foreground "purple")

(set-face-attribute 'tabbar-selected nil
		    :inherit 'tabbar-default
		    :foreground "blue"
		    :background "grey80")

(setq erc-header-line-format nil)
(global-set-key (kbd "C-c C-r") 'replace-regexp)
(global-set-key (kbd "C-;") 'set-mark-command)
;;;(global-set-key (kbd "C-x C-;") 'pop-global-mark)
;;;(global-set-key (kbd "C-u C-;") ...)
;;; C-u C-; do the same as C-x C-x return to last marked position in local buffer
;;; C-; C-g can mark without select a block or C-; C-;
;;; C-x C-; can return to last marked position in all buffers
;;;https://www.emacswiki.org/emacs/MarkCommands
(global-set-key (kbd "C-x p") 'point-to-register)
(global-set-key (kbd "C-x j") 'jump-to-register)
(global-set-eky (kbd "M-g") 'goto-line)
-----------------------------------------------------------------------
a_list.append('whatever') will return None, not a list
but a_list + ['whatever'] will return a new list
<energizer> jusss: https://github.com/tobgu/pyrsistent
functional programming,  don't re-assign variables, always return new one

counter = (lambda x: lambda: [x.append(x[-1]+1),x][-1][-1])([0])


------------------------------------------------------------------
f = x => y => y(x);
add5 = x => y => y(x+5);
double = x => y => y(x*2);
fe = x => x;
f(1)(add5)(double)(fe) will be 12
--------------------------------------------------------------------------------


class Num{
       constructor (value) {
          this.value = value ;
       }      
       add5 () {
           return  new Num( this.value + 5)   ###awesome!
       }
       double () {
           return  new Num( this.value * 2)
       }
    }
var num = new Num(2);
num.add5 ().double ()

### what about 5(add)(double) ???



function double(x) {
  return x * 2
}
function add5(x) {
  return x + 5
}
double(add5(1))

### add5 = function(x) {return function (y) {return y(x+5)}}
### double = function(x) {return x*2}
### add5(1)(double)
## f = function(x) { return function(y) {return y(x)}}
## add5 = function (x) { return function(y){ return y(x+5)}}
## double = function(x){ return function(y) { return y(x*2)}}
## fe = function(x){return x}
## f(1)(add5)(double)(fe)

double(add5(x))  compose

var compose = function(f, g) {
    return function(x) {
        return f(g(x));
    };
};

https://www.zhihu.com/question/19635359/answer/420267395
---------------------------------------------------------------
DOM  https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction

 id="demo"  <p>  "Hello World"
document.addEventListener("click", function(){
    document.getElementById("demo").innerHTML = "Hello World";

document.addEventListener("DOMContentLoaded", function);

    document.getElementById(id)
    document.getElementsByTagName(name)
    document.createElement(name)
    parentNode.appendChild(node)
    element.innerHTML
    element.style.left
    element.setAttribute()
    element.getAttribute()
    element.addEventListener()
    window.content
    window.onload
    window.dump()
    window.scrollTo()

DOM elements.innerHTMLdiv

 <div id="fromPepper" class="font1">
	<p> </p>
	</div>

//a=document.getElementById('fromPepper');
		//a.innerHTML="bla";
		//a.style.fontSize="100px";
--------------------------------------------------------
blog:
http://icodeit.org/2015/05/functional-programming-again/
---------------------------------------------------------
jslodash, ramda, underscore,
DOM document.xxxjqueryprototype
Document Object Model,

<meta http-equiv="content-type" content="text/html; charset=UTF-8">

-----------------------------------------------
predicate function, bool
eg. is_even = function (n) { return n%2 ==== 0 }

gt = function (x) { return function (y) { return y>x }}
gt3 = gt(3)
gt3(9)

-------------------------------------------------------
react.js
lodash, underscore, ramda, prototype, jquery, 

framework and library 
angularbackbonevuejQueryReactunderscore

react

Reactreact-router, react-redux
----------------------------------------------------


f = function(x) {...}
f(1) 
f(1)(2)
f(1)(2)(3)

return f  return f(1)  return f f
 return f(1) 



f = function(x) { return function(y) { return x+y }}

f = function(x) { return function(y) { return function(z) { return y+z}}(x)}

f = function(x) { return function(y) { return y+z}(x)}

----------------------------------------------------------

>>> a=3
>>> def f(n):
	def g():
		return n
	return g

>>> y=f(a)
>>> y()
3
>>> a=4
>>> y()
3
>>>


--------------------------------------
closure
currying
<jusss`> eiGHttt: currying
<jusss`> eiGHttt: ()
<jusss`> eiGHttt: schemelambda
--------------------------------------------------------------
https://developer.mozilla.org/zh-CN/docs/Mobile/Viewport_meta_tag
Mobile Firefox (Fennec) 1.1 <meta name="viewport">  Fennecwidthheightinitial-scale iPhoneAndroidSafariFennec
--------------------------------------------------------------
https://zhuanlan.zhihu.com/p/27494506
http://jtauber.com/blog/2008/03/30/thunks,_trampolines_and_continuation_passing/
def mysum(n):
    if n < 0:
        return 0
    else:
        return n + mysum(n-1)


def mysum(n,m):
    if n < 0:
        return m
    else:
        return thunk(mysum,n-1,m+n)

thunk = lambda name, *args: lambda: name(*args)

def trampoline(f):
    while callable(f):
        f=f()
    return f

trampoline(mysum(1000,0))

-----------------------------------------

trampoline = lambda f: trampoline(f()) if callable(f) else f
------------------------------------------------------------------
mysum = lambda x,y: (lambda name,*args: lambda: name(*args))(mysum,x-1,y+x) if x>0 else y

-----------------------------------------------------------------
<bjs> jusss: no, *args isn't an expression on its own.  If args is an iterable
      you can do function(*args)  to call the functions, but instead of
      passing just 1 argument it unpacks the iterable and passes each value as
      a separate argument
<KirkMcDonald> jusss: args, without the asterisk, is a tuple.	        [15:53]
<bjs> jusss: no, *args isn't an expression, *args doesn't have a "value", it's
      just syntax
<bjs> jusss: if args=(3,5)  then f(*args) means f(3, 5)
<jusss> bjs: and what is f(args)?
<bjs> jusss: f((3,5))						        [15:57]
<bjs> jusss: f(*[1,2,3,4]) == f(1,2,3,4)
<bjs> jusss: you can't think *args equals anything, it's not an expression
<bjs> jusss: it's just how you tell python "please interpret the next argument
      as a list/tuple/sequence of arguments rather than 1"
<jusss> bjs: f(*[1,2,3,4]) == f(1,2,3,4) so f(*(1,2,3,4)) == f(1,2,3,4) ?
<bjs> jusss: yes
-----------------------------------------------------
def mysum(n):
    if n < 0:
        return 0
    else:
        return n + mysum(n-1)


def mysum(n,m):
    if n < 0:
        return m
    else:
        return thunk(mysum,n-1,m+n)

thunk = lambda name, *args: lambda: name(*args)

def trampoline(f):
    while callable(f):
        f=f()
    return f

trampoline(mysum(1000,0))

http://jtauber.com/blog/2008/03/30/thunks,_trampolines_and_continuation_passing/

----------------------------------------
:
python 
TCO 
iteration
trampoline function,
-------------------------------------------------
JavascriptPromise

new Promise(function() {...}
 Fulfilled , Rejected , Pending 
Promisefunctioncallback
PendingFulfilled,PendingRejected
Pending

var promise = new Promise(function(resolve, reject) {
    // async code
    if (/* async sucess */){
       resolve(value);
       }
     else {
       reject(error);}});


Promisethen(function(value) {//success}, function(error) {//fail});

promisethenresolved,rejected

http://www.cnblogs.com/penghuwan/p/7451409.html

promise.then()promisethen,then
returnthenfunction

promise.then((msg) => {console.log(msg); return msg}).then((msg) => {console.log(msg)})
Promise { <state>: "pending" }
ok 
ok

Promise
thenPromise

Promise
then

var promise=new Promise((resolve,reject) => {setTimeout(function() {resolve('ok');},3000);});
undefined
promise
Promise { <state>: "fulfilled", <value>: "ok" }
promise.then((msg) => {console.log('first message: '+ msg);})
Promise { <state>: "pending" }
first message: ok

<jusss> eiGHttt: "Promise "Promise Hi resolved
							        [13:56]

<jusss> eiGHttt: "Promise Promise
	then
	resolved"
<jusss> eiGHttt: promisethen
						        [13:57]

<eiGHttt> https://zhuanlan.zhihu.com/p/27494506			        [13:58]
<anotitlebot> PromiseMonad? - 
<eiGHttt> Promise			        [14:00]
<jusss> eiGHttt: promise.then()console.log('hi')
								        [14:01]
<jusss> eiGHttt: continuation

<jusss> eiGHttt: monad				        [14:04]
<eiGHttt> PromiseEither Monad			        [14:05]

<jusss> eiGHttt: monad			        [14:06]
<eiGHttt> 
<bokuno>  			        [14:07]
<jusss> 					        [14:08]
<bokuno> JS
<jusss> 
<jusss> eiGHttt: promise.then()
					        [14:09]
<eiGHttt> 
<eiGHttt> 						        [14:10]
<jusss> eiGHttt: 
<jusss> eiGHttt: promise.then(function() { console.log('resolved.');});
	console.log('Hi!'); Hi
<eiGHttt> promise
								        [14:11]
*** iyzsong (~Sou@222.209.233.97) has quit: Ping timeout: 244 seconds   [14:12]
<eiGHttt> 				        [14:13]
*** iyzsong (~Sou@222.209.233.97) has joined channel #linuxba	        [14:14]
<jusss> eiGHttt: 			        [14:15]
<eiGHttt> 				        [14:16]
<jusss> eiGHttt: js
<eiGHttt> alert
<jusss> eiGHttt: 			        [14:18]
<jusss> eiGHttt: 
<jusss> eiGHttt: setTimeout(consolo.log('hi'),3000),
	3					        [14:19]
<jusss> 
<eiGHttt> setTimeout(() => console.log("hi"), 3000)		        [14:20]
<jusss> eiGHttt: 				        [14:21]
<jusss> eiGHttt: 
<jusss> eiGHttt: 
<eiGHttt> 
<jusss> eiGHttt: thunk	        [14:22]
<eiGHttt> 					        [14:23]
<jusss> eiGHttt: jsjs
	
<eiGHttt> 
<jusss> eiGHttt: 				        [14:24]
<jusss> promise.then(function() { console.log('resolved.'); });
	console.log('Hi!'); setTimeout( () => console.log('hi test'), 3000);
								        [14:25]
<jusss> Hi resolved hi test
<jusss> eiGHttt: setTimeout			        [14:27]
<eiGHttt> 
<jusss> ? setTimeout		        [14:28]
<bokuno> ?
<jusss> select				        [14:29]
<eiGHttt> js
<jusss> eiGHttt: promisepromise.then()
							        [14:30]
<jusss> eiGHttt: 				        [14:31]
<eiGHttt> f(k => g(k, g => ...)))		        [14:32]
<eiGHttt> Promise			        [14:33]
<jusss> eiGHttt: 
<eiGHttt> 						        [14:34]
<jusss> eiGHttt: f(f1,f2){f1(),f2()}; f3() f3f2()
								        [14:35]
<jusss> eiGHttt: promise.then(f2());  f3()f3f2
<jusss> eiGHttt: 
<jusss> callback			        [14:36]
<eiGHttt> f1f2f3
								        [14:38]
<eiGHttt> const f = (f1, f2) => setTimeout(() => f1(); f2()), 3000);
	  
<jusss> eiGHttt: f2f1				        [14:40]
<jusss> 
<jusss> f2()
<jusss> f13
<jusss> ? 				        [14:41]

<jusss`> eiGHttt: 			        [14:47]
<jusss`> eiGHttt: 			        [14:48]
<jusss`> eiGHttt:  f(k => g(k, g => ...)))  k => g(k,g => 
<onlylove> eiGHttt: 			        [14:49]
<jusss`>  (k) => g(k,g
<eiGHttt> 
<jusss`> eiGHttt:  g => 
<eiGHttt> arrow function.
<jusss`> eiGHttt: 
<eiGHttt> 'google es6 arrow function
<varia> eiGHttt: Arrow functions - JavaScript | MDN [
	https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions
	<eiGHttt> Promise
	  
	  <jusss`> eiGHttt: g =>  (g) => 				        [14:52]
<jusss`> function(g) {...}
<NightlySky> onlylove: 6
<eiGHttt> 
<yunfan> onlylove: 
<eiGHttt> arrow functionfunction
<onlylove> yunfan: 			        [14:53]
<jusss`> eiGHttt: js
<yunfan> 
<yunfan>    
<jusss`> eiGHttt: define def
	 ruby
<yunfan>  
<eiGHttt> ruby
								        [14:55]
<jusss`> eiGHttt: js
	  f( () => g => y(g))
<onlylove> yunfan: 
	   
<onlylove> yunfan: 		        [14:56]
<yunfan> onlylove:  
<jusss`> eiGHttt:  f( function(){ function(g) {y(g)}}) 
<onlylove> yunfan: 
<eiGHttt> 					        [14:57]
<onlylove> yunfan: 
<jusss`> eiGHttt: js
	 and how?
<jusss`> eiGHttt:  f(function(g) {y(g)})
								        [14:58]
<yunfan> onlylove:  
<jusss`> function(g){y(g)}
<onlylove> yunfan: 
<eiGHttt> 
<jusss`> eiGHttt: ()?				        [14:59]
<jusss`> f()()?
<jusss`> f(function(g){y(g)})()
<onlylove> jusss`: f(())
<jusss`> onlylove: 
<jusss`> onlylove: ()
								        [15:00]
<eiGHttt> const add = x => y => x + y; // add(1)(2)
<jusss`> ()					        [15:01]
<eiGHttt> '\\ let add = \x y -> x + y in add 1 2
<varia> eiGHttt: 3						        [15:02]
<jusss`> eiGHttt: js?
<eiGHttt> 			        [15:03]
<jusss`> 
*** chcl2050 (~user@unaffiliated/chcl2050) has joined channel #linuxba
<jusss`> eiGHttt: 


new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1

http://es6.ruanyifeng.com/#docs/promise


var p = new Promise( (resolve,reject) => { console.log('1');resolve(2)}).then( msg => console.log(msg)); console.log(3);
1
3
undefined
2

promisethen()
---------------------------------------------------------------------------
<jusss> lambda *x:x[-1]
<jfhbrook> jusss: in this case, *x means "all positional arguments of the lambda as a list"
*x 
>>> (lambda *x: x[-1])([1,2,3], 3, "a", [1,2])
[1, 2]
function objectfunction's name, function's name()
function call, lambda()

objectobject,object?
functionobject,function?
--------------------------------------------------------------------------------
what is **?  **ddkey=value
d={"a":"b", "b":"c"}
**da="b",b="c"
>>> d={"a":"b", "b":"c"}
>>> def f(a,b):
	print(a)
	print(b)

	
>>> f(**d)
b
c
--------------------------------------------------------------------------------
scheme's alist, cl's plist, python's dict

>>> a="b"
>>> b="c"
>>> c={a:b}
>>> c[a]
'c'
--------------------------------------------------------------------------------
switch case in python, instead of if else
>>> def ice():
	print('ice')

	
>>> def water():
	print('water')

	
>>> ice()
ice
>>> water()
water
>>> a_dict={'ice':ice, 'water':water}
>>> a_dict['ice']()
ice
--------------------------------------------------------------------------------

1 2 3  4 5  6 7

12 3 4 5 6 723 4 5 6 7  67

1.
2.

(define remove-same-element
  (lambda (alist reducelist newlist)
  	  (if (eq? '() (cdr reducelist))
	      (if (eq? (car alist) (car reduceist))
	      	  (remove-same-element (car alist
  	  (if (eq? (car alist) (car reducelist))
	      (remove-same-element (cdr alist) (cdr reducelist) newlist)
	      (remove-same-element alist (cdr reducelist) newlist)




(define (f1 x1 alist)
  (let ((counter 0))
    (define (f2 x2 alist2)
      (if (null? alist2)
	  counter
	  (if (eq? x2 (car alist2))
	      (set! counter (+ counter 1))
	      (f2 x2 (cdr alist2)))))
    (f2 x1 alist)))


(define a-single-atom is 3)
(map (let ((count 0))
     	  (lambda (atom)
	  	  (if (eq? a-single-atom atom)
		      (set! count (+ count 1))
		      count)))
     '(1 2 3))


dot pair in lisp
(cons 1 2) => (1 . 2)
(cons 1 '()) => (1)
(cons 3 (cons 2 1)) => (3 2 . 1) == (3 . (2 . 1))
(cons '() (2 . 1)) => (2 1)
(3) is (3.())

python, dot pair like [1 [2 [3]]]

(define (map f alist)
	(if (null? alist)
	    '()
	    (cons (f (car alist)) 
	    	  (map f (cdr alist)))))

Don't use null!!! in case (() ())  if you (cdr '(() ())) get (())
(cdr '(())) get (), they both are null!!!
but (()) is (().())
and (() ()) is (() ().())

(define (map f alist)
	(if (eq? alist '())
	    '()
	    (cons (f (car alist))
	    	  (map f (cdr alist)))))


(define remove-empty-list
  (lambda (alist)
    (if (eq? alist '())
	'()
	(if (eq? (car alist) '())
	    (remove-empty-list (cdr alist))
	    (cons (car alist) (remove-empty-list (cdr alist)))))))

(map (lambda (x)
       (if (> (apply + (map (lambda (y)
			       (if (eq? x y) 1 0))
			     alist))
	      1) '() x))
     alist)

(define remove-same-element
  (lambda (alist)
  	  (remove-empty-list
		(map (lambda (x)
		       (if (> (apply + (map (lambda (y)
		       	      	     	       (if (eq? x y) 1 0))
					     alist))
	                    1) '() x))
	             alist))))

(define get-max-value
  (lambda (alist max)
    ;max is (car alist) at the first time
    (if (eq? alist '())
	max
	(if (> (car alist) max)
	    (get-max-value (cdr alist) (car alist))
	    (get-max-value (cdr alist) max)))))

(define alist '(1 2 3 3 5 9 7 7))
> (get-max-value (remove-same-element alist) (car alist))
9

the cons will make a dot pair until alist become an empty list,
then turn the dot pair into a list through it return an empty list '()

emacs 26.1 on windwos 7, M-x package-list-packages ; M-x package-refresh-contents
M-x package-install racket-mode
install and download racket for windows, then put the installed path into environment variable "The Path" on windows 7
then you can open a new.rkt file and press C-c C-z or F5 call rakcet repl out
don't forget put #lang racket on the top of file
if you use emacs 24.3, then racket-mode warn it needs emacs support :nowait, and
that feature is in emacs 25 and after

M-x package-list-packages; if it tips press U to make some elpa packages for upgrading,
then press U make them, and press x upgrading them

racket-mode, python-mode, auto-complete

in python-mode, C-c C-c will eval current line
in racket-mode, F5 will eval entire file, don't forget set system's environment "PATH" point to python or racket installed path

auto-complete, company-mode, M-/

auto-complete for html
M-x package-install auto-complete  slime cl-lib ac-slime
https://stackoverflow.com/questions/8095715/emacs-auto-complete-mode-at-startup
(require 'ac-slime)
(setq ac-modes '(racket-mode python-mode html-mode web-mode slime-mode))
(ac-config-default)
(defun auto-complete-mode-maybe ()
  "No maybe for you. Only AC!"
  (auto-complete-mode 1))
(add-hook 'slime-mode-hook 'set-up-slime-ac)
 (add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
 (eval-after-load "auto-complete"
   '(add-to-list 'ac-modes 'slime-repl-mode))
ac-slime should now automatically be enabled when you visit a buffer in which slime-mode is active and auto-complete is enabled

-----------------------------------------------------------------------
M-x package-list-packages
M-x package-refresh-contents
M-x package-install auto-complete  slime  cl-clib  and ac-slime
reference: https://github.com/purcell/ac-slime

wrote this into ~/.emacs
(require 'ac-slime)

(setq ac-modes '(scheme-mode c++-mode sql-mode racket-mode python-mode html-mode web-mode slime-mode js-mode javascript-mode))
(ac-config-default)
(add-hook 'slime-mode-hook 'set-up-slime-ac)
(add-hook 'slime-repl-mode-hook 'set-up-slime-ac)
(eval-after-load "auto-complete"
 '(add-to-list 'ac-modes 'slime-repl-mode))

important! (setq ac-modes '(js-mode javascript-mode html-mode)) if you don't set
this variable, then you cann't enable auto-complete-mode in js file buffer
aha, maybe you should use (add-to-list 'ac-modes 'javascript-mode) is better!

ac-slime should now automatically be enabled when you visit a buffer in which slime-mode is active and auto-complete is enabled. (The symbols "Slime" and "AC" should appear in the modeline.)

enable slime-mode and auto-complete in javascript buffer and ac-slime will be enabled

put html-mode into ac-modes list, I guess if html-mode is enabled, auto-complete will auto be enabled

I think you can do it in various ways. To enable it globally you should use
(global-auto-complete-mode t)
But it uses auto-complete-mode-maybe, which turn AC on only those listed in ac-modes. You can add them manually just like this
(add-to-list 'ac-modes 'sql-mode)
You can make your own list if you wish AC be active only for few modes
(setq ac-modes '(c++-mode sql-mode))
Or rewrite it to have AC everywhere.
(defun auto-complete-mode-maybe ()
  "No maybe for you. Only AC!"
  (auto-complete-mode 1))
https://stackoverflow.com/questions/8095715/emacs-auto-complete-mode-at-startup

CHOPIN - NOCTURNE NO.20 IN C-SHARP MINOR OP.POSTH
Beethoven Silence

--------------------------------------------------------------------------------
FUCK! turn out you just need auto-complete will be fine!
just append the mode which you want auto complete into ac-modes list!
auto-complete will do that for you! nothing else need!
(require 'auto-complete)
;(setq ac-modes '(scheme-mode c++-mode sql-mode racket-mode python-mode html-mode web-mode slime-mode js-mode javascript-mode))
(add-to-list 'ac-modes 'javascript-mode) 
(add-to-list 'ac-modes 'html-mode)
(add-to-list 'ac-modes 'python-mode)
(add-to-list 'ac-modes 'slime-mode)
(add-to-list 'ac-modes 'scheme-mode)
(add-to-list 'ac-modes 'css-mode)
(ac-config-default)
--------------------------------------------------------------
emacs 24.3 on windows 7 is really smooth, 25 and 26 are not
-------------------------------------------------------
changing the default directory that  emacs will open when press C-x C-f
Update: There are three solutions to the problem that I found to work, however I believe solution 3 is Windows only.

    Solution 1: Add (cd "C:/Users/Name/Desktop") to the .emacs file

    Solution 2: Add (setq default-directory "C:/Documents and Settings/USER_NAME/Desktop/") to the .emacs file

    Solution 3: Right click the Emacs short cut, hit properties and change the start in field to the desired directory.

decorator
<jusss> yunfan: pythondecorator
								        [10:43]

<yunfan> funca, b  wrapper(func)(a, b)


---------------------------------------------------------
Tkinter has been renamed to tkinter in Python 3. The 2to3 tool will automatically adapt imports when converting your sources to Python 3.
import Tkinter
Or, more often:
from Tkinter import *


---------------------------------------------------------------------------
pythonself.var
self.


class

classself, 

classclass,

classself,

:  
:  
self,.  
---------------------------------------------------------------------------------
co-routines, asyncio, asyinc/wait, promise/future, continuation, green-thread, twisted-python

if __main__ = name
When the Python interpreter reads a source file, it executes all of the code found in it.

Before executing the code, it will define a few special variables. For example, if the Python interpreter is running that module (the source file) as the main program, it sets the special __name__ variable to have a value "__main__". If this file is being imported from another module, __name__ will be set to the module's name.


return yield 
----------------------------------------------------------------------

def a(var):
	def b():
		print("hello")
	
	
	def setq(x):
		name["c"]=x
	def add(nam):
		name["nam"]=nam
	name={"b":b,"c":1,"setq":setq,"add":add}
	return name[var]

def f(x):
	if x=="name":
		return "f"

<jusss> yunfan: 

 def a(var):
	def b():
		print("hello")
	
	
	def setq(na,va):
		name[name.index(na) +1]=va
		
		return name
	def add(nam):
		name[nam.__name__]=nam
	name=["b",b,"setq",setq,"add",add,"c",1]
	return name[name.index(var) +1]

 def a(var):
	def b():
		print("hello")
	
	
	def setq(na,va):
		global name
		name.append(na)
		name.append(va)
		return a
		
	def add(nam):
		global name
		name[nam.__name__]=nam
	global name
	name=["b",b,"setq",setq,"add",add]
	return name[name.index(var) +1]

---------------------------------------------
success!
def a(var):
	def b():
		print("hello")
	
	
	def setq(na,va):
		global name
		name[na]=va
		return a
		
	def add(nam):
		global name
		name[nam.__name__]=nam
	global name
	name["b"]=b
	name["setq"]=setq
	name["add"]=add
	return name[var]

name={}
a("setq")("c",9)
------------------------------
def a(var):
	name={}
	def b():
		print("hello")
	
	
	def setq(na,va):
		nonlocal name
		name[na]=va
		return a
		
	def add(nam):
		nonlocal name
		name[nam.__name__]=nam
	
	name["b"]=b
	name["setq"]=setq
	name["add"]=add
	return name[var]
-----------------------------------------------------------------
wonderful!  https://repl.it/repls/OutlyingPalegreenLesson

def f():
  name = {}
  def b():
    print("b")

  def setq(na,x):
    name[na] = x
    return name

  def add(x):
    name[x.__name__] = x
    return x

  name.update({
    "b": b,
    "c": 1,
    "setq": setq,
    "add": add
  })

  return name

fuck = f()

result = fuck["setq"]("d",9)
print(result)
print(fuck["d"])
print(fuck)

def p():
  print("hello")
z=fuck["add"](p)
z()
print(fuck)
------------------------------------------------------------
https://repl.it/repls/CrookedDistinctLamp
def f(name):
  def set_name(k):
    attr["a"] = k(attr["a"])
    return attr

  attr = {
    "a": 1,
    "set": set_name
  }

  return attr[name]

result = f("set")(lambda x: x + 1)
print(result)

<jusss> eiGHttt:   attr["a"] = k(attr["a"]) f("set")(lambda
	...) k(lambda ...) k1?a?
<jusss> eiGHttt: alambda
-------------------------------------------------------------------
WONDERFUL!
def f():
  name = {}
  def b():
    print("b")

  def setq(na,x):
    name[na] = x
    return name

  def add_method(x):
    name[x.__name__] = x
    return name

  name.update({
    "b": b,
    "c": 1,
    "setq": setq,
    "add_method": add_method
  })

  return name
fuck = f()
def p():
  print("world")
fuck["add_method"](p)
fuck["p"]()
fuck["setq"]("c",9)
print(fuck["c"])
z=fuck["add_method"](p)
z["p"]()
----------------------------------------------------------------------





def f():
  name = {}
  def b():
    print("b")

  def setq(na,x):
    name[na] = x
    return name

  def add_method(x):
    name[x.__name__] = x
    return name

  """
  name.update({
    "b": b,
    "c": 1,
    "setq": setq,
    "add_method": add_method
  })
  """
  name["b"]=b
  name["setq"]=setq
  name["add_method"]=add_method
  name["c"]=1
  return name

fuck = f()
def p():
  print("world")
fuck["add_method"](p)
fuck["p"]()
fuck["setq"]("c",9)
print(fuck["c"])
z=fuck["add_method"](p)
z["p"]()
z["setq"]("c",3)
print(fuck["c"])
print(z["c"])
-------------------------------------------------------
def f(name):
  def set_name(k):
    attr["a"] = k(attr["a"])
    return attr

  attr = {
    "a": 1,
    "set": set_name
  }

  return attr[name]

result = f("set")(lambda x: x + 1)
print(result) 
lambdalambda
----------------------------------------------------

import socket, os, string, time, sys, ssl
from threading import Thread
from Tkinter import *

def network_connect(t):
    show_area=t
    name={}

    def connect_init():
        try:
            name['sock'].connect((name['server_addr'],name['port']))
        except Exception as e:
            print(e)
            time.sleep(10)
            name.update({
                'sock':ssl.wrap_socket(socket.socket(socket.AF_INET,socket.SOCK_STREAM))})
            connect_init()
        name['sock'].send(('NICK '+name['nick']+'\r\n').encode('utf-8'))
        name['sock'].send(('USER '+name['username']+' 8 * :'+name['realname']+'\r\n').encode('utf-8'))
        name['sock'].send(('JOIN '+name['channel']+'\r\n').encode('utf-8'))

    def make_up_data(a_str):
        ":nick!~2ac8711f@unaffiliated/username PRIVMSG #channel :words"
        if (a_str.find(":",0) != -1 and a_str.find("!",1) != -1 and a_str.find(":",1) != -1 and a_str.find("PRIVMSG",1) != -1):
            return("<" + a_str[1:a_str.find("!",1)] + ">: "
                   + a_str[a_str.find(":",1)+1:])
        else:
            return a_str

    def recv_from_server():
        while True:
            try:
                recv_msg=name['sock'].recv(1024)
            except Exception as e:
                print(e)
                name['sock'].close()
                name.update({
                'sock':ssl.wrap_socket(socket.socket(socket.AF_INET,socket.SOCK_STREAM))})
                connect_init()
            recv_msg=recv_msg.decode('utf-8')
            # make it read only
            show_area.configure(state='normal')
            # PING PONG
            if recv_msg.find("PING :",0) != -1:
                name['sock'].send(recv_msg.replace("PING","PONG").encode('utf-8'))
            else:
                if (recv_msg.find(name['nick']) != -1) and ((recv_msg.find("PRIVMSG") != -1)
                                                    or
                                                    (recv_msg.find("NOTICE") != -1)):
                    show_area.insert(END,make_up_data(recv_msg),'highlight')
                else:
                    show_area.insert(END,make_up_data(recv_msg))
            show_area.configure(state='disabled')
            show_area.see(END)   # autoscroll bar to end


    def recv_from_keyboard(event=None):
        msg=my_msg.get()
        my_msg.set("")
        if msg.find("/",0) != -1:
            name['sock'].send((msg[1:]+"\r\n").encode('utf-8'))
        else:
            #make it read only
            show_area.configure(state='normal')
            show_area.insert(END,"<"+name['nick']+">: "+msg+ "\r\n")
            show_area.configure(state='disabled')
            show_area.see(END)
            msg='PRIVMSG '+name['channel']+' :'+msg+'\r\n'
            name['sock'].send(msg.encode('utf-8'))
    name.update({
        'server_addr':'irc.freenode.net',
        'port':7000,
        'nick':'jussssss',
        'username':'xxxxx',
        'realname':'xxxxx',
        'channel':'#linuxba',
        'sock':ssl.wrap_socket(socket.socket(socket.AF_INET,socket.SOCK_STREAM)),
        'connect_init':connect_init,
        'make_up_data':make_up_data,
        'recv_from_server':recv_from_server,
        'recv_from_keyboard':recv_from_keyboard
    })
    return name


if __name__ == '__main__':

    top_window = Tk()
    show_area=Text(top_window,height=30,width=70)
    # highlight
    show_area.tag_configure("highlight",foreground="red")
    show_area.pack(anchor=NW,expand=True,fill='both')
    whatever = network_connect(show_area)

    top_window.title("Chat")
    #top_window.geometry("650x500")
    my_msg = StringVar()  # For the messages to be sent.
    my_msg.set("")
    input_area=Entry(top_window,width=70,textvariable=my_msg)
    input_area.bind("<Return>",whatever['recv_from_keyboard'])
    input_area.pack(anchor="sw",expand=True,fill="x")
    whatever['connect_init']()
    rt=Thread(target=whatever['recv_from_server'])
    rt.start()
    top_window.mainloop()



name
steqadddo whatever you want

-------------------------------------------------------------------------
>>> a=3
>>> def b():
...    a=9
...    print(a)
...
>>> a
3
>>> b()
9
>>> a
3
>>> c={"a":3}
>>> def d():
...   c["a"]=9
...
>>> d()
>>> c
{'a': 9}

inner
----------------------------------------------------------------
emacs 26.1 or 25 24windowsC-v

(setq inhibit-compacting-font-caches t)
(set-face-attribute 'default nil :family "SimSun" :height 100)
http://emacs.1067599.n8.nabble.com/bug-25148-25-1-Slow-scrolling-with-emacs-25-1-and-Windows-10-td415225.html
------------------------------------------------------------------
emacs24modepython, python.el, package-installpython-mode.el
windows7emacs2426,python.elC-c C-ctk codebuffer,tk,
C-c C-c*Messages*Set: from Tkinter import *...*Python*repl
tkcodearchlinuxemacs
ubuntuemacsubuntuemacsC-c C-ctkubuntu bionic lts
------------------------------------------------------------------------------------------------
in python 2.7, string is bytes string, not unicode, and unicode is not an encoding
but in python 3, string is unicode

2.7 "abc"str"abc"bytes string'\xa\xb\xc'bytes string
python 3k"abc"unicodebytes string,"abc".encode('utf-8')bytes string
unicodeutf-8
python 2.7socket.send(str)bytes string,str,
python 3ksocket.send(str.encode())

tkinterEntry widgetunicodesocket.send()
------------------------------------------------------------------------------------


def all():
  def a():
    print('hello')
  return lambda x: eval(x)

c=all()
c("a()")

name 'a' is not defined

def all():
    def a():
        print('hello')
    def b():
        print('world')
    return {a.__name__:a, b.__name__:b}

c=all()
c["a"]()

def bll(x):
    def a():
        print('h')
    def b():
        print('w')
    return {a.__name__:a, b.__name__:b}[x]
dd= bll("a")
dd()

def cll():
    def a():
        print('aha')
    def b():
        print('bla')
    def f(x):
        eval(x)
    return f
cc=cll()
cc("a()")
--------------------------------------------------------------

try:
	xxx
except:
	pass
-----------------------------------
def onIput_onStart(self,p):
    ...
    self.onStopped()
def onInput_onStop(self):
    self.onUnload()
    self.onStopped()
def onUnload(self):
    pass
def self.onStopped()
    pass

choregrapheonInput_onStartonInput_onStop
onStopped()onStopped__init__
onInput_onStartonStopped
onInput_onStoponUnloadonStopped

onUnloadonStoponInput_onStoponUnloadonStopped,onStoppedonStopped
onStartonInput_onStart
    ---------------------------------------------------

"everyting ends, that's always sad, but everything begins again
	too,and that's always happy"				        [14:12]
"be happy"
--------------------------------------------------
>>> def f(a):
	b=1
	print(eval(a))

	
>>> f("b")
1
>>> 
---------------------------------------------------------------
normal-order  and applicative-order

python lambda: f(x)pythonapplicative-order,lazy-evaluation
scheme(quote (f x))(f x)schemeapplicative-order


pythonfunctools.partial(f,x)
-----------------------------------------------------------
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
     s.connect((Host,Port))

conn, addr = s.accept()
with conn:
     while True:
     	   data = conn.recv(1024)
	   if not data:
	      break
	   conn.sendall(data)

python 2withwiths.close(), python3withsocket

--------------------------------------
<a> j: virtualenv creates isolated environments you can install libraries into.  And you can put that env wherever, such as in a writable directory :]
<altendky> jesse__: mostly, you should almost always use virtualenv or venv
	   (py3 only). Even on your desktop etc
<grym> jesse__: venv is.
<grym> jesse__: virtualenv is not.  confusingly, people abbreviate both the
       same :(
<altendky> jesse__: well, there's venv which is in python3
---------------------------------------------------------
twisted instead of socket
-------------------------------------

self.whatever = {"'stop":stop_all,
                         "'shutdown":self.system.shutdown,
                         "'reboot":self.system.reboot,
                         "'dance":(lambda self.behaviorName="bz10004_hungarian_dance_v/.": self.bm.runBehavior(self.behaviorName))}
lambdaparameterassignment,argument,
lambda
lambdaparameterself.x

pythonfunctools.partial,
def int2(x, base=2):
  return int(x, base)

int2('1010101') => 85

int2 = functools.partial(int, base=2)        lambda: int(x,2)
int2('1010101') => 85
functools.partial
base=2argumentassignment,base


<jusss> functools.partial() is better than lambda form?		        [11:07]
<altendky> jusss: lambda can 'throw away' parameters, partial can't.  partial
	   nicely expresses specifying some parameters
<jusss> altendky: what you mean 'throw away'?
<jusss> they are not equivalent?
<altendky> jusss: `lambda x, y, *args, **kwargs: f(x, *args, **kwargs)`
	   doesn't pass `y` on to the wrapped `f`
<jusss> altendky: ok then
<jusss> 'throw away'
<altendky> jusss: there are cases where functools.partial and lambda can both
	   do the same thing.  but yes, they are very different tools
								        [11:13]

-----------------------------------------------------


applicative-order

lambda : [[var],[f var]][-1]
------------------------------------------
python2withsocket
python3withsocket
----------------------------
socket.close()
socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
before socket.bind()
https://stackoverflow.com/questions/6380057/python-binding-socket-address-already-in-use
-------------------------------------------------
help(Tkinter.Entry.grid)
-------------------------------------------------
def f(para, *args, **kwargs):
    print(kwargs)  dict** f(para, *a_tuple, **a_dict)
*args,2argstuple
**kwargs,name="John"kwargsdict


-----------------------------------------------
concurrency with processes, threads, and coroutines
module: subprocess, signal, threading, multiprocessing, asyncio, concurrent.futures


--------------------------------------------------
python Threading.Threadtarget
while True:
      if name['exit_signal']:
      	 return "end"
name['exit_signal']=False,True
----------------------------------------------------------------------------
a_list.remove('element')
a_list.append('element')

a_dict={'#linuxba':['onlylove','yunfan'], '#python':['abc','def']}
a_dict['#new']=['a','b']

for k,v in a_dict.items():
  if 'onlylove' in v:
     print k

[k for k,v in a_dict.items() if 'onlylove' in v]

3 in [1, 2, 3]  True
'a' in 'abc'  True
---------------------------------------------------------------------
poweroff or reboot in grub2

grub2 support `halt` or `reboot` in command line

edit /etc/grub.d/40_custom and add
menuentry "Reboot" {
reboot
}
then run sudo update-grub.
---------------------------------------------------
python's socketreadlinereadlines
event-loop socket buffering  twisted trio
 "ab\r\nc\d\r\n".split("\r\n")
---------------------------------------------
[i for i in a if 'a' in i]				        [09:49]
<jusss> [print(i) for i in a if 'a' in i]
<jusss> why the first one works fine, and the seconds got error?

<aeyxa> print isn't a function in 2.7
<aeyxa> so you can't use it in list comprehension		        [09:52]

list comprehensionexpressionstatement

[3 for i in a if 'a' in i] 

>>> a_str=':Liuyan!what PRIVMSG #linuxba : haha'
>>> hash_tag = [i if '#' in i else False for i in a_str.split(' ')][0]
>>> hash_tag
False
>>> [i if '#' in i for i in a_str.split(' ')]
SyntaxError: invalid syntax
>>> [i for i in a_str.split(' ') if '#' in i]
['#linuxba']
>>> [i if '#' in i else False for i in a_str.split(' ')]
[False, False, '#linuxba', False, False]

1. list comprehensionif elseforiffor
2. if else


group = re.match(data).group(1) if re.match(data) else None

_data= [y for x in data if (x) as y is not None]
data= [y for x in data if (y:=f(x)) is not None]

if (match:=pattern.search(data) is not None:

match=pattern.search(data)
if match is not None:

if ae:=[i for i in ['abc','def'] if 'a' in i]
   print(ae[0])

if ae is [], bool(ae) will be False, so print(ae[0]) won't execute

python doesn't provide list.replace() but it can be with list comprehension

<_habnabit> jusss, ['c' if x == 'a' else x for x in mylist]


>>> c
{}
>>> def g():
	for k,v in c.items():
		if '#lin' == k:
			c['#lin'] = c['#lin'] + 'ux'
		else:
			c['#lin'] = 'c'

			
>>> g()
>>> c
{}
>>> 

because c.items() is [], for k,v in []: won't execute, so g() won't create elements in dict c,
just give c one element, for-statement will execute, for-statement must need one element to iterate,
otherwise it won't execute

for i in alist:
  if m in i:
     do something
  else:
	do something

else:
for-statementelse,if

list comprehension,dict comprehension
>>> c
{'a': 'b', '#lin': 'c'}
{k:v for (k,v) in c.items() if 'a' in k}
{'a': 'b'}

 'a' in c True or False

<Shirakawasuna> jusss, there is syntax that looks like a tuple comprehension,
		but it creates a generator
<Shirakawasuna> jusss, which doesn't execute until you iterate over it
<liste> tuple(x for y in z) :)

if " JOIN #" in a_str and ":" in a_str and "!" in a_str and (name['nick'] not in a_str):


<_habnabit> jusss, any('a' in thestring for thestring in thelist)
<aeyxa> jusss: any(['a' in x for x in ['abc', 'bcd', 'def']])

<altendky> jusss: ['low' if x < 42 else 'high' for x in [1, 53, 42, 30, 60]]
<altendky> jusss: the part before the `for` can be any expression

<altendky> jusss: don't work directly with the socket module.  don't implement
	   irc protocols yourself.  probably don't use tk but that's more on
	   the preference side, sort of.

<altendky> oh, and don't thread
<_habnabit> twisted integrates neatly with tk
<altendky> twisted also integrate with pyqt5
<jusss> _habnabit: altendky why python don't contain twisted in default
	packages even if python don't suggest handle socket directly
<jusss> and why not remove Threading and tkinter
<jusss> even it's not safe
<_habnabit> jusss, take your pick: 1) putting things in the stdlib is a bad
	    idea, 2) they did; they just rewrote it from scratch and called it
	    'asyncio'
<altendky> jusss: well, they do have asyncio now.  but i personally don't feel
	   a need for everything to be in stdlib.  stuff in stdlib often gets
	   used simply because that's what is there, not because it is what is
	   good.
<altendky> jusss: as to threads, they have their hazards and in other
	   languages that may be worthwhile due to the extra cpu time you get.
	   you don't get extra cpu time from threads for python code though,
	   so...  whatever, little upside.  and async is fairly mature for
	   many things.
<jusss> and yet lots of development still in python 2.7
<altendky> jusss: true, they aren't adding significant features to py2.  start
	   new stuff in py3					        [10:37]
<energizer> craftyguy: what functinoality do you want
<altendky> jusss: or, use twisted

<altendky> jusss: once something gets into stdlib it's stuck on a 18 month or
	   whatever release cycle.  it's stuck on massive backward
	   compatibility and never can be removed.  and people start using it
	   because of where it is rather than based on merit.  *shrug*  it's
	   handy to have stuff in stdlib but there's a cost as well
-------------------------------------------
c=':ab c :d'
c.split(':') => ['','ab c','d']
c.plit(':').remove('') won't work
d=c.split(':')
d.remove('') => ['ab c','d'] work    weird
[s for s in c.split(":") if len(s)>0]

'abcad'.strip('a') => 'bcad'
------------------------------------------------
>>> if [3]:
	print 'hi'
hi
>>> if []:
	print 'hi'

>>> bool([])
False
>>> bool([3])
True
>>> 

<whateveryouwant> [] is not False, neither True
<ChrisWarrick> whateveryouwant: because it is not a boolean value
<ChrisWarrick> whateveryouwant: the `is` operator checks identity, avoid it in
	       most cases.  The == operator checks equality, and a boolean
	       value False is not equal to an empty list.
<ChrisWarrick> whateveryouwant: if []:  does not mean if [] == True.  It
	       checks bool([]).
<iivvoo> if you want to be more explicit, you could if len(x) == 0: ...
<iivvoo> whateveryouwant: just `if value:` - value will be evaluated in a
	 boolean context
-------------------------------------------------------
dl=[]
def f():
  dl.append(3)
def f2():
  dl=[]

f() dl => [3]
f2() dl => [3] why f2 don't clear dl?
-------------------------------------------------------
python 3kf-strings,ruby
python 2format 'abc{0} cd{1}'.format(variable-a,variable-b)
------------------------------------------------------------------------------
Microsoft Speech To Text REST API:

import requests
def saf():
    with open('/home/jesse/Downloads/a.wav', 'rb') as f:
        while 1:
            data=f.read(1024)
            if not data:
                break
            yield data
 
headers = {
    'Transfer-Encoding': 'chunked',
    'Ocp-Apim-Subscription-Key': '',
    'Content-type': 'audio/wav; codec=audio/pcm; samplerate=16000'
    
}
 
response = requests.post('https://speech.platform.bing.com/speech/recognition/interactive/cognitiveservices/v1?language=zh-CN&format=detailed', headers=headers,  data=saf())
 
print(response.content)

----------------
 final_result = json.loads(response.content)['NBest'][0]['Display']
        self.tts.say(final_result)

------------------------------------------------------------------------------------
jesse@cube:~/Downloads$ cat STT.sh
#!/bin/bash
curl -v -X POST "https://speech.platform.bing.com/speech/recognition/interactive/cognitiveservices/v1?language=zh-CN&format=detailed" -H "Transfer-Encoding: chunked" -H "Ocp-Apim-Subscription-Key: " -H "Content-type: audio/wav; codec=audio/pcm; samplerate=16000" --data-binary @whatsday.wav
--------------------------------------------------------------------------------------------------
'Transfer-Encoding': 'chunked' data=saf(), saf()binary data,
reference; https://www.taygan.co/blog/2018/02/09/getting-started-with-speech-to-text
https://curl.trillworks.com/
-----------------------------------------------------------------------------
the keyword 'is' in python is not equal '=='
<SnoopJeDi> `is` tests identity, `==` tests equality. They aren't the same concept.
<KirkMcDonald> jusss: 'is' tests whether two things refer to the same object.
<_habnabit> jusss, 'is' is only used for 'x is None'		        [09:26]
<SnoopJeDi> jusss, "is exactly the same object"
<cluelessperson> jusss: == means equal value;  is tests if it identifies as the same object
<SnoopJeDi> you rarely ever need to use `is`
<cluelessperson> does "is" test if it's the same Type?
<cluelessperson> if a is True;
<_habnabit> cluelessperson, implicitly
<KirkMcDonald> cluelessperson: The same *object*.
<cluelessperson> KirkMcDonald: so,  a=True;  is the same object as a b=True;
<_habnabit> cluelessperson, the same object must necessarily be the same type
<KirkMcDonald> It is both possible for 'a is b' to be False while 'a == b'
	       returns True, and vice versa.
<jusss> so what 'is' is used for?
<_habnabit> jusss, 'a is None'
<_habnabit> jusss, that is the only example
<jusss> _habnabit: ok
<jusss> you guys create a keyword and only use it for one situation :)
<_habnabit> jusss, yes, python has some pretty bad ideas in it
<jusss> _habnabit: is there other keyword for instead of '==' ?
<_habnabit> jusss, no
<jusss> but I tried it in python2.7, a='s'; a is 's' will return a True
<_habnabit> jusss, that will give you a random value which may or may not be
	    true
<jusss> _habnabit: ok
<SnoopJeDi> jusss, the simple version is that you should use == when you mean
	    ==, which is always
<KirkMcDonald> jennie: 'is' is basically meaningless when applied to immutable
	       objects.
>>> [1,2,3] is [1,2,3]
False
<SnoopJeDi> jusss, if you want a preview of why `is` will mislead you, try
	    `[1,2,3] is [1,2,3]`
<jusss> SnoopJeDi: wow, it is False
<SnoopJeDi> jusss, because when evaluating that statement, Python creates
	    *two* list objects which are NOT the same object.	        [09:46]
<jusss> KirkMcDonald: what is immutable objects? you mean strings?
<SnoopJeDi> They *are* equal, though, so `[1,2,3] == [1,2,3]`
<Jonno_FTW> why are you so concerned about the behaviour of `is`? It only
	    returns when two things point to the same memory. Of course it's
	    going to give odd behaviour in edge cases
<KirkMcDonald> jusss: Strings, integers, and others.
<SnoopJeDi> jusss, "mutable" means something that can change. Immutable means
	    the opposite.
<Jonno_FTW> some things get interned and will always point to the same memory,
	    for everything else you probably want ==
<SnoopJeDi> Jonno_FTW, the point is that you can't count on `is`
<Jonno_FTW> SnoopJeDi: this is well known
<SnoopJeDi> Jonno_FTW, not to beginners
<jusss> ok							        [09:48]
<SnoopJeDi> hence...the reason this conversation is happening
<Jonno_FTW> SnoopJeDi: right, the recommendation I read was that you only use
	    `is None` and that's it. There's rarely a usecase

--------------------------------------------------------------------------------

<jusss> use dict to implement switch, there's a problem, what if the
	'condition' isn't in the 'key'?
<altendky> jusss: .get() to specify a default?
<jusss> altendky: more details?
<jusss> altendky: eg, c={'a':'b'}, c['d'] will keyerror		        [10:08]
<altendky> jusss: sure, i said .get()
<altendky> jusss: `{'option a': the_first_function, 'option b':
	   the_second_function}.get('but i want something else',
	   too_bad_try_again_function)`
<jusss> altendky: wow, I see

get(...)
   D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.

---------------------------------------------------------------------
<jusss> can I use if-else in function's parameters? like f(x if a=3 else b) ?
								        [13:15]
<_habnabit> jusss, `a=3` isn't an expression
<jusss> _habnabit: then a==3
<_habnabit> jusss, then yes					        [13:16]
<jusss> _habnabit: wonderful_
*** dxiri (~dxiri@186.32.223.123) has joined channel #python
<jusss> _habnabit: I can use if-else in anywhere I want? 
<_habnabit> jusss, sure
<jusss> where I can't use it					        [13:17]
<_habnabit> jusss, an import statement
<ironfroggy> why can docstrings not be f-strings?
<jusss> _habnabit: ok
<jusss> but I tried it in python2.7, a='s'; a is 's' will return a True
<_habnabit> jusss, that will give you a random value which may or may not be
	    true
<KirkMcDonald> jennie: 'is' is basically meaningless when applied to immutable
	       objects.
<SnoopJeDi> jusss, the simple version is that you should use == when you mean
	    ==, which is always
<SnoopJeDi> jusss, if you want a preview of why `is` will mislead you, try
	    `[1,2,3] is [1,2,3]`
<jusss> SnoopJeDi: wow, it is False
<SnoopJeDi> jusss, because when evaluating that statement, Python creates
	    *two* list objects which are NOT the same object.	        [09:46]
<jusss> KirkMcDonald: what is immutable objects? you mean strings?
<SnoopJeDi> They *are* equal, though, so `[1,2,3] == [1,2,3]`
<Jonno_FTW> why are you so concerned about the behaviour of `is`? It only
	    returns when two things point to the same memory. Of course it's
	    going to give odd behaviour in edge cases
*** tomvolek (~tomvolek@2601:647:4201:97a0:15f8:7129:f46a:6c8) has joined
    channel #python
<KirkMcDonald> jusss: Strings, integers, and others.
*** Blue_Hat (~alciann@72.27.185.6) has joined channel #python
<SnoopJeDi> jusss, "mutable" means something that can change. Immutable means
	    the opposite.
<jusss> if-else is statement or expression?
<KirkMcDonald> jusss: Python has both.				        [13:26]
<jusss> and put statements in the position of parameters of functions, that's
	right?
<KirkMcDonald> jusss: There is an if statement, and there is a conditional
	       expression.

<jusss> KirkMcDonald: so can I use statement as parameter in function?
<jusss> I suppose it only support expressions
<KirkMcDonald> jusss: Yeah. Function arguments are expressions.
<jusss> in list comprehension, if there's only if statement ,you must put it
	front of 'for' statement, if it's if-else then put it behind the
	'for'
<jusss> KirkMcDonald: that means I can use if-else as parameter, but I can't
	use if-statement as parameter, and if-else is expression, if is just a
	statement, am I correct?				        [13:32]
<SnoopJeDi> jusss, no
<KirkMcDonald> More or less. Note that the 'if' clause of a list comprehension
	       is a third, different thing.			        [13:33]
<SnoopJeDi> yea, it's easiest to just think of them as separate things
	    entirely.
<astronavt> it's basically SQL SELCT or LINQ
<jusss> I'm fused						        [13:35]
<jusss> confused
<astronavt> [ <expression> for <variables> in <iterable> if <conditional> ]
								        [13:36]
<jusss> one by one, can I use statement as paramter?
<jusss> [expression if-else for ...]
<astronavt> oh i was talking about list comprehensions
<astronavt> ohh
<jusss> [expression for ... if without else]
<SnoopJeDi> jusss, the grammar of Python is here:
	    https://docs.python.org/3/reference/grammar.html Notice that
	    `if_stmt` describes the valid form of a conditional block, but
	    'if' also appears in several over valid contexts.
<astronavt> yeah those are 2 different things
<SnoopJeDi> they're just completely different things that happen to share
	    tokens
<astronavt> 'a if b then c' is just Python syntax for a conditional operator
<astronavt> jusss so that 'a if b else c' is a standalone thing
<astronavt> that can occur just about anywhere and it has nothing to do with
	    list comprehensions
<jusss> so I'm wonder f(x=3)   so that means I can use statement as parameter?
*** lbalhar (~lbalhar@93.185.13.26) has joined channel #python	        [13:39]
<astronavt> not in general, no
<_habnabit> jusss, x=3 isn't a statement there
<astronavt> f(x=while True: break)
<_habnabit> jusss, it doesn't do assignment
<jusss> confused again						        [13:40]
<SnoopJeDi> jusss, even if you can do something like that, it's harder to read
	    vs. just writing out the if-statement
<SnoopJeDi> usually before the call
<astronavt> jusss no you cannot use a statement as a function parameter, and
	    it wouldn't make sense if you could
<astronavt> can you give an example of a statement that you would like to use
	    as a function parameter
<jusss> I don't know, I though x=3 is a statemnt and if-else is a statement
	too, now you tell me they're not			        [13:41]
*** fprstn (~miller@62.241.196.200) has joined channel #python
<_habnabit> jusss, confusingly, they're both
<astronavt> x=3 is not a statement in that context
<astronavt> neither is the conditional expression 'a if b else c'
<jusss> so 'x=3' as parameter, it's not a statement , and what it is?
<jusss> an expression?
<_habnabit> jusss, keyword argument
<astronavt> 'a if b else c' is special syntax for a conditional
	    operator. 'f(x=3)' is special syntax that binds the value '3' to
	    the function parameter 'x'
<jusss> and except statement and expression, what those 'keyword' and
	'operator' stuff are?
<jusss> I'm so confused about those concepts
<astronavt> jusss a "keyword argument" is "an argument that is bound by name,
	    not position"
<astronavt> in this case, f(x=3) means "bind to the argument named x" not
	    "bind to the argument in the first position"	        [13:45]
<astronavt> therefore "x" is a keyword argument here
<astronavt> whereas in f(3) you only have the first positional argument
<astronavt> jusss what other languages have you used? C?	        [13:46]
<jusss> astronavt: scheme
<astronavt> ah
<astronavt> jusss have you used common lisp? or just scheme
<jusss> astronavt: both
<astronavt> (f :x 3)						        [13:47]
<astronavt> or whatever the syntax is in CL
<astronavt> (f &key :x 3)
<astronavt> thats the one
<jusss> astronavt: I know that, but mostly I just use the old way like
	((lambda (x) ...) 3) 
<astronavt> ok. well f(x=3) is equivalent to (f &key :x 3)
<astronavt> an "operator" would just be a function that has special syntax
<astronavt> like in python "3 + 4" the "+" still acts like a function even
	    though it doesnt look like one
<astronavt> same for 'a if b else c'
<jusss> astronavt: a:b is true?c				        [13:50]
<jusss> kind of?
<deniska> `a if b else c` is fundamentally not a function
<jusss> I forget it
<astronavt> jusss yeah its like 'a ? b : c'
<astronavt> deniska it is mathematically!			        [13:51]
<astronavt> jusss ack i messed up the order. its 'b ? a : c'
<deniska> astronavt: yeah, but in python it only evaluates an operand which is
	  needed
<jusss> astronavt: I don't know that either
<astronavt> deniska true
<deniska> I don't know the broader context of a discussion, just picking on
	  technically wrong things, like people on irc do :)
<astronavt> jusss its common in C-flavored languages		        [13:52]
<jusss> astronavt: yeah, it is a operator
<jusss> an
<astronavt> (f &key :x (if a b c))  <==>  f(x=a if b else c)
<astronavt> (f &key :x (if a b c))  <==>  f(x=b if a else c)
<astronavt> scratch the first one... kinda tired
<jusss> operator not are fucntions? that's right?		        [13:53]
<jusss> a special syntax?
<astronavt> mathematically they are, from python's perspective they can be
	    anything
<jusss> a special syntax created by functions?
<astronavt> not necessarily created by...			        [13:54]
<deniska> well, some operators in python are a special way of calling
	  functions, some operators are, well, operators
<astronavt> Wikipedia to the rescue				        [13:55]
<astronavt> "Programming languages typically support a set of operators:
	    constructs which behave generally like functions, but which differ
	    syntactically or semantically from usual functions."
<jusss> a + b, what is the function ways? add(a,b)?
<jusss> why not +(a,b) ?
<deniska> jusss: a.__add__(b)
<jusss> oh yeah, OOP
<deniska> well, it's what python actually does :)
<astronavt> jusss i have never seen someone so steeped in lisp as you   [13:56]
*** lifeai (~lifeand@80.240.20.120) has joined channel #python
<astronavt> im kind of impressed
<jusss> astronavt: just lambdas
<deniska> in lisp + is just an ordinary function		        [13:57]
<thebigj> I am trying to auto fix pep8 errors. I am using autopep8 for that.
<jusss> astronavt: I'm so loving those without many symbols language, it is
	simple and plain
<jusss> just functions
<jusss> and return tings
<astronavt> jusss understandable
<jusss> things
<astronavt> jusss its written "a + b" and not "+(a, b)" because when people
	    write regular math they write "a + b"
<astronavt> and because most programming languages already did it that way :)
<jusss> astronavt: yeah, I thought it would be (+ a b)
<jusss> :)							        [13:59]
<jusss> everything keeps in a list
<jusss> or a dotted pair
<astronavt> jusss sadly python code is not so easily represented as data
<astronavt> but most python objects are based around associative arrays
	    internally (i.e. hash tables, i.e. dicts)
<astronavt> i think the only exceptions are basic built-in types
<jusss> astronavt: speak of hash tables, now I have a question	        [14:04]
<astronavt> but im probably wrong on some aspect of that
*** libertyprime (~libertypr@uo-uod-student-04.nat.otago.ac.nz) has quit: Ping
    timeout: 244 seconds					        [14:05]
<astronavt> jusss whats the question
*** EdJoJob (~EdJoJob@203.41.122.242) has quit: Ping timeout: 252 seconds
*** XCE (~XCE@2601:646:8a01:4720:4d60:85a3:3ecf:3ca1) has joined channel
    #python
<jusss> astronavt: https://paste.ubuntu.com/p/k26KMpHVSv/
<astronavt> jusss a list is not "hashable", therefore it can't be used as the
	    key in a dictionary
<astronavt> what are you trying to do with that line?
<jusss> astronavt: you see I store functions as value in dict, and I want run
	that functions
<jusss> astronavt: like c={'a':f} then c['a']()
<jusss> astronavt: use dict to avoid if-else
<astronavt> jusss are you trying to run each function in sequence?
<astronavt> oh
<jusss> astronavt: not run each fucntion in sequence, just run one matched by
	string 'p'
<astronavt> jusss what happens if it's more than one?
<astronavt> in your case there aren't any overlapping characters, but what if
	    there is?
<jusss> astronavt: then just trigger the first one I think
<astronavt> jusss ok
<astronavt> jusss do beware that in python 2.7 dictionary order is unspecified
	    and cannot be relied on
<astronavt> so the notion of "first" will be somewhat random in this case
<jusss> astronavt: what if p isn't in k, what get_first() will get?
<astronavt> jusss get_first just gets the next element of something
	    iterable. if the iterable thing is empty, it returns the value of
	    `default`, which is None in this case
<astronavt> so if p isn't in k, get_first will get an empty sequence
<astronavt> and return None
<jusss> astronavt: doesn't it need a [] to contain k for ...?	        [14:29]
<astronavt> nope :D
<jusss> if I put [] in there, that would be wrong?
*** astronavt_ (~astronavt@8.37.179.150) has joined channel #python
<jusss> put[k for ..] not just 'k for..'
<astronavt> jusss nope you dont need the []
<astronavt> again, more syntax
<astronavt> [] is for list comprehensions. that computes the whole result and
	    collects it into a list
<jusss> astronavt: because I heard there're dict comprehesion, so I don't want
	mix that
<astronavt> () is for *generator* comprehensions
<astronavt> it's a lazy iterable
<astronavt> so (i for i in range(10) if i > 5)
<astronavt> is a lazy iterable of 6, 7, 8, 9
<jusss> wow, now we have list comprehesion, generator comprehensions, dict
	comprehension, and what else we have?
<astronavt> thats about it i think
<astronavt> oh, set comprehension
<jusss> is there tuple comprehension
<jusss> ?
<astronavt> nope
<jusss> and why?
<astronavt> but...
<astronavt> a generator comprehension lets you do something special     [14:32]
<astronavt> f([i for i in range(10) if i > 5])
<astronavt> thats valid right?
*** MessedUpHare (~MessedUpH@213.205.198.145) has joined channel #python
<jusss> yeah
<astronavt> ok. and f((i for i in range(10) if i > 5)) is also valid
<astronavt> you just replace the list comp with a generator comp
<astronavt> now, heres the fun part
-----------------------------------------------------------------------
<astronavt> f(i for i in range(10) if i > 5) is equivalent to f((i for i in
	    range(10) if i > 5))
--------------------------------------------------------------------
<astronavt> so get_first(k for k in self.procedures if p in k) is equivalent
	    to get_first((k for k in self.procedures if p in k))

<jusss> that's I'm confused, tuple use () too, and how I can know it is a
	tuple or not						        [14:34]
<astronavt> and (k for k in self.procedures if p in k) is a lazy iterable
<astronavt> syntax, again
<astronavt> (1, 2, 3)  <-  tuple
<astronavt> (i for i in range(4) if i > 0)  <-  generator
<jusss> [1,2,3] <- list
<astronavt> (('a', i) for i in range(4) if i > 0)  <- generator that yields
	    tuples :)
<jusss> [if for whatever] <- list
<astronavt> ((i for i in range(3)), (i for i in range(5))  <- tuple of
	    generators!!					        [14:35]
<astronavt> whoops i left out a trailing )
<astronavt> ((i for i in range(3)), (i for i in range(5)))
<jusss> ok, the key is the ',' I suppose
<astronavt> pretty much						        [14:36]
<astronavt> in fact, the () for a tuple aren't always necessary
<astronavt> x = 1, 2
<astronavt> that assigns the tuple (1, 2) to x
<jusss> wow, wonderful
<jusss> never heard
<jusss> too many skills in python
<astronavt> yes, its very heavy on syntax
<astronavt> its just that if you are a native english speaker, it looks like
	    written english. so its easy for us
<energizer> all generators are iterators, not all iterators are generators
<ziggylazer> astronavt, why would iteration be lazy or did I miss something?
<astronavt> ziggylazer iteration with 'for' is lazy in that it calls next()
	    repeatedly. in a generator, next() lazily produces the following
	    value
<ziggylazer> I see what you mean astronavt
<jusss> how to express an empty sequence? like I can use [] to express an
	empty list
<jusss> use () ?
<energizer> jusss: () is a tuple. you can use [] or () or set()
<jusss> energizer: if generator comprehension return an empty sequence, how I
	should now it's or not ?				        [15:48]
<jusss> know
<energizer> jusss: what do you want to do with it?
<jusss> energizer: liek astronavt's code, on
	https://paste.pound-python.org/show/vMjFFDaP6wSgxHkhhTCd/  
<jusss> astronavt: you use try-except to catch en empty sequece, is there
	other method
<astronavt> jusss yes i found it out tonight			        [15:50]
<astronavt> jusss next(some_generator, -1) will return -1 if some_generator is
	    empty
<jusss> I wonder how python to express an empty sequence?
<astronavt> jusss usually an empty list is fine
<astronavt> theres no generic notion of an empty sequence
<jusss> astronavt: if I use [] to compare your code, that empty sequence, what
	will happend
<jusss> happen
<astronavt> jusss you mean like next([], None) ?
<energizer> i think juss is asking about == []
<jusss> astronavt: I mean iterator == [] in your  return next(iterator)
<astronavt> jusss next([]) will raise StopIteration error. next([], None) will
	    return None.
<astronavt> jusss: () or tuple() is empty tuple, [] or list() is empty list,
	    {} or dict() is empty dictionary, and set() is empty set
<jusss> generator comprehension may return an empty sequence, and can I use an
	empty list to compare it or empty dict or tuple???
<jusss> what is the proper way to do that
<astronavt> no you cant
<astronavt> if you need to compare to a dict, just use another dict
<jusss> so I wonder how to express an empty sequence that generated by
	generator comprehensions				        [15:57]
<astronavt> jusss its not really the same thing
<astronavt> an empty dict is an empty container
<astronavt> an "empty generator" isnt a container, its a source of values that
	    is no longer producing values

--------------------------------------------------------------------
python 2.7 dictionary order is unspecified  and cannot be relied on  


-------------------------------------------------------------------

dict.get()dict['whatever']switchif-else
-----------------------------------------------------------------------
-------------------------------------------------------------------------
expression, statement, operator, syntax, keyword argument
--------------------------------------------------------------------------
list comprehension, generator comprehension, dict comprehension, set comprehension,
-----------------------------------------------------------------------
 expressionoperatorstatement

f(a if b==3 else c) operator

import statement xx if xx elseoperator,

express if what else xxx operator,Ca:b?csyntaxexpresson or statement
iflistlist

'a if b else c'  'if a: b else: c'syntax,if-statementexpression

x=3assignment statement,
---------------------------------------------------------------------------
generator comprehension,  (i for i in range(10) if i > 5) and it's not a tuple and there's no tuple comprehension, but you can use that to generate a tuple just put ',' into it
generator comprehensionempty sequence,try: next(this-empty-sequence)empty sequence
list comprehensionempty list[]

generator comprehensiontuple','

generatoriteratorgeneratoryielditeratoriterable
list, tuple, dict, str... generatoriterator,iteratorgenerator

<astronavt> (i for i in range(4) if i > 0)  <-  generator
<astronavt> (('a', i) for i in range(4) if i > 0)  <- generator that yields
	    tuples :)

<astronavt> in fact, the () for a tuple aren't always necessary
<astronavt> x = 1, 2
<astronavt> that assigns the tuple (1, 2) to x

<astronavt> jusss: () or tuple() is empty tuple, [] or list() is empty list,
	    {} or dict() is empty dictionary, and set() is empty set
<astronavt> if you need to compare to a dict, just use another dict
<astronavt> an "empty generator" isnt a container, its a source of values that
	    is no longer producing values

r = (i for i in range(0,9) if i > 10)
rgenerator object,iterablegenerator, next(r)raise exception
next(r,None)generator, emptyNone

keywordempty generator,empty sequence
empty list[]
------------------------------------------------------------------------------
dict.keys().values().get(key,if-not)
proc = next((k for k in self.procedures if p in k), None)
(k for k in ...)generator comprehension,generator object,
next()None
-----------------------------------------------------------------------------
 alist[:]=[]
--------------------------------------
str(a_str.split(':')[2:])  this is wrong to get a string, this will get a list within a string,

>>> a='ab : cd :ed w'
>>> a.split(':')[2:]
['ed w']
>>> str(a.split(':')[2:])
"['ed w']"
>>> c=str(a.split(':')[2:])
>>> ''.join(c)
"['ed w']"


>>> a='ab : cd :ed w :waht'
>>> a.split(':')[2:]
['ed w ', 'waht']
>>> a.split(':',2)[2]
'ed w :waht'

S.split([sep [,maxsplit]]) -> list of strings

String to List, and List to String
---------------------------------------------------

JavaScriptJavaScript<head>
<head>
  <script>
    alert('Hello, world');
  </script>
</head>
JavaScript.jsHTML<script src="..."></script>
<head>
  <script src="/static/js/abc.js"></script>
</head>
/static/js/abc.js
<script type="text/javascript">
typeJavaScripttypeJavaScript


var x = 1;

if (2 > 1) {
    x = 1;
    y = 2;
    z = 3;
}

//
/*...*/
JavaScript
JavaScriptNumberNumber
-99; // 
NaN; // NaNNot a NumberNaN
Infinity; // InfinityJavaScriptNumberInfinity
0x0-9a-f
truefalse
&&true&&true
||true||true
!truefalsefalsetrue
JavaScript=====
NaNNumber
NaNisNaN()
null0''0''0null
[1, 2, 3.14, 'Hello', null, true];
Array()

new Array(1, 2, 3); // [1, 2, 3]

var arr = [1, 2, 3.14, 'Hello', null, true];

JavaScript-

var person = {
    name: 'Bob',
    age: 20,
    tags: ['js', 'web', 'mobile'],
    city: 'Beijing',
    hasCar: true,
    zipcode: null
};

JavaScriptperson6personname'Bob'zipcodenull

.

person.name; // 'Bob'
person.zipcode; // null

JavaScript$_JavaScriptifwhilevar
JavaScript=var

var a = 123; // a123   assign
a = 'ABC'; // a        re-assign

Java

int a = 123; // aint
a = "ABC"; // 



var x = 100;
console.log(x);

var

i = 10; // i
\nES6 ` ... ` 
+
var message = `, ${name}, ${age}!`;  //
var s = 'Hello, world!';
s.length; // 13
s[0]; // 'H'
JavaScript
s.indexOf('world'); // 7 otherwise it will return -1
s.substring(0, 5); // 055'hello'
var arr = [1, 2, 3];
arr.length = 6;
arr; // arr[1, 2, 3, undefined, undefined, undefined]
slice()Stringsubstring()ArrayArray

var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
arr.slice(0, 3); // 033: ['A', 'B', 'C']
arr.slice(3); /
var arr = ['A', 'B', 'C', 1, 2, 3];
arr.join('-'); // 'A-B-C-1-2-3'

concat()ArrayArrayArray

JavaScript{}MapDictionary

JavaScriptNumber
Map
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
m.delete('Adam'); // key 'Adam'
m.set('Adam', 67); // 

SetMapkeyvaluekeySetkey

SetArraySet

var s1 = new Set(); // Set
var s2 = new Set([1, 2, 3]); // 1, 2, 3
Set

var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}

for (i=0; i<arr.length; i++) {...}
for (var key in o) {...}
while () {}
do {} while ()

for ... inArray

Array, keyvalue
for ... of, key

iterableforEachArray
a.forEach(function (element, index, array) {
    // element: 
    // index: 
    // array: Array
    console.log(element + ', index = ' + index);
});

JavaScriptArrayelement

var a = ['A', 'B', 'C'];
a.forEach(function (element) {
    console.log(element);
});


----------------------------------------------------------------------------------------------
python, list object is not an iterator!!!
<energizer> jusss: iterable not iterator, because it doesnt implement the iterator protocol, https://nedbatchelder.com/text/iter.html
list objectlist.__iter__()iterator,iter(list)
>>> iter(a)
<listiterator object at 0x02D6B9B0>
>>> c=iter(a)
>>> next(c)
1
>>> a.__iter__()
<listiterator object at 0x02D7C530>
---------------------------------------------------------------------------

JavaScript

function abs(x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
}

JavaScriptabs()abs



var abs = function (x) {
    if (x >= 0) {
        return x;
    } else {
        return -x;
    }
};

function (x) { ... }absabs

;

JavaScriptargumentsargumentsArrayArray
rest
function foo(a, b, ...rest) {}

JavaScriptvar
JavaScriptwindowwindow

'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'

coursewindow.course
var foo = function () {}window
'use strict';

function foo() {
    alert('foo');
}

foo(); // foo()
window.foo(); // window.foo()
alert()window
JavaScriptReferenceError
----------------------------------------------------------------


windowJavaScript



// MYAPP:
var MYAPP = {};

// :
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// :
MYAPP.foo = function () {
    return 'foo';
};

MYAPP

JavaScriptjQueryYUIunderscore

ES6letletvar

'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}
ES6constconstlet

'use strict';

const PI = 3.14;
PI = 3; // 
PI; // 3.14

varletforconst

ES6
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
[...][x,y,z]



var {hostname:domain, pathname:path} = location;

JavaScript

var xiaoming = {
    name: '',
    birth: 1990
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
};
thisxiaomingthis.birthxiaomingbirth
getAge()thiswindow

var fn = xiaoming.age; // xiaomingage
fn(); // NaN

thisobj.xxx()
thatthis
 age: function () {
        var that = this; // this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // thatthis
        }

jsapplycall
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, thisxiaoming, 

apply()call()

    apply()Array

    call()

Math.max(3, 5, 4)apply()call()

Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5

----------------------------------------------------
var whatever = function () {...} lambda???
var whatever = {};
whatever.bla='xxx'; window.whatever
applycall
'use strict';

var count = 0;
var oldParseInt = parseInt; // 

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 
};

,newlisp
newlisplambda listlist,car cdr whatever you want

boldjsnewlispnewlisplambda listf-expression, jsfunctionwindowapplycallpythondict 

<eiGHttt> jsclass
	  mixin

-----------------------------------------------------------------
Higher-order function
jsArraymap

'use strict';

function pow(x) {
    return x * x;
}


var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]
console.log(results);

var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x + y;
}); // 25

[1, 3, 5, 7, 9]13579reduce()

var arr = [1, 3, 5, 7, 9];
arr.reduce(function (x, y) {
    return x * 10 + y;
}); // 13579

filter()Array

var arr = ['A', 'B', 'C'];
var r = arr.filter(function (element, index, self) {
    console.log(element); // 'A', 'B', 'C'
    console.log(index); // 0, 1, 2
    console.log(self); // selfarr
    return true;
});
--------------------------------------------------------------
<jusss> function called callback when it's as a parameter, function called
	closure when it's by returned and inside a function, do something
	before or after function, that called decorator, is there anything
	else like those concepts?
<energizer> jusss: there's a lot of stuff like that in functional programming
<energizer> jusss:
	    https://github.com/dbrattli/oslash/wiki/Functors,-Applicatives,-And-Monads-In-Pictures
<jusss`> eiGHttt: callback, closure, 
	 codedecorator, 
<eiGHttt> 
--------------------------------------------------------------

ABAcallback
AB,ABAclosure
AcodeA,decorator
AAhigher-order function

-----------------------------------------------------------------
jsArraymap, reduce, filter, sort,higher-order function
'use strict';

var arr = [10, 20, 1, 2];
arr.sort(function (x, y) {
    if (x < y) {
        return -1;
    }
    if (x > y) {
        return 1;
    }
    return 0;
});
console.log(arr); // [1, 2, 10, 20]

Array.sort()array,array

----------------------------------------------------------
Pythons closures are late binding. This means that the values of variables used in closures are looked up at the time the inner function is called.

adders=[0,1,2,3]

for i in [0,1,2,3]:
   adders[i]=lambda a: i+a

print adders[1](3)

https://docs.python-guide.org/writing/gotchas/#late-binding-closures



adders[i]= lambda a,b=i: a+b
 adders[i] = (lambda b: lambda a: a+b)(i)
-------------------------------------------------------------
Arrow Function
x => x*x  function (x) { return x*x; }
x => { if (x>0) {return x*x;}
       else {return - x*x;}}
(x,y) => x*x + y*y
() => 3.14
(x,y, ...rest) => { 
 var i, sum = x + y;
    for (i=0; i<rest.length; i++) {
        sum += rest[i];
    }
    return sum;
}

x => { foo: x }  {foo: x}    
x => ({foo: x})


generator

function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}

generatorgeneratorfunction**returnyield
generatorgeneratornext()
for ... ofgeneratordone


------------------------------------------------------------
The Lumineers - Sleep On The Floor
-----------------------------------------------
