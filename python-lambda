python lambda closure lisp


(let ((n 0)) ...) equal ((lambda (n) ..) 0) equal def a(n) then f=a(0) f is a function

python's function call with (), 
 
def a(n):
 def b():
  n=n+1
  return n
 return b
f=a(0)
f()     this won't work because you can't change that outer n's value in function b

nonlocal can change the variable's value that is in one upper level and only one upper level, for example

n=0
def b():
    nonlocal n
    n=1
    
then you can change the n's value inside function b and affect that n's value which is at the same namespace with function b

global is not a same thing with nonlocal, nonlocal only change that one upper level,
but global change that top level's variable
https://stackoverflow.com/questions/1261875/python-nonlocal-statement


def f(n):
    def b():
        nonlocal n
        n += 1
        return n
    return b

inc = f(0)
print(inc())
print(inc())

>>> def a():
...   n=0
...   def b():
...     nonlocal n
...     n=n+1
...     return n
...   return b
... 
>>> f=a()
>>> f()
1
>>> f()
2

<W> j: in py3, you can use the nonlocal keyword. in py2... ugly
	 hacks.
<j> it seems a bit likely, class and closure
<W> j: it's usually cleaner to encapsulate data in a class instead of
	 having mutable nonlocal state.



         
lambda x,y: [x](y)




-----------------------------------------------------------------------------
python lambda closure

https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture

尝试批量生成函数

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=lambda a: i+a

print(adders[1](3))
结果是6而不是4
I expected it to store a pinter to the integer object currently pointed to by i.
That means what when i assigned a new integer object it shouldn't effect the previously created closures.
Sadly, inspecting the adders array within a debugger shows that it does, All lambda functions refer
to the last value of i, 3, which results in adders[1](3) returning 6.

Scoping in Python is lexical. A closure will always remeber the name and scope of the variable,
not the object it's pointing to. Since all the functions in your example are created in the same
scope and use the same variable name, they always refer to the same variable.

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=(lambda a: lambda b: b+a)(i)

print(adders[1](3))

用()来函数调用，exit不行，exit()可以函数调用, f不行,f()函数调用
lambda里调用了外部变量形成closure, closure会和这个lambda一起绑定在namespace里

-----------------------------------------------
>>> f= lambda x: lambda y: x+y
>>> f
<function <lambda> at 0x7fca971f5f28>
>>> f(3)(4)
7
>>> f(3)
<function <lambda>.<locals>.<lambda> at 0x7fca97583048>
>>> 
-----------------------------------------


>>> f=lambda x: x+1
>>> f(3)
4

>>> (lambda x: x+1)(3)
4

(lambda x, y: x + y)(5, 3)  => 8

>>> def make_adder(n):
...     return lambda x: x + n

(lambda x: print(x))(3)

(lambda: 3)()

lambda: 3 and (lambda: 3) are both functions, you want (lambda: 3)()

>>> list(map(lambda x: x * 2, item))
[2, 4, 6]
>>> item
[1, 2, 3]
>>> [items * 2 for items in item]
[2, 4, 6]

python3 map(func,list)返回的是个可迭代的对象, 但是python里面又没有指定的iterator类
所以还是用anything you like. A for loop. list(). ''.join(). Lots of
	things iterate.

>>> for i in d:
...  print(i)
... 
2
4
6

