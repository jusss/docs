python 3.0 aka python 3k or python 3000, more details see PEP 3000, GvR steps down BDFL because of the argument about PEP 572. at 2018.07.13
reduce() is removed from python 3k, but you can also find it in functools module.
lambda, filter, and map, filter and map will return iterators instead of lists.

"Lambda functions are mainly used in combination with the functions filter(), map() and reduce(). The lambda feature was added to Python due to the demand from Lisp programmers."

lambda argument,argument: expression
map(function, sequence_like_a_list)
filter(function, sequence)
reduce(function, sequence)

import functools
functools.reduce(lambda x,y: x+y, [47,11,42,13])   => 113
这个lambda先作用在前2个元素上，然后再作用在返回的结果和第三个元素上，依次递推

检测一个列表里最大的值
reduce(lambda a,b: a if (a>b) else b, [47,11,42,102,13])  => 102

计算1到100的和
reduce(lambda x,y: x+y, range(1,101))  => 5050

计算前100项Fibonacci数列之和
reduce(lambda x,y: x+y, fs)

Fibonacci数列
fs=map(f, range(0,101))   只要加了()就相当于函数调用，所以此处是f而不是f()

Fibonacci数
f=lambda c,x=0,y=1: x if c==0 else f(c-1,y,x+y)

filer()把function作用在sequence的每个元素上，返回值是true的元素返回, sequence可以是list or tuple, dictionary啥的

map() applies the function to all the elements of the sequence and return a list in python2 and an iterator in python3
a=[1,2,3,5]
b=[17,12,11,10]
list(map(lambda x,y: x+y, a, b)) => [18,14,14,15]

---------------------------------------------------
https://stackoverflow.com/questions/890128/why-are-python-lambdas-useful
mult3 = filter(lambda x: x%3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
mult3 is [3,6,9]
or mult3 = [x for x in [1,2...9] if x%3 ==0]
','.join(str(x) for x in [1,2,3,4,5,6])

map, filter, reduce, 

lambda is useful in GUI for callback
---------------------------------------------
python lambda closure lisp


(let ((n 0)) ...) equal ((lambda (n) ..) 0) equal def a(n) then f=a(0) f is a function

python's function call with (), 
 
def a(n):
 def b():
  n=n+1
  return n
 return b
f=a(0)
f()     this won't work because you can't change that outer n's value in function b

nonlocal can change the variable's value that is in one upper level and only one upper level, for example

n=0
def b():
    nonlocal n
    n=1
    
then you can change the n's value inside function b and affect that n's value which is at the same namespace with function b

global is not a same thing with nonlocal, nonlocal only change that one upper level,
but global change that top level's variable
https://stackoverflow.com/questions/1261875/python-nonlocal-statement


def f(n):
    def b():
        nonlocal n
        n += 1
        return n
    return b

inc = f(0)
print(inc())
print(inc())

>>> def a():
...   n=0
...   def b():
...     nonlocal n
...     n=n+1
...     return n
...   return b
... 
>>> f=a()
>>> f()
1
>>> f()
2

<W> j: in py3, you can use the nonlocal keyword. in py2... ugly
	 hacks.
<j> it seems a bit likely, class and closure
<W> j: it's usually cleaner to encapsulate data in a class instead of
	 having mutable nonlocal state.



         
lambda x,y: [x](y)




-----------------------------------------------------------------------------
python lambda closure

https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture

尝试批量生成函数

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=lambda a: i+a

print(adders[1](3))
结果是6而不是4
I expected it to store a pinter to the integer object currently pointed to by i.
That means what when i assigned a new integer object it shouldn't effect the previously created closures.
Sadly, inspecting the adders array within a debugger shows that it does, All lambda functions refer
to the last value of i, 3, which results in adders[1](3) returning 6.

Scoping in Python is lexical. A closure will always remeber the name and scope of the variable,
not the object it's pointing to. Since all the functions in your example are created in the same
scope and use the same variable name, they always refer to the same variable.

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=(lambda a: lambda b: b+a)(i)

print(adders[1](3))

用()来函数调用，exit不行，exit()可以函数调用, f不行,f()函数调用
lambda里调用了外部变量形成closure, closure会和这个lambda一起绑定在namespace里

-----------------------------------------------
>>> f= lambda x: lambda y: x+y
>>> f
<function <lambda> at 0x7fca971f5f28>
>>> f(3)(4)
7
>>> f(3)
<function <lambda>.<locals>.<lambda> at 0x7fca97583048>
>>> 
-----------------------------------------


>>> f=lambda x: x+1
>>> f(3)
4

>>> (lambda x: x+1)(3)
4

(lambda x, y: x + y)(5, 3)  => 8

>>> def make_adder(n):
...     return lambda x: x + n

(lambda x: print(x))(3)

(lambda: 3)()

lambda: 3 and (lambda: 3) are both functions, you want (lambda: 3)()

>>> list(map(lambda x: x * 2, item))
[2, 4, 6]
>>> item
[1, 2, 3]
>>> [items * 2 for items in item]
[2, 4, 6]

python3 map(func,list)返回的是个可迭代的对象, 但是python里面又没有指定的iterator类
所以还是用anything you like. A for loop. list(). ''.join(). Lots of
	things iterate.

>>> for i in d:
...  print(i)
... 
2
4
6

