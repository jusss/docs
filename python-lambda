
(lambda:
      (globals().__setitem__('a', [3]), a.append(5), print(a)))()

<jusss> bjs: counter = (lambda x: lambda: [x.append(x[-1]+1),x][-1][-1])([0])

<jusss> bjs: have a look at this (lambda g,x,y,z: y if z==0 else
        g(g,y,x+y,z-1))((lambda g,x,y,z: y if z==0 else
        g(g,y,x+y,z-1)),0,1,100)

<bjs> jusss: again, that's probably just CPS-style programs causing that, not
      Python
<jusss> bjs: ok  [00:27]

<jusss> bjs: and how to do b=3 in lambda? 

<SnoopJeDi> jusss, because you said you wanted to _change_ the object. If you
            wanted to return a new list that extends by 5, you'd write
            something like `lambda l: l + [5]`
<bjs> jusss: it depends, what do you mean by "b=3", the easiest way is just to
      do an encoding of a let-binding like: `(lambda b: ...)(3)`  [00:28]
<jusss> bjs: no, this b is outside of lambda
<jusss> bjs: can I change it
<bjs> jusss: yes, you can use setattr or globals/locals or something else.
      You need to do a bit more work to understand exactly *which* b it is

<bjs> when you write `x = 1` as an expression Python does some jumping through
      hoops to figure things out for you.  Eventually (3.8) we'll get a `x :=
      1` expression too which does the same jumping for you

<jusss> bjs: you're right, any assignment inside the function they can
        transform to the (lambda b: ...)(3) form
<jusss> bjs: like the 'let' did in js or scheme
<jusss> but not in cl, IIRC, let is a sugar in scheme, but not cl  [00:31]
<python476> jusss: you seem too familiar with everything fp/lisp
<jusss> python476: no, I'm just a newbie
<python476> are you a gnu guile mole in secret mission ?
<bjs> jusss: whether or not it's sugar will change depending on versions of
      the compiler and such, I wouldn't think too hard
<jusss> to any language
<python476> jusss: a newbie.. broh, we'all noobies then
<jusss> python476: actually I prefer racket  [00:32]
<bjs> jusss: but generally `let x = y in z` is pretty similar to `(\x. z) y`
<python476> this chan is odd today, but I don't dislike this lambda flavouring

<bjs> and the basic point is that all things can be re-written to a lambda
      like the right-hand side and Python is not different
<jusss> python476: you can try scheme or js, and you will love it  [00:33]
<bjs> jusss: and just to end this with some fun, and it's basically tradition
      to show this at the end of these conversations:
      https://gist.github.com/habnabit/3805075/
<python476> jusss: I'm a lisper for life, anything sexp or ml is my joy
##############################
a=3 if 'a' in 'abc' else 4
<squirrel> i'd have ? : over = if else any day
-----------------------------------------
<jusss> None, False, [], (), they are same or different? bool() them will be
	same False
<ChrisWarrick> jusss: different
<jusss> ok
<ChrisWarrick> jusss: by this logic, 1 is the same as 2 is the same as 3…
<jusss> in other languages, like C if it's not 0, it will be true,in lisp, if
	it's not nil or () it will be true
<jusss> but in python, eval None, False, [], () , they all are False
<jusss> it's kind of weird
<nedbat> jusss: languages are different. that's why we have more than one
	 language
<nedbat> jusss: also, "", {} are false  [01:01]
<ChrisWarrick> and 0
<ChrisWarrick> although I prefer the word “falsey”
<nedbat> jusss: right, and 0 and 0.0
<jarthur> Yea, I usually say something like falsey as well.
--------------------------------------
python的函数默认返回None,或者除非用return来指定返回的值
-----------------------------------------------------------
beware use lambda in for statement

improper:  i will always be 2, like this lambda in for statement
c=[lambda x: x+i for i in [0,1,2]]
d=[(lambda : lambda x: x+i)() for i in [0,1,2]]
e=[lambda: lambda x: x+i for i in [0,1,2]]

proper:  i will be 0, 1, 2
f=[(lambda y: lambda x: x+y)(i) for i in [0,1,2]]
<nedbat> jusss: you can also get 0,1,2  with f=[(lambda x,y=i: x+y) for i in
	 [0,1,2]]  [01:07]
<ChrisWarrick> or define a function and use functools.partial
<jusss> nedbat: what made 'for' do this differnt?
<nedbat> jusss: it's not the for that's different, it's the lambda
<jusss> use if-else instead of lambda in that position, and if-else will
	generate result every time
<jusss> but it is lambda, why lambda only get the last same value  [01:12]
<ChrisWarrick> jusss: an if-else or a call is evaluated at iteration time
<jusss> ChrisWarrick: and the lambda won't eval?
<ChrisWarrick> jusss: the lambda does not save values at that time

<ChrisWarrick> jusss: it just knows to use the `i` from somewhere, and the `i`
	       ends up being 2 after the loop

<jusss> ChrisWarrick: so all I do is just make lambda be evaluated, that will
	make lambda save it values?
<ChrisWarrick> 19:04:35 <jusss> but f=[(lambda y: lambda x: x+y)(i) for i in
	       [0,1,2]] this will be 0,1,2  [01:15]
<ChrisWarrick> this is evaluating

<ChrisWarrick> 19:07:20 <nedbat> jusss: you can also get 0,1,2  with
	       f=[(lambda x,y=i: x+y) for i in [0,1,2]]
<ChrisWarrick> this is one possible solution

<jusss> yeah, I did make it evaluted

<jusss> lambda in python is like a girl, you can only kiss her but never make
	out
----------------------------------------------------------------
closure in python ,如果不想使用nonlocal,就用字典来替代变量

proper:
def f(x):
    def y():
    	nonlocal x
	x = x+1
	return x
    return y
    

proper:
def f():
    x=1
    def y():
       nonlocal x
       x = x+1
       return x
    return y

improper:   don't forget return n
def f(n):
    def b():
        nonlocal n
        n=n+1
        
    return b
c=f(0)
print(c())
-----------------------------------------------------------------
list comprehension
generator and iterator的属性？generator可以用for x in gen或list(gen)来操作
function object的属性？传递class? 把class做参数传递？

[ expression for x in iterator ]
[ expression-of-x condition-x ]
lambda x: expression-of-x if condition else another-expression-of-x

c=[39, 35, 55]
f=[ x+1 for x in c]
print(f) => [40,36,56]

[(x,y,z) for x in range(1,30) for y in range(x,30) for z in range(y,30) if x**2 + y**2 ==z**2]
[(3,4,5), (5,12,13), ...(20,21,29)]

colours=["red","green","yellow"]
things=["house","car","tree"]
colours_things=[(x,y) for x in clours for y in things]
print(colours_things) => [('red', 'house'), ('red', 'car'), ('red','tree'), ...]

x=(x**2 for x in range(20))
x=list(x) 

>>> colors=["red","blue","yellow"]
>>> things=["car","house","sky"]
>>> [(x,y) for x in colors for y in things]
[('red', 'car'), ('red', 'house'), ('red', 'sky'), ('blue', 'car'), ('blue', 'house'), ('blue', 'sky'), ('yellow', 'car'), ('yellow', 'house'), ('yellow', 'sky')]
>>> [(x,y) for i in range(0,3) for x in colors[i] for y in things[i]]
[('r', 'c'), ('r', 'a'), ('r', 'r'), ('e', 'c'), ('e', 'a'), ('e', 'r'), ('d', 'c'), ('d', 'a'), ('d', 'r'), ('b', 'h'), ('b', 'o'), ('b', 'u'), ('b', 's'), ('b', 'e'), ('l', 'h'), ('l', 'o'), ('l', 'u'), ('l', 's'), ('l', 'e'), ('u', 'h'), ('u', 'o'), ('u', 'u'), ('u', 's'), ('u', 'e'), ('e', 'h'), ('e', 'o'), ('e', 'u'), ('e', 's'), ('e', 'e'), ('y', 's'), ('y', 'k'), ('y', 'y'), ('e', 's'), ('e', 'k'), ('e', 'y'), ('l', 's'), ('l', 'k'), ('l', 'y'), ('l', 's'), ('l', 'k'), ('l', 'y'), ('o', 's'), ('o', 'k'), ('o', 'y'), ('w', 's'), ('w', 'k'), ('w', 'y')]
>>> colors[0]
'red'
>>> [(colors[i],things[i]) for i in range(0,3)]
[('red', 'car'), ('blue', 'house'), ('yellow', 'sky')]
>>> 


>>> a=["red","blue","deep blue"]
>>> b=["horse","cat","dog"]
>>> {a[i]:b[i] for i in range(0,3)}
{'red': 'horse', 'blue': 'cat', 'deep blue': 'dog'}
>>> c={a[i]:b[i] for i in range(0,3)}
>>> c["red"]
'horse'

map(lambda x,y: {}.append(x:y), list1, list2)

-------------------------
python 3.0 aka python 3k or python 3000, more details see PEP 3000, GvR steps down BDFL because of the argument about PEP 572. at 2018.07.13
reduce() is removed from python 3k, but you can also find it in functools module.
lambda, filter, and map, filter and map will return iterators instead of lists.

"Lambda functions are mainly used in combination with the functions filter(), map() and reduce(). The lambda feature was added to Python due to the demand from Lisp programmers."

lambda argument,argument: expression
map(function, sequence_like_a_list)
filter(function, sequence)
reduce(function, sequence)

import functools
functools.reduce(lambda x,y: x+y, [47,11,42,13])   => 113
这个lambda先作用在前2个元素上，然后再作用在返回的结果和第三个元素上，依次递推

检测一个列表里最大的值
reduce(lambda a,b: a if (a>b) else b, [47,11,42,102,13])  => 102

计算1到100的和
reduce(lambda x,y: x+y, range(1,101))  => 5050

计算前100项Fibonacci数列之和
reduce(lambda x,y: x+y, fs)

Fibonacci数列
fs=map(f, range(0,101))   只要加了()就相当于函数调用，所以此处是f而不是f()

Fibonacci数
f=lambda c,x=0,y=1: x if c==0 else f(c-1,y,x+y)

filer()把function作用在sequence的每个元素上，返回值是true的元素返回, sequence可以是list or tuple, dictionary啥的

map() applies the function to all the elements of the sequence and return a list in python2 and an iterator in python3
a=[1,2,3,5]
b=[17,12,11,10]
list(map(lambda x,y: x+y, a, b)) => [18,14,14,15]

---------------------------------------------------
https://stackoverflow.com/questions/890128/why-are-python-lambdas-useful
mult3 = filter(lambda x: x%3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
mult3 is [3,6,9]
or mult3 = [x for x in [1,2...9] if x%3 ==0]
','.join(str(x) for x in [1,2,3,4,5,6])

map, filter, reduce, 

lambda is useful in GUI for callback
---------------------------------------------
python lambda closure lisp


(let ((n 0)) ...) equal ((lambda (n) ..) 0) equal def a(n) then f=a(0) f is a function

python's function call with (), 
 
def a(n):
 def b():
  n=n+1
  return n
 return b
f=a(0)
f()     this won't work because you can't change that outer n's value in function b

nonlocal can change the variable's value that is in one upper level and only one upper level, for example

n=0
def b():
    nonlocal n
    n=1
    
then you can change the n's value inside function b and affect that n's value which is at the same namespace with function b

global is not a same thing with nonlocal, nonlocal only change that one upper level,
but global change that top level's variable
https://stackoverflow.com/questions/1261875/python-nonlocal-statement


def f(n):
    def b():
        nonlocal n
        n += 1
        return n
    return b

inc = f(0)
print(inc())
print(inc())

>>> def a():
...   n=0
...   def b():
...     nonlocal n
...     n=n+1
...     return n
...   return b
... 
>>> f=a()
>>> f()
1
>>> f()
2

<W> j: in py3, you can use the nonlocal keyword. in py2... ugly
	 hacks.
<j> it seems a bit likely, class and closure
<W> j: it's usually cleaner to encapsulate data in a class instead of
	 having mutable nonlocal state.



         
lambda x,y: [x](y)




-----------------------------------------------------------------------------
python lambda closure

https://stackoverflow.com/questions/2295290/what-do-lambda-function-closures-capture

尝试批量生成函数

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=lambda a: i+a

print(adders[1](3))
结果是6而不是4
I expected it to store a pinter to the integer object currently pointed to by i.
That means what when i assigned a new integer object it shouldn't effect the previously created closures.
Sadly, inspecting the adders array within a debugger shows that it does, All lambda functions refer
to the last value of i, 3, which results in adders[1](3) returning 6.

Scoping in Python is lexical. A closure will always remeber the name and scope of the variable,
not the object it's pointing to. Since all the functions in your example are created in the same
scope and use the same variable name, they always refer to the same variable.

adders=[0,1,2,3]

for i in [0,1,2,3]:
    adders[i]=(lambda a: lambda b: b+a)(i)

print(adders[1](3))

用()来函数调用，exit不行，exit()可以函数调用, f不行,f()函数调用
lambda里调用了外部变量形成closure, closure会和这个lambda一起绑定在namespace里

-----------------------------------------------
>>> f= lambda x: lambda y: x+y
>>> f
<function <lambda> at 0x7fca971f5f28>
>>> f(3)(4)
7
>>> f(3)
<function <lambda>.<locals>.<lambda> at 0x7fca97583048>
>>> 
-----------------------------------------


>>> f=lambda x: x+1
>>> f(3)
4

>>> (lambda x: x+1)(3)
4

(lambda x, y: x + y)(5, 3)  => 8

>>> def make_adder(n):
...     return lambda x: x + n

(lambda x: print(x))(3)

(lambda: 3)()

lambda: 3 and (lambda: 3) are both functions, you want (lambda: 3)()

>>> list(map(lambda x: x * 2, item))
[2, 4, 6]
>>> item
[1, 2, 3]
>>> [items * 2 for items in item]
[2, 4, 6]

python3 map(func,list)返回的是个可迭代的对象, 但是python里面又没有指定的iterator类
所以还是用anything you like. A for loop. list(). ''.join(). Lots of
	things iterate.

>>> for i in d:
...  print(i)
... 
2
4
6

---------------------------------------------
