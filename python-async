http://python.jobbole.com/87310/

promise/future, co-routines, concurrency, generator, lazy-evaluation, continuation,
asyncio,

multiprocess,multithread, parallelism

event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。
coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。
task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。
future： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别
async/await 关键字：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。

import asyncio
# create a function
async def do_something_later():
  ....
# create a coroutine base the function 
coroutine = do_something_later()

# create a event loop
loop = asyncio.get_event_loop()
# put that coroutine into loop 
loop.run_until_complete(coroutine)

协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象。所谓task对象是Future类的子类。保存了协程运行后的状态，用于未来获取协程的结果。
task = loop.create_task(coroutine)
print(task)
loop.run_until_complete(task)
print(task)
创建task后，在loop.run_until_complete(task)把task加入事件循环之前是pending状态
task执行后是finished状态

asyncio.ensure_future(coroutin)和loop.create_task(coroutine)都可以创建task
run_until_complete的参数是个future对象

task = asyncio.ensure_future(coroutine)
task.add_done_callback(callback_func)
loop.run_until_complete(task)

def callback_func(t, future):
  print('callback:',t,future.result())
coroutine执行结束时会调用callback_func,并把future当参数传递给callback函数这样
就可以在callback_func里获取future的状态

对callback函数的参数有要求，

比如 def abc(callback):
        a,b,c = 0,1,2
	callback(a,b,c)

1. it seems 只要用loop.run_until_complete(task)之后这个task就回运行
和多线程的j.start()很像
2. co-routine,在scheme里用continuation里实现时就是单线程 依次并发执行
多个函数，并不是多个CPU核心同时执行多个函数那种并行
3. 异步编程还有个select()函数
4. racket里就是用async来取代多线程多进程在GUI编程里使用socket

使用await可以让出控制权类似yield
async def do_something():
  await asyncio.sleep(3)

future对象有几个状态 Pending, Running, Done, Cancelled
