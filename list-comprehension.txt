
quickSort :: (Ord a) => [a] -> [a]
quickSort [] = []
quickSort (x:xs) =
    let smallerSorted = quickSort [a | a <- xs, a <= x]
        biggerSorted = quickSort [a | a <- xs, a > x]
    in smallerSorted <> [x] <> biggerSorted

main = print $ quickSort [1,3,2,4,1]

p = s[2..] where s (x: xs) = s [i <- xs, mod i x /= 0]

the list comprehension version is more easy to read
its "let's assume there's a middle value called x, and we compare other values with x"and we actually don't know what x is, but we can use it, is that amazing
in list comprehension

