TSPL
(letrec ([f (lambda (x) (cons 'a x))]
         [g (lambda (x) (cons 'b (f x)))]
         [h (lambda (x) (g (cons 'c x)))])
  (cons 'd (h '()))) <graphic> (d b a c)


(letrec ([f (lambda (x k) (k (cons 'a x)))]
         [g (lambda (x k)
              (f x (lambda (v) (k (cons 'b v)))))]
         [h (lambda (x k) (g (cons 'c x) k))])
  (h '() (lambda (v) (cons 'd v))))


in (f x $ \v ->...) v is the f's result, because f = \x, k -> k (cons 'a x)
k will take f's result, and in the calling f x $ \v ->...
\v is k, so v is f's result, in a calling, using a lambda to capture an result is interesting, and if lambda as parameter, so lambda itself can be changed in recursive calling, amazing!

https://scheme.com/tspl4/further.html

(define product_
  (lambda (ls k)
    (let ([break k])
      (letrec ((f (lambda (ls k)
        (cond
          [(null? ls) (k 1)]
          [(= (car ls) 0) (break 0)]
          [else (f (cdr ls)
                   (lambda (x)
                     (k (* (car ls) x))))]))))
    (f ls k)))))

CPS can allow more than one result to its continuation
(define car&cdr
  (lambda (p k)
    (k (car p) (cdr p))))

(car&cdr '(a b c)
  (lambda (x y)
    (list y x)))


(define integer-divide
  (lambda (x y success failure)
    (if (= y 0)
        (failure "divide by zero")
        (let ([q (quotient x y)])
          (success q (- x (* q y)))))))

(integer-divide 10 3 list (lambda (x) x)) 
(integer-divide 10 0 list (lambda (x) x))

(define product
  (lambda (ls)
    (call/cc
      (lambda (break)
        (letrec ((f (lambda (ls)
          (cond
            [(null? ls) 1]
            [(= (car ls) 0) (break 0)]
            [else (* (car ls) (f (cdr ls)))]))))
          (f ls))))))

callCC transform to CPS

(define product
  (lambda (ls k)
    (let ([break k])
      (letrec ((f (lambda (ls k)
        (cond
          [(null? ls) (k 1)]
          [(= (car ls) 0) (break 0)]
          [else (f (cdr ls)
                   (lambda (x)
                     (k (* (car ls) x))))]))))
        (f ls k)))))
        
(product_ '(1 2 0) (lambda (x) x))

transform to python

def product(ls, k):
    _break = k
    def f(ls, k):
        if not ls:
            return k(1)
        elif ls[0] == 0:
            return _break(0)
        else:
            return f(ls[1:], lambda x: k(ls[0] * x))

    return f(ls, k)

print(product([1,2,0], lambda x: x))


mapK p [] k = k []
mapK p (x: xs) k = p x $ \v -> mapK p xs $ \ns -> k (v : ns)

map p [] = []
map p (x: xs) = (p x) : (map p xs)

(define mapK
  (lambda (p ls k)
    (if (null? ls)
        (k '())
        (p (car ls) (lambda (v) (mapK p (cdr ls) (lambda (ns) (k (cons v ns)))))))))

(define rec
  (lambda (ls k)
    (mapK (lambda (x c)
            (if (= 0 x) (k "zero found")
                (c (/ 1 x))))
          ls
          k)))
(rec '(1 2 3) (lambda (x) x))


1. in definition p x f, when calling f is \v, v always will be p's result, and f will take result in definition of p
2. function mapK take function p and continuation k, when calling p with \v, v is p's result and calling mapK with \ns, ns is mapK's result
3. the inner p x in map, turn into outer p x in mapK, it needs using v as its result and give v to its old behavior

(define factorial
  (lambda (x)
    (if (= x 0)
        (call/cc (lambda (k) (set! retry k) 1))
        (* x (factorial (- x 1))))))

(define factorial
       (lambda (x k)
                      (if (= x 0)
                          (k 1)
                   (factorial (- x 1) (lambda (v) (k (* v x)))))))


(define product 
  (lambda (ls)
    (call/cc
      (lambda (break) (letrec ((f (lambda (ls)
        (cond ((null? ls) 1)
                     ((= (car ls) 0) (break 0))
                      (else (* (car ls) (f (cdr ls))))))))
         (f ls))))))

def product(ls, k):
  _break = k
  def f(ls, k):
    if not ls:
      return k(1)
    elif ls[0] == 0:
      return _break(0)
    else:
      return f(ls[1:], lambda x: k(ls[0] * x))
  return f(ls, k)
product([1,2,3], lambda x: x))

https://stackoverflow.com/questions/50958042/continuation-passing-style-and-concurrency

https://tmp.barzilay.org/cont.txt

https://www.cs.purdue.edu/homes/suresh/590s-Fall2002/lectures/lecture-4.html#:~:text=Continuation%20passing%20style%20makes%20the,they%20return%20to%20their%20caller.


in scheme they use call/cc to capture the rest computation, and call/cc can transform to CPS, how CPS would capture the rest computation?

ski :every call in CPS is a tail call
dolio :Yeah, in CPS, every computation is called with the rest of the computation as an argument.
dolio :And the last thing it does is call the rest of the computation.

f x k, call k in the last in f definition 
in calling f x \v -> ... v is the f's result \v is the rest computation of f
k 1 like f's rest computation as 1
set k k in call/cc \k -> set k k then k k
like \v -> ... is v in \v -> ...
k call k
f k in definition 
but f f in calling 

f x (\v -> ...) when f is with CPS and v is the result of f, \v -> is the rest computation of f


I suddenly think that Java in android programming uses a lot of CPS, you can pass an object or a lambda which that can take some results, abstract class
geekosaur :CPS is fairly common in modern UI programming, although it's not often called that



so if f x (\v -> ...) is curried, then (f x)(\v -> ...)
very like js's  promise
(f x)(\f' -> ...)(\f'' -> ...)
f' is f's k
f'' is k of f'

since we have mapK which like traverse or mapM
what would bindK be like?

if f is an unary function, then it would be f x k
if f is a binary function, it would be f g x k
and g would be another CPS computation 
g would have g :: a -> (a-> b) -> b
CPSed
