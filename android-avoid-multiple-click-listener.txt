function visit and change outside variable, is closure

function's closure is very like OOP's instance, they implement the same function,
run one same function repeatly, and get different result, and store that result out side of function
so it can't be reset in every function call
 
kotlin doesn't have non-local keyword, so you can't change the outside variable inside the function
but function can visit it, if they are in same scope
haskell can't define function inside another function, and variable is constant 

1. function closure
js
function initCounter() {
  var x = 0;
  function counter() {
    x += 1;
    console.log(x);
  }
  return counter;
}

counter = initCounter();

counter() // 1
counter() // 2
counter() // 3
##############
python
def counter():
  count=0
  def inner():
    nonlocal count
    count += 1
    print(count)
  return inner

c = counter()
c() // 1
c() // 2
c() //3

2. OOP use object.attribute to store value that inner function changed
kotlin
class Counter() {
  var count: Int
  init {
    count = 0
  }
  fun getCount(){
    count += 1
    println(count)
  }
}

val counter = Counter()
counter.getCount() // 1
counter.getCount() // 2
counter.getCount(0 // 3

3. function and OOP, on closure, they always want to change the variable out side of function,
so the function every time run, won't reset that variable

in Android, avoid multiple click in the same time

in Adapter out ViewHolder
java
    abstract class SingleClickListener implements View.OnClickListener{
        private long mLastClickTime = 0L
        public void onClick(View view){
            //
            if(time - mLastClickTime < 1000){
                onSingleClick(view);
            }
        }
        protected abstract void onSingleClick(View view);
    }

abstract class could expand interface, like Monad expand Functor

kotlin,  when to compare Long as condition, remember use 3000L not 3000

4.
     abstract class SingleClickListener: View.OnClickListener {
        private var initTime = 0L
        var index: Int = 0
        var viewHolder: ViewHolder? = null
        override fun onClick(view: View){
            if (System.currentTimeMillis() - initTime > 3000L){
                onSingleClick(view, index, viewHolder)
            }
            initTime = System.currentTimeMillis()
        }
        abstract  fun onSingleClick(view: View, index: Int, viewHolder: ViewHolder?)
    }


   

in fun onBindViewHolder, every refresh, it will run, so 
view.setOnClickListener(object: SignleClickListener{...}) will create repeat, initTime will be 0L repeat
in class ViewHolder, it will only run once, so define this object in it
5.
class ViewHolder(view: View): RecyclerView.ViewHolder(view){
val pauseClickListener: SingleClickListener
  val itemViewClickListener: SingleClickListener

init {
                       pauseClickListener = object: SingleClickListener(){
                override fun onSingleClick(view: View, index: Int, viewHolder: ViewHolder?){
                        println("*** ${System.currentTimeMillis()} was clicked!")
                        println("*** position is ${index}")
                        MultipleUploadProgress.list[index].pause =
                            MultipleUploadProgress.list[index].pause.not()
                        if (MultipleUploadProgress.list[index].pause) {
                            viewHolder?.speed?.text = ""
                            viewHolder?.pause?.setImageResource(R.drawable.play)
                        } else {
                            viewHolder?.pause?.setImageResource(R.drawable.pause)
                            remoteList.append(MultipleUploadProgress.list[index])
                        }
                }
            }

            itemViewClickListener = object: SingleClickListener(){
                override fun onSingleClick(view: View, index: Int, viewHolder: ViewHolder?) {
                        if (MultipleUploadProgress.list[index].percent != 100) {
                            if (!MultipleUploadProgress.list[index].cancel) {
                                cancelDialog.pop(view.context, MultipleUploadProgress.list[index])
                            }
                        }
                        else {
                            cancelDialog.removeFromList(view.context, MultipleUploadProgress.list[index])
                        }
                }
            }

}

then use it in onBindViewHolder
6.
 override fun onBindViewHolder(viewHolder: ViewHolder, position: Int) {
        viewHolder.pauseClickListener.index = position // at first, so every refresh and click would get right position 
        viewHolder.itemViewClickListener.index = position
        viewHolder.pauseClickListener.viewHolder = viewHolder
        viewHolder.itemViewClickListener.viewHolder = viewHolder


        viewHolder.pause.setOnClickListener(viewHolder.pauseClickListener)
        viewHolder.itemView.setOnClickListener(viewHolder.itemViewClickListener)
}


-------------------------------------------------------------------------------------
another 

        viewHolder.pause.setOnClickListener {
            viewHolder.pause.isClickable = false  // won't be clickable
            viewHolder.pause.isEnabled = false  // won't get focus
            MultipleUploadProgress.list[position].pause = MultipleUploadProgress.list[position].pause.not()
            if (MultipleUploadProgress.list[position].pause) {
                viewHolder.speed.text = ""
//                    // pausing, wait IO signal
////                viewHolder.pause.setImageResource(R.drawable.next)
////                // receive event bus then click again
                viewHolder.pause.setImageResource(R.drawable.play)
            } else {
                viewHolder.pause.setImageResource(R.drawable.pause)
                remoteList.append(MultipleUploadProgress.list[position])
            }
            CoroutineScope(Dispatchers.Main).launch {
                delay(3000)
                viewHolder.pause.isClickable = true
                viewHolder.pause.isEnabled = true
            }
        }



