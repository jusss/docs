
Type Constructor and Value Constructor

data T a = V a   
w = V 3 则 w :: T Int
x::T String 则 V "whatever"的type是x, (T String)是一个type,而(V "whatever")是一个value

data A = B
A是Type Constructor, B是Value Constructor

data T a = V a 就定义了T和V

Elm里的Type相当于Haskell的data
而在haskell里type相当于elm的Type alias
type X = Int  X就可以代表Int

newtype相当于一个优化的data

newtype = 只允许有一个值的data

newtype X = X Int 定义了一个新的X类型和对应的俩构造器

data X = X Int 表示X这个值构造器接受一个Int返回一个X
X::Int -> X
haskell GADT

data X = Int 是没有这种写法的，只有 type X = Int 定义类型构造器的别名

data Y = Y
x = Y 这样是可以的

值构造器不是类型

Int是个类型构造器
data Int = 0|1|2|...|4294967295

Value Constructor可以当作一类特殊的函数，可以在模式匹配里用,match pattern,
但普通函数不能在模式匹配里用， 值构造器可以作为函数使用，也可以模式匹配
所以Haskell有类型构造器 值构造器 和函数,  其它语言里的Constructor一般是指Value Constructor
data E = X | Y
:type X
X :: E
:type Y
Y :: E
:type 1
1 :: Num p => p
:type 1 :: Int
1 :: Int :: Int
所以:1也是值构造器还是多态的

类型构造器和值构造器都可以没有参数
data Bool = True | False   Bool是个无参数的类型构造器, True和False是无参数的值构造器
data Maybe a = Nothing | Just a    Maybe是类型构造器，a是在等号左边是类型变量,a在等号右边是值变量，Just是值构造器

Haskell除了值，类型之外还有Kind
Int是Int::*
Maybe是*->*
Kind就是Type的Type,  Idris可以无限层级堆叠类型
Haskell最高只有两阶类型，所以没法表达所有集合的集合, 是data和typeclass之别，好像没问题，Elm 0.19还没有typeclass
https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/
C++好像也是两阶的
Kind就是描述类型构造器的类型的,
先用Type描述数字，data Nat这样用Nat Succ这样去描述数字
https://hackage.haskell.org/package/data-nat
data-nat: data Nat = Zero | Succ Nat

data T a = V a
x :: T Int 怎么把V 3里的3通过操作x提取出来？
得把x写成函数
x :: T Int -> Int
x (V boom) = boom
或者
x biu = case biu of
        (V boom) -> boom

Elm没有data,只有Type和Type alias, Elm的Type和Haskell的data功能一样, Elm的Type alias和Haskell的type功能一样或者newtype?
Haskell开LambdaCase之后可以这样写
:set -XLambdaCase
y = \case (V boom) -> boom
:type x
x :: T a -> a
:type y
y :: T a -> a

Module X where 这个where就是定义了一个块状区域，类似c系语言里的大括号把后面缩进的内容都包含进去了

t = map f  这个是curring柯里化也是pointfree写法
括号里有逗号就是tuple,没有逗号就是优先求值
x :: (Int, String, Int) -> Int 和 y :: Int->String->Int-> Int 后者是柯里化的

haskell没有一元tuple 但是有0元tuple,0元tuple就是()

module X where 就是指这个文件的名字是X.hs或X.elm, where类似C的大括号,这个文件可以作为模块给其它文件使用
也可以 module Main where, module Test where, module Whatever where, module就是把这个文件声明成了模块给其它文件使用
而在python里一个文件默认就是模块，test.py可以在同目录的其它python文件里直接import test去掉文件名后缀.py导入，但是为了防止在导入
test.py时求值里面的函数，所以一般就在test.py里把求值的函数都写在if __name__ == '__main__':里，这样在其它文件导入test.py时，
因为主文件的__name__才等于__main__,导入时test.py里的__name__不等于__main__这样test.py里的求值函数就不会求值，
因为python的执行顺序是从top到bottom,所以python的程序入口点entry point就是第一行，
而C的程序入口点是main(),  Elm和Haskell的程序入口点是main = 

#######################################

There are three ways in which Elm and JavaScript (JS below) interact: Port, Native module and programWithFlags. (Finally about the differences.)
Port is a mechanism to communicate with JS provided in Elm.
Prepare a function with only a name and type as follows in Elm, and execute it as Cmd / Sub.
port hello : String -> Cmd msg
port jsHello : (String -> msg) -> Sub msg

Then you can use it as follows on JS side.
const elm = document.getElementById('elm');
const app = Elm.Test.embed(elm);  // Launch the Elm application
// Subscribe from Elm to JS
app.ports.hello.subscribe(function(fromElm) {

  console.log(fromElm);
  // Send from JS to Elm
  app.ports.jsHello.send("Hi!");

});

// JS to Elm send
app.ports.jsHello.send("Elm! hellooooo");

It's pretty easy.
It is a correspondence table of the type of Elm and JS.
Elm 	Javascript
Bool 	Bool
String 	String
Int Float 	Number
List 	array
Arrays 	array
Tuples 	array(固定長、複数の型)
Records 	object
Maybe (Nothing) 	null
Maybe (Just 42) 	42
Json.Encode.Value 	JSON

First change the top line from module to port module. (I forget about it and get angry with the compiler.)
port module Test exposing (..)
Note: Packages using the port module can not be published in Elm Package. You also need to install JS at the same time.

Publish Cmd from Elm to JS
Call out JS from Elm.

Elm side
port function_name: send_type-> Cmd msg
port hello : String -> Cmd msg

Write port to define the function name and type. At this time, type is send type-> Cmd msg. (The msg must be written in lower case.)
And this function is used by init function and update function.
init = "" ! [hello "Hello!JS!"]
If you write to init, the value will be sent to JS immediately after Elm initialization.

JS side
JS side registers and receives functions as ports.defined function name.subscribe. (I often forget the "s" in ports)
var elm = document.getElementById('elm');
var app = Elm.Test.embed(elm);
// Receive from Elm!
app.ports.hello.subscribe(function(str) {
  console.log(str);
});
Now I can call the JS code from Elm at my favorite timing.

Send from JS to Elm

Next, Elm passes the value from JS to Elm, and Elm receives it.

Elm side
port function_name: (type_ coming_ from_ JS-> msg)-> Sub msg
port jsHello : (String -> msg) -> Sub msg

Write and define the function (msg is lowercase).
The value coming from JS is Msg in Elm. So we define Msg type.
And use the function defined by port as follows.

type Msg = GetHello String  --Msg definition
port jsHello : (String -> msg) -> Sub msg     --JS-> Elm's port
main = program {... , subscriptions = subscriptions}  Used for the --subscriptions function.
subscriptions : Model -> Sub Msg
subscriptions model = jsHello GetHello         --例。
update msg model =
  case msg of
    GetHello str -> ...         The value from --JS is Msg.

JS side
JS side sends to Elm with app name.ports.function name.send (value to send).
app.ports.jsHello.send("hellooooo");  // Send to Elm

For example, call JQuery.
Finally, let's call JQuery from Elm.
I just wanted to have the ability to automatically scroll to the bottom like this on the chat screen. When I search Google, I get the JQuery code.
$ (Selector to scroll) .animate ({"scrollTop": $ (selector to scroll) [0] .scrollHeight}, scroll time);
JQuery is useful to be able to specify the scroll time and animation in a single line.
I will call it by port.
Elm
port scrollDown : () -> Cmd msg

update msg model =
    ...  -> ... ! [scrollDown ()]

consoleView =
    div [id "console"] [ ...]

js
const app = Elm.Main.embed(...);

app.ports.scrollDown.subscribe((_) => {

    $("#console").animate({"scrollTop": $("#console")[0].scrollHeight}, 5);

});
Now it scrolls as each letter is added to the screen.
In this way, if you use Port with Elm, you can use JS assets immediately.

trouble shooting
It seems to be a trade-off with Elm's scheduler, but once I wrote the process to extract the DOM after calling Elm, I could not extract it.
const App = Elm.Main.embed(document.getElementById("main"));

document.getElementById('hoge').addEventListener("pointerdown" , (event) => {
        console.log(event);
    });

It works by enclosing it with setTimeout.
setTimeout(function () {
    document.getElementById('hoge').addEventListener("pointerdown" , (event) => {
        console.log(event);
    });

}, 0);

Port and Native modules
programWithFlags is a mechanism to pass an initial value to Elm, about Port and Native modules.
I think that the Native module is used for wrapping api, and also for publishing it as an Elm package. And since the main web api is released as a library, if you want to use the JS code, you should be able to use a port.
The Native module is not supported (does not disclose how to use, api changes without announcement), and it is a policy provided only from the official side. Also, packages using Native are currently not available from Elm packages.
The reason for this (as summarized in my own interpretation) is that the Native module directly expands the JS code into the Elm runtime, so the runtime becomes more fragile as the library is expanded to the user. Elm also looks at things other than JS (web assembly), so I want to minimize JS so that various libraries don't seem to use code wrapped separately. It is around.
However, there are also cases where Native is more convenient, such as Test code, and sometimes it is redundant with Port. The following links will be helpful.
https://qiita.com/ento/items/10401fb27ca604491c10
https://qiita.com/k-motoyan/items/24f8b5f27ab828efb024
https://qiita.com/jooex/items/5ff2d3b86563cf5dbd84


#Elm #elm #ports #port #Port #Ports
###############
https://qiita.com/jooex/items/5ff2d3b86563cf5dbd84

index.html
<!doctype html>
<html>
  <head>
    <title>WebSockets Hello World</title>
    <meta charset="utf-8" />
    <style type="text/css">
    </style>
	 <script src="main.js"></script> 
	  <script src="hello.js"></script>
  </head>
  <body>
  <div id="elm"></div>
 </body>
  <script>
  var app = Elm.Main.init({
    node: document.getElementById('elm')
  });
      app.ports.sayHello.subscribe(function(data) { console.log(data)});
	  //app.ports.jsHello.send("Elm! hellooooo");
	  toE = function(x) {app.ports.jsHello.send(x);};
    </script>
</html>
#############################################
Main.elm
port module Main exposing (..)

import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Browser exposing (sandbox)
type alias Model = Int

type Msg
  = Inc
  | Dec
  | GetHello String

model : Model
model = 0

port sayHello : String -> Cmd msg
port jsHello : (String -> msg) -> Sub msg 

init : flags -> ( Model, Cmd Msg )
init dataFromJSwhenInit = (model, Cmd.none)

update : Msg -> Model  -> (Model, Cmd msg)
update msg model2 =
  case msg of
    Inc ->
      (model2 + 1, sayHello "i")
    Dec ->
      (model2 - 1, sayHello "d")
    GetHello str ->
     (model2, sayHello str)


view : Model -> Html Msg
view model1 =
  div []
    [ button [ onClick Inc] [ text "Inc" ]
    , text (String.fromInt model1)
    , button [ onClick Dec ] [ text "Dec" ]
    ]

subscriptions : Model -> Sub Msg
subscriptions model3 = jsHello GetHello


main : Program () Model Msg
main =  Browser.element
       { init = init
       , view = view
        , update = update , subscriptions = subscriptions}
##############################################
hello.js
hello = (function(self) {
	self.hello = function(world) {console.log(world)};
	 return self;

})(window.hello || {});
